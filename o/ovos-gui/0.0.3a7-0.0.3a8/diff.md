# Comparing `tmp/ovos_gui-0.0.3a7-py3-none-any.whl.zip` & `tmp/ovos_gui-0.0.3a8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,30 @@
-Zip file size: 45631 bytes, number of entries: 28
--rw-r--r--  2.0 unx      648 b- defN 23-Jul-04 20:22 ovos_gui/__init__.py
--rw-r--r--  2.0 unx      944 b- defN 23-Jul-04 20:22 ovos_gui/__main__.py
--rw-r--r--  2.0 unx     8008 b- defN 23-Jul-04 20:22 ovos_gui/bus.py
--rw-r--r--  2.0 unx     2927 b- defN 23-Jul-04 20:22 ovos_gui/extensions.py
--rw-r--r--  2.0 unx     9870 b- defN 23-Jul-04 20:22 ovos_gui/homescreen.py
--rw-r--r--  2.0 unx    32552 b- defN 23-Jul-04 20:22 ovos_gui/namespace.py
--rw-r--r--  2.0 unx      713 b- defN 23-Jul-04 20:22 ovos_gui/page.py
--rw-r--r--  2.0 unx     2500 b- defN 23-Jul-04 20:22 ovos_gui/service.py
--rw-r--r--  2.0 unx     6373 b- defN 23-Jul-04 20:22 ovos_gui/tui.py
--rw-r--r--  2.0 unx      114 b- defN 23-Jul-04 20:22 ovos_gui/version.py
--rw-r--r--  2.0 unx    15240 b- defN 23-Jul-04 20:22 ovos_gui/res/snd/clicked.wav
--rw-r--r--  2.0 unx     4176 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/FeatureRequest.qml
--rw-r--r--  2.0 unx      811 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/RequestHandler.qml
--rw-r--r--  2.0 unx     1523 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/SYSTEM_AdditionalSettings.qml
--rw-r--r--  2.0 unx     2804 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/SYSTEM_AnimatedImageFrame.qml
--rw-r--r--  2.0 unx      478 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/SYSTEM_HtmlFrame.qml
--rw-r--r--  2.0 unx     2796 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/SYSTEM_ImageFrame.qml
--rw-r--r--  2.0 unx     1206 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/SYSTEM_TextFrame.qml
--rw-r--r--  2.0 unx     6539 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/SYSTEM_UrlFrame.qml
--rw-r--r--  2.0 unx     1405 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/SwipeArea.qml
--rw-r--r--  2.0 unx     3215 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/WebViewHtmlFrame.qml
--rw-r--r--  2.0 unx     3031 b- defN 23-Jul-04 20:22 ovos_gui/res/ui/WebViewUrlFrame.qml
--rw-r--r--  2.0 unx    11423 b- defN 23-Jul-04 20:22 ovos_gui-0.0.3a7.dist-info/LICENSE.md
--rw-r--r--  2.0 unx      449 b- defN 23-Jul-04 20:22 ovos_gui-0.0.3a7.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-04 20:22 ovos_gui-0.0.3a7.dist-info/WHEEL
--rw-r--r--  2.0 unx      100 b- defN 23-Jul-04 20:22 ovos_gui-0.0.3a7.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        9 b- defN 23-Jul-04 20:22 ovos_gui-0.0.3a7.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2371 b- defN 23-Jul-04 20:22 ovos_gui-0.0.3a7.dist-info/RECORD
-28 files, 122317 bytes uncompressed, 41803 bytes compressed:  65.8%
+Zip file size: 38818 bytes, number of entries: 28
+-rw-r--r--  2.0 unx      648 b- defN 23-Jul-08 00:06 ovos_gui/__init__.py
+-rw-r--r--  2.0 unx      944 b- defN 23-Jul-08 00:06 ovos_gui/__main__.py
+-rw-r--r--  2.0 unx    10499 b- defN 23-Jul-08 00:06 ovos_gui/bus.py
+-rw-r--r--  2.0 unx     2927 b- defN 23-Jul-08 00:06 ovos_gui/extensions.py
+-rw-r--r--  2.0 unx     1743 b- defN 23-Jul-08 00:06 ovos_gui/gui_file_server.py
+-rw-r--r--  2.0 unx     9858 b- defN 23-Jul-08 00:06 ovos_gui/homescreen.py
+-rw-r--r--  2.0 unx    40389 b- defN 23-Jul-08 00:06 ovos_gui/namespace.py
+-rw-r--r--  2.0 unx     3246 b- defN 23-Jul-08 00:06 ovos_gui/page.py
+-rw-r--r--  2.0 unx     2500 b- defN 23-Jul-08 00:06 ovos_gui/service.py
+-rw-r--r--  2.0 unx     6373 b- defN 23-Jul-08 00:06 ovos_gui/tui.py
+-rw-r--r--  2.0 unx      114 b- defN 23-Jul-08 00:06 ovos_gui/version.py
+-rw-r--r--  2.0 unx     4176 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/FeatureRequest.qml
+-rw-r--r--  2.0 unx      811 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/RequestHandler.qml
+-rw-r--r--  2.0 unx     1523 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/SYSTEM_AdditionalSettings.qml
+-rw-r--r--  2.0 unx     2804 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/SYSTEM_AnimatedImageFrame.qml
+-rw-r--r--  2.0 unx      478 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/SYSTEM_HtmlFrame.qml
+-rw-r--r--  2.0 unx     2796 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/SYSTEM_ImageFrame.qml
+-rw-r--r--  2.0 unx     1206 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/SYSTEM_TextFrame.qml
+-rw-r--r--  2.0 unx     6539 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/SYSTEM_UrlFrame.qml
+-rw-r--r--  2.0 unx     1405 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/SwipeArea.qml
+-rw-r--r--  2.0 unx     3215 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/WebViewHtmlFrame.qml
+-rw-r--r--  2.0 unx     3031 b- defN 23-Jul-08 00:06 ovos_gui/res/gui/qt5/WebViewUrlFrame.qml
+-rw-r--r--  2.0 unx    11423 b- defN 23-Jul-08 00:06 ovos_gui-0.0.3a8.dist-info/LICENSE.md
+-rw-r--r--  2.0 unx      449 b- defN 23-Jul-08 00:06 ovos_gui-0.0.3a8.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-08 00:06 ovos_gui-0.0.3a8.dist-info/WHEEL
+-rw-r--r--  2.0 unx      100 b- defN 23-Jul-08 00:06 ovos_gui-0.0.3a8.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        9 b- defN 23-Jul-08 00:06 ovos_gui-0.0.3a8.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2426 b- defN 23-Jul-08 00:06 ovos_gui-0.0.3a8.dist-info/RECORD
+28 files, 121724 bytes uncompressed, 34882 bytes compressed:  71.3%
```

## zipnote {}

```diff
@@ -6,14 +6,17 @@
 
 Filename: ovos_gui/bus.py
 Comment: 
 
 Filename: ovos_gui/extensions.py
 Comment: 
 
+Filename: ovos_gui/gui_file_server.py
+Comment: 
+
 Filename: ovos_gui/homescreen.py
 Comment: 
 
 Filename: ovos_gui/namespace.py
 Comment: 
 
 Filename: ovos_gui/page.py
@@ -24,62 +27,59 @@
 
 Filename: ovos_gui/tui.py
 Comment: 
 
 Filename: ovos_gui/version.py
 Comment: 
 
-Filename: ovos_gui/res/snd/clicked.wav
-Comment: 
-
-Filename: ovos_gui/res/ui/FeatureRequest.qml
+Filename: ovos_gui/res/gui/qt5/FeatureRequest.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/RequestHandler.qml
+Filename: ovos_gui/res/gui/qt5/RequestHandler.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/SYSTEM_AdditionalSettings.qml
+Filename: ovos_gui/res/gui/qt5/SYSTEM_AdditionalSettings.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/SYSTEM_AnimatedImageFrame.qml
+Filename: ovos_gui/res/gui/qt5/SYSTEM_AnimatedImageFrame.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/SYSTEM_HtmlFrame.qml
+Filename: ovos_gui/res/gui/qt5/SYSTEM_HtmlFrame.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/SYSTEM_ImageFrame.qml
+Filename: ovos_gui/res/gui/qt5/SYSTEM_ImageFrame.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/SYSTEM_TextFrame.qml
+Filename: ovos_gui/res/gui/qt5/SYSTEM_TextFrame.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/SYSTEM_UrlFrame.qml
+Filename: ovos_gui/res/gui/qt5/SYSTEM_UrlFrame.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/SwipeArea.qml
+Filename: ovos_gui/res/gui/qt5/SwipeArea.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/WebViewHtmlFrame.qml
+Filename: ovos_gui/res/gui/qt5/WebViewHtmlFrame.qml
 Comment: 
 
-Filename: ovos_gui/res/ui/WebViewUrlFrame.qml
+Filename: ovos_gui/res/gui/qt5/WebViewUrlFrame.qml
 Comment: 
 
-Filename: ovos_gui-0.0.3a7.dist-info/LICENSE.md
+Filename: ovos_gui-0.0.3a8.dist-info/LICENSE.md
 Comment: 
 
-Filename: ovos_gui-0.0.3a7.dist-info/METADATA
+Filename: ovos_gui-0.0.3a8.dist-info/METADATA
 Comment: 
 
-Filename: ovos_gui-0.0.3a7.dist-info/WHEEL
+Filename: ovos_gui-0.0.3a8.dist-info/WHEEL
 Comment: 
 
-Filename: ovos_gui-0.0.3a7.dist-info/entry_points.txt
+Filename: ovos_gui-0.0.3a8.dist-info/entry_points.txt
 Comment: 
 
-Filename: ovos_gui-0.0.3a7.dist-info/top_level.txt
+Filename: ovos_gui-0.0.3a8.dist-info/top_level.txt
 Comment: 
 
-Filename: ovos_gui-0.0.3a7.dist-info/RECORD
+Filename: ovos_gui-0.0.3a8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ovos_gui/bus.py

```diff
@@ -22,65 +22,65 @@
     5) Connection persists for graphical interaction indefinitely
 
 If the connection is lost, it must be renegotiated and restarted.
 """
 import asyncio
 import json
 from threading import Lock
+from typing import List
 
 from ovos_bus_client import Message, GUIMessage
 from ovos_config.config import Configuration
-# from ovos_gui.namespace import NamespaceManager
+from ovos_gui.page import GuiPage
 from ovos_utils import create_daemon
 from ovos_utils.log import LOG
 from tornado import ioloop
 from tornado.options import parse_command_line
 from tornado.web import Application
 from tornado.websocket import WebSocketHandler
+# from ovos_gui.namespace import NamespaceManager
 
 _write_lock = Lock()
 
 
 def get_gui_websocket_config() -> dict:
     """
     Retrieves the configuration values for establishing a GUI message bus
     """
     config = Configuration()
     websocket_config = config["gui_websocket"]
 
     return websocket_config
 
 
-def create_gui_service(enclosure) -> Application:
+def create_gui_service(nsmanager=None) -> Application:
     """
     Initiate a websocket for communicating with the GUI service.
-    @param enclosure: NamespaceManager instance
+    @param nsmanager: NamespaceManager instance
     """
     LOG.info('Starting message bus for GUI...')
     websocket_config = get_gui_websocket_config()
     # Disable all tornado logging so mycroft loglevel isn't overridden
     parse_command_line(['--logging=None'])
 
     routes = [(websocket_config['route'], GUIWebsocketHandler)]
-    application = Application(routes)
-    # TODO: Is the NamespaceManager used by `application`, or can it be a
-    #   GUIWebsocketHandler class variable
-    application.enclosure = enclosure
+    application = Application(routes, namespace_manager=nsmanager)
     application.listen(
         websocket_config['base_port'], websocket_config['host']
     )
 
     create_daemon(ioloop.IOLoop.instance().start)
     LOG.info('GUI Message bus started!')
     return application
 
 
 def send_message_to_gui(message: dict):
     """
-    Sends the supplied message to all connected GUI clients.
+    Sends the supplied message to all connected GUI clients. This function does
+    NOT account for the GUI framework in use by each client
     @param message: dict data to send to GUI clients
     """
     for connection in GUIWebsocketHandler.clients:
         try:
             connection.send(message)
         except Exception as e:
             LOG.exception(repr(e))
@@ -93,14 +93,26 @@
     return len(GUIWebsocketHandler.clients) > 0
 
 
 class GUIWebsocketHandler(WebSocketHandler):
     """Defines the websocket pipeline between the GUI and Mycroft."""
     clients = []
 
+    def __init__(self, *args, **kwargs):
+        WebSocketHandler.__init__(self, *args, **kwargs)
+        self._framework = "qt5"
+        self.ns_manager = self.application.settings.get("namespace_manager")
+
+    @property
+    def framework(self) -> str:
+        """
+        Get the GUI framework used by this client
+        """
+        return self._framework or "qt5"
+
     def open(self):
         """
         Add a new connection to `clients` and synchronize
         """
         GUIWebsocketHandler.clients.append(self)
         LOG.info('New Connection opened!')
         self.synchronize()
@@ -108,50 +120,66 @@
     def on_close(self):
         """
         Remove a closed connection from `clients`
         """
         LOG.info('Closing {}'.format(id(self)))
         GUIWebsocketHandler.clients.remove(self)
 
+    def get_client_pages(self, namespace):
+        """
+        Get a list of client page URLs for the given namespace
+        @param namespace: Namespace to get pages for
+        @return: list of page URIs for this GUI Client
+        """
+        client_pages = []
+        server_url = self.ns_manager.gui_file_server.url if \
+            self.ns_manager.gui_file_server else None
+        for page in namespace.pages:
+            uri = page.get_uri(self.framework, server_url)
+            client_pages.append(uri)
+
+        return client_pages
+
     def synchronize(self):
         """
         Upload namespaces, pages and data to the last connected client.
         """
         namespace_pos = 0
-        enclosure = self.application.enclosure
 
-        for namespace in enclosure.active_namespaces:
-            LOG.info(f'Sync {namespace.name}')
+        for namespace in self.ns_manager.active_namespaces:
+            LOG.info(f'Sync {namespace.skill_id}')
             # Insert namespace
             self.send({"type": "mycroft.session.list.insert",
                        "namespace": "mycroft.system.active_skills",
                        "position": namespace_pos,
-                       "data": [{"skill_id": namespace.name}]
+                       "data": [{"skill_id": namespace.skill_id}]
                        })
             # Insert pages
             self.send({"type": "mycroft.gui.list.insert",
-                       "namespace": namespace.name,
+                       "namespace": namespace.skill_id,
                        "position": 0,
-                       "data": [{"url": p.url} for p in namespace.pages]
+                       "data": [{"url": url} for url in
+                                self.get_client_pages(namespace)]
                        })
             # Insert data
             for key, value in namespace.data.items():
                 self.send({"type": "mycroft.session.set",
-                           "namespace": namespace.name,
+                           "namespace": namespace.skill_id,
                            "data": {key: value}
                            })
             namespace_pos += 1
 
     def on_message(self, message: str):
         """
         Handle a message on the GUI websocket. Deserialize the message, map
         message types to valid equivalents for the core messagebus and emit
         on the core messagebus.
         @param message: Serialized Message
         """
+        LOG.debug(f"Received: {message}")
         parsed_message = GUIMessage.deserialize(message)
         LOG.debug(f"Received: {parsed_message.msg_type}|{parsed_message.data}")
 
         # msg = json.loads(message)
         if parsed_message.msg_type == "mycroft.events.triggered" and \
                 (parsed_message.data.get('event_name') == 'page_gained_focus' or
                  parsed_message.data.get('event_name') ==
@@ -175,47 +203,85 @@
 
         elif parsed_message.msg_type == 'mycroft.session.set':
             # A value was changed send it back to the skill
             msg_type = f"{parsed_message.data['namespace']}.set"
             msg_data = parsed_message.data['data']
         elif parsed_message.msg_type == 'mycroft.gui.connected':
             # new client connected to GUI
+
+            # NOTE: mycroft-gui clients do this directly in core bus, don't
+            # send it to gui bus. In those cases, framework is read from config,
+            # defaulting to qt5 for backwards-compat.
+            default_qt_version = \
+                Configuration().get('gui', {}).get('default_qt_version') or 5
             msg_type = parsed_message.msg_type
             msg_data = parsed_message.data
+
+            framework = msg_data.get("framework")  # new api
+            if framework is None:
+                # mycroft-gui api
+                qt = msg_data.get("qt_version") or default_qt_version
+                if int(qt) == 6:
+                    framework = "qt6"
+                else:
+                    framework = "qt5"
+
+            self._framework = framework
         else:
             # message not in spec
             # https://github.com/MycroftAI/mycroft-gui/blob/master/transportProtocol.md
             LOG.error(f"unknown GUI protocol message type, ignoring: "
-                      f"{parsed_message}")
+                      f"{parsed_message.msg_type}")
             return
 
+        parsed_message.context["gui_framework"] = self.framework
         message = Message(msg_type, msg_data, parsed_message.context)
-        self.application.enclosure.core_bus.emit(message)
-        LOG.debug('Forwarded to core bus')
+        LOG.debug('Forwarding to core bus...')
+        self.ns_manager.core_bus.emit(message)
+        LOG.debug('Done!')
 
     def write_message(self, *arg, **kwarg):
         """
         Wraps WebSocketHandler.write_message() with a lock.
         """
         try:
             asyncio.get_event_loop()
         except RuntimeError:
             asyncio.set_event_loop(asyncio.new_event_loop())
 
         with _write_lock:
             super().write_message(*arg, **kwarg)
 
+    def send_gui_pages(self, pages: List[GuiPage], namespace: str,
+                       position: int):
+        """
+        Send GUI pages to this client, accounting for the client-specific pages
+        @param pages: list of GuiPage objects to send
+        @param namespace: namespace to put GuiPages in
+        @param position: position to insert pages at
+        """
+        server_url = self.ns_manager.gui_file_server.url if \
+            self.ns_manager.gui_file_server else None
+        framework = self.framework
+
+        message = {
+            "type": "mycroft.gui.list.insert",
+            "namespace": namespace,
+            "position": position,
+            "data": [{"url": page.get_uri(framework, server_url)}
+                     for page in pages]
+        }
+        self.send(message)
+
     def send(self, data: dict):
         """
         Send the given data across the socket as JSON
         @param data: Data to send to the GUI
         """
         s = json.dumps(data)
-        # LOG.info('Sending {}'.format(s))
         self.write_message(s)
 
     def check_origin(self, origin):
         """
-        Disable origin check to make js connections work.
+        Override origin check to make js connections work.
         """
-        # TODO: Should this be implemented or deprecated
         return True
```

## ovos_gui/homescreen.py

```diff
@@ -97,16 +97,16 @@
         self.set_active_homescreen(new_homescreen)
 
     def get_active_homescreen(self) -> Optional[dict]:
         """
         Get the active homescreen according to configuration if it is loaded
         @return: Loaded homescreen with an ID matching configuration
         """
-        enclosure_config = Configuration().get("gui") or {}
-        active_homescreen = enclosure_config.get("idle_display_skill")
+        gui_config = Configuration().get("gui") or {}
+        active_homescreen = gui_config.get("idle_display_skill")
         LOG.debug(f"Homescreen Manager: Active Homescreen {active_homescreen}")
         for h in self.homescreens:
             if h["id"] == active_homescreen:
                 return active_homescreen
 
     def set_active_homescreen(self, homescreen_id: str):
         """
```

## ovos_gui/namespace.py

```diff
@@ -35,30 +35,34 @@
 stack that also has a numeric persistence, the namespace being replaced will
 be removed from the active namespace stack.
 
 The state of the active namespace stack is maintained locally and in the GUI
 code.  Changes to namespaces, and their contents, are communicated to the GUI
 over the GUI message bus.
 """
-
+import shutil
+from os import makedirs
+from os.path import join, dirname, isfile, exists
+from threading import Event
 from threading import Lock, Timer
 from time import sleep
-from typing import List, Union, Optional
+from typing import List, Union, Optional, Dict
 
+from ovos_bus_client import Message, MessageBusClient
 from ovos_config.config import Configuration
 from ovos_utils.log import LOG
-from ovos_bus_client import Message, MessageBusClient
 
 from ovos_gui.bus import (
     create_gui_service,
     determine_if_gui_connected,
     get_gui_websocket_config,
-    send_message_to_gui
+    send_message_to_gui, GUIWebsocketHandler
 )
 from ovos_gui.page import GuiPage
+from ovos_gui.gui_file_server import start_gui_http_server
 
 namespace_lock = Lock()
 
 RESERVED_KEYS = ['__from', '__idle']
 
 
 def _validate_page_message(message: Message) -> bool:
@@ -113,52 +117,51 @@
 
     In the majority of cases, a namespace represents a skill.  There is a
     SYSTEM namespace for GUI screens that exist outside of skills.  This class
     defines an API to manage a namespace, its pages and its data.  Actions
     are communicated to the GUI message bus.
 
     Attributes:
-        name: the name of the Namespace, generally the skill ID
+        skill_id: the name of the Namespace, generally the skill ID
         persistent: indicates whether or not the namespace persists for a
             period of time or until the namespace is removed.
         duration: if the namespace persists for a period of time, this is the
             number of seconds of persistence
         pages: when the namespace is active, contains all the pages that are
             displayed at the same time
         data: a key/value pair representing the data used to populate the GUI
     """
-
-    def __init__(self, name: str):
-        self.name = name
+    def __init__(self, skill_id: str):
+        self.skill_id = skill_id
         self.persistent = False
         self.duration = 30
         self.pages: List[GuiPage] = list()
         self.data = dict()
         self.page_number = 0
         self.session_set = False
 
     def add(self):
         """
         Adds this namespace to the list of active namespaces.
         """
-        LOG.info(f"Adding \"{self.name}\" to active GUI namespaces")
+        LOG.info(f"Adding \"{self.skill_id}\" to active GUI namespaces")
         message = dict(
             type="mycroft.session.list.insert",
             namespace="mycroft.system.active_skills",
             position=0,
-            data=[dict(skill_id=self.name)]
+            data=[dict(skill_id=self.skill_id)]
         )
         send_message_to_gui(message)
 
     def activate(self, position: int):
         """
         Activate this namespace if its already in the list of active namespaces.
         @param position: position to move this namespace FROM
         """
-        LOG.info(f"Activating GUI namespace \"{self.name}\"")
+        LOG.info(f"Activating GUI namespace \"{self.skill_id}\"")
         message = {
             "type": "mycroft.session.list.move",
             "namespace": "mycroft.system.active_skills",
             "from": position,
             "to": 0,
             "items_number": 1
         }
@@ -166,15 +169,15 @@
 
     def remove(self, position: int):
         """
         Removes this namespace from the list of active namespaces. Also clears
         any session data.
         @param position: position to remove this namespace FROM
         """
-        LOG.info(f"Removing {self.name} from active GUI namespaces")
+        LOG.info(f"Removing {self.skill_id} from active GUI namespaces")
 
         # unload the data first before removing the namespace
         # use the keys of the data to unload the data
         for key in self.data:
             self.unload_data(key)
 
         message = dict(
@@ -194,32 +197,32 @@
 
         Args:
             name: The name of the attribute
             value: The attribute's value
         """
         message = dict(
             type="mycroft.session.set",
-            namespace=self.name,
+            namespace=self.skill_id,
             data={name: value}
         )
 
-        # LOG.info(f"Setting data {message} in GUI namespace {self.name}")
+        # LOG.info(f"Setting data {message} in GUI namespace {self.skill_id}")
         send_message_to_gui(message)
 
     def unload_data(self, name: str):
         """
         Delete data from the namespace
         @param name: name of property to delete
         """
         message = dict(
             type="mycroft.session.delete",
             property=name,
-            namespace=self.name
+            namespace=self.skill_id
         )
-        # LOG.info(f"Deleting data {message} from GUI namespace {self.name}")
+        # LOG.info(f"Deleting data {message} from GUI namespace {self.skill_id}")
         send_message_to_gui(message)
 
     def get_position_of_last_item_in_data(self) -> int:
         """
         Get the position of the last item
         """
         return len(self.data) - 1
@@ -272,60 +275,49 @@
         """
         if show_index is None:
             LOG.warning(f"Expected int show_index but got `None`. Default to 0")
             show_index = 0
         new_pages = list()
 
         for page in pages:
-            if page.url not in [p.url for p in self.pages]:
+            if page.id not in [p.id for p in self.pages]:
                 new_pages.append(page)
 
         self.pages.extend(new_pages)
         if new_pages:
             self._add_pages(new_pages)
 
         self._activate_page(pages[show_index])
 
     def _add_pages(self, new_pages: List[GuiPage]):
         """
         Adds one or more pages to the active page list.
-
         @param new_pages: pages to add to the active page list
         """
-        LOG.info(f"Adding pages to GUI namespace {self.name}: {new_pages}")
-        LOG.info(f"Current pages: {self.pages}")
-        # print the attributes of the new pages
-        for page in new_pages:
-            LOG.info(f"Page: {page.url}, {page.name}, {page.persistent}, "
-                     f"{page.duration}")
+        LOG.debug(f"namespace {self.skill_id} current pages: {self.pages}")
+        LOG.debug(f"new_pages={new_pages}")
 
         # Find position of new page in self.pages
         position = self.pages.index(new_pages[0])
-
-        message = dict(
-            type="mycroft.gui.list.insert",
-            namespace=self.name,
-            position=position,
-            data=[dict(url=page.url) for page in new_pages]
-        )
-        send_message_to_gui(message)
+        for client in GUIWebsocketHandler.clients:
+            client.send_gui_pages(new_pages, self.skill_id, position)
 
     def _activate_page(self, page: GuiPage):
         """
         Returns focus to a page already in the active page list.
 
         @param page: the page that will gain focus
         """
-        LOG.info(f"Activating page {page.name} in GUI namespace {self.name}")
-        LOG.info(f"Current pages from _activate_page: {self.pages}")
+        LOG.info(f"Activating page {page.name} in GUI namespace {self.skill_id}")
+        LOG.debug(f"Current pages from _activate_page: {self.pages}")
         # TODO: Simplify two loops into one (with unit test)
         # get the index of the page in the self.pages list
         page_index = 0
         for i, p in enumerate(self.pages):
-            if p.url == page.url:
+            if p.id == page.id:
                 page_index = i
                 break
 
         self.page_number = page_index
 
         # set the page active attribute to True and update the self.pages list,
         # mark all other pages as inactive
@@ -337,56 +329,56 @@
                 # update the self.pages list with the page active status changes
                 self.pages[self.pages.index(p)] = p
 
         self.pages[page_index] = page
 
         message = dict(
             type="mycroft.events.triggered",
-            namespace=self.name,
+            namespace=self.skill_id,
             event_name="page_gained_focus",
             data=dict(number=page_index)
         )
         send_message_to_gui(message)
 
     def remove_pages(self, positions: List[int]):
         """
         Deletes one or more pages by index from the active page list.
 
         @param positions: list of int page positions to remove
         """
-        LOG.info(f"Removing pages from GUI namespace {self.name}: {positions}")
+        LOG.info(f"Removing pages from GUI namespace {self.skill_id}: {positions}")
         positions.sort(reverse=True)
         for position in positions:
             page = self.pages.pop(position)
-            LOG.info(f"Deleting {page} from GUI namespace {self.name}")
+            LOG.info(f"Deleting {page} from GUI namespace {self.skill_id}")
             message = dict(
                 type="mycroft.gui.list.remove",
-                namespace=self.name,
+                namespace=self.skill_id,
                 position=position,
                 items_number=1
             )
             send_message_to_gui(message)
 
     def page_gained_focus(self, page_number: int):
         """
         Updates the active page in `self.pages`.
         @param page_number: the index of the page that will gain focus
         """
         LOG.info(
-            f"Page {page_number} gained focus in GUI namespace {self.name}")
+            f"Page {page_number} gained focus in GUI namespace {self.skill_id}")
         self._activate_page(self.pages[page_number])
 
     def page_update_interaction(self, page_number: int):
         """
         Update the interaction of the page_number.
         @param page_number: the index of the page to update
         """
 
         LOG.info(f"Page {page_number} update interaction in GUI namespace "
-                 f"{self.name}")
+                 f"{self.skill_id}")
 
         page = self.pages[page_number]
         if not page.persistent and page.duration > 0:
             page.duration = page.duration / 2
 
         # update the self.pages list with the page interaction status changes
         self.pages[page_number] = page
@@ -450,35 +442,123 @@
             a persistence expressed in seconds
         idle_display_skill: skill ID of the skill that controls the idle screen
     """
 
     def __init__(self, core_bus: MessageBusClient):
         self.core_bus = core_bus
         self.gui_bus = create_gui_service(self)
-        self.loaded_namespaces = dict()
-        self.active_namespaces = list()
-        self.remove_namespace_timers = dict()
+        self.loaded_namespaces: Dict[str, Namespace] = dict()
+        self.active_namespaces: List[Namespace] = list()
+        self.remove_namespace_timers: Dict[str, Timer] = dict()
         self.idle_display_skill = _get_idle_display_config()
         self.active_extension = _get_active_gui_extension()
+        self._system_res_dir = join(dirname(__file__), "res", "gui")
+        self._ready_event = Event()
+        self.gui_file_server = None
+        self.gui_file_path = None
+        self._connected_frameworks: List[str] = list()
+        self._init_gui_server()
         self._define_message_handlers()
 
+    @property
+    def _active_homescreen(self) -> str:
+        return Configuration().get('gui', {}).get('idle_display_skill')
+
+    def _init_gui_server(self):
+        """
+        Initialize a GUI HTTP file server if enabled in configuration
+        """
+        config = Configuration().get("gui", {})
+        if config.get("gui_file_server", False):
+            from ovos_utils.file_utils import get_temp_path
+            self.gui_file_path = config.get("server_path") or \
+                get_temp_path("ovos_gui_file_server")
+            self.gui_file_server = start_gui_http_server(self.gui_file_path)
+            self._upload_system_resources()
+
     def _define_message_handlers(self):
         """
         Defines event handlers for core messagebus.
         """
         self.core_bus.on("gui.clear.namespace", self.handle_clear_namespace)
         self.core_bus.on("gui.event.send", self.handle_send_event)
         self.core_bus.on("gui.page.delete", self.handle_delete_page)
         self.core_bus.on("gui.page.show", self.handle_show_page)
+        self.core_bus.on("gui.page.upload", self.handle_receive_gui_pages)
         self.core_bus.on("gui.status.request", self.handle_status_request)
         self.core_bus.on("gui.value.set", self.handle_set_value)
         self.core_bus.on("mycroft.gui.connected", self.handle_client_connected)
         self.core_bus.on("gui.page_interaction", self.handle_page_interaction)
-        self.core_bus.on("gui.page_gained_focus",
-                         self.handle_page_gained_focus)
+        self.core_bus.on("gui.page_gained_focus", self.handle_page_gained_focus)
+        self.core_bus.on("mycroft.skills.trained", self.handle_ready)
+
+    def handle_ready(self, message):
+        self._ready_event.set()
+        self.core_bus.on("gui.volunteer_page_upload",
+                         self.handle_gui_pages_available)
+
+    def handle_gui_pages_available(self, message: Message):
+        """
+        Handle a skill or plugin advertising that it has GUI pages available to
+        upload. If there are connected clients, request pages for each connected
+        GUI framework.
+        @param message: `gui.volunteer_page_upload` message
+        """
+        if not self.gui_file_path:
+            LOG.debug("No GUI file server running")
+            return
+
+        for framework in self._connected_frameworks:
+            skill_id = message.data.get("skill_id")
+            self.core_bus.emit(message.reply("gui.request_page_upload",
+                                             {'skill_id': skill_id,
+                                              'framework': framework},
+                                             {"source": "gui",
+                                              "destination": ["skills",
+                                                              "PHAL"]}))
+
+    def handle_receive_gui_pages(self, message: Message):
+        """
+        Handle GUI resources from a skill or plugin. Pages are written to
+        `self.server_path` which is accessible via a lightweight HTTP server and
+        may additionally be mounted to a host path/volume in container setups.
+        @param message: Message containing UI resource file contents and meta
+            message.data:
+                pages: dict page_filename to encoded bytes content;
+                    paths are relative to the `framework` directory, so a page
+                    for framework `all` could be `qt5/subdir/file.qml` and the
+                    equivalent page for framework `qt5` would be
+                    `subdir/file.qml`
+                framework: `all` if all GUI resources are included, else the
+                    specific GUI framework (i.e. `qt5`, `qt6`)
+                __from: skill_id of module uploading GUI resources
+        """
+        for page, contents in message.data["pages"].items():
+            try:
+                if message.data.get("framework") == "all":
+                    # All GUI resources are uploaded
+                    resource_base_path = join(self.gui_file_path,
+                                              message.data['__from'])
+                else:
+                    resource_base_path = join(self.gui_file_path,
+                                              message.data['__from'],
+                                              message.data.get('framework') or
+                                              "qt5")
+                byte_contents = bytes.fromhex(contents)
+                file_path = join(resource_base_path, page)
+                LOG.debug(f"writing UI file: {file_path}")
+                makedirs(dirname(file_path), exist_ok=True)
+                with open(file_path, 'wb+') as f:
+                    f.write(byte_contents)
+            except Exception as e:
+                LOG.exception(f"Failed to write {page}: {e}")
+        if message.data["__from"] == self._active_homescreen:
+            # Configured home screen skill just uploaded pages, show it again
+            self.core_bus.emit(
+                message.forward("homescreen.manager.show_active"))
 
     def handle_clear_namespace(self, message: Message):
         """
         Handles a request to remove a namespace.
         @param message: the message requesting namespace removal
         """
         try:
@@ -528,67 +608,111 @@
         @param namespace_name: the affected namespace
         @param pages_to_remove: names of pages to delete
         """
         namespace = self.loaded_namespaces.get(namespace_name)
         if namespace is not None and namespace in self.active_namespaces:
             page_positions = []
             for index, page in enumerate(pages_to_remove):
-                # if page matches namespace.pages.url:
-                if page == namespace.pages[index].url:
+                if page == namespace.pages[index].id:
                     page_positions.append(index)
 
             page_positions.sort(reverse=True)
             namespace.remove_pages(page_positions)
 
+    @staticmethod
+    def _parse_persistence(persistence: Optional[Union[int, bool]]) -> \
+            (bool, int):
+        """
+        Parse a persistence spec into persist and duration.
+        @param persistence: message.data["__idle"] spec
+        @return: bool persistence, int duration
+        """
+        if isinstance(persistence, float):
+            persistence = round(persistence)
+        if isinstance(persistence, bool):
+            return persistence, 0
+        elif isinstance(persistence, int):
+            if persistence < 0:
+                raise ValueError("Requested negative persistence")
+            return False,  persistence
+        else:
+            # Defines default behavior as displaying for 30 seconds
+            return False, 30
+
+    def _legacy_show_page(self, message: Message) -> List[GuiPage]:
+        """
+        Backwards-compat method to handle messages without ui_directories and
+        page_names.
+        @param message: message requesting to display pages
+        @return: list of GuiPage objects
+        """
+        pages_to_show = message.data["page"]
+        LOG.info(f"Handling legacy page show request. pages={pages_to_show}")
+
+        pages_to_load = list()
+        persist, duration = self._parse_persistence(message.data["__idle"])
+        for page in pages_to_show:
+            name = page.split('/')[-1]
+            # check if persistence is type of int or bool
+            pages_to_load.append(GuiPage(page, name, persist, duration))
+        return pages_to_load
+
     def handle_show_page(self, message: Message):
         """
         Handles a request to show one or more pages on the screen.
         @param message: the message containing the page show request
         """
         message_is_valid = _validate_page_message(message)
-        if message_is_valid:
-            namespace_name = message.data["__from"]
-            pages_to_show = message.data["page"]
-            persistence = message.data["__idle"]
-            show_index = message.data.get("index", None)
-
-            LOG.info(f"Handling page show request. pages={pages_to_show}")
-
-            pages_to_load = list()
-            for page in pages_to_show:
-                name = page.split('/')[-1]
-                # check if persistence is type of int or bool
-                if isinstance(persistence, bool):
-                    persist = persistence
-                    duration = 0
-
-                # check if persistence is type of int
-                elif isinstance(persistence, int):
-                    persist = False
-                    duration = persistence
-
-                else:
-                    persist = False
-                    duration = 30
-
-                pages_to_load.append(GuiPage(page, name, persist, duration))
+        if not message_is_valid:
+            LOG.error(f"invalid request: {message.data}")
+            return
 
-            with namespace_lock:
-                self._activate_namespace(namespace_name)
-                self._load_pages(pages_to_load, show_index)
-                self._update_namespace_persistence(persistence)
+        namespace_name = message.data["__from"]
+        page_ids_to_show = message.data.get('page_names')
+        page_resource_dirs = message.data.get('ui_directories')
+        persistence = message.data["__idle"]
+        show_index = message.data.get("index", None)
+
+        if not page_resource_dirs and page_ids_to_show and \
+                all((x.startswith("SYSTEM") for x in page_ids_to_show)):
+            page_resource_dirs = {"all": self._system_res_dir}
+
+        if not all((page_ids_to_show, page_resource_dirs)):
+            LOG.info(f"Handling legacy page request: data={message.data}")
+            pages = self._legacy_show_page(message)
+        else:
+            pages = list()
+            persist, duration = self._parse_persistence(message.data["__idle"])
+            for page in page_ids_to_show:
+                url = None
+                name = page
+                if isfile(page):
+                    LOG.warning(f"Expected resource name but got file: {url}")
+                    name = page.split('/')[-1]
+                    url = f"file://{page}"
+                elif "://" in page:
+                    LOG.warning(f"Expected resource name but got URI: {page}")
+                    name = page.split('/')[-1]
+                    url = page
+                pages.append(GuiPage(url, name, persist, duration,
+                                     page, namespace_name, page_resource_dirs))
+
+        with namespace_lock:
+            self._activate_namespace(namespace_name)
+            self._load_pages(pages, show_index)
+            self._update_namespace_persistence(persistence)
 
     def _activate_namespace(self, namespace_name: str):
         """
         Instructs the GUI to load a namespace and its associated data.
 
         @param namespace_name: the name of the namespace to load
         """
         namespace = self._ensure_namespace_exists(namespace_name)
-        LOG.info(f"Activating namespace: {namespace_name}")
+        LOG.debug(f"Activating namespace: {namespace_name}")
 
         if namespace in self.active_namespaces:
             namespace_position = self.active_namespaces.index(namespace)
             namespace.activate(namespace_position)
             self.active_namespaces.insert(
                 0, self.active_namespaces.pop(namespace_position)
             )
@@ -634,50 +758,50 @@
         the skill is showing the pages.
         @param persistence: length of time the namespace should be displayed
         """
         LOG.debug(f"Setting namespace persistence to {persistence}")
         for position, namespace in enumerate(self.active_namespaces):
             if position:
                 if not namespace.persistent:
-                    self._remove_namespace(namespace.name)
+                    self._remove_namespace(namespace.skill_id)
             else:
-                if namespace.name == self.idle_display_skill:
+                if namespace.skill_id == self.idle_display_skill:
                     namespace.set_persistence(skill_type="idleDisplaySkill")
                 else:
                     namespace.set_persistence(skill_type="genericSkill")
 
                     # check if there is a scheduled remove_namespace_timer
                     # and cancel it
-                    if namespace.persistent and namespace.name in \
+                    if namespace.persistent and namespace.skill_id in \
                             self.remove_namespace_timers:
-                        self.remove_namespace_timers[namespace.name].cancel()
-                        self._del_namespace_in_remove_timers(namespace.name)
+                        self.remove_namespace_timers[namespace.skill_id].cancel()
+                        self._del_namespace_in_remove_timers(namespace.skill_id)
 
                 if not namespace.persistent:
                     LOG.info("It is being scheduled here")
                     self._schedule_namespace_removal(namespace)
 
     def _schedule_namespace_removal(self, namespace: Namespace):
         """
         Uses a timer thread to remove the namespace.
         @param namespace: the namespace to be removed
         """
         # Before removing check if there isn't already a timer for this namespace
-        if namespace.name in self.remove_namespace_timers:
+        if namespace.skill_id in self.remove_namespace_timers:
             return
 
         remove_namespace_timer = Timer(
             namespace.duration,
             self._remove_namespace_via_timer,
-            args=(namespace.name,)
+            args=(namespace.skill_id,)
         )
-        LOG.debug(f"Scheduled removal of namespace {namespace.name} in "
+        LOG.debug(f"Scheduled removal of namespace {namespace.skill_id} in "
                   f"duration {namespace.duration}")
         remove_namespace_timer.start()
-        self.remove_namespace_timers[namespace.name] = remove_namespace_timer
+        self.remove_namespace_timers[namespace.skill_id] = remove_namespace_timer
 
     def _remove_namespace_via_timer(self, namespace_name: str):
         """
         Removes a namespace and the corresponding timer instance.
         @param namespace_name: name of namespace to remove
         """
         self._remove_namespace(namespace_name)
@@ -691,18 +815,18 @@
         LOG.debug(f"Removing namespace {namespace_name}")
 
         # Remove all timers associated with the namespace
         if namespace_name in self.remove_namespace_timers:
             self.remove_namespace_timers[namespace_name].cancel()
             self._del_namespace_in_remove_timers(namespace_name)
 
-        namespace = self.loaded_namespaces.get(namespace_name)
+        namespace: Namespace = self.loaded_namespaces.get(namespace_name)
         if namespace is not None and namespace in self.active_namespaces:
             self.core_bus.emit(Message("gui.namespace.removed",
-                                       data={"skill_id": namespace.name}))
+                                       data={"skill_id": namespace.skill_id}))
             if self.active_extension == "Bigscreen":
                 # TODO: Define callback or event instead of arbitrary sleep
                 # wait for window management in bigscreen extension to finish
                 sleep(1)
             namespace_position = self.active_namespaces.index(namespace)
             namespace.remove(namespace_position)
             self.active_namespaces.remove(namespace)
@@ -711,15 +835,15 @@
 
     def _emit_namespace_displayed_event(self):
         """
         Emit a `gui.namespace.displayed` Message to notify core of changes.
         """
         if self.active_namespaces:
             displaying_namespace = self.active_namespaces[0]
-            message_data = dict(skill_id=displaying_namespace.name)
+            message_data = dict(skill_id=displaying_namespace.skill_id)
             self.core_bus.emit(
                 Message("gui.namespace.displayed", data=message_data)
             )
 
     def handle_status_request(self, message: Message):
         """
         Handles a GUI status request by replying with the connection status.
@@ -753,51 +877,72 @@
         @param namespace_name: the name of the namespace to update
         @param data: the name and new value of one or more data attributes
         """
         namespace = self._ensure_namespace_exists(namespace_name)
         for key, value in data.items():
             if key not in RESERVED_KEYS and namespace.data.get(key) != value:
                 LOG.debug(
-                    f"Setting {key} to {value} in namespace {namespace.name}")
+                    f"Setting {key} to {value} in namespace {namespace.skill_id}")
                 namespace.data[key] = value
                 if namespace in self.active_namespaces:
                     namespace.load_data(key, value)
 
     def handle_client_connected(self, message: Message):
         """
         Handles an event from the GUI indicating it is connected to the bus.
         @param message: the event sent by the GUI
         """
-        # GUI has announced presence
-        # Announce connection, the GUI should connect on it soon
+        # old style GUI has announced presence in core bus
+        # send websocket port, the GUI should connect on it soon
         gui_id = message.data.get("gui_id")
+
+        framework = message.data.get("framework")  # new api
+        if framework is None:
+            qt = message.data.get("qt_version", 5)  # mycroft-gui api
+            if int(qt) == 6:
+                framework = "qt6"
+            else:
+                framework = "qt5"
+
         LOG.info(f"GUI with ID {gui_id} connected to core message bus")
         websocket_config = get_gui_websocket_config()
         port = websocket_config["base_port"]
         message = message.forward("mycroft.gui.port",
                                   dict(port=port, gui_id=gui_id))
         self.core_bus.emit(message)
 
+        if self.gui_file_path:
+            if not self._ready_event.wait(90):
+                LOG.warning("Not reported ready after 90s")
+            if framework not in self._connected_frameworks:
+                self.core_bus.emit(Message("gui.request_page_upload",
+                                           {'framework': framework},
+                                           {"source": "gui",
+                                            "destination": ["skills", "PHAL"]}))
+
+        if framework not in self._connected_frameworks:
+            self._connected_frameworks.append(framework)
+
     def handle_page_interaction(self, message: Message):
         """
         Handles an event from the GUI indicating a page has been interacted with.
         @param message: the event sent by the GUI
         """
         # GUI has interacted with a page
         # Update and increase the namespace duration and reset the remove timer
         namespace_name = message.data.get("skill_id")
         LOG.debug(f"GUI interacted with page in namespace {namespace_name}")
         if namespace_name == self.idle_display_skill:
             return
         else:
             namespace = self.loaded_namespaces.get(namespace_name)
             if not namespace.persistent:
-                if self.remove_namespace_timers[namespace.name]:
-                    self.remove_namespace_timers[namespace.name].cancel()
-                    self._del_namespace_in_remove_timers(namespace.name)
+                if self.remove_namespace_timers[namespace.skill_id]:
+                    self.remove_namespace_timers[namespace.skill_id].cancel()
+                    self._del_namespace_in_remove_timers(namespace.skill_id)
                     self._schedule_namespace_removal(namespace)
 
     def handle_page_gained_focus(self, message: Message):
         """
         Handles focus events from the GUI indicating the page has gained focus.
         @param message: the event sent by the GUI
         """
@@ -814,19 +959,30 @@
                 namespace.page_gained_focus(namespace_page_number)
 
     def handle_namespace_global_back(self, message: Optional[Message]):
         """
         Handles global back events from the GUI.
         @param message: the event sent by the GUI
         """
-        namespace_name = self.active_namespaces[0].name
+        namespace_name = self.active_namespaces[0].skill_id
         namespace = self.loaded_namespaces.get(namespace_name)
         if namespace in self.active_namespaces:
             namespace.global_back()
 
     def _del_namespace_in_remove_timers(self, namespace_name: str):
         """
         Delete namespace from remove_namespace_timers dict.
         @param namespace_name: name of namespace to be deleted
         """
         if namespace_name in self.remove_namespace_timers:
             del self.remove_namespace_timers[namespace_name]
+
+    def _upload_system_resources(self):
+        """
+        Copy system GUI resources to the served file path
+        """
+        output_path = join(self.gui_file_path, "system")
+        if exists(output_path):
+            LOG.info(f"Removing existing system resources before updating")
+            shutil.rmtree(output_path)
+        shutil.copytree(self._system_res_dir, output_path)
+        LOG.debug(f"Copied system resources to {self.gui_file_path}")
```

## ovos_gui/page.py

```diff
@@ -1,18 +1,84 @@
+from os.path import join, isfile, dirname
+from typing import Union, Optional
+from dataclasses import dataclass
 from ovos_utils.log import LOG
 
 
+@dataclass
 class GuiPage:
-    def __init__(self, url: str, name: str, persistent: bool, duration: int):
+    """
+    A GuiPage represents a single GUI Display within a given namespace.
+    A Page can either be `persistent` or be removed after some `duration`.
+    Note that a page is generally framework-independent
+    @param url: URI (local or network path) of the GUI Page
+    @param name: Name of the page as shown in its namespace (could
+    @param persistent: If True, page is displayed indefinitely
+    @param duration: Number of seconds to display the page for
+    @param namespace: Skill/component identifier
+    @param page_id: Page identifier
+        (file path relative to gui_framework directory with no extension)
+    """
+    url: Optional[str]  # This param is left for backwards-compat.
+    name: str
+    persistent: bool
+    duration: Union[int, bool]
+    page_id: Optional[str] = None
+    namespace: Optional[str] = None
+    resource_dirs: Optional[dict] = None
+
+    active: bool = False
+
+    @property
+    def id(self):
+        """
+        Get a unique identifier for this page.
+        """
+        return self.page_id or self.url
+
+    @staticmethod
+    def get_file_extension(framework: str) -> str:
         """
-        A GuiPage represents a single GUI Display within a given namespace.
-        A Page can either be `persistent` or be removed after some `duration`.
-        @param url: URI (local or network path) of the GUI Page
-        @param name: Name of the page as shown in its namespace
-        @param persistent: If True, page is displayed indefinitely
-        @param duration: Number of seconds to display the page for
-        """
-        self.url = url
-        self.name = name
-        self.persistent = persistent
-        self.duration = duration
-        self.active = False
+        Get a file extension for the specified GUI framework
+        @param framework: string framework to get file extension for
+        @return: string file extension (empty string if unknown)
+        """
+        if framework in ("qt5", "qt6"):
+            return "qml"
+        return ""
+
+    def get_uri(self, framework: str = "qt5", server_url: str = None) -> str:
+        """
+        Get a valid URI for this Page.
+        @param framework: String GUI framework to get resources for
+        @param server_url: String server URL if available
+        @return: Absolute path to the requested resource
+        """
+        if self.url:
+            LOG.warning(f"Static URI: {self.url}")
+            return self.url
+
+        res_filename = f"{self.page_id}.{self.get_file_extension(framework)}"
+        res_namespace = "system" if self.page_id.startswith("SYSTEM") else \
+            self.namespace
+        if server_url:
+            if "://" not in server_url:
+                LOG.debug(f"No schema in server_url, assuming 'http'")
+                server_url = f"http://{server_url}"
+            path = f"{server_url}/{res_namespace}/{framework}/{res_filename}"
+            LOG.info(f"Resolved server URI: {path}")
+            return path
+        base_path = self.resource_dirs.get(framework)
+        if not base_path and self.resource_dirs.get("all"):
+            file_path = join(self.resource_dirs.get('all'), framework,
+                             res_filename)
+        else:
+            file_path = join(base_path, res_filename)
+        if isfile(file_path):
+            return file_path
+        # Check system resources
+        file_path = join(dirname(__file__), "res", "gui", framework)
+        if isfile(file_path):
+            return file_path
+        raise FileNotFoundError(f"Unable to resolve resource file for "
+                                f"resource {res_filename} for framework "
+                                f"{framework}")
```

## ovos_gui/version.py

```diff
@@ -1,6 +1,6 @@
 # START_VERSION_BLOCK
 VERSION_MAJOR = 0
 VERSION_MINOR = 0
 VERSION_BUILD = 3
-VERSION_ALPHA = 7
+VERSION_ALPHA = 8
 # END_VERSION_BLOCK
```

## Comparing `ovos_gui/res/ui/FeatureRequest.qml` & `ovos_gui/res/gui/qt5/FeatureRequest.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/RequestHandler.qml` & `ovos_gui/res/gui/qt5/RequestHandler.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/SYSTEM_AdditionalSettings.qml` & `ovos_gui/res/gui/qt5/SYSTEM_AdditionalSettings.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/SYSTEM_AnimatedImageFrame.qml` & `ovos_gui/res/gui/qt5/SYSTEM_AnimatedImageFrame.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/SYSTEM_ImageFrame.qml` & `ovos_gui/res/gui/qt5/SYSTEM_ImageFrame.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/SYSTEM_TextFrame.qml` & `ovos_gui/res/gui/qt5/SYSTEM_TextFrame.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/SYSTEM_UrlFrame.qml` & `ovos_gui/res/gui/qt5/SYSTEM_UrlFrame.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/SwipeArea.qml` & `ovos_gui/res/gui/qt5/SwipeArea.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/WebViewHtmlFrame.qml` & `ovos_gui/res/gui/qt5/WebViewHtmlFrame.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui/res/ui/WebViewUrlFrame.qml` & `ovos_gui/res/gui/qt5/WebViewUrlFrame.qml`

 * *Files identical despite different names*

## Comparing `ovos_gui-0.0.3a7.dist-info/LICENSE.md` & `ovos_gui-0.0.3a8.dist-info/LICENSE.md`

 * *Files identical despite different names*

## Comparing `ovos_gui-0.0.3a7.dist-info/RECORD` & `ovos_gui-0.0.3a8.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 ovos_gui/__init__.py,sha256=hJ9nauO2fOmytikCByaFsM1pOsrkQnJ20eInzQK8pCo,648
 ovos_gui/__main__.py,sha256=gmD8ifeZdbqKT3KZ_ZeDoy3IUe1ybnWCzsTww6cuOVg,944
-ovos_gui/bus.py,sha256=JDctuDufMnlniUWRt3L14Kzk1FHHJrl5XOL9RjNgxdw,8008
+ovos_gui/bus.py,sha256=lVel5OL-pST3YeEYuygMwGxJO4vYytxz4fV7bYF9O3U,10499
 ovos_gui/extensions.py,sha256=QMSekth0ehYhS1YrRK4nq606p12_Cu0Dz22oZ7Zxaf8,2927
-ovos_gui/homescreen.py,sha256=CgwRnlJPPhssNPWVxOeI0QfseZ99pdgtH9GzS7l7RCg,9870
-ovos_gui/namespace.py,sha256=dtTfzP5co4onhxqmxKj8Y9iY2hySlzVHhCgoAPMi5vE,32552
-ovos_gui/page.py,sha256=2RyX3x6250_M7SHZuPDSDqLGVrFcruIf2UGnLg5haXI,713
+ovos_gui/gui_file_server.py,sha256=34GpRqaT0ycEt70lTe_heBy_b7dhgwgitbrZ7efEU4U,1743
+ovos_gui/homescreen.py,sha256=f8uQkyygbv9T2FgOnlJSRauvgDTvjstuabYmOE6l9Us,9858
+ovos_gui/namespace.py,sha256=NybRfmIYjXrs0JzSevBSKrWvB9QHhvKVJP7iOWLneXo,40389
+ovos_gui/page.py,sha256=f24S06PvyObGuVzlIVNT-w_NWpesBVVYlKIb6XTD8QY,3246
 ovos_gui/service.py,sha256=aeQFP3QwWaoRZXri1aXODXHIHz1oQq6LWBtSqDzfXzg,2500
 ovos_gui/tui.py,sha256=fprzIuBYwTGAqo9onVSIyFGlK9OjuV4JAzMQ0W5GhiA,6373
-ovos_gui/version.py,sha256=Yaw1FQSL7crgiPzccRkbOv5tYFFMObLw2NyPxxAJlg8,114
-ovos_gui/res/snd/clicked.wav,sha256=lknQ7YbyEp45Voki7aQ9olwofKDSkFMo7N29cNEfuzQ,15240
-ovos_gui/res/ui/FeatureRequest.qml,sha256=f-gbDMPCd9FLSouCVcrKVHwbFB5-ySwvIDIVXUJF3sc,4176
-ovos_gui/res/ui/RequestHandler.qml,sha256=hM21FWuwVOb7KtbPgkx1tvvRV8cW7uc664kAp31PYWs,811
-ovos_gui/res/ui/SYSTEM_AdditionalSettings.qml,sha256=2qo3Fx1bpLb0xcjmkcOQjsJZ01YO9wFH9-1KEDM_NHM,1523
-ovos_gui/res/ui/SYSTEM_AnimatedImageFrame.qml,sha256=Tclqjg4rJWicw7LU3Ja6m0fny6WndpNj_h_mp6xXfDo,2804
-ovos_gui/res/ui/SYSTEM_HtmlFrame.qml,sha256=At9bviiJnGE06tsmbmyYygBPLRHjfJ_bdWUTFrYWac8,478
-ovos_gui/res/ui/SYSTEM_ImageFrame.qml,sha256=f51Og6CZKQVeMg0C-q9_d4T12Goj9POEos0GGiJU0Oc,2796
-ovos_gui/res/ui/SYSTEM_TextFrame.qml,sha256=FgPxoYoQlJx5ux9PU1vsABilru6O0CPtHtLAfXTlVdc,1206
-ovos_gui/res/ui/SYSTEM_UrlFrame.qml,sha256=nktJTLJKmqnrH6974rYV9sQtIPd1UVs9KXppcpFt5zA,6539
-ovos_gui/res/ui/SwipeArea.qml,sha256=iNbxJLrgSkVNEY3JE9omDzQrTPNExuuLLVRYUL6bs4c,1405
-ovos_gui/res/ui/WebViewHtmlFrame.qml,sha256=zBUG3cbSaf5_4e6rLo2OF6M7XNy19Vtg-qZz_bKT6SM,3215
-ovos_gui/res/ui/WebViewUrlFrame.qml,sha256=NdytZ0TB5khcoCzCCV2BrSUe81IV3V7AElPSYuxNSlM,3031
-ovos_gui-0.0.3a7.dist-info/LICENSE.md,sha256=HP46TQN2uSd_OW1lJPi1TJ-SVSgLJXixGmY9C16CQJQ,11423
-ovos_gui-0.0.3a7.dist-info/METADATA,sha256=pXlPC2PyFsWjziigwOovHGpatqN7b30PXIWRgpHGWGg,449
-ovos_gui-0.0.3a7.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-ovos_gui-0.0.3a7.dist-info/entry_points.txt,sha256=OKK57gb6Tf7DZg2DdJf0oFhRQd2nl_C7AhOI_4PQ1zc,100
-ovos_gui-0.0.3a7.dist-info/top_level.txt,sha256=njR-r8BVkBUH1vZ3_54Mr1cpSW6Ix4CW1X8QgQC4Kd8,9
-ovos_gui-0.0.3a7.dist-info/RECORD,,
+ovos_gui/version.py,sha256=C2FW4qIz_6fPEpJmrm-FdZnd3s2gx-z-EUf6ML_TBIE,114
+ovos_gui/res/gui/qt5/FeatureRequest.qml,sha256=f-gbDMPCd9FLSouCVcrKVHwbFB5-ySwvIDIVXUJF3sc,4176
+ovos_gui/res/gui/qt5/RequestHandler.qml,sha256=hM21FWuwVOb7KtbPgkx1tvvRV8cW7uc664kAp31PYWs,811
+ovos_gui/res/gui/qt5/SYSTEM_AdditionalSettings.qml,sha256=2qo3Fx1bpLb0xcjmkcOQjsJZ01YO9wFH9-1KEDM_NHM,1523
+ovos_gui/res/gui/qt5/SYSTEM_AnimatedImageFrame.qml,sha256=Tclqjg4rJWicw7LU3Ja6m0fny6WndpNj_h_mp6xXfDo,2804
+ovos_gui/res/gui/qt5/SYSTEM_HtmlFrame.qml,sha256=At9bviiJnGE06tsmbmyYygBPLRHjfJ_bdWUTFrYWac8,478
+ovos_gui/res/gui/qt5/SYSTEM_ImageFrame.qml,sha256=f51Og6CZKQVeMg0C-q9_d4T12Goj9POEos0GGiJU0Oc,2796
+ovos_gui/res/gui/qt5/SYSTEM_TextFrame.qml,sha256=FgPxoYoQlJx5ux9PU1vsABilru6O0CPtHtLAfXTlVdc,1206
+ovos_gui/res/gui/qt5/SYSTEM_UrlFrame.qml,sha256=nktJTLJKmqnrH6974rYV9sQtIPd1UVs9KXppcpFt5zA,6539
+ovos_gui/res/gui/qt5/SwipeArea.qml,sha256=iNbxJLrgSkVNEY3JE9omDzQrTPNExuuLLVRYUL6bs4c,1405
+ovos_gui/res/gui/qt5/WebViewHtmlFrame.qml,sha256=zBUG3cbSaf5_4e6rLo2OF6M7XNy19Vtg-qZz_bKT6SM,3215
+ovos_gui/res/gui/qt5/WebViewUrlFrame.qml,sha256=NdytZ0TB5khcoCzCCV2BrSUe81IV3V7AElPSYuxNSlM,3031
+ovos_gui-0.0.3a8.dist-info/LICENSE.md,sha256=HP46TQN2uSd_OW1lJPi1TJ-SVSgLJXixGmY9C16CQJQ,11423
+ovos_gui-0.0.3a8.dist-info/METADATA,sha256=RzjykHQXACQibgj6DvnsMRjr_Yzhl721KngHp7s4TBE,449
+ovos_gui-0.0.3a8.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+ovos_gui-0.0.3a8.dist-info/entry_points.txt,sha256=OKK57gb6Tf7DZg2DdJf0oFhRQd2nl_C7AhOI_4PQ1zc,100
+ovos_gui-0.0.3a8.dist-info/top_level.txt,sha256=njR-r8BVkBUH1vZ3_54Mr1cpSW6Ix4CW1X8QgQC4Kd8,9
+ovos_gui-0.0.3a8.dist-info/RECORD,,
```

