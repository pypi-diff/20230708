# Comparing `tmp/hat_drivers-0.6.9-cp38.cp39.cp310-none-any.whl.zip` & `tmp/hat_drivers-0.7.0-cp310.cp311-abi3-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,99 +1,112 @@
-Zip file size: 156904 bytes, number of entries: 97
+Zip file size: 272267 bytes, number of entries: 110
 -rw-r--r--  2.0 unx       28 b- defN 21-May-03 22:33 hat/drivers/__init__.py
--rw-r--r--  2.0 unx    14501 b- defN 21-Feb-14 00:28 hat/drivers/cosp.py
--rw-r--r--  2.0 unx    14253 b- defN 21-Feb-14 00:39 hat/drivers/cotp.py
--rw-r--r--  2.0 unx     6645 b- defN 23-Jan-06 22:25 hat/drivers/serial.py
--rw-r--r--  2.0 unx     2735 b- defN 22-Aug-29 13:31 hat/drivers/ssdp.py
--rw-r--r--  2.0 unx    10153 b- defN 23-Jan-23 17:39 hat/drivers/tcp.py
--rw-r--r--  2.0 unx     4036 b- defN 21-Feb-23 13:44 hat/drivers/tpkt.py
--rw-r--r--  2.0 unx     2756 b- defN 22-May-10 19:12 hat/drivers/udp.py
--rw-r--r--  2.0 unx    15198 b- defN 22-Jul-16 23:39 hat/drivers/acse/__init__.py
--rw-r--r--  2.0 unx     8498 b- defN 23-Jan-23 22:11 hat/drivers/acse/asn1_repo.json
+-rw-r--r--  2.0 unx     2691 b- defN 23-Jun-25 13:28 hat/drivers/ssdp.py
+-rw-r--r--  2.0 unx    12953 b- defN 23-Jun-25 23:57 hat/drivers/tcp.py
+-rw-r--r--  2.0 unx     4582 b- defN 23-Jun-26 13:54 hat/drivers/tpkt.py
+-rw-r--r--  2.0 unx     3139 b- defN 23-Jun-25 17:30 hat/drivers/udp.py
+-rw-r--r--  2.0 unx    18002 b- defN 23-Jun-26 14:04 hat/drivers/acse/__init__.py
+-rw-r--r--  2.0 unx     8498 b- defN 23-Jul-08 10:45 hat/drivers/acse/asn1_repo.json
 -rw-r--r--  2.0 unx     1024 b- defN 22-Nov-01 19:30 hat/drivers/cdt/__init__.py
 -rw-r--r--  2.0 unx      286 b- defN 22-Oct-30 23:00 hat/drivers/cdt/browser.py
--rw-r--r--  2.0 unx     3476 b- defN 22-Oct-30 23:23 hat/drivers/cdt/connection.py
+-rw-r--r--  2.0 unx     3466 b- defN 23-Jun-25 14:31 hat/drivers/cdt/connection.py
 -rw-r--r--  2.0 unx      596 b- defN 22-Nov-01 19:29 hat/drivers/cdt/page.py
--rw-r--r--  2.0 unx     1297 b- defN 22-Oct-30 23:31 hat/drivers/cdt/runtime.py
--rw-r--r--  2.0 unx     2859 b- defN 22-Oct-30 23:08 hat/drivers/cdt/target.py
--rw-r--r--  2.0 unx    14325 b- defN 22-Jul-16 23:39 hat/drivers/copp/__init__.py
--rw-r--r--  2.0 unx    12628 b- defN 23-Jan-23 22:11 hat/drivers/copp/asn1_repo.json
--rw-r--r--  2.0 unx     7994 b- defN 22-Nov-22 02:28 hat/drivers/iec101/__init__.py
--rw-r--r--  2.0 unx    16692 b- defN 22-Nov-22 00:17 hat/drivers/iec101/common.py
--rw-r--r--  2.0 unx     1025 b- defN 22-Nov-22 02:00 hat/drivers/iec101/connection.py
--rw-r--r--  2.0 unx    33150 b- defN 22-Dec-07 00:44 hat/drivers/iec101/encoder.py
--rw-r--r--  2.0 unx     3592 b- defN 22-Nov-22 00:18 hat/drivers/iec103/__init__.py
--rw-r--r--  2.0 unx     4230 b- defN 22-Nov-22 00:19 hat/drivers/iec103/common.py
--rw-r--r--  2.0 unx    17825 b- defN 22-Dec-07 00:44 hat/drivers/iec103/master.py
--rw-r--r--  2.0 unx     8052 b- defN 22-Dec-13 10:03 hat/drivers/iec104/__init__.py
--rw-r--r--  2.0 unx     5967 b- defN 22-Dec-13 10:02 hat/drivers/iec104/common.py
--rw-r--r--  2.0 unx    30142 b- defN 22-Dec-07 00:46 hat/drivers/iec104/encoder.py
--rw-r--r--  2.0 unx     3426 b- defN 23-Jan-12 00:04 hat/drivers/iec104/connection/__init__.py
--rw-r--r--  2.0 unx     1060 b- defN 22-Dec-13 10:04 hat/drivers/iec104/connection/regular.py
--rw-r--r--  2.0 unx     3533 b- defN 22-Dec-13 12:14 hat/drivers/iec104/connection/secure.py
+-rw-r--r--  2.0 unx     1268 b- defN 23-Jun-26 14:37 hat/drivers/cdt/runtime.py
+-rw-r--r--  2.0 unx     2807 b- defN 23-Jun-26 14:37 hat/drivers/cdt/target.py
+-rw-r--r--  2.0 unx    17263 b- defN 23-Jun-26 14:04 hat/drivers/copp/__init__.py
+-rw-r--r--  2.0 unx    12628 b- defN 23-Jul-08 10:45 hat/drivers/copp/asn1_repo.json
+-rw-r--r--  2.0 unx      582 b- defN 23-Jun-25 21:06 hat/drivers/cosp/__init__.py
+-rw-r--r--  2.0 unx      670 b- defN 23-Jun-25 22:12 hat/drivers/cosp/common.py
+-rw-r--r--  2.0 unx    13338 b- defN 23-Jun-26 14:05 hat/drivers/cosp/connection.py
+-rw-r--r--  2.0 unx     3895 b- defN 23-Jun-25 22:23 hat/drivers/cosp/encoder.py
+-rw-r--r--  2.0 unx      506 b- defN 23-Jun-25 22:49 hat/drivers/cotp/__init__.py
+-rw-r--r--  2.0 unx     1747 b- defN 23-Jun-25 22:52 hat/drivers/cotp/common.py
+-rw-r--r--  2.0 unx    10851 b- defN 23-Jun-26 13:55 hat/drivers/cotp/connection.py
+-rw-r--r--  2.0 unx     4807 b- defN 23-Jun-25 22:56 hat/drivers/cotp/encoder.py
+-rw-r--r--  2.0 unx     7928 b- defN 23-Jun-27 23:41 hat/drivers/iec101/__init__.py
+-rw-r--r--  2.0 unx    17550 b- defN 23-Jun-27 23:45 hat/drivers/iec101/common.py
+-rw-r--r--  2.0 unx      996 b- defN 23-Jun-27 23:46 hat/drivers/iec101/connection.py
+-rw-r--r--  2.0 unx    33161 b- defN 23-Jun-27 23:46 hat/drivers/iec101/encoder.py
+-rw-r--r--  2.0 unx     3526 b- defN 23-Jun-27 23:48 hat/drivers/iec103/__init__.py
+-rw-r--r--  2.0 unx     4734 b- defN 23-Jun-27 23:48 hat/drivers/iec103/common.py
+-rw-r--r--  2.0 unx    17832 b- defN 23-Jun-27 23:49 hat/drivers/iec103/master.py
+-rw-r--r--  2.0 unx     7986 b- defN 23-Jun-28 00:08 hat/drivers/iec104/__init__.py
+-rw-r--r--  2.0 unx     7450 b- defN 23-Jun-27 23:55 hat/drivers/iec104/common.py
+-rw-r--r--  2.0 unx    30153 b- defN 23-Jun-27 23:56 hat/drivers/iec104/encoder.py
+-rw-r--r--  2.0 unx     3324 b- defN 23-Jun-28 00:09 hat/drivers/iec104/connection/__init__.py
+-rw-r--r--  2.0 unx      977 b- defN 23-Jun-28 00:04 hat/drivers/iec104/connection/regular.py
+-rw-r--r--  2.0 unx     3340 b- defN 23-Jun-28 00:09 hat/drivers/iec104/connection/secure.py
 -rw-r--r--  2.0 unx       42 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/__init__.py
--rw-r--r--  2.0 unx      647 b- defN 23-Jan-07 21:06 hat/drivers/iec60870/apci/__init__.py
--rw-r--r--  2.0 unx      571 b- defN 22-Nov-22 00:12 hat/drivers/iec60870/apci/common.py
--rw-r--r--  2.0 unx    15414 b- defN 23-Jan-07 21:10 hat/drivers/iec60870/apci/connection.py
--rw-r--r--  2.0 unx     2159 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/apci/encoder.py
--rw-r--r--  2.0 unx      725 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/link/__init__.py
--rw-r--r--  2.0 unx     1336 b- defN 22-Nov-22 00:12 hat/drivers/iec60870/link/common.py
--rw-r--r--  2.0 unx      335 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/link/connection.py
--rw-r--r--  2.0 unx     4822 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/link/encoder.py
--rw-r--r--  2.0 unx     2348 b- defN 23-Jan-06 20:14 hat/drivers/iec60870/link/endpoint.py
+-rw-r--r--  2.0 unx      572 b- defN 23-Jun-27 22:06 hat/drivers/iec60870/apci/__init__.py
+-rw-r--r--  2.0 unx      570 b- defN 23-Jun-27 22:07 hat/drivers/iec60870/apci/common.py
+-rw-r--r--  2.0 unx    16414 b- defN 23-Jun-27 23:00 hat/drivers/iec60870/apci/connection.py
+-rw-r--r--  2.0 unx     2175 b- defN 23-Jun-27 22:07 hat/drivers/iec60870/apci/encoder.py
+-rw-r--r--  2.0 unx      652 b- defN 23-Jun-27 22:04 hat/drivers/iec60870/link/__init__.py
+-rw-r--r--  2.0 unx     1309 b- defN 23-Jun-27 21:57 hat/drivers/iec60870/link/common.py
+-rw-r--r--  2.0 unx      339 b- defN 23-Jun-27 21:58 hat/drivers/iec60870/link/connection.py
+-rw-r--r--  2.0 unx     4838 b- defN 23-Jun-27 21:58 hat/drivers/iec60870/link/encoder.py
+-rw-r--r--  2.0 unx     2349 b- defN 23-Jun-27 21:59 hat/drivers/iec60870/link/endpoint.py
 -rw-r--r--  2.0 unx       90 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/link/balanced/__init__.py
--rw-r--r--  2.0 unx     1085 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/link/balanced/connection.py
+-rw-r--r--  2.0 unx     1103 b- defN 23-Jun-27 22:00 hat/drivers/iec60870/link/balanced/connection.py
 -rw-r--r--  2.0 unx      368 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/link/unbalanced/__init__.py
--rw-r--r--  2.0 unx    12180 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/link/unbalanced/master.py
--rw-r--r--  2.0 unx     8162 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/link/unbalanced/slave.py
+-rw-r--r--  2.0 unx    12166 b- defN 23-Jun-27 22:01 hat/drivers/iec60870/link/unbalanced/master.py
+-rw-r--r--  2.0 unx     8118 b- defN 23-Jun-27 22:03 hat/drivers/iec60870/link/unbalanced/slave.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Nov-22 00:10 hat/drivers/iec60870/msgs/__init__.py
--rw-r--r--  2.0 unx     3110 b- defN 22-Mar-03 17:24 hat/drivers/iec60870/msgs/common.py
--rw-r--r--  2.0 unx     6488 b- defN 22-Dec-07 00:37 hat/drivers/iec60870/msgs/encoder.py
+-rw-r--r--  2.0 unx     2956 b- defN 23-Jun-27 21:45 hat/drivers/iec60870/msgs/common.py
+-rw-r--r--  2.0 unx     6645 b- defN 23-Jun-27 21:40 hat/drivers/iec60870/msgs/encoder.py
 -rw-r--r--  2.0 unx      182 b- defN 22-Nov-22 00:13 hat/drivers/iec60870/msgs/iec101/__init__.py
--rw-r--r--  2.0 unx    15262 b- defN 22-Nov-22 00:14 hat/drivers/iec60870/msgs/iec101/common.py
--rw-r--r--  2.0 unx    48820 b- defN 22-Dec-07 02:10 hat/drivers/iec60870/msgs/iec101/encoder.py
+-rw-r--r--  2.0 unx    15741 b- defN 23-Jun-27 21:47 hat/drivers/iec60870/msgs/iec101/common.py
+-rw-r--r--  2.0 unx    48353 b- defN 23-Jun-27 21:44 hat/drivers/iec60870/msgs/iec101/encoder.py
 -rw-r--r--  2.0 unx      182 b- defN 22-Nov-22 00:15 hat/drivers/iec60870/msgs/iec103/__init__.py
--rw-r--r--  2.0 unx    13455 b- defN 22-Nov-22 00:15 hat/drivers/iec60870/msgs/iec103/common.py
--rw-r--r--  2.0 unx    35045 b- defN 22-Dec-07 00:40 hat/drivers/iec60870/msgs/iec103/encoder.py
+-rw-r--r--  2.0 unx    13182 b- defN 23-Jun-27 21:49 hat/drivers/iec60870/msgs/iec103/common.py
+-rw-r--r--  2.0 unx    35040 b- defN 23-Jun-27 21:50 hat/drivers/iec60870/msgs/iec103/encoder.py
 -rw-r--r--  2.0 unx      182 b- defN 22-Nov-22 00:15 hat/drivers/iec60870/msgs/iec104/__init__.py
--rw-r--r--  2.0 unx     9677 b- defN 22-Dec-06 20:26 hat/drivers/iec60870/msgs/iec104/common.py
--rw-r--r--  2.0 unx    10043 b- defN 22-Dec-07 02:11 hat/drivers/iec60870/msgs/iec104/encoder.py
+-rw-r--r--  2.0 unx     9902 b- defN 23-Jun-27 21:52 hat/drivers/iec60870/msgs/iec104/common.py
+-rw-r--r--  2.0 unx    10037 b- defN 23-Jun-27 21:52 hat/drivers/iec60870/msgs/iec104/encoder.py
 -rw-r--r--  2.0 unx      203 b- defN 22-Dec-06 20:15 hat/drivers/iec60870/msgs/security/__init__.py
--rw-r--r--  2.0 unx     7219 b- defN 22-Dec-15 08:40 hat/drivers/iec60870/msgs/security/common.py
--rw-r--r--  2.0 unx    25326 b- defN 22-Dec-19 12:43 hat/drivers/iec60870/msgs/security/encoder.py
--rw-r--r--  2.0 unx     4434 b- defN 21-Feb-07 20:54 hat/drivers/mms/__init__.py
--rw-r--r--  2.0 unx   186717 b- defN 23-Jan-23 22:11 hat/drivers/mms/asn1_repo.json
--rw-r--r--  2.0 unx    10223 b- defN 22-Apr-11 21:00 hat/drivers/mms/common.py
--rw-r--r--  2.0 unx    13095 b- defN 22-Jul-16 23:41 hat/drivers/mms/connection.py
--rw-r--r--  2.0 unx    26923 b- defN 21-Jan-19 20:56 hat/drivers/mms/encoder.py
+-rw-r--r--  2.0 unx     7369 b- defN 23-Jun-27 21:55 hat/drivers/iec60870/msgs/security/common.py
+-rw-r--r--  2.0 unx    25259 b- defN 23-Jun-27 21:55 hat/drivers/iec60870/msgs/security/encoder.py
+-rw-r--r--  2.0 unx     4404 b- defN 23-Jun-26 13:48 hat/drivers/mms/__init__.py
+-rw-r--r--  2.0 unx   186717 b- defN 23-Jul-08 10:45 hat/drivers/mms/asn1_repo.json
+-rw-r--r--  2.0 unx     8238 b- defN 23-Jun-26 12:58 hat/drivers/mms/common.py
+-rw-r--r--  2.0 unx    13117 b- defN 23-Jun-26 14:04 hat/drivers/mms/connection.py
+-rw-r--r--  2.0 unx    26924 b- defN 23-Jun-26 12:58 hat/drivers/mms/encoder.py
 -rw-r--r--  2.0 unx     1112 b- defN 23-Jan-07 03:37 hat/drivers/modbus/__init__.py
 -rw-r--r--  2.0 unx      532 b- defN 21-May-19 00:33 hat/drivers/modbus/common.py
--rw-r--r--  2.0 unx    12155 b- defN 23-Jan-23 22:08 hat/drivers/modbus/master.py
--rw-r--r--  2.0 unx    15351 b- defN 23-Jan-07 20:35 hat/drivers/modbus/slave.py
+-rw-r--r--  2.0 unx    13153 b- defN 23-Jun-25 13:42 hat/drivers/modbus/master.py
+-rw-r--r--  2.0 unx    16491 b- defN 23-Jun-25 13:45 hat/drivers/modbus/slave.py
 -rw-r--r--  2.0 unx     3526 b- defN 23-Jan-06 17:57 hat/drivers/modbus/transport/__init__.py
--rw-r--r--  2.0 unx     5176 b- defN 23-Jan-06 17:55 hat/drivers/modbus/transport/common.py
--rw-r--r--  2.0 unx     3907 b- defN 23-Jan-23 19:38 hat/drivers/modbus/transport/connection.py
--rw-r--r--  2.0 unx    19777 b- defN 23-Jan-07 19:45 hat/drivers/modbus/transport/encoder.py
+-rwxr-xr-x  2.0 unx   108045 b- defN 23-Jul-08 10:45 hat/drivers/modbus/transport/_encoder.abi3.pyd
+-rw-r--r--  2.0 unx     4552 b- defN 23-Jun-26 14:46 hat/drivers/modbus/transport/common.py
+-rw-r--r--  2.0 unx     4709 b- defN 23-Jun-26 14:49 hat/drivers/modbus/transport/connection.py
+-rw-r--r--  2.0 unx    19933 b- defN 23-Jun-26 14:48 hat/drivers/modbus/transport/encoder.py
 -rw-r--r--  2.0 unx      823 b- defN 22-Sep-12 23:42 hat/drivers/pnetgateway/__init__.py
--rw-r--r--  2.0 unx     6161 b- defN 22-Sep-12 23:59 hat/drivers/pnetgateway/client.py
--rw-r--r--  2.0 unx     1182 b- defN 22-Sep-12 23:11 hat/drivers/pnetgateway/common.py
--rw-r--r--  2.0 unx     1880 b- defN 22-Sep-12 23:18 hat/drivers/pnetgateway/encoder.py
--rw-r--r--  2.0 unx      791 b- defN 23-Jan-07 20:49 hat/drivers/pnetgateway/transport.py
--rw-r--r--  2.0 unx     2029 b- defN 22-May-10 19:12 hat/drivers/snmp/__init__.py
--rw-r--r--  2.0 unx     6184 b- defN 22-May-10 19:12 hat/drivers/snmp/agent.py
--rw-r--r--  2.0 unx     4942 b- defN 22-May-10 19:12 hat/drivers/snmp/common.py
--rw-r--r--  2.0 unx     7545 b- defN 22-May-10 19:12 hat/drivers/snmp/manager.py
--rw-r--r--  2.0 unx    12648 b- defN 22-May-11 11:37 hat/drivers/snmp/trap.py
--rw-r--r--  2.0 unx     2511 b- defN 22-Jul-16 23:43 hat/drivers/snmp/encoder/__init__.py
--rw-r--r--  2.0 unx     9211 b- defN 23-Jan-23 22:11 hat/drivers/snmp/encoder/asn1_repo.json
--rw-r--r--  2.0 unx     6259 b- defN 22-May-10 19:12 hat/drivers/snmp/encoder/v1.py
--rw-r--r--  2.0 unx     7937 b- defN 22-May-10 19:12 hat/drivers/snmp/encoder/v2c.py
+-rw-r--r--  2.0 unx     6296 b- defN 23-Jun-26 14:36 hat/drivers/pnetgateway/client.py
+-rw-r--r--  2.0 unx     1142 b- defN 23-Jun-25 13:41 hat/drivers/pnetgateway/common.py
+-rw-r--r--  2.0 unx     1881 b- defN 23-Jun-26 14:27 hat/drivers/pnetgateway/encoder.py
+-rw-r--r--  2.0 unx      803 b- defN 23-Jun-26 14:30 hat/drivers/pnetgateway/transport.py
+-rw-r--r--  2.0 unx     1965 b- defN 23-Jun-26 14:23 hat/drivers/serial/__init__.py
+-rwxr-xr-x  2.0 unx   120682 b- defN 23-Jul-08 10:45 hat/drivers/serial/_native_serial.abi3.pyd
+-rw-r--r--  2.0 unx     1103 b- defN 23-Jun-26 14:23 hat/drivers/serial/common.py
+-rw-r--r--  2.0 unx     5794 b- defN 23-Apr-19 17:27 hat/drivers/serial/native_serial.py
+-rw-r--r--  2.0 unx     4681 b- defN 23-Apr-10 22:50 hat/drivers/serial/py_serial.py
+-rw-r--r--  2.0 unx     1879 b- defN 23-Jun-26 14:13 hat/drivers/snmp/__init__.py
+-rw-r--r--  2.0 unx     6185 b- defN 23-Jun-26 14:18 hat/drivers/snmp/agent.py
+-rw-r--r--  2.0 unx     4871 b- defN 23-Jun-26 14:13 hat/drivers/snmp/common.py
+-rw-r--r--  2.0 unx     7546 b- defN 23-Jun-26 14:18 hat/drivers/snmp/manager.py
+-rw-r--r--  2.0 unx    12554 b- defN 23-Jun-26 14:18 hat/drivers/snmp/trap.py
+-rw-r--r--  2.0 unx     2598 b- defN 23-Jun-26 14:19 hat/drivers/snmp/encoder/__init__.py
+-rw-r--r--  2.0 unx     9211 b- defN 23-Jul-08 10:45 hat/drivers/snmp/encoder/asn1_repo.json
+-rw-r--r--  2.0 unx     6241 b- defN 23-Jun-26 14:22 hat/drivers/snmp/encoder/v1.py
+-rw-r--r--  2.0 unx     7935 b- defN 23-Jun-25 13:37 hat/drivers/snmp/encoder/v2c.py
 -rw-r--r--  2.0 unx     1943 b- defN 22-May-10 19:12 hat/drivers/snmp/encoder/v3.py
+-rw-r--r--  2.0 unx     2082 b- defN 23-Jun-25 13:32 hat/drivers/ssl/__init__.py
+-rwxr-xr-x  2.0 unx   107412 b- defN 23-Jul-08 10:45 hat/drivers/ssl/_ssl.abi3.pyd
 -rw-r--r--  2.0 unx       34 b- defN 21-May-03 22:27 hat/drivers/upnp/__init__.py
--rw-r--r--  2.0 unx     3199 b- defN 21-May-03 22:25 hat/drivers/upnp/description.py
--rw-r--r--  2.0 unx    11358 b- defN 23-Jan-23 22:11 hat_drivers-0.6.9.dist-info/LICENSE
--rw-r--r--  2.0 unx     2063 b- defN 23-Jan-23 22:11 hat_drivers-0.6.9.dist-info/METADATA
--rw-r--r--  2.0 unx      132 b- defN 23-Jan-23 22:11 hat_drivers-0.6.9.dist-info/WHEEL
--rw-r--r--  2.0 unx        4 b- defN 23-Jan-23 22:11 hat_drivers-0.6.9.dist-info/top_level.txt
--rw-r--r--  2.0 unx        1 b- defN 23-Jan-23 22:11 hat_drivers-0.6.9.dist-info/zip-safe
-?rw-rw-r--  2.0 unx     8689 b- defN 23-Jan-23 22:11 hat_drivers-0.6.9.dist-info/RECORD
-97 files, 877914 bytes uncompressed, 143074 bytes compressed:  83.7%
+-rw-r--r--  2.0 unx     3132 b- defN 23-Jun-25 13:31 hat/drivers/upnp/description.py
+-rw-r--r--  2.0 unx    11358 b- defN 23-Jul-08 10:45 hat_drivers-0.7.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2484 b- defN 23-Jul-08 10:45 hat_drivers-0.7.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      127 b- defN 23-Jul-08 10:45 hat_drivers-0.7.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        4 b- defN 23-Jul-08 10:45 hat_drivers-0.7.0.dist-info/top_level.txt
+-rw-r--r--  2.0 unx        1 b- defN 23-Jul-08 10:45 hat_drivers-0.7.0.dist-info/zip-safe
+-rw-rw-r--  2.0 unx     9861 b- defN 23-Jul-08 10:45 hat_drivers-0.7.0.dist-info/RECORD
+110 files, 1245003 bytes uncompressed, 256587 bytes compressed:  79.4%
```

## zipnote {}

```diff
@@ -1,19 +1,10 @@
 Filename: hat/drivers/__init__.py
 Comment: 
 
-Filename: hat/drivers/cosp.py
-Comment: 
-
-Filename: hat/drivers/cotp.py
-Comment: 
-
-Filename: hat/drivers/serial.py
-Comment: 
-
 Filename: hat/drivers/ssdp.py
 Comment: 
 
 Filename: hat/drivers/tcp.py
 Comment: 
 
 Filename: hat/drivers/tpkt.py
@@ -48,14 +39,38 @@
 
 Filename: hat/drivers/copp/__init__.py
 Comment: 
 
 Filename: hat/drivers/copp/asn1_repo.json
 Comment: 
 
+Filename: hat/drivers/cosp/__init__.py
+Comment: 
+
+Filename: hat/drivers/cosp/common.py
+Comment: 
+
+Filename: hat/drivers/cosp/connection.py
+Comment: 
+
+Filename: hat/drivers/cosp/encoder.py
+Comment: 
+
+Filename: hat/drivers/cotp/__init__.py
+Comment: 
+
+Filename: hat/drivers/cotp/common.py
+Comment: 
+
+Filename: hat/drivers/cotp/connection.py
+Comment: 
+
+Filename: hat/drivers/cotp/encoder.py
+Comment: 
+
 Filename: hat/drivers/iec101/__init__.py
 Comment: 
 
 Filename: hat/drivers/iec101/common.py
 Comment: 
 
 Filename: hat/drivers/iec101/connection.py
@@ -207,14 +222,17 @@
 
 Filename: hat/drivers/modbus/slave.py
 Comment: 
 
 Filename: hat/drivers/modbus/transport/__init__.py
 Comment: 
 
+Filename: hat/drivers/modbus/transport/_encoder.abi3.pyd
+Comment: 
+
 Filename: hat/drivers/modbus/transport/common.py
 Comment: 
 
 Filename: hat/drivers/modbus/transport/connection.py
 Comment: 
 
 Filename: hat/drivers/modbus/transport/encoder.py
@@ -231,14 +249,29 @@
 
 Filename: hat/drivers/pnetgateway/encoder.py
 Comment: 
 
 Filename: hat/drivers/pnetgateway/transport.py
 Comment: 
 
+Filename: hat/drivers/serial/__init__.py
+Comment: 
+
+Filename: hat/drivers/serial/_native_serial.abi3.pyd
+Comment: 
+
+Filename: hat/drivers/serial/common.py
+Comment: 
+
+Filename: hat/drivers/serial/native_serial.py
+Comment: 
+
+Filename: hat/drivers/serial/py_serial.py
+Comment: 
+
 Filename: hat/drivers/snmp/__init__.py
 Comment: 
 
 Filename: hat/drivers/snmp/agent.py
 Comment: 
 
 Filename: hat/drivers/snmp/common.py
@@ -261,32 +294,38 @@
 
 Filename: hat/drivers/snmp/encoder/v2c.py
 Comment: 
 
 Filename: hat/drivers/snmp/encoder/v3.py
 Comment: 
 
+Filename: hat/drivers/ssl/__init__.py
+Comment: 
+
+Filename: hat/drivers/ssl/_ssl.abi3.pyd
+Comment: 
+
 Filename: hat/drivers/upnp/__init__.py
 Comment: 
 
 Filename: hat/drivers/upnp/description.py
 Comment: 
 
-Filename: hat_drivers-0.6.9.dist-info/LICENSE
+Filename: hat_drivers-0.7.0.dist-info/LICENSE
 Comment: 
 
-Filename: hat_drivers-0.6.9.dist-info/METADATA
+Filename: hat_drivers-0.7.0.dist-info/METADATA
 Comment: 
 
-Filename: hat_drivers-0.6.9.dist-info/WHEEL
+Filename: hat_drivers-0.7.0.dist-info/WHEEL
 Comment: 
 
-Filename: hat_drivers-0.6.9.dist-info/top_level.txt
+Filename: hat_drivers-0.7.0.dist-info/top_level.txt
 Comment: 
 
-Filename: hat_drivers-0.6.9.dist-info/zip-safe
+Filename: hat_drivers-0.7.0.dist-info/zip-safe
 Comment: 
 
-Filename: hat_drivers-0.6.9.dist-info/RECORD
+Filename: hat_drivers-0.7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## hat/drivers/ssdp.py

```diff
@@ -1,31 +1,29 @@
 """Simple Service Discovery Protocol"""
 
 import logging
 import typing
 
 from hat import aio
-from hat import util
 from hat.drivers import udp
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
 
 
 class DeviceInfo(typing.NamedTuple):
     addr: udp.Address
     location: str
     server: str
     service: str
 
 
-DeviceInfoCb = aio.AsyncCallable[[DeviceInfo], None]
+DeviceInfoCb: typing.TypeAlias = aio.AsyncCallable[[DeviceInfo], None]
 """Device info callback"""
-util.register_type_alias('DeviceInfoCb')
 
 
 default_multicast_addr = udp.Address('239.255.255.250', 1900)
 
 
 async def discover(device_info_cb: DeviceInfoCb,
                    multicast_addr: udp.Address = default_multicast_addr,
```

## hat/drivers/tcp.py

```diff
@@ -1,152 +1,132 @@
 """Asyncio TCP wrapper"""
 
 import asyncio
-import contextlib
-import enum
+import collections
+import functools
 import logging
-import pathlib
-import ssl
 import typing
 
 from hat import aio
+from hat import util
+
+from hat.drivers import ssl
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
 
 
-Bytes = typing.Union[bytes, bytearray, memoryview]
-
-
-class SslProtocol(enum.Enum):
-    TLS_CLIENT = ssl.PROTOCOL_TLS_CLIENT
-    TLS_SERVER = ssl.PROTOCOL_TLS_SERVER
-
-
 class Address(typing.NamedTuple):
     host: str
     port: int
 
 
 class ConnectionInfo(typing.NamedTuple):
     local_addr: Address
     remote_addr: Address
 
 
-ConnectionCb = aio.AsyncCallable[['Connection'], None]
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[['Connection'], None]
 """Connection callback"""
 
 
 async def connect(addr: Address,
+                  *,
+                  input_buffer_limit: int = 64 * 1024,
                   **kwargs
                   ) -> 'Connection':
     """Create TCP connection
 
-    Additional arguments are passed directly to `asyncio.open_connection`.
+    Argument `addr` specifies remote server listening address.
+
+    Argument `input_buffer_limit` defines number of bytes in input buffer
+    that whill temporary pause data receiving. Once number of bytes
+    drops bellow `input_buffer_limit`, data receiving is resumed. If this
+    argument is ``0``, data receive pausing is disabled.
+
+    Additional arguments are passed directly to `asyncio.create_connection`.
 
     """
-    reader, writer = await asyncio.open_connection(addr.host, addr.port,
-                                                   **kwargs)
-    return Connection(reader, writer)
+    loop = asyncio.get_running_loop()
+    create_transport = functools.partial(Protocol, None, input_buffer_limit)
+    _, protocol = await loop.create_connection(create_transport,
+                                               addr.host, addr.port,
+                                               **kwargs)
+    return Connection(protocol)
 
 
 async def listen(connection_cb: ConnectionCb,
                  addr: Address,
                  *,
                  bind_connections: bool = False,
+                 input_buffer_limit: int = 64 * 1024,
                  **kwargs
                  ) -> 'Server':
     """Create listening server
 
     If `bind_connections` is ``True``, closing server will close all open
     incoming connections.
 
-    Additional arguments are passed directly to `asyncio.start_server`.
+    Argument `input_buffer_limit` is associated with newly created connections
+    (see `connect`).
+
+    Additional arguments are passed directly to `asyncio.create_server`.
 
     """
     server = Server()
     server._connection_cb = connection_cb
     server._bind_connections = bind_connections
     server._async_group = aio.Group()
 
-    def on_connection(reader, writer):
-        try:
-            server.async_group.spawn(server._on_connection, reader, writer)
+    on_connection = functools.partial(server.async_group.spawn,
+                                      server._on_connection)
+    create_transport = functools.partial(Protocol, on_connection,
+                                         input_buffer_limit)
+
+    loop = asyncio.get_running_loop()
+    server._srv = await loop.create_server(create_transport, addr.host,
+                                           addr.port, **kwargs)
 
-        except Exception:
-            reader.close()
+    server.async_group.spawn(aio.call_on_cancel, server._on_close)
 
-    server._srv = await asyncio.start_server(on_connection,
-                                             addr.host, addr.port, **kwargs)
-    server._async_group.spawn(aio.call_on_cancel, server._on_close)
+    try:
+        socknames = (socket.getsockname() for socket in server._srv.sockets)
+        server._addresses = [Address(*sockname[:2]) for sockname in socknames]
 
-    socknames = (socket.getsockname() for socket in server._srv.sockets)
-    server._addresses = [Address(*sockname[:2]) for sockname in socknames]
+    except Exception:
+        await aio.uncancellable(server.async_close())
+        raise
 
     return server
 
 
-def create_ssl_ctx(protocol: SslProtocol,
-                   verify_cert: bool = False,
-                   cert_path: typing.Optional[pathlib.PurePath] = None,
-                   key_path: typing.Optional[pathlib.PurePath] = None,
-                   ca_path: typing.Optional[pathlib.PurePath] = None,
-                   password: typing.Optional[str] = None
-                   ) -> ssl.SSLContext:
-    ctx = ssl.SSLContext(protocol.value)
-    ctx.check_hostname = False
-
-    if verify_cert:
-        ctx.verify_mode = ssl.VerifyMode.CERT_REQUIRED
-        ctx.load_default_certs(ssl.Purpose.SERVER_AUTH
-                               if protocol == SslProtocol.TLS_SERVER
-                               else ssl.Purpose.CLIENT_AUTH)
-        if ca_path:
-            ctx.load_verify_locations(cafile=str(ca_path))
-
-    else:
-        ctx.verify_mode = ssl.VerifyMode.CERT_NONE
-
-    if cert_path:
-        ctx.load_cert_chain(certfile=str(cert_path),
-                            keyfile=str(key_path),
-                            password=password)
-
-    return ctx
-
-
 class Server(aio.Resource):
     """TCP listening server
 
     Closing server will cancel all running `connection_cb` coroutines.
 
     """
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._async_group
 
     @property
-    def addresses(self) -> typing.List[Address]:
+    def addresses(self) -> list[Address]:
         """Listening addresses"""
         return self._addresses
 
     async def _on_close(self):
         self._srv.close()
         await self._srv.wait_closed()
 
-    async def _on_connection(self, reader, writer):
-        try:
-            conn = Connection(reader, writer)
-
-        except Exception:
-            reader.close()
-            return
+    async def _on_connection(self, protocol):
+        conn = Connection(protocol)
 
         try:
             await aio.call(self._connection_cb, conn)
 
             if self._bind_connections:
                 await conn.wait_closing()
 
@@ -160,203 +140,308 @@
             if conn:
                 await aio.uncancellable(conn.async_close())
 
 
 class Connection(aio.Resource):
     """TCP connection"""
 
-    def __init__(self,
-                 reader: asyncio.StreamReader,
-                 writer: asyncio.StreamWriter):
-        self._reader = reader
-        self._writer = writer
-        self._read_queue = aio.Queue()
+    def __init__(self, protocol: 'Protocol'):
+        self._protocol = protocol
         self._async_group = aio.Group()
 
-        self.async_group.spawn(self._read_loop)
-
-        sockname = writer.get_extra_info('sockname')
-        peername = writer.get_extra_info('peername')
-        self._info = ConnectionInfo(
-            local_addr=Address(sockname[0], sockname[1]),
-            remote_addr=Address(peername[0], peername[1]))
+        self.async_group.spawn(aio.call_on_cancel, protocol.async_close)
+        self.async_group.spawn(aio.call_on_done, protocol.wait_closed(),
+                               self.close)
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._async_group
 
     @property
     def info(self) -> ConnectionInfo:
         """Connection info"""
-        return self._info
+        return self._protocol.info
 
-    def write(self, data: Bytes):
+    @property
+    def ssl_object(self) -> ssl.SSLObject | ssl.SSLSocket | None:
+        """SSL Object"""
+        return self._protocol.ssl_object
+
+    async def write(self, data: util.Bytes):
         """Write data
 
-        See `asyncio.StreamWriter.write`.
+        This coroutine will wait until `data` can be added to output buffer.
 
         """
-        self._writer.write(data)
-
-    async def drain(self):
-        """Drain stream writer
+        if not self.is_open:
+            raise ConnectionError()
 
-        See `asyncio.StreamWriter.drain`.
+        await self._protocol.write(data)
 
-        """
-        await self._writer.drain()
+    async def drain(self):
+        """Drain output buffer"""
+        await self._protocol.drain()
 
-    async def read(self,
-                   n: int = -1
-                   ) -> Bytes:
+    async def read(self, n: int = -1) -> util.Bytes:
         """Read up to `n` bytes
 
         If EOF is detected and no new bytes are available, `ConnectionError`
         is raised.
 
-        See `asyncio.StreamReader.read`.
-
         """
-        future = asyncio.Future()
-        try:
-            self._read_queue.put_nowait((future, False, n))
-            return await future
+        return await self._protocol.read(n)
 
-        except aio.QueueClosedError:
-            raise ConnectionError()
-
-    async def readexactly(self,
-                          n: int
-                          ) -> Bytes:
+    async def readexactly(self, n: int) -> util.Bytes:
         """Read exactly `n` bytes
 
         If exact number of bytes could not be read, `ConnectionError` is
         raised.
 
-        See `asyncio.StreamReader.readexactly`.
-
         """
-        future = asyncio.Future()
-        try:
-            self._read_queue.put_nowait((future, True, n))
-            return await future
-
-        except aio.QueueClosedError:
-            raise ConnectionError()
+        return await self._protocol.readexactly(n)
 
-    async def reset_input_buffer(self) -> int:
+    def reset_input_buffer(self) -> int:
         """Reset input buffer
 
         Returns number of bytes cleared from buffer.
 
         """
-        future = asyncio.Future()
+        return self._protocol.reset_input_buffer()
+
+
+class Protocol(asyncio.Protocol):
+    """Asyncio protocol implementation"""
+
+    def __init__(self,
+                 on_connected: typing.Callable[['Protocol'], None] | None,
+                 input_buffer_limit: int):
+        self._on_connected = on_connected
+        self._input_buffer_limit = input_buffer_limit
+        self._loop = asyncio.get_running_loop()
+        self._input_buffer = util.BytesBuffer()
+        self._transport = None
+        self._read_queue = None
+        self._write_queue = None
+        self._drain_futures = None
+        self._closed_futures = None
+        self._info = None
+        self._ssl_object = None
+
+    @property
+    def info(self) -> ConnectionInfo:
+        return self._info
+
+    @property
+    def ssl_object(self) -> ssl.SSLObject | ssl.SSLSocket | None:
+        return self._ssl_object
+
+    def connection_made(self, transport: asyncio.Transport):
+        self._transport = transport
+        self._read_queue = collections.deque()
+        self._closed_futures = collections.deque()
+
         try:
-            self._read_queue.put_nowait((future, False, None))
-            return await future
+            sockname = transport.get_extra_info('sockname')
+            peername = transport.get_extra_info('peername')
+            self._info = ConnectionInfo(
+                local_addr=Address(sockname[0], sockname[1]),
+                remote_addr=Address(peername[0], peername[1]))
+            self._ssl_object = transport.get_extra_info('ssl_object')
+
+            if self._on_connected:
+                self._on_connected(self)
+
+        except Exception:
+            transport.abort()
+            return
+
+    def connection_lost(self, exc: Exception | None):
+        self._transport = None
+        write_queue, self._write_queue = self._write_queue, None
+        drain_futures, self._drain_futures = self._drain_futures, None
+        closed_futures, self._closed_futures = self._closed_futures, None
+
+        self.eof_received()
+
+        while write_queue:
+            _, future = write_queue.popleft()
+            if not future.done():
+                future.set_exception(ConnectionError())
+
+        while drain_futures:
+            future = drain_futures.popleft()
+            if not future.done():
+                future.set_result(None)
+
+        while closed_futures:
+            future = closed_futures.popleft()
+            if not future.done():
+                future.set_result(None)
+
+    def pause_writing(self):
+        self._write_queue = collections.deque()
+        self._drain_futures = collections.deque()
+
+    def resume_writing(self):
+        write_queue, self._write_queue = self._write_queue, None
+        drain_futures, self._drain_futures = self._drain_futures, None
+
+        while self._write_queue is None and write_queue:
+            data, future = write_queue.popleft()
+            if future.done():
+                continue
+
+            self._transport.write(data)
+            future.set_result(None)
+
+        if write_queue:
+            write_queue.extend(self._write_queue)
+            self._write_queue = write_queue
+
+            drain_futures.extend(self._drain_futures)
+            self._drain_futures = drain_futures
 
-        except aio.QueueClosedError:
+            return
+
+        while drain_futures:
+            future = drain_futures.popleft()
+            if not future.done():
+                future.set_result(None)
+
+    def data_received(self, data: util.Bytes):
+        self._input_buffer.add(data)
+        self._process_input_buffer()
+
+    def eof_received(self):
+        while self._read_queue:
+            exact, n, future = self._read_queue.popleft()
+            if future.done():
+                continue
+
+            if exact and n <= len(self._input_buffer):
+                future.set_result(self._input_buffer.read(n))
+
+            elif not exact and self._input_buffer:
+                future.set_result(self._input_buffer.read(n))
+
+            else:
+                future.set_exception(ConnectionError())
+
+        self._read_queue = None
+
+    async def write(self, data: util.Bytes):
+        if self._transport is None:
             raise ConnectionError()
 
-    async def _read_loop(self):
-        future = None
-        buffer = bytearray()
-        try:
-            while True:
-                future, is_exact, n = await self._read_queue.get()
+        if self._write_queue is None:
+            self._transport.write(data)
+            return
 
-                while not future.done():
-                    if n is None:
+        future = self._loop.create_future()
+        self._write_queue.append((data, future))
+        await future
 
-                        # HACK read until asyncio.StreamReader internal buffer
-                        #      empty
-                        if hasattr(self._reader, '_buffer'):
-                            while not future.done() and self._reader._buffer:
-                                count = len(self._reader._buffer)
-                                data = await self._reader.read(count)
-                                buffer.extend(data)
-
-                        if future.done():
-                            break
-
-                        future.set_result(len(buffer))
-                        buffer = bytearray()
-                        break
-
-                    if n >= 0 and len(buffer) >= n:
-                        break
-
-                    if n < 0 and is_exact:
-                        future.set_exception(
-                            ValueError('invalid number of bytes'))
-                        break
-
-                    if buffer and not is_exact:
-                        break
-
-                    if not self.is_open:
-                        return
-
-                    async with self.async_group.create_subgroup() as subgroup:
-                        fn = (self._reader.readexactly if is_exact
-                              else self._reader.read)
-                        count = n - len(buffer) if n > 0 else n
-                        result = asyncio.Future()
-                        subgroup.spawn(_set_future_with_result, result, fn,
-                                       count)
-
-                        await asyncio.wait([result, future],
-                                           return_when=asyncio.FIRST_COMPLETED)
-
-                        if not result.done():
-                            break
-
-                    data = result.result()
-                    if not data:
-                        raise EOFError()
-
-                    buffer.extend(data)
-
-                if future.done():
-                    continue
-
-                if n > 0:
-                    buffer = memoryview(buffer)
-                    data, buffer = buffer[:n], bytearray(buffer[n:])
-                    future.set_result(data)
-
-                elif n < 0:
-                    future.set_result(buffer)
-                    buffer = bytearray()
+    async def drain(self):
+        if self._drain_futures is None:
+            return
 
-                else:
-                    future.set_result(b'')
+        future = self._loop.create_future()
+        self._drain_futures.append(future)
+        await future
+
+    async def read(self, n: int) -> util.Bytes:
+        if n == 0:
+            return b''
+
+        if self._input_buffer and not self._read_queue:
+            data = self._input_buffer.read(n)
+            self._process_input_buffer()
+            return data
 
-        except EOFError:
-            pass
+        if self._read_queue is None:
+            raise ConnectionError()
 
-        except Exception as e:
-            mlog.warning("read loop error: %s", e, exc_info=e)
+        future = self._loop.create_future()
+        future.add_done_callback(self._on_read_future_done)
+        self._read_queue.append((False, n, future))
+        return await future
+
+    async def readexactly(self, n: int) -> util.Bytes:
+        if n == 0:
+            return b''
+
+        if n <= len(self._input_buffer) and not self._read_queue:
+            data = self._input_buffer.read(n)
+            self._process_input_buffer()
+            return data
 
-        finally:
-            self.close()
-            self._read_queue.close()
+        if self._read_queue is None:
+            raise ConnectionError()
 
-            while True:
-                if future and not future.done():
-                    future.set_exception(ConnectionError())
-                if self._read_queue.empty():
-                    break
-                future, _, __ = self._read_queue.get_nowait()
-
-            self._writer.close()
-            with contextlib.suppress(Exception):
-                await aio.uncancellable(self._writer.wait_closed())
+        future = self._loop.create_future()
+        future.add_done_callback(self._on_read_future_done)
+        self._read_queue.append((True, n, future))
+        self._process_input_buffer()
+        return await future
+
+    def reset_input_buffer(self) -> int:
+        count = self._input_buffer.clear()
+        self._transport.resume_reading()
+        return count
+
+    async def async_close(self):
+        if self._transport is not None:
+            self._transport.close()
 
+        await self.wait_closed()
 
-async def _set_future_with_result(future, fn, *args):
-    try:
-        future.set_result(await fn(*args))
+    async def wait_closed(self):
+        if self._closed_futures is None:
+            return
+
+        future = self._loop.create_future()
+        self._closed_futures.append(future)
+        await future
+
+    def _on_read_future_done(self, future):
+        if not self._read_queue:
+            return
+
+        if not isinstance(future, asyncio.CancelledError):
+            return
+
+        for _ in range(len(self._read_queue)):
+            i = self._read_queue.popleft()
+            if not i[2].done():
+                self._read_queue.append(i)
+
+        self._process_input_buffer()
+
+    def _process_input_buffer(self):
+        while self._input_buffer and self._read_queue:
+            exact, n, future = self._read_queue.popleft()
+            if future.done():
+                continue
+
+            if not exact:
+                future.set_result(self._input_buffer.read(n))
+
+            elif n <= len(self._input_buffer):
+                future.set_result(self._input_buffer.read(n))
+
+            else:
+                self._read_queue.appendleft((exact, n, future))
+                break
+
+        if not self._transport:
+            return
+
+        pause = (self._input_buffer_limit > 0 and
+                 len(self._input_buffer) > self._input_buffer_limit and
+                 not self._read_queue)
+
+        if pause:
+            self._transport.pause_reading()
 
-    except Exception as e:
-        future.set_exception(e)
+        else:
+            self._transport.resume_reading()
```

## hat/drivers/tpkt.py

```diff
@@ -2,149 +2,169 @@
 
 import asyncio
 import itertools
 import logging
 import typing
 
 from hat import aio
+from hat import util
+
 from hat.drivers import tcp
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
 
-
-class Address(typing.NamedTuple):
-    host: str
-    port: int = 102
-
-
-class ConnectionInfo(typing.NamedTuple):
-    local_addr: Address
-    remote_addr: Address
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[['Connection'], None]
+"""Connection callback"""
 
 
-ConnectionCb = aio.AsyncCallable[['Connection'], None]
-"""Connection callback"""
+async def connect(addr: tcp.Address,
+                  **kwargs
+                  ) -> 'Connection':
+    """Create new TPKT connection
 
+    Additional arguments are passed directly to `hat.drivers.tcp.connect`.
 
-async def connect(addr: Address) -> 'Connection':
-    """Create new TPKT connection"""
-    conn = await tcp.connect(tcp.Address(*addr))
+    """
+    conn = await tcp.connect(addr, **kwargs)
     return Connection(conn)
 
 
 async def listen(connection_cb: ConnectionCb,
-                 addr: Address = Address('0.0.0.0')
+                 addr: tcp.Address = tcp.Address('0.0.0.0', 102),
+                 **kwargs
                  ) -> 'Server':
-    """Create new TPKT listening server"""
+    """Create new TPKT listening server
+
+    Additional arguments are passed directly to `hat.drivers.tcp.listen`.
+
+    """
     server = Server()
     server._connection_cb = connection_cb
-    server._srv = await tcp.listen(server._on_connection, tcp.Address(*addr))
-    server._addresses = [Address(*i) for i in server._srv.addresses]
+
+    server._srv = await tcp.listen(server._on_connection, addr, **kwargs)
+
     return server
 
 
 class Server(aio.Resource):
     """TPKT listening server
 
     For creation of new instance see `listen` coroutine.
 
-    Closing server doesn't close active incoming connections.
-
-    Closing server will cancel all running `connection_cb` coroutines.
-
     """
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._srv.async_group
 
     @property
-    def addresses(self) -> typing.List[Address]:
+    def addresses(self) -> list[tcp.Address]:
         """Listening addresses"""
-        return self._addresses
+        return self._srv.addresses
 
     async def _on_connection(self, conn):
-        conn = Connection(conn)
         try:
+            conn = Connection(conn)
             await aio.call(self._connection_cb, conn)
 
         except Exception as e:
             mlog.warning('connection callback error: %s', e, exc_info=e)
             await aio.uncancellable(conn.async_close())
 
         except asyncio.CancelledError:
             await aio.uncancellable(conn.async_close())
             raise
 
 
 class Connection(aio.Resource):
     """TPKT connection"""
 
-    def __init__(self, conn: tcp.Connection):
+    def __init__(self,
+                 conn: tcp.Connection):
         self._conn = conn
-        self._info = ConnectionInfo(*(Address(*i) for i in conn.info))
-        self._read_queue = aio.Queue()
-        conn.async_group.spawn(self._read_loop)
+        self._loop = asyncio.get_running_loop()
+        self._receive_futures = aio.Queue()
+
+        self.async_group.spawn(self._read_loop)
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._conn.async_group
 
     @property
-    def info(self) -> ConnectionInfo:
+    def info(self) -> tcp.ConnectionInfo:
         """Connection info"""
-        return self._info
+        return self._conn.info
 
-    async def read(self) -> bytes:
-        """Read data"""
+    async def receive(self) -> util.Bytes:
+        """Receive data"""
         try:
-            return await self._read_queue.get()
+            future = self._loop.create_future()
+            self._receive_futures.put_nowait(future)
+            return await future
 
         except aio.QueueClosedError:
             raise ConnectionError()
 
-    def write(self, data: bytes):
-        """Write data"""
+    async def send(self, data: util.Bytes):
+        """Send data"""
         data_len = len(data)
 
         if data_len > 0xFFFB:
             raise ValueError("data length greater than 0xFFFB")
 
         if data_len < 3:
             raise ValueError("data length less than 3")
 
         packet_length = data_len + 4
         packet = bytes(itertools.chain(
             [3, 0, packet_length >> 8, packet_length & 0xFF],
             data))
-        self._conn.write(packet)
+
+        await self._conn.write(packet)
+
+    async def drain(self):
+        """Drain output buffer"""
+        await self._conn.drain()
 
     async def _read_loop(self):
+        future = None
         try:
             while True:
                 header = await self._conn.readexactly(4)
                 if header[0] != 3:
                     raise Exception(f"invalid vrsn number "
                                     f"(received {header[0]})")
 
                 packet_length = (header[2] << 8) | header[3]
                 if packet_length < 7:
                     raise Exception(f"invalid packet length "
                                     f"(received {packet_length})")
 
                 data_length = packet_length - 4
                 data = await self._conn.readexactly(data_length)
-                await self._read_queue.put(data)
+
+                while not future or future.done():
+                    future = await self._receive_futures.get()
+
+                future.set_result(data)
 
         except ConnectionError:
             pass
 
         except Exception as e:
             mlog.warning("read loop error: %s", e, exc_info=e)
 
         finally:
             self.close()
-            self._read_queue.close()
+            self._receive_futures.close()
+
+            while True:
+                if future and not future.done():
+                    future.set_exception(ConnectionError())
+                if self._receive_futures.empty():
+                    break
+                future = self._receive_futures.get_nowait()
```

## hat/drivers/udp.py

```diff
@@ -1,27 +1,33 @@
 """Asyncio UDP endpoint wrapper"""
 
 import asyncio
+import logging
 import typing
 
 from hat import aio
+from hat import util
+
+
+mlog: logging.Logger = logging.getLogger(__name__)
+"""Module logger"""
 
 
 class Address(typing.NamedTuple):
     host: str
     port: int
 
 
 class EndpointInfo(typing.NamedTuple):
     local_addr: Address
-    remote_addr: typing.Optional[Address]
+    remote_addr: Address | None
 
 
-async def create(local_addr: typing.Optional[Address] = None,
-                 remote_addr: typing.Optional[Address] = None,
+async def create(local_addr: Address | None = None,
+                 remote_addr: Address | None = None,
                  queue_size: int = 0,
                  **kwargs
                  ) -> 'Endpoint':
     """Create new UDP endpoint
 
     Args:
         local_addr: local address
@@ -39,15 +45,20 @@
 
     class Protocol(asyncio.DatagramProtocol):
 
         def connection_lost(self, exc):
             endpoint._async_group.close()
 
         def datagram_received(self, data, addr):
-            endpoint._queue.put_nowait((data, Address(addr[0], addr[1])))
+            try:
+                endpoint._queue.put_nowait(
+                    (data, Address(addr[0], addr[1])))
+
+            except aio.QueueFullError:
+                mlog.warning('receive queue full - dropping datagram')
 
     loop = asyncio.get_running_loop()
     endpoint._transport, endpoint._protocol = \
         await loop.create_datagram_endpoint(Protocol, local_addr, remote_addr,
                                             **kwargs)
 
     endpoint._async_group.spawn(aio.call_on_cancel, endpoint._transport.close)
@@ -77,21 +88,29 @@
 
     @property
     def empty(self) -> bool:
         """Is receive queue empty"""
         return self._queue.empty()
 
     def send(self,
-             data: bytes,
-             remote_addr: typing.Optional[Address] = None):
+             data: util.Bytes,
+             remote_addr: Address | None = None):
         """Send datagram
 
         If `remote_addr` is not set, `remote_addr` passed to :func:`create`
         is used.
 
         """
+        if not self.is_open:
+            raise ConnectionError()
+
         self._transport.sendto(data, remote_addr or self._remote_addr)
 
-    async def receive(self) -> typing.Tuple[bytes, Address]:
+    async def receive(self) -> tuple[util.Bytes, Address]:
         """Receive datagram"""
-        data, addr = await self._queue.get()
+        try:
+            data, addr = await self._queue.get()
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
+
         return data, addr
```

## hat/drivers/acse/__init__.py

```diff
@@ -1,324 +1,431 @@
 """Association Controll Service Element"""
 
+import asyncio
 import importlib.resources
 import logging
 import typing
 
 from hat import aio
 from hat import asn1
+
 from hat.drivers import copp
+from hat.drivers import tcp
 
 
 mlog = logging.getLogger(__name__)
 
+# (joint-iso-itu-t, association-control, abstract-syntax, apdus, version1)
+_acse_syntax_name = (2, 2, 1, 0, 1)
 
-IdentifiedEntity = copp.IdentifiedEntity
-"""Identified entity"""
-
-
-Address = copp.Address
-"""Address"""
-
-
-SyntaxNames = copp.SyntaxNames
-"""Syntax names"""
+with importlib.resources.as_file(importlib.resources.files(__package__) /
+                                 'asn1_repo.json') as _path:
+    _encoder = asn1.Encoder(asn1.Encoding.BER,
+                            asn1.Repository.from_json(_path))
 
 
 class ConnectionInfo(typing.NamedTuple):
-    local_addr: Address
-    local_tsel: typing.Optional[int]
-    local_ssel: typing.Optional[int]
-    local_psel: typing.Optional[int]
-    local_ap_title: typing.Optional[asn1.ObjectIdentifier]
-    local_ae_qualifier: typing.Optional[int]
-    remote_addr: Address
-    remote_tsel: typing.Optional[int]
-    remote_ssel: typing.Optional[int]
-    remote_psel: typing.Optional[int]
-    remote_ap_title: typing.Optional[asn1.ObjectIdentifier]
-    remote_ae_qualifier: typing.Optional[int]
-
-
-ValidateResult = typing.Optional[IdentifiedEntity]
-"""Validate result"""
-
-
-ValidateCb = aio.AsyncCallable[[SyntaxNames, IdentifiedEntity], ValidateResult]
+    local_addr: tcp.Address
+    local_tsel: int | None
+    local_ssel: int | None
+    local_psel: int | None
+    local_ap_title: asn1.ObjectIdentifier | None
+    local_ae_qualifier: int | None
+    remote_addr: tcp.Address
+    remote_tsel: int | None
+    remote_ssel: int | None
+    remote_psel: int | None
+    remote_ap_title: asn1.ObjectIdentifier | None
+    remote_ae_qualifier: int | None
+
+
+ValidateCb: typing.TypeAlias = aio.AsyncCallable[[copp.SyntaxNames,
+                                                  copp.IdentifiedEntity],
+                                                 copp.IdentifiedEntity | None]
 """Validate callback"""
 
-
-ConnectionCb = aio.AsyncCallable[['Connection'], None]
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[['Connection'], None]
 """Connection callback"""
 
 
-# (joint-iso-itu-t, association-control, abstract-syntax, apdus, version1)
-_acse_syntax_name = (2, 2, 1, 0, 1)
-with importlib.resources.path(__package__, 'asn1_repo.json') as _path:
-    _encoder = asn1.Encoder(asn1.Encoding.BER,
-                            asn1.Repository.from_json(_path))
-
-
-async def connect(syntax_name_list: typing.List[asn1.ObjectIdentifier],
+async def connect(addr: tcp.Address,
+                  syntax_name_list: list[asn1.ObjectIdentifier],
                   app_context_name: asn1.ObjectIdentifier,
-                  addr: Address,
-                  local_tsel: typing.Optional[int] = None,
-                  remote_tsel: typing.Optional[int] = None,
-                  local_ssel: typing.Optional[int] = None,
-                  remote_ssel: typing.Optional[int] = None,
-                  local_psel: typing.Optional[int] = None,
-                  remote_psel: typing.Optional[int] = None,
-                  local_ap_title: typing.Optional[asn1.ObjectIdentifier] = None,  # NOQA
-                  remote_ap_title: typing.Optional[asn1.ObjectIdentifier] = None,  # NOQA
-                  local_ae_qualifier: typing.Optional[int] = None,
-                  remote_ae_qualifier: typing.Optional[int] = None,
-                  user_data: typing.Optional[IdentifiedEntity] = None
+                  user_data: copp.IdentifiedEntity | None = None,
+                  *,
+                  local_ap_title: asn1.ObjectIdentifier | None = None,
+                  remote_ap_title: asn1.ObjectIdentifier | None = None,
+                  local_ae_qualifier: int | None = None,
+                  remote_ae_qualifier: int | None = None,
+                  acse_receive_queue_size: int = 1024,
+                  acse_send_queue_size: int = 1024,
+                  **kwargs
                   ) -> 'Connection':
-    """Connect to ACSE server"""
-    syntax_names = SyntaxNames([_acse_syntax_name, *syntax_name_list])
+    """Connect to ACSE server
+
+    Additional arguments are passed directly to `hat.drivers.copp.connect`
+    (`syntax_names` is set by this coroutine).
+
+    """
+    syntax_names = copp.SyntaxNames([_acse_syntax_name, *syntax_name_list])
     aarq_apdu = _aarq_apdu(syntax_names, app_context_name,
                            local_ap_title, remote_ap_title,
                            local_ae_qualifier, remote_ae_qualifier,
                            user_data)
     copp_user_data = _acse_syntax_name, _encode(aarq_apdu)
-    copp_conn = await copp.connect(syntax_names=syntax_names,
-                                   addr=addr,
-                                   local_tsel=local_tsel,
-                                   remote_tsel=remote_tsel,
-                                   local_ssel=local_ssel,
-                                   remote_ssel=remote_ssel,
-                                   local_psel=local_psel,
-                                   remote_psel=remote_psel,
-                                   user_data=copp_user_data)
+    conn = await copp.connect(addr, syntax_names, copp_user_data, **kwargs)
+
     try:
-        aare_apdu_syntax_name, aare_apdu_entity = copp_conn.conn_res_user_data
+        aare_apdu_syntax_name, aare_apdu_entity = conn.conn_res_user_data
         if aare_apdu_syntax_name != _acse_syntax_name:
             raise Exception("invalid syntax name")
+
         aare_apdu = _decode(aare_apdu_entity)
         if aare_apdu[0] != 'aare' or aare_apdu[1]['result'] != 0:
             raise Exception("invalid apdu")
+
         calling_ap_title, called_ap_title = _get_ap_titles(aarq_apdu)
         calling_ae_qualifier, called_ae_qualifier = _get_ae_qualifiers(
             aarq_apdu)
-        return _create_connection(copp_conn, aarq_apdu, aare_apdu,
-                                  calling_ap_title, called_ap_title,
-                                  calling_ae_qualifier, called_ae_qualifier)
+        return Connection(conn, aarq_apdu, aare_apdu,
+                          calling_ap_title, called_ap_title,
+                          calling_ae_qualifier, called_ae_qualifier,
+                          acse_receive_queue_size, acse_send_queue_size)
+
     except Exception:
-        await aio.uncancellable(
-            _close_connection(copp_conn, _abrt_apdu(1)))
+        await aio.uncancellable(_close_copp(conn, _abrt_apdu(1)))
         raise
 
 
 async def listen(validate_cb: ValidateCb,
                  connection_cb: ConnectionCb,
-                 addr: Address = Address('0.0.0.0', 102)
+                 addr: tcp.Address = tcp.Address('0.0.0.0', 102),
+                 *,
+                 bind_connections: bool = False,
+                 acse_receive_queue_size: int = 1024,
+                 acse_send_queue_size: int = 1024,
+                 **kwargs
                  ) -> 'Server':
     """Create ACSE listening server
 
+    Additional arguments are passed directly to `hat.drivers.copp.listen`.
+
     Args:
         validate_cb: callback function or coroutine called on new
             incomming connection request prior to creating connection object
         connection_cb: new connection callback
         addr: local listening address
 
     """
+    server = Server()
+    server._validate_cb = validate_cb
+    server._connection_cb = connection_cb
+    server._bind_connections = bind_connections
+    server._receive_queue_size = acse_receive_queue_size
+    server._send_queue_size = acse_send_queue_size
+
+    server._srv = await copp.listen(server._on_validate,
+                                    server._on_connection,
+                                    addr,
+                                    bind_connections=False,
+                                    **kwargs)
+
+    return server
 
-    async def on_validate(syntax_names, user_data):
+
+class Server(aio.Resource):
+    """ACSE listening server
+
+    For creating new server see `listen`.
+
+    """
+
+    @property
+    def async_group(self) -> aio.Group:
+        """Async group"""
+        return self._srv.async_group
+
+    @property
+    def addresses(self) -> list[tcp.Address]:
+        """Listening addresses"""
+        return self._srv.addresses
+
+    async def _on_validate(self, syntax_names, user_data):
         aarq_apdu_syntax_name, aarq_apdu_entity = user_data
         if aarq_apdu_syntax_name != _acse_syntax_name:
             raise Exception('invalid acse syntax name')
+
         aarq_apdu = _decode(aarq_apdu_entity)
         if aarq_apdu[0] != 'aarq':
             raise Exception('not aarq message')
+
         aarq_external = aarq_apdu[1]['user-information'][0]
         if aarq_external.direct_ref is not None:
             if aarq_external.direct_ref != _encoder.syntax_name:
                 raise Exception('invalid encoder identifier')
+
         _, called_ap_title = _get_ap_titles(aarq_apdu)
         _, called_ae_qualifier = _get_ae_qualifiers(aarq_apdu)
         _, called_ap_invocation_identifier = \
             _get_ap_invocation_identifiers(aarq_apdu)
         _, called_ae_invocation_identifier = \
             _get_ae_invocation_identifiers(aarq_apdu)
 
         aarq_user_data = (syntax_names.get_name(aarq_external.indirect_ref),
                           aarq_external.data)
-        user_validate_result = await aio.call(
-            validate_cb, syntax_names, aarq_user_data)
+
+        user_validate_result = await aio.call(self._validate_cb, syntax_names,
+                                              aarq_user_data)
+
         aare_apdu = _aare_apdu(syntax_names,
                                user_validate_result,
                                called_ap_title, called_ae_qualifier,
                                called_ap_invocation_identifier,
                                called_ae_invocation_identifier)
         return _acse_syntax_name, _encode(aare_apdu)
 
-    async def on_connection(copp_conn):
-        try:
-            aarq_apdu = _decode(copp_conn.conn_req_user_data[1])
-            aare_apdu = _decode(copp_conn.conn_res_user_data[1])
-            calling_ap_title, called_ap_title = _get_ap_titles(aarq_apdu)
-            calling_ae_qualifier, called_ae_qualifier = _get_ae_qualifiers(
-                aarq_apdu)
-            conn = _create_connection(
-                copp_conn, aarq_apdu, aare_apdu,
-                called_ap_title, calling_ap_title,
-                called_ae_qualifier, calling_ae_qualifier)
-            await aio.call(connection_cb, conn)
-        except BaseException as e:
-            mlog.error("error creating new incomming connection: %s", e,
-                       exc_info=e)
-            await aio.uncancellable(
-                _close_connection(copp_conn, _abrt_apdu(1)))
-
-    async def wait_copp_server_closed():
+    async def _on_connection(self, copp_conn):
         try:
-            await copp_server.wait_closed()
-        finally:
-            async_group.close()
-
-    async_group = aio.Group()
-    copp_server = await copp.listen(on_validate, on_connection, addr)
-    async_group.spawn(aio.call_on_cancel, copp_server.async_close)
-    async_group.spawn(wait_copp_server_closed)
-
-    srv = Server()
-    srv._async_group = async_group
-    srv._copp_server = copp_server
-    return srv
-
+            try:
+                aarq_apdu = _decode(copp_conn.conn_req_user_data[1])
+                aare_apdu = _decode(copp_conn.conn_res_user_data[1])
+
+                calling_ap_title, called_ap_title = _get_ap_titles(aarq_apdu)
+                calling_ae_qualifier, called_ae_qualifier = _get_ae_qualifiers(
+                    aarq_apdu)
 
-class Server(aio.Resource):
-    """ACSE listening server
-
-    For creating new server see :func:`listen`
-
-    Closing server doesn't close active incomming connections
-
-    """
+                conn = Connection(copp_conn, aarq_apdu, aare_apdu,
+                                  calling_ap_title, called_ap_title,
+                                  calling_ae_qualifier, called_ae_qualifier,
+                                  self._receive_queue_size,
+                                  self._send_queue_size)
+
+            except Exception:
+                await aio.uncancellable(_close_copp(copp_conn, _abrt_apdu(1)))
+                raise
+
+            try:
+                await aio.call(self._connection_cb, conn)
+
+            except BaseException:
+                await aio.uncancellable(conn.async_close())
+                raise
 
-    @property
-    def async_group(self) -> aio.Group:
-        """Async group"""
-        return self._async_group
+        except Exception as e:
+            mlog.error("error creating new incomming connection: %s", e,
+                       exc_info=e)
+            return
 
-    @property
-    def addresses(self) -> typing.List[Address]:
-        """Listening addresses"""
-        return self._copp_server.addresses
+        if not self._bind_connections:
+            return
 
+        try:
+            await conn.wait_closed()
 
-def _create_connection(copp_conn, aarq_apdu, aare_apdu,
-                       local_ap_title, remote_ap_title,
-                       local_ae_qualifier, remote_ae_qualifier):
-    aarq_external = aarq_apdu[1]['user-information'][0]
-    aare_external = aare_apdu[1]['user-information'][0]
-    conn_req_user_data = (
-        copp_conn.syntax_names.get_name(aarq_external.indirect_ref),
-        aarq_external.data)
-    conn_res_user_data = (
-        copp_conn.syntax_names.get_name(aare_external.indirect_ref),
-        aare_external.data)
-
-    conn = Connection()
-    conn._copp_conn = copp_conn
-    conn._conn_req_user_data = conn_req_user_data
-    conn._conn_res_user_data = conn_res_user_data
-    conn._info = ConnectionInfo(local_ap_title=local_ap_title,
-                                local_ae_qualifier=local_ae_qualifier,
-                                remote_ap_title=remote_ap_title,
-                                remote_ae_qualifier=remote_ae_qualifier,
-                                **copp_conn.info._asdict())
-    conn._read_queue = aio.Queue()
-    conn._async_group = aio.Group()
-    conn._async_group.spawn(conn._read_loop)
-    return conn
+        except BaseException:
+            await aio.uncancellable(conn.async_close())
+            raise
 
 
 class Connection(aio.Resource):
     """ACSE connection
 
-    For creating new connection see :func:`connect`
+    For creating new connection see `connect` or `listen`.
 
     """
 
+    def __init__(self,
+                 conn: copp.Connection,
+                 aarq_apdu: asn1.Value,
+                 aare_apdu: asn1.Value,
+                 local_ap_title: asn1.ObjectIdentifier | None,
+                 remote_ap_title: asn1.ObjectIdentifier | None,
+                 local_ae_qualifier: int | None,
+                 remote_ae_qualifier: int | None,
+                 receive_queue_size: int,
+                 send_queue_size: int):
+        aarq_external = aarq_apdu[1]['user-information'][0]
+        aare_external = aare_apdu[1]['user-information'][0]
+
+        conn_req_user_data = (
+            conn.syntax_names.get_name(aarq_external.indirect_ref),
+            aarq_external.data)
+        conn_res_user_data = (
+            conn.syntax_names.get_name(aare_external.indirect_ref),
+            aare_external.data)
+
+        self._conn = conn
+        self._conn_req_user_data = conn_req_user_data
+        self._conn_res_user_data = conn_res_user_data
+        self._loop = asyncio.get_running_loop()
+        self._info = ConnectionInfo(local_ap_title=local_ap_title,
+                                    local_ae_qualifier=local_ae_qualifier,
+                                    remote_ap_title=remote_ap_title,
+                                    remote_ae_qualifier=remote_ae_qualifier,
+                                    **conn.info._asdict())
+        self._close_apdu = _abrt_apdu(0)
+        self._receive_queue = aio.Queue(receive_queue_size)
+        self._send_queue = aio.Queue(send_queue_size)
+        self._async_group = aio.Group()
+
+        self.async_group.spawn(aio.call_on_cancel, self._on_close)
+        self.async_group.spawn(self._receive_loop)
+        self.async_group.spawn(self._send_loop)
+        self.async_group.spawn(aio.call_on_done, conn.wait_closing(),
+                               self.close)
+
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._async_group
 
     @property
     def info(self) -> ConnectionInfo:
         """Connection info"""
         return self._info
 
     @property
-    def conn_req_user_data(self) -> IdentifiedEntity:
+    def conn_req_user_data(self) -> copp.IdentifiedEntity:
         """Connect request's user data"""
         return self._conn_req_user_data
 
     @property
-    def conn_res_user_data(self) -> IdentifiedEntity:
+    def conn_res_user_data(self) -> copp.IdentifiedEntity:
         """Connect response's user data"""
         return self._conn_res_user_data
 
-    async def read(self) -> IdentifiedEntity:
-        """Read data"""
-        return await self._read_queue.get()
-
-    def write(self, data: IdentifiedEntity):
-        """Write data"""
-        self._copp_conn.write(data)
+    async def receive(self) -> copp.IdentifiedEntity:
+        """Receive data"""
+        try:
+            return await self._receive_queue.get()
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
+
+    async def send(self, data: copp.IdentifiedEntity):
+        """Send data"""
+        try:
+            await self._send_queue.put((data, None))
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
+
+    async def drain(self):
+        """Drain output buffer"""
+        try:
+            future = self._loop.create_future()
+            await self._send_queue.put((None, future))
+            await future
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
 
-    async def _read_loop(self):
-        close_apdu = _abrt_apdu(0)
+    async def _on_close(self):
+        await _close_copp(self._conn, self._close_apdu)
+
+    def _close(self, apdu):
+        if not self.is_open:
+            return
+
+        self._close_apdu = apdu
+        self._async_group.close()
+
+    async def _receive_loop(self):
         try:
             while True:
-                syntax_name, entity = await self._copp_conn.read()
+                syntax_name, entity = await self._conn.receive()
+
                 if syntax_name == _acse_syntax_name:
                     if entity[0] == 'abrt':
                         close_apdu = None
+
                     elif entity[0] == 'rlrq':
                         close_apdu = _rlre_apdu()
+
                     else:
                         close_apdu = _abrt_apdu(1)
+
+                    self._close(close_apdu)
                     break
-                await self._read_queue.put((syntax_name, entity))
+
+                await self._receive_queue.put((syntax_name, entity))
+
+        except ConnectionError:
+            pass
+
+        except Exception as e:
+            mlog.error("receive loop error: %s", e, exc_info=e)
+
         finally:
-            self._async_group.close()
-            self._read_queue.close()
-            await aio.uncancellable(
-                _close_connection(self._copp_conn, close_apdu))
+            self._close(_abrt_apdu(1))
+            self._receive_queue.close()
 
+    async def _send_loop(self):
+        future = None
+        try:
+            while True:
+                data, future = await self._send_queue.get()
+
+                if data is None:
+                    await self._conn.drain()
+
+                else:
+                    await self._conn.send(data)
+
+                if future and not future.done():
+                    future.set_result(None)
+
+        except ConnectionError:
+            pass
+
+        except Exception as e:
+            mlog.error("send loop error: %s", e, exc_info=e)
+
+        finally:
+            self._close(_abrt_apdu(1))
+            self._send_queue.close()
 
-async def _close_connection(copp_conn, apdu):
+            while True:
+                if future and not future.done():
+                    future.set_result(None)
+                if self._send_queue.empty():
+                    break
+                _, future = self._send_queue.get_nowait()
+
+
+async def _close_copp(copp_conn, apdu):
     data = (_acse_syntax_name, _encode(apdu)) if apdu else None
     await copp_conn.async_close(data)
 
 
 def _get_ap_titles(aarq_apdu):
     calling = None
-    called = None
     if 'calling-AP-title' in aarq_apdu[1]:
         if aarq_apdu[1]['calling-AP-title'][0] == 'ap-title-form2':
             calling = aarq_apdu[1]['calling-AP-title'][1]
+
+    called = None
     if 'called-AP-title' in aarq_apdu[1]:
         if aarq_apdu[1]['called-AP-title'][0] == 'ap-title-form2':
             called = aarq_apdu[1]['called-AP-title'][1]
+
     return calling, called
 
 
 def _get_ae_qualifiers(aarq_apdu):
     calling = None
-    called = None
     if 'calling-AE-qualifier' in aarq_apdu[1]:
         if aarq_apdu[1]['calling-AE-qualifier'][0] == 'ap-qualifier-form2':
             calling = aarq_apdu[1]['calling-AE-qualifier'][1]
+
+    called = None
     if 'called-AE-qualifier' in aarq_apdu[1]:
         if aarq_apdu[1]['called-AE-qualifier'][0] == 'ap-qualifier-form2':
             called = aarq_apdu[1]['called-AE-qualifier'][1]
+
     return calling, called
 
 
 def _get_ap_invocation_identifiers(aarq_apdu):
     calling = aarq_apdu[1].get('calling-AP-invocation-identifier')
     called = aarq_apdu[1].get('called-AP-invocation-identifier')
     return calling, called
@@ -331,29 +438,35 @@
 
 
 def _aarq_apdu(syntax_names, app_context_name,
                calling_ap_title, called_ap_title,
                calling_ae_qualifier, called_ae_qualifier,
                user_data):
     aarq_apdu = 'aarq', {'application-context-name': app_context_name}
+
     if calling_ap_title is not None:
         aarq_apdu[1]['calling-AP-title'] = 'ap-title-form2', calling_ap_title
+
     if called_ap_title is not None:
         aarq_apdu[1]['called-AP-title'] = 'ap-title-form2', called_ap_title
+
     if calling_ae_qualifier is not None:
         aarq_apdu[1]['calling-AE-qualifier'] = ('ae-qualifier-form2',
                                                 calling_ae_qualifier)
+
     if called_ae_qualifier is not None:
         aarq_apdu[1]['called-AE-qualifier'] = ('ae-qualifier-form2',
                                                called_ae_qualifier)
+
     if user_data:
         aarq_apdu[1]['user-information'] = [
             asn1.External(direct_ref=_encoder.syntax_name,
                           indirect_ref=syntax_names.get_id(user_data[0]),
                           data=user_data[1])]
+
     return aarq_apdu
 
 
 def _aare_apdu(syntax_names, user_data,
                responding_ap_title, responding_ae_qualifier,
                responding_ap_invocation_identifier,
                responding_ae_invocation_identifier):
@@ -361,26 +474,31 @@
         'application-context-name': user_data[0],
         'result': 0,
         'result-source-diagnostic': ('acse-service-user', 0),
         'user-information': [
             asn1.External(direct_ref=_encoder.syntax_name,
                           indirect_ref=syntax_names.get_id(user_data[0]),
                           data=user_data[1])]}
+
     if responding_ap_title is not None:
         aare_apdu[1]['responding-AP-title'] = ('ap-title-form2',
                                                responding_ap_title)
+
     if responding_ae_qualifier is not None:
         aare_apdu[1]['responding-AE-qualifier'] = ('ae-qualifier-form2',
                                                    responding_ae_qualifier)
+
     if responding_ap_invocation_identifier is not None:
         aare_apdu[1]['responding-AP-invocation-identifier'] = \
             responding_ap_invocation_identifier
+
     if responding_ae_invocation_identifier is not None:
         aare_apdu[1]['responding-AE-invocation-identifier'] = \
             responding_ae_invocation_identifier
+
     return aare_apdu
 
 
 def _abrt_apdu(source):
     return 'abrt', {'abort-source': source}
```

## hat/drivers/cdt/connection.py

```diff
@@ -57,15 +57,15 @@
                           cb: EventCb
                           ) -> util.RegisterCallbackHandle:
         return self._event_cbs.register(cb)
 
     async def call(self,
                    method: str,
                    params: json.Data = {},
-                   session_id: typing.Optional[SessionId] = None
+                   session_id: SessionId | None = None
                    ) -> json.Data:
         if not self.is_open:
             raise ConnectionError()
 
         msg = {'id': next(self._next_ids),
                'method': method,
                'params': params}
```

## hat/drivers/cdt/runtime.py

```diff
@@ -1,21 +1,22 @@
 import typing
 
 from hat import json
+
 from hat.drivers.cdt.target import Session
 
 
 RemoteObjectId = str
 
 
 class RemoteObject(typing.NamedTuple):
     type: str
-    subtype: typing.Optional[str]
-    value: typing.Optional[json.Data]
-    id: typing.Optional[RemoteObjectId]
+    subtype: str | None
+    value: json.Data | None
+    id: RemoteObjectId | None
 
 
 class Runtime:
 
     def __init__(self, session: Session):
         self._session = session
```

## hat/drivers/cdt/target.py

```diff
@@ -1,39 +1,39 @@
 import typing
 
 from hat import json
+
 from hat.drivers.cdt.connection import SessionId, Connection
 
 
 TargetId = str
 
 
 class TargetInfo(typing.NamedTuple):
     target_id: TargetId
     type: str
     title: str
     url: str
     attached: bool
 
 
-async def getTargetInfos(conn: Connection
-                         ) -> typing.List[TargetInfo]:
+async def getTargetInfos(conn: Connection) -> list[TargetInfo]:
     res = await conn.call('Target.getTargets')
     return [TargetInfo(target_id=i['targetId'],
                        type=i['type'],
                        title=i['title'],
                        url=i['url'],
                        attached=i['attached'])
             for i in res['targetInfos']]
 
 
 async def createTarget(conn: Connection,
                        url: str = '',
-                       width: typing.Optional[int] = None,
-                       height: typing.Optional[int] = None,
+                       width: int | None = None,
+                       height: int | None = None,
                        new_window: bool = False,
                        background: bool = False
                        ) -> 'Target':
     req = {'url': url,
            'new_window': new_window,
            'background': background}
     if width is not None:
```

## hat/drivers/copp/__init__.py

```diff
@@ -1,235 +1,268 @@
-"""Connection oriented presentation protocol
-
-Attributes:
-    mlog (logging.Logger): module logger
-
-"""
+"""Connection oriented presentation protocol"""
 
+import asyncio
 import importlib.resources
 import logging
 import typing
 
 from hat import aio
 from hat import asn1
+
 from hat.drivers import cosp
+from hat.drivers import tcp
 
 
 mlog = logging.getLogger(__name__)
 
-
-IdentifiedEntity = typing.Tuple[asn1.ObjectIdentifier, asn1.Entity]
-"""Identified entity"""
-
-
-Address = cosp.Address
-"""Address"""
+with importlib.resources.as_file(importlib.resources.files(__package__) /
+                                 'asn1_repo.json') as _path:
+    _encoder = asn1.Encoder(asn1.Encoding.BER,
+                            asn1.Repository.from_json(_path))
 
 
 class ConnectionInfo(typing.NamedTuple):
-    local_addr: Address
-    local_tsel: typing.Optional[int]
-    local_ssel: typing.Optional[int]
-    local_psel: typing.Optional[int]
-    remote_addr: Address
-    remote_tsel: typing.Optional[int]
-    remote_ssel: typing.Optional[int]
-    remote_psel: typing.Optional[int]
+    local_addr: tcp.Address
+    local_tsel: int | None
+    local_ssel: int | None
+    local_psel: int | None
+    remote_addr: tcp.Address
+    remote_tsel: int | None
+    remote_ssel: int | None
+    remote_psel: int | None
 
 
-ValidateResult = typing.Optional[IdentifiedEntity]
-"""Validate result"""
-
+IdentifiedEntity: typing.TypeAlias = tuple[asn1.ObjectIdentifier, asn1.Entity]
+"""Identified entity"""
 
-ValidateCb = aio.AsyncCallable[['SyntaxNames', IdentifiedEntity],
-                               ValidateResult]
+ValidateCb: typing.TypeAlias = aio.AsyncCallable[['SyntaxNames',
+                                                  IdentifiedEntity],
+                                                 IdentifiedEntity | None]
 """Validate callback"""
 
-
-ConnectionCb = aio.AsyncCallable[['Connection'], None]
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[['Connection'], None]
 """Connection callback"""
 
 
-with importlib.resources.path(__package__, 'asn1_repo.json') as _path:
-    _encoder = asn1.Encoder(asn1.Encoding.BER,
-                            asn1.Repository.from_json(_path))
-
-
 class SyntaxNames:
     """Syntax name registry
 
     Args:
         syntax_names: list of ASN.1 ObjectIdentifiers representing syntax names
 
     """
 
-    def __init__(self, syntax_names: typing.List[asn1.ObjectIdentifier]):
+    def __init__(self, syntax_names: list[asn1.ObjectIdentifier]):
         self._syntax_id_names = {(i * 2 + 1): name
                                  for i, name in enumerate(syntax_names)}
         self._syntax_name_ids = {v: k
                                  for k, v in self._syntax_id_names.items()}
 
     def get_name(self, syntax_id: int) -> asn1.ObjectIdentifier:
         """Get syntax name associated with id"""
         return self._syntax_id_names[syntax_id]
 
     def get_id(self, syntax_name: asn1.ObjectIdentifier) -> int:
         """Get syntax id associated with name"""
         return self._syntax_name_ids[syntax_name]
 
 
-async def connect(syntax_names: SyntaxNames,
-                  addr: Address,
-                  local_tsel: typing.Optional[int] = None,
-                  remote_tsel: typing.Optional[int] = None,
-                  local_ssel: typing.Optional[int] = None,
-                  remote_ssel: typing.Optional[int] = None,
-                  local_psel: typing.Optional[int] = None,
-                  remote_psel: typing.Optional[int] = None,
-                  user_data: typing.Optional[IdentifiedEntity] = None
+async def connect(addr: tcp.Address,
+                  syntax_names: SyntaxNames,
+                  user_data: IdentifiedEntity | None = None,
+                  *,
+                  local_psel: int | None = None,
+                  remote_psel: int | None = None,
+                  copp_receive_queue_size: int = 1024,
+                  copp_send_queue_size: int = 1024,
+                  **kwargs
                   ) -> 'Connection':
-    """Connect to COPP server"""
+    """Connect to COPP server
+
+    Additional arguments are passed directly to `hat.drivers.cosp.connect`.
+
+    """
     cp_ppdu = _cp_ppdu(syntax_names, local_psel, remote_psel, user_data)
     cp_ppdu_data = _encode('CP-type', cp_ppdu)
-    cosp_conn = await cosp.connect(addr=addr,
-                                   local_tsel=local_tsel,
-                                   remote_tsel=remote_tsel,
-                                   local_ssel=local_ssel,
-                                   remote_ssel=remote_ssel,
-                                   user_data=cp_ppdu_data)
+    conn = await cosp.connect(addr, cp_ppdu_data, **kwargs)
+
     try:
-        cpa_ppdu = _decode('CPA-PPDU', cosp_conn.conn_res_user_data)
+        cpa_ppdu = _decode('CPA-PPDU', conn.conn_res_user_data)
         _validate_connect_response(cp_ppdu, cpa_ppdu)
+
         calling_psel, called_psel = _get_psels(cp_ppdu)
-        return _create_connection(syntax_names, cosp_conn, cp_ppdu, cpa_ppdu,
-                                  calling_psel, called_psel)
+        return Connection(conn, syntax_names, cp_ppdu, cpa_ppdu,
+                          calling_psel, called_psel,
+                          copp_receive_queue_size, copp_send_queue_size)
+
     except Exception:
-        await aio.uncancellable(_close_connection(cosp_conn, _arp_ppdu()))
+        await aio.uncancellable(_close_cosp(conn, _arp_ppdu()))
         raise
 
 
 async def listen(validate_cb: ValidateCb,
                  connection_cb: ConnectionCb,
-                 addr: Address = Address('0.0.0.0', 102)
+                 addr: tcp.Address = tcp.Address('0.0.0.0', 102),
+                 *,
+                 bind_connections: bool = False,
+                 copp_receive_queue_size: int = 1024,
+                 copp_send_queue_size: int = 1024,
+                 **kwargs
                  ) -> 'Server':
     """Create COPP listening server
 
+    Additional arguments are passed directly to `hat.drivers.cosp.listen`.
+
     Args:
         validate_cb: callback function or coroutine called on new
             incomming connection request prior to creating connection object
         connection_cb: new connection callback
         addr: local listening address
 
     """
+    server = Server()
+    server._validate_cb = validate_cb
+    server._connection_cb = connection_cb
+    server._bind_connections = bind_connections
+    server._receive_queue_size = copp_receive_queue_size
+    server._send_queue_size = copp_send_queue_size
+
+    server._srv = await cosp.listen(server._on_validate,
+                                    server._on_connection,
+                                    addr,
+                                    bind_connections=False,
+                                    **kwargs)
+
+    return server
+
+
+class Server(aio.Resource):
+    """COPP listening server
+
+    For creating new server see `listen`.
+
+    """
+
+    @property
+    def async_group(self) -> aio.Group:
+        """Async group"""
+        return self._srv.async_group
+
+    @property
+    def addresses(self) -> list[tcp.Address]:
+        """Listening addresses"""
+        return self._srv.addresses
 
-    async def on_validate(user_data):
+    async def _on_validate(self, user_data):
         cp_ppdu = _decode('CP-type', user_data)
         cp_params = cp_ppdu['normal-mode-parameters']
         called_psel_data = cp_params.get('called-presentation-selector')
         called_psel = (int.from_bytes(called_psel_data, 'big')
                        if called_psel_data else None)
         cp_pdv_list = cp_params['user-data'][1][0]
         syntax_names = _sytax_names_from_cp_ppdu(cp_ppdu)
         cp_user_data = (
             syntax_names.get_name(
                 cp_pdv_list['presentation-context-identifier']),
             cp_pdv_list['presentation-data-values'][1])
-        cpa_user_data = await aio.call(
-            validate_cb, syntax_names, cp_user_data)
+
+        cpa_user_data = await aio.call(self._validate_cb, syntax_names,
+                                       cp_user_data)
+
         cpa_ppdu = _cpa_ppdu(syntax_names, called_psel, cpa_user_data)
         cpa_ppdu_data = _encode('CPA-PPDU', cpa_ppdu)
         return cpa_ppdu_data
 
-    async def on_connection(cosp_conn):
+    async def _on_connection(self, cosp_conn):
         try:
-            cp_ppdu = _decode('CP-type', cosp_conn.conn_req_user_data)
-            cpa_ppdu = _decode('CPA-PPDU', cosp_conn.conn_res_user_data)
-            syntax_names = _sytax_names_from_cp_ppdu(cp_ppdu)
-            calling_psel, called_psel = _get_psels(cp_ppdu)
-            conn = _create_connection(syntax_names, cosp_conn,
-                                      cp_ppdu, cpa_ppdu,
-                                      called_psel, calling_psel)
-            await aio.call(connection_cb, conn)
-        except BaseException as e:
+            try:
+                cp_ppdu = _decode('CP-type', cosp_conn.conn_req_user_data)
+                cpa_ppdu = _decode('CPA-PPDU', cosp_conn.conn_res_user_data)
+
+                syntax_names = _sytax_names_from_cp_ppdu(cp_ppdu)
+                calling_psel, called_psel = _get_psels(cp_ppdu)
+
+                conn = Connection(cosp_conn, syntax_names, cp_ppdu, cpa_ppdu,
+                                  calling_psel, called_psel,
+                                  self._receive_queue_size,
+                                  self._send_queue_size)
+
+            except Exception:
+                await aio.uncancellable(_close_cosp(cosp_conn, _arp_ppdu()))
+                raise
+
+            try:
+                await aio.call(self._connection_cb, conn)
+
+            except BaseException:
+                await aio.uncancellable(conn.async_close())
+                raise
+
+        except Exception as e:
             mlog.error("error creating new incomming connection: %s", e,
                        exc_info=e)
-            await aio.uncancellable(_close_connection(cosp_conn, _arp_ppdu()))
+            return
+
+        if not self._bind_connections:
+            return
 
-    async def wait_cosp_server_closed():
         try:
-            await cosp_server.wait_closed()
-        finally:
-            async_group.close()
+            await conn.wait_closed()
 
-    async_group = aio.Group()
-    cosp_server = await cosp.listen(on_validate, on_connection, addr)
-    async_group.spawn(aio.call_on_cancel, cosp_server.async_close)
-    async_group.spawn(wait_cosp_server_closed)
-
-    srv = Server()
-    srv._async_group = async_group
-    srv._cosp_server = cosp_server
-    return srv
+        except BaseException:
+            await aio.uncancellable(conn.async_close())
+            raise
 
 
-class Server(aio.Resource):
-    """COPP listening server
-
-    For creating new server see :func:`listen`
+class Connection(aio.Resource):
+    """COPP connection
 
-    Closing server doesn't close active incomming connections
+    For creating new connection see `connect` or `listen`.
 
     """
 
-    @property
-    def async_group(self) -> aio.Group:
-        """Async group"""
-        return self._async_group
-
-    @property
-    def addresses(self) -> typing.List[Address]:
-        """Listening addresses"""
-        return self._cosp_server.addresses
-
-
-def _create_connection(syntax_names, cosp_conn, cp_ppdu, cpa_ppdu,
-                       local_psel, remote_psel):
-    cp_user_data = cp_ppdu['normal-mode-parameters']['user-data']
-    cpa_user_data = cpa_ppdu['normal-mode-parameters']['user-data']
-
-    conn_req_user_data = (
-        syntax_names.get_name(
-            cp_user_data[1][0]['presentation-context-identifier']),
-        cp_user_data[1][0]['presentation-data-values'][1])
-    conn_res_user_data = (
-        syntax_names.get_name(
-            cpa_user_data[1][0]['presentation-context-identifier']),
-        cpa_user_data[1][0]['presentation-data-values'][1])
-
-    conn = Connection()
-    conn._cosp_conn = cosp_conn
-    conn._syntax_names = syntax_names
-    conn._conn_req_user_data = conn_req_user_data
-    conn._conn_res_user_data = conn_res_user_data
-    conn._info = ConnectionInfo(local_psel=local_psel,
-                                remote_psel=remote_psel,
-                                **cosp_conn.info._asdict())
-    conn._close_ppdu = _arp_ppdu()
-    conn._read_queue = aio.Queue()
-    conn._async_group = aio.Group()
-    conn._async_group.spawn(conn._read_loop)
-    return conn
-
-
-class Connection(aio.Resource):
-    """COPP connection
+    def __init__(self,
+                 conn: cosp.Connection,
+                 syntax_names: SyntaxNames,
+                 cp_ppdu: asn1.Value,
+                 cpa_ppdu: asn1.Value,
+                 local_psel: int | None,
+                 remote_psel: int | None,
+                 receive_queue_size: int,
+                 send_queue_size: int):
+        cp_user_data = cp_ppdu['normal-mode-parameters']['user-data']
+        cpa_user_data = cpa_ppdu['normal-mode-parameters']['user-data']
 
-    For creating new connection see :func:`connect`
+        conn_req_user_data = (
+            syntax_names.get_name(
+                cp_user_data[1][0]['presentation-context-identifier']),
+            cp_user_data[1][0]['presentation-data-values'][1])
+        conn_res_user_data = (
+            syntax_names.get_name(
+                cpa_user_data[1][0]['presentation-context-identifier']),
+            cpa_user_data[1][0]['presentation-data-values'][1])
 
-    """
+        self._conn = conn
+        self._syntax_names = syntax_names
+        self._conn_req_user_data = conn_req_user_data
+        self._conn_res_user_data = conn_res_user_data
+        self._loop = asyncio.get_running_loop()
+        self._info = ConnectionInfo(local_psel=local_psel,
+                                    remote_psel=remote_psel,
+                                    **conn.info._asdict())
+        self._close_ppdu = _arp_ppdu()
+        self._receive_queue = aio.Queue(receive_queue_size)
+        self._send_queue = aio.Queue(send_queue_size)
+        self._async_group = aio.Group()
+
+        self.async_group.spawn(aio.call_on_cancel, self._on_close)
+        self.async_group.spawn(self._receive_loop)
+        self.async_group.spawn(self._send_loop)
+        self.async_group.spawn(aio.call_on_done, conn.wait_closing(),
+                               self.close)
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._async_group
 
     @property
@@ -248,57 +281,125 @@
         return self._conn_req_user_data
 
     @property
     def conn_res_user_data(self) -> IdentifiedEntity:
         """Connect response's user data"""
         return self._conn_res_user_data
 
-    def close(self, user_data: typing.Optional[IdentifiedEntity] = None):
+    def close(self, user_data: IdentifiedEntity | None = None):
         """Close connection"""
-        self._close_ppdu = _aru_ppdu(self._syntax_names, user_data)
-        self._async_group.close()
+        self._close(_aru_ppdu(self._syntax_names, user_data))
 
-    async def async_close(self,
-                          user_data: typing.Optional[IdentifiedEntity] = None):
+    async def async_close(self, user_data: IdentifiedEntity | None = None):
         """Async close"""
         self.close(user_data)
         await self.wait_closed()
 
-    async def read(self) -> IdentifiedEntity:
-        """Read data"""
-        return await self._read_queue.get()
-
-    def write(self, data: IdentifiedEntity):
-        """Write data"""
-        ppdu_data = _encode('User-data', _user_data(self._syntax_names, data))
-        self._cosp_conn.write(ppdu_data)
+    async def receive(self) -> IdentifiedEntity:
+        """Receive data"""
+        try:
+            return await self._receive_queue.get()
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
 
-    async def _read_loop(self):
+    async def send(self, data: IdentifiedEntity):
+        """Send data"""
+        try:
+            await self._send_queue.put((data, None))
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
+
+    async def drain(self):
+        """Drain output buffer"""
+        try:
+            future = self._loop.create_future()
+            await self._send_queue.put((None, future))
+            await future
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
+
+    async def _on_close(self):
+        await _close_cosp(self._conn, self._close_ppdu)
+
+    def _close(self, ppdu):
+        if not self.is_open:
+            return
+
+        self._close_ppdu = ppdu
+        self._async_group.close()
+
+    async def _receive_loop(self):
         try:
             while True:
-                cosp_data = await self._cosp_conn.read()
+                cosp_data = await self._conn.receive()
+
                 user_data = _decode('User-data', cosp_data)
                 pdv_list = user_data[1][0]
                 syntax_name = self._syntax_names.get_name(
                     pdv_list['presentation-context-identifier'])
                 data = pdv_list['presentation-data-values'][1]
-                await self._read_queue.put((syntax_name, data))
+
+                await self._receive_queue.put((syntax_name, data))
+
+        except ConnectionError:
+            pass
+
+        except Exception as e:
+            mlog.error("receive loop error: %s", e, exc_info=e)
+
+        finally:
+            self._close(_arp_ppdu())
+            self._receive_queue.close()
+
+    async def _send_loop(self):
+        future = None
+        try:
+            while True:
+                data, future = await self._send_queue.get()
+
+                if data is None:
+                    await self._conn.drain()
+
+                else:
+                    ppdu_data = _encode('User-data',
+                                        _user_data(self._syntax_names, data))
+                    await self._conn.send(ppdu_data)
+
+                if future and not future.done():
+                    future.set_result(None)
+
+        except ConnectionError:
+            pass
+
+        except Exception as e:
+            mlog.error("send loop error: %s", e, exc_info=e)
+
         finally:
-            self._async_group.close()
-            self._read_queue.close()
-            await aio.uncancellable(
-                _close_connection(self._cosp_conn, self._close_ppdu))
+            self._close(_arp_ppdu())
+            self._send_queue.close()
+
+            while True:
+                if future and not future.done():
+                    future.set_result(None)
+                if self._send_queue.empty():
+                    break
+                _, future = self._send_queue.get_nowait()
 
 
-async def _close_connection(cosp_conn, ppdu):
+async def _close_cosp(cosp_conn, ppdu):
     try:
-        data = _encode('Abort-type', ppdu) if ppdu else None
+        data = _encode('Abort-type', ppdu)
+
     except Exception as e:
-        mlog.error("error encoding ppdu: %s", e, exc_info=e)
+        mlog.error("error encoding abort ppdu: %s", e, exc_info=e)
         data = None
+
     finally:
         await cosp_conn.async_close(data)
 
 
 def _get_psels(cp_ppdu):
     cp_params = cp_ppdu['normal-mode-parameters']
     calling_psel_data = cp_params.get('calling-presentation-selector')
@@ -311,66 +412,78 @@
 
 
 def _validate_connect_response(cp_ppdu, cpa_ppdu):
     cp_params = cp_ppdu['normal-mode-parameters']
     cpa_params = cpa_ppdu['normal-mode-parameters']
     called_psel_data = cp_params.get('called-presentation-selector')
     responding_psel_data = cpa_params.get('responding-presentation-selector')
+
     if called_psel_data and responding_psel_data:
         called_psel = int.from_bytes(called_psel_data, 'big')
         responding_psel = int.from_bytes(responding_psel_data, 'big')
+
         if called_psel != responding_psel:
             raise Exception('presentation selectors not matching')
+
     result_list = cpa_params['presentation-context-definition-result-list']
     if any(i['result'] != 0 for i in result_list):
         raise Exception('presentation context not accepted')
 
 
 def _cp_ppdu(syntax_names, calling_psel, called_psel, user_data):
     cp_params = {
         'presentation-context-definition-list': [
             {'presentation-context-identifier': i,
              'abstract-syntax-name': name,
              'transfer-syntax-name-list': [_encoder.syntax_name]}
             for i, name in syntax_names._syntax_id_names.items()]}
+
     if calling_psel is not None:
         cp_params['calling-presentation-selector'] = \
             calling_psel.to_bytes(4, 'big')
+
     if called_psel is not None:
         cp_params['called-presentation-selector'] = \
             called_psel.to_bytes(4, 'big')
+
     if user_data:
         cp_params['user-data'] = _user_data(syntax_names, user_data)
+
     return {
         'mode-selector': {
             'mode-value': 1},
         'normal-mode-parameters': cp_params}
 
 
 def _cpa_ppdu(syntax_names, responding_psel, user_data):
     cpa_params = {
         'presentation-context-definition-result-list': [
             {'result': 0,
              'transfer-syntax-name': _encoder.syntax_name}
             for _ in syntax_names._syntax_id_names.keys()]}
+
     if responding_psel is not None:
         cpa_params['responding-presentation-selector'] = \
             responding_psel.to_bytes(4, 'big')
+
     if user_data:
         cpa_params['user-data'] = _user_data(syntax_names, user_data)
+
     return {
         'mode-selector': {
             'mode-value': 1},
         'normal-mode-parameters': cpa_params}
 
 
 def _aru_ppdu(syntax_names, user_data):
     aru_params = {}
+
     if user_data:
         aru_params['user-data'] = _user_data(syntax_names, user_data)
+
     return 'aru-ppdu', ('normal-mode-parameters', aru_params)
 
 
 def _arp_ppdu():
     return 'arp-ppdu', {}
```

## hat/drivers/iec101/__init__.py

```diff
@@ -1,11 +1,10 @@
 """IEC 60870-5-101 communication protocol"""
 
-from hat.drivers.iec101.common import (Bytes,
-                                       CauseSize,
+from hat.drivers.iec101.common import (CauseSize,
                                        AsduAddressSize,
                                        IoAddressSize,
                                        TimeSize,
                                        Time,
                                        OriginatorAddress,
                                        AsduAddress,
                                        IoAddress,
@@ -93,16 +92,15 @@
                                        ParameterActivationMsg,
                                        Msg,
                                        time_from_datetime,
                                        time_to_datetime)
 from hat.drivers.iec101.connection import Connection
 
 
-__all__ = ['Bytes',
-           'CauseSize',
+__all__ = ['CauseSize',
            'AsduAddressSize',
            'IoAddressSize',
            'TimeSize',
            'Time',
            'OriginatorAddress',
            'AsduAddress',
            'IoAddress',
```

## hat/drivers/iec101/common.py

```diff
@@ -1,47 +1,46 @@
 import enum
 import typing
 
 from hat.drivers.iec60870.msgs import iec101
 
 
-Bytes = iec101.common.Bytes
-CauseSize = iec101.common.CauseSize
-AsduAddressSize = iec101.common.AsduAddressSize
-IoAddressSize = iec101.common.IoAddressSize
-TimeSize = iec101.common.TimeSize
-Time = iec101.common.Time
-
-OriginatorAddress = iec101.common.OriginatorAddress
-AsduAddress = iec101.common.AsduAddress
-IoAddress = iec101.common.IoAddress
-
-IndicationQuality = iec101.common.IndicationQuality
-MeasurementQuality = iec101.common.MeasurementQuality
-CounterQuality = iec101.common.CounterQuality
-ProtectionQuality = iec101.common.ProtectionQuality
-Quality = iec101.common.Quality
-
-FreezeCode = iec101.common.FreezeCode
-
-SingleValue = iec101.common.SingleValue
-DoubleValue = iec101.common.DoubleValue
-RegulatingValue = iec101.common.RegulatingValue
-StepPositionValue = iec101.common.StepPositionValue
-BitstringValue = iec101.common.BitstringValue
-NormalizedValue = iec101.common.NormalizedValue
-ScaledValue = iec101.common.ScaledValue
-FloatingValue = iec101.common.FloatingValue
-BinaryCounterValue = iec101.common.BinaryCounterValue
-ProtectionValue = iec101.common.ProtectionValue
-ProtectionStartValue = iec101.common.ProtectionStartValue
-ProtectionCommandValue = iec101.common.ProtectionCommandValue
-StatusValue = iec101.common.StatusValue
+CauseSize: typing.TypeAlias = iec101.common.CauseSize
+AsduAddressSize: typing.TypeAlias = iec101.common.AsduAddressSize
+IoAddressSize: typing.TypeAlias = iec101.common.IoAddressSize
+TimeSize: typing.TypeAlias = iec101.common.TimeSize
+Time: typing.TypeAlias = iec101.common.Time
+
+OriginatorAddress: typing.TypeAlias = iec101.common.OriginatorAddress
+AsduAddress: typing.TypeAlias = iec101.common.AsduAddress
+IoAddress: typing.TypeAlias = iec101.common.IoAddress
+
+IndicationQuality: typing.TypeAlias = iec101.common.IndicationQuality
+MeasurementQuality: typing.TypeAlias = iec101.common.MeasurementQuality
+CounterQuality: typing.TypeAlias = iec101.common.CounterQuality
+ProtectionQuality: typing.TypeAlias = iec101.common.ProtectionQuality
+Quality: typing.TypeAlias = iec101.common.Quality
+
+FreezeCode: typing.TypeAlias = iec101.common.FreezeCode
+
+SingleValue: typing.TypeAlias = iec101.common.SingleValue
+DoubleValue: typing.TypeAlias = iec101.common.DoubleValue
+RegulatingValue: typing.TypeAlias = iec101.common.RegulatingValue
+StepPositionValue: typing.TypeAlias = iec101.common.StepPositionValue
+BitstringValue: typing.TypeAlias = iec101.common.BitstringValue
+NormalizedValue: typing.TypeAlias = iec101.common.NormalizedValue
+ScaledValue: typing.TypeAlias = iec101.common.ScaledValue
+FloatingValue: typing.TypeAlias = iec101.common.FloatingValue
+BinaryCounterValue: typing.TypeAlias = iec101.common.BinaryCounterValue
+ProtectionValue: typing.TypeAlias = iec101.common.ProtectionValue
+ProtectionStartValue: typing.TypeAlias = iec101.common.ProtectionStartValue
+ProtectionCommandValue: typing.TypeAlias = iec101.common.ProtectionCommandValue
+StatusValue: typing.TypeAlias = iec101.common.StatusValue
 
-OtherCause = int
+OtherCause: typing.TypeAlias = int
 """Other cause in range [0, 63]"""
 
 
 class DataResCause(enum.Enum):
     PERIODIC = iec101.common.CauseType.PERIODIC.value
     BACKGROUND_SCAN = iec101.common.CauseType.BACKGROUND_SCAN.value
     SPONTANEOUS = iec101.common.CauseType.SPONTANEOUS.value
@@ -68,15 +67,15 @@
     INTERROGATED_COUNTER = iec101.common.CauseType.INTERROGATED_COUNTER.value  # NOQA
     INTERROGATED_COUNTER01 = iec101.common.CauseType.INTERROGATED_COUNTER01.value  # NOQA
     INTERROGATED_COUNTER02 = iec101.common.CauseType.INTERROGATED_COUNTER02.value  # NOQA
     INTERROGATED_COUNTER03 = iec101.common.CauseType.INTERROGATED_COUNTER03.value  # NOQA
     INTERROGATED_COUNTER04 = iec101.common.CauseType.INTERROGATED_COUNTER04.value  # NOQA
 
 
-DataCause = typing.Union[DataResCause, OtherCause]
+DataCause: typing.TypeAlias = DataResCause | OtherCause
 
 
 class CommandReqCause(enum.Enum):
     ACTIVATION = iec101.common.CauseType.ACTIVATION.value
     DEACTIVATION = iec101.common.CauseType.DEACTIVATION.value
 
 
@@ -86,38 +85,38 @@
     ACTIVATION_TERMINATION = iec101.common.CauseType.ACTIVATION_TERMINATION.value  # NOQA
     UNKNOWN_TYPE = iec101.common.CauseType.UNKNOWN_TYPE.value
     UNKNOWN_CAUSE = iec101.common.CauseType.UNKNOWN_CAUSE.value
     UNKNOWN_ASDU_ADDRESS = iec101.common.CauseType.UNKNOWN_ASDU_ADDRESS.value  # NOQA
     UNKNOWN_IO_ADDRESS = iec101.common.CauseType.UNKNOWN_IO_ADDRESS.value
 
 
-CommandCause = typing.Union[CommandReqCause, CommandResCause, OtherCause]
+CommandCause: typing.TypeAlias = CommandReqCause | CommandResCause | OtherCause
 
 
 class InitializationResCause(enum.Enum):
     LOCAL_POWER = 0
     LOCAL_RESET = 1
     REMOTE_RESET = 2
 
 
-InitializationCause = typing.Union[InitializationResCause, OtherCause]
+InitializationCause: typing.TypeAlias = InitializationResCause | OtherCause
 
 
 class ReadReqCause(enum.Enum):
     REQUEST = iec101.common.CauseType.REQUEST.value
 
 
 class ReadResCause(enum.Enum):
     UNKNOWN_TYPE = iec101.common.CauseType.UNKNOWN_TYPE.value
     UNKNOWN_CAUSE = iec101.common.CauseType.UNKNOWN_CAUSE.value
     UNKNOWN_ASDU_ADDRESS = iec101.common.CauseType.UNKNOWN_ASDU_ADDRESS.value  # NOQA
     UNKNOWN_IO_ADDRESS = iec101.common.CauseType.UNKNOWN_IO_ADDRESS.value
 
 
-ReadCause = typing.Union[ReadReqCause, ReadResCause, OtherCause]
+ReadCause: typing.TypeAlias = ReadReqCause | ReadResCause | OtherCause
 
 
 class ClockSyncReqCause(enum.Enum):
     ACTIVATION = iec101.common.CauseType.ACTIVATION.value
 
 
 class ClockSyncResCause(enum.Enum):
@@ -125,34 +124,34 @@
     ACTIVATION_CONFIRMATION = iec101.common.CauseType.ACTIVATION_CONFIRMATION.value  # NOQA
     UNKNOWN_TYPE = iec101.common.CauseType.UNKNOWN_TYPE.value
     UNKNOWN_CAUSE = iec101.common.CauseType.UNKNOWN_CAUSE.value
     UNKNOWN_ASDU_ADDRESS = iec101.common.CauseType.UNKNOWN_ASDU_ADDRESS.value  # NOQA
     UNKNOWN_IO_ADDRESS = iec101.common.CauseType.UNKNOWN_IO_ADDRESS.value
 
 
-ClockSyncCause = typing.Union[ClockSyncReqCause,
-                              ClockSyncResCause,
-                              OtherCause]
+ClockSyncCause: typing.TypeAlias = (ClockSyncReqCause |
+                                    ClockSyncResCause |
+                                    OtherCause)
 
 
 class ActivationReqCause(enum.Enum):
     ACTIVATION = iec101.common.CauseType.ACTIVATION.value
 
 
 class ActivationResCause(enum.Enum):
     ACTIVATION_CONFIRMATION = iec101.common.CauseType.ACTIVATION_CONFIRMATION.value  # NOQA
     UNKNOWN_TYPE = iec101.common.CauseType.UNKNOWN_TYPE.value
     UNKNOWN_CAUSE = iec101.common.CauseType.UNKNOWN_CAUSE.value
     UNKNOWN_ASDU_ADDRESS = iec101.common.CauseType.UNKNOWN_ASDU_ADDRESS.value  # NOQA
     UNKNOWN_IO_ADDRESS = iec101.common.CauseType.UNKNOWN_IO_ADDRESS.value
 
 
-ActivationCause = typing.Union[ActivationReqCause,
-                               ActivationResCause,
-                               OtherCause]
+ActivationCause: typing.TypeAlias = (ActivationReqCause |
+                                     ActivationResCause |
+                                     OtherCause)
 
 
 class DelayReqCause(enum.Enum):
     SPONTANEOUS = iec101.common.CauseType.SPONTANEOUS.value
     ACTIVATION = iec101.common.CauseType.ACTIVATION.value
 
 
@@ -160,15 +159,15 @@
     ACTIVATION_CONFIRMATION = iec101.common.CauseType.ACTIVATION_CONFIRMATION.value  # NOQA
     UNKNOWN_TYPE = iec101.common.CauseType.UNKNOWN_TYPE.value
     UNKNOWN_CAUSE = iec101.common.CauseType.UNKNOWN_CAUSE.value
     UNKNOWN_ASDU_ADDRESS = iec101.common.CauseType.UNKNOWN_ASDU_ADDRESS.value  # NOQA
     UNKNOWN_IO_ADDRESS = iec101.common.CauseType.UNKNOWN_IO_ADDRESS.value
 
 
-DelayCause = typing.Union[DelayReqCause, DelayResCause, OtherCause]
+DelayCause: typing.TypeAlias = DelayReqCause | DelayResCause | OtherCause
 
 
 class ParameterReqCause(enum.Enum):
     SPONTANEOUS = iec101.common.CauseType.SPONTANEOUS.value
     ACTIVATION = iec101.common.CauseType.ACTIVATION.value
 
 
@@ -193,15 +192,17 @@
     INTERROGATED_GROUP16 = iec101.common.CauseType.INTERROGATED_GROUP16.value  # NOQA
     UNKNOWN_TYPE = iec101.common.CauseType.UNKNOWN_TYPE.value
     UNKNOWN_CAUSE = iec101.common.CauseType.UNKNOWN_CAUSE.value
     UNKNOWN_ASDU_ADDRESS = iec101.common.CauseType.UNKNOWN_ASDU_ADDRESS.value  # NOQA
     UNKNOWN_IO_ADDRESS = iec101.common.CauseType.UNKNOWN_IO_ADDRESS.value
 
 
-ParameterCause = typing.Union[ParameterReqCause, ParameterResCause, OtherCause]
+ParameterCause: typing.TypeAlias = (ParameterReqCause |
+                                    ParameterResCause |
+                                    OtherCause)
 
 
 class ParameterActivationReqCause(enum.Enum):
     ACTIVATION = iec101.common.CauseType.ACTIVATION.value
     DEACTIVATION = iec101.common.CauseType.DEACTIVATION.value
 
 
@@ -210,17 +211,17 @@
     DEACTIVATION_CONFIRMATION = iec101.common.CauseType.DEACTIVATION_CONFIRMATION.value  # NOQA
     UNKNOWN_TYPE = iec101.common.CauseType.UNKNOWN_TYPE.value
     UNKNOWN_CAUSE = iec101.common.CauseType.UNKNOWN_CAUSE.value
     UNKNOWN_ASDU_ADDRESS = iec101.common.CauseType.UNKNOWN_ASDU_ADDRESS.value  # NOQA
     UNKNOWN_IO_ADDRESS = iec101.common.CauseType.UNKNOWN_IO_ADDRESS.value
 
 
-ParameterActivationCause = typing.Union[ParameterActivationReqCause,
-                                        ParameterActivationResCause,
-                                        OtherCause]
+ParameterActivationCause: typing.TypeAlias = (ParameterActivationReqCause |
+                                              ParameterActivationResCause |
+                                              OtherCause)
 
 
 class SingleData(typing.NamedTuple):
     value: SingleValue
     quality: IndicationQuality
 
 
@@ -237,15 +238,15 @@
 class BitstringData(typing.NamedTuple):
     value: BitstringValue
     quality: MeasurementQuality
 
 
 class NormalizedData(typing.NamedTuple):
     value: NormalizedValue
-    quality: typing.Optional[MeasurementQuality]
+    quality: MeasurementQuality | None
 
 
 class ScaledData(typing.NamedTuple):
     value: ScaledValue
     quality: MeasurementQuality
 
 
@@ -281,26 +282,26 @@
 
 
 class StatusData(typing.NamedTuple):
     value: StatusValue
     quality: MeasurementQuality
 
 
-Data = typing.Union[SingleData,
-                    DoubleData,
-                    StepPositionData,
-                    BitstringData,
-                    NormalizedData,
-                    ScaledData,
-                    FloatingData,
-                    BinaryCounterData,
-                    ProtectionData,
-                    ProtectionStartData,
-                    ProtectionCommandData,
-                    StatusData]
+Data: typing.TypeAlias = (SingleData |
+                          DoubleData |
+                          StepPositionData |
+                          BitstringData |
+                          NormalizedData |
+                          ScaledData |
+                          FloatingData |
+                          BinaryCounterData |
+                          ProtectionData |
+                          ProtectionStartData |
+                          ProtectionCommandData |
+                          StatusData)
 
 
 class SingleCommand(typing.NamedTuple):
     value: SingleValue
     select: bool
     qualifier: int
     """qualifier in range [0, 31]"""
@@ -335,21 +336,21 @@
     select: bool
 
 
 class BitstringCommand(typing.NamedTuple):
     value: BitstringValue
 
 
-Command = typing.Union[SingleCommand,
-                       DoubleCommand,
-                       RegulatingCommand,
-                       NormalizedCommand,
-                       ScaledCommand,
-                       FloatingCommand,
-                       BitstringCommand]
+Command: typing.TypeAlias = (SingleCommand |
+                             DoubleCommand |
+                             RegulatingCommand |
+                             NormalizedCommand |
+                             ScaledCommand |
+                             FloatingCommand |
+                             BitstringCommand)
 
 
 class NormalizedParameter(typing.NamedTuple):
     value: NormalizedValue
     qualifier: int
     """qualifier in range [0, 255]"""
 
@@ -362,26 +363,26 @@
 
 class FloatingParameter(typing.NamedTuple):
     value: FloatingValue
     qualifier: int
     """qualifier in range [0, 255]"""
 
 
-Parameter = typing.Union[NormalizedParameter,
-                         ScaledParameter,
-                         FloatingParameter]
+Parameter: typing.TypeAlias = (NormalizedParameter |
+                               ScaledParameter |
+                               FloatingParameter)
 
 
 class DataMsg(typing.NamedTuple):
     is_test: bool
     originator_address: OriginatorAddress
     asdu_address: AsduAddress
     io_address: IoAddress
     data: Data
-    time: typing.Optional[Time]
+    time: Time | None
     cause: DataCause
 
 
 class CommandMsg(typing.NamedTuple):
     is_test: bool
     originator_address: OriginatorAddress
     asdu_address: AsduAddress
@@ -477,23 +478,23 @@
     asdu_address: AsduAddress
     io_address: IoAddress
     qualifier: int
     """qualifier in range [0, 255]"""
     cause: ParameterActivationCause
 
 
-Msg = typing.Union[DataMsg,
-                   CommandMsg,
-                   InitializationMsg,
-                   InterrogationMsg,
-                   CounterInterrogationMsg,
-                   ReadMsg,
-                   ClockSyncMsg,
-                   TestMsg,
-                   ResetMsg,
-                   DelayMsg,
-                   ParameterMsg,
-                   ParameterActivationMsg]
+Msg: typing.TypeAlias = (DataMsg |
+                         CommandMsg |
+                         InitializationMsg |
+                         InterrogationMsg |
+                         CounterInterrogationMsg |
+                         ReadMsg |
+                         ClockSyncMsg |
+                         TestMsg |
+                         ResetMsg |
+                         DelayMsg |
+                         ParameterMsg |
+                         ParameterActivationMsg)
 
 
 time_from_datetime = iec101.common.time_from_datetime
 time_to_datetime = iec101.common.time_to_datetime
```

## hat/drivers/iec101/connection.py

```diff
@@ -1,9 +1,7 @@
-import typing
-
 from hat import aio
 
 from hat.drivers.iec101 import common
 from hat.drivers.iec101 import encoder
 from hat.drivers.iec60870 import link
 
 
@@ -19,14 +17,14 @@
                                         asdu_address_size=asdu_address_size,
                                         io_address_size=io_address_size)
 
     @property
     def async_group(self):
         return self._conn.async_group
 
-    async def send(self, msgs: typing.List[common.Msg]):
+    async def send(self, msgs: list[common.Msg]):
         for data in self._encoder.encode(msgs):
             await self._conn.send(data)
 
-    async def receive(self) -> typing.List[common.Msg]:
+    async def receive(self) -> list[common.Msg]:
         data = await self._conn.receive()
         return list(self._encoder.decode(data))
```

## hat/drivers/iec101/encoder.py

```diff
@@ -1,11 +1,13 @@
 import contextlib
 import enum
 import typing
 
+from hat import util
+
 from hat.drivers.iec101 import common
 from hat.drivers.iec60870.msgs import iec101
 
 
 class Encoder:
 
     def __init__(self,
@@ -14,21 +16,21 @@
                  io_address_size: common.IoAddressSize):
         self._encoder = iec101.encoder.Encoder(
             cause_size=cause_size,
             asdu_address_size=asdu_address_size,
             io_address_size=io_address_size)
 
     def encode(self,
-               msgs: typing.List[common.Msg]
-               ) -> typing.Iterable[common.Bytes]:
+               msgs: list[common.Msg]
+               ) -> typing.Iterable[util.Bytes]:
         for asdu in _encode_msgs(msgs):
             yield self._encoder.encode_asdu(asdu)
 
     def decode(self,
-               data: common.Bytes
+               data: util.Bytes
                ) -> typing.Iterable[common.Msg]:
         asdu, _ = self._encoder.decode_asdu(data)
         yield from _decode_asdu(asdu)
 
 
 def _encode_msgs(msgs):
     # TODO: group messages and io elements
```

## hat/drivers/iec103/__init__.py

```diff
@@ -1,11 +1,10 @@
 """IEC 60870-5-103 communication protocol"""
 
-from hat.drivers.iec103.common import (Bytes,
-                                       Description,
+from hat.drivers.iec103.common import (Description,
                                        IoAddress,
                                        Identification,
                                        TimeSize,
                                        Time,
                                        ValueType,
                                        NoneValue,
                                        TextValue,
@@ -42,16 +41,15 @@
                                        time_from_datetime,
                                        time_to_datetime)
 from hat.drivers.iec103.master import (DataCb,
                                        GenericDataCb,
                                        MasterConnection)
 
 
-__all__ = ['Bytes',
-           'Description',
+__all__ = ['Description',
            'IoAddress',
            'Identification',
            'TimeSize',
            'Time',
            'ValueType',
            'NoneValue',
            'TextValue',
```

## hat/drivers/iec103/common.py

```diff
@@ -1,48 +1,47 @@
 import enum
 import typing
 
 from hat.drivers.iec60870.msgs import iec103
 
 
-Bytes = iec103.common.Bytes
-AsduAddress = iec103.common.AsduAddress
-OtherCause = iec103.common.OtherCause
-Description = iec103.common.Description
-IoAddress = iec103.common.IoAddress
-Identification = iec103.common.Identification
-TimeSize = iec103.common.TimeSize
-Time = iec103.common.Time
-
-ValueType = iec103.common.ValueType
-NoneValue = iec103.common.NoneValue
-TextValue = iec103.common.TextValue
-BitstringValue = iec103.common.BitstringValue
-UIntValue = iec103.common.UIntValue
-IntValue = iec103.common.IntValue
-UFixedValue = iec103.common.UFixedValue
-FixedValue = iec103.common.FixedValue
-Real32Value = iec103.common.Real32Value
-Real64Value = iec103.common.Real64Value
-DoubleValue = iec103.common.DoubleValue
-SingleValue = iec103.common.SingleValue
-ExtendedDoubleValue = iec103.common.ExtendedDoubleValue
-MeasurandValue = iec103.common.MeasurandValue
-TimeValue = iec103.common.TimeValue
-IdentificationValue = iec103.common.IdentificationValue
-RelativeTimeValue = iec103.common.RelativeTimeValue
-IoAddressValue = iec103.common.IoAddressValue
-DoubleWithTimeValue = iec103.common.DoubleWithTimeValue
-DoubleWithRelativeTimeValue = iec103.common.DoubleWithRelativeTimeValue
-MeasurandWithRelativeTimeValue = iec103.common.MeasurandWithRelativeTimeValue
-TextNumberValue = iec103.common.TextNumberValue
-ReplyValue = iec103.common.ReplyValue
-ArrayValue = iec103.common.ArrayValue
-IndexValue = iec103.common.IndexValue
-Value = iec103.common.Value
+AsduAddress: typing.TypeAlias = iec103.common.AsduAddress
+OtherCause: typing.TypeAlias = iec103.common.OtherCause
+Description: typing.TypeAlias = iec103.common.Description
+IoAddress: typing.TypeAlias = iec103.common.IoAddress
+Identification: typing.TypeAlias = iec103.common.Identification
+TimeSize: typing.TypeAlias = iec103.common.TimeSize
+Time: typing.TypeAlias = iec103.common.Time
+
+ValueType: typing.TypeAlias = iec103.common.ValueType
+NoneValue: typing.TypeAlias = iec103.common.NoneValue
+TextValue: typing.TypeAlias = iec103.common.TextValue
+BitstringValue: typing.TypeAlias = iec103.common.BitstringValue
+UIntValue: typing.TypeAlias = iec103.common.UIntValue
+IntValue: typing.TypeAlias = iec103.common.IntValue
+UFixedValue: typing.TypeAlias = iec103.common.UFixedValue
+FixedValue: typing.TypeAlias = iec103.common.FixedValue
+Real32Value: typing.TypeAlias = iec103.common.Real32Value
+Real64Value: typing.TypeAlias = iec103.common.Real64Value
+DoubleValue: typing.TypeAlias = iec103.common.DoubleValue
+SingleValue: typing.TypeAlias = iec103.common.SingleValue
+ExtendedDoubleValue: typing.TypeAlias = iec103.common.ExtendedDoubleValue
+MeasurandValue: typing.TypeAlias = iec103.common.MeasurandValue
+TimeValue: typing.TypeAlias = iec103.common.TimeValue
+IdentificationValue: typing.TypeAlias = iec103.common.IdentificationValue
+RelativeTimeValue: typing.TypeAlias = iec103.common.RelativeTimeValue
+IoAddressValue: typing.TypeAlias = iec103.common.IoAddressValue
+DoubleWithTimeValue: typing.TypeAlias = iec103.common.DoubleWithTimeValue
+DoubleWithRelativeTimeValue: typing.TypeAlias = iec103.common.DoubleWithRelativeTimeValue  # NOQA
+MeasurandWithRelativeTimeValue: typing.TypeAlias = iec103.common.MeasurandWithRelativeTimeValue  # NOQA
+TextNumberValue: typing.TypeAlias = iec103.common.TextNumberValue
+ReplyValue: typing.TypeAlias = iec103.common.ReplyValue
+ArrayValue: typing.TypeAlias = iec103.common.ArrayValue
+IndexValue: typing.TypeAlias = iec103.common.IndexValue
+Value: typing.TypeAlias = iec103.common.Value
 
 
 class DataCause(enum.Enum):
     SPONTANEOUS = iec103.common.Cause.SPONTANEOUS.value
     CYCLIC = iec103.common.Cause.CYCLIC.value
     TEST_MODE = iec103.common.Cause.TEST_MODE.value
     GENERAL_INTERROGATION = iec103.common.Cause.GENERAL_INTERROGATION.value
@@ -77,31 +76,31 @@
     M2_U_L3E = (iec103.common.AsduType.MEASURANDS_2.value, 5)
     M2_P = (iec103.common.AsduType.MEASURANDS_2.value, 6)
     M2_Q = (iec103.common.AsduType.MEASURANDS_2.value, 7)
     M2_F = (iec103.common.AsduType.MEASURANDS_2.value, 8)
 
 
 class MeasurandValues(typing.NamedTuple):
-    values: typing.Dict[MeasurandType, MeasurandValue]
+    values: dict[MeasurandType, MeasurandValue]
 
 
 class Data(typing.NamedTuple):
     asdu_address: AsduAddress
     io_address: IoAddress
-    cause: typing.Union[DataCause, OtherCause]
-    value: typing.Union[DoubleWithTimeValue,
-                        DoubleWithRelativeTimeValue,
-                        MeasurandValues,
-                        MeasurandWithRelativeTimeValue]
+    cause: DataCause | OtherCause
+    value: (DoubleWithTimeValue |
+            DoubleWithRelativeTimeValue |
+            MeasurandValues |
+            MeasurandWithRelativeTimeValue)
 
 
 class GenericData(typing.NamedTuple):
     asdu_address: AsduAddress
     io_address: IoAddress
-    cause: typing.Union[GenericDataCause, OtherCause]
+    cause: GenericDataCause | OtherCause
     identification: Identification
     description: Description
     value: ArrayValue
 
 
 time_from_datetime = iec103.common.time_from_datetime
 time_to_datetime = iec103.common.time_to_datetime
```

## hat/drivers/iec103/master.py

```diff
@@ -12,24 +12,25 @@
 from hat.drivers.iec60870 import link
 from hat.drivers.iec60870.msgs import iec103
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 
 
-DataCb = aio.AsyncCallable[[common.Data], None]
-GenericDataCb = aio.AsyncCallable[[common.GenericData], None]
+DataCb: typing.TypeAlias = aio.AsyncCallable[[common.Data], None]
+
+GenericDataCb: typing.TypeAlias = aio.AsyncCallable[[common.GenericData], None]
 
 
 class MasterConnection(aio.Resource):
 
     def __init__(self,
                  conn: link.Connection,
-                 data_cb: typing.Optional[DataCb] = None,
-                 generic_data_cb: typing.Optional[GenericDataCb] = None):
+                 data_cb: DataCb | None = None,
+                 generic_data_cb: GenericDataCb | None = None):
         self._conn = conn
         self._data_cb = data_cb
         self._generic_data_cb = generic_data_cb
 
         self._encoder = iec103.encoder.Encoder()
 
         self._interrogate_lock = asyncio.Lock()
@@ -69,15 +70,15 @@
         self.async_group.spawn(self._receive_loop)
 
     @property
     def async_group(self):
         return self._conn.async_group
 
     async def time_sync(self,
-                        time: typing.Optional[common.Time] = None,
+                        time: common.Time | None = None,
                         asdu_address: common.AsduAddress = 0xFF):
         if not self.is_open:
             raise ConnectionError()
 
         time = time or common.time_from_datetime(datetime.datetime.now())
         io_address = common.IoAddress(
             _FunctionType.GLOBAL_FUNCTION_TYPE.value,
```

## hat/drivers/iec104/__init__.py

```diff
@@ -1,11 +1,10 @@
 """IEC 60870-5-104 communication protocol"""
 
-from hat.drivers.iec104.common import (Bytes,
-                                       TimeSize,
+from hat.drivers.iec104.common import (TimeSize,
                                        Time,
                                        OriginatorAddress,
                                        AsduAddress,
                                        IoAddress,
                                        IndicationQuality,
                                        MeasurementQuality,
                                        CounterQuality,
@@ -94,16 +93,15 @@
                                        Function)
 from hat.drivers.iec104.connection import (ConnectionCb,
                                            connect,
                                            listen,
                                            Server)
 
 
-__all__ = ['Bytes',
-           'TimeSize',
+__all__ = ['TimeSize',
            'Time',
            'OriginatorAddress',
            'AsduAddress',
            'IoAddress',
            'IndicationQuality',
            'MeasurementQuality',
            'CounterQuality',
```

## hat/drivers/iec104/common.py

```diff
@@ -6,155 +6,154 @@
 from hat import util
 
 from hat.drivers import iec101
 from hat.drivers import tcp
 from hat.drivers.iec60870 import apci
 
 
-Bytes = iec101.Bytes
-TimeSize = iec101.TimeSize
-Time = iec101.Time
+TimeSize: typing.TypeAlias = iec101.TimeSize
+Time: typing.TypeAlias = iec101.Time
 
-OriginatorAddress = iec101.OriginatorAddress
+OriginatorAddress: typing.TypeAlias = iec101.OriginatorAddress
 """Originator address in range [0, 255] - 0 if not available"""
-AsduAddress = iec101.AsduAddress
+AsduAddress: typing.TypeAlias = iec101.AsduAddress
 """ASDU address in range [0, 65535]"""
-IoAddress = iec101.IoAddress
+IoAddress: typing.TypeAlias = iec101.IoAddress
 """IO address in range [0, 16777215]"""
 
-IndicationQuality = iec101.IndicationQuality
-MeasurementQuality = iec101.MeasurementQuality
-CounterQuality = iec101.CounterQuality
-ProtectionQuality = iec101.ProtectionQuality
-Quality = iec101.Quality
-
-FreezeCode = iec101.FreezeCode
-
-SingleValue = iec101.SingleValue
-DoubleValue = iec101.DoubleValue
-RegulatingValue = iec101.RegulatingValue
-StepPositionValue = iec101.StepPositionValue
-BitstringValue = iec101.BitstringValue
-NormalizedValue = iec101.NormalizedValue
-ScaledValue = iec101.ScaledValue
-FloatingValue = iec101.FloatingValue
-BinaryCounterValue = iec101.BinaryCounterValue
-ProtectionValue = iec101.ProtectionValue
-ProtectionStartValue = iec101.ProtectionStartValue
-ProtectionCommandValue = iec101.ProtectionCommandValue
-StatusValue = iec101.StatusValue
+IndicationQuality: typing.TypeAlias = iec101.IndicationQuality
+MeasurementQuality: typing.TypeAlias = iec101.MeasurementQuality
+CounterQuality: typing.TypeAlias = iec101.CounterQuality
+ProtectionQuality: typing.TypeAlias = iec101.ProtectionQuality
+Quality: typing.TypeAlias = iec101.Quality
+
+FreezeCode: typing.TypeAlias = iec101.FreezeCode
+
+SingleValue: typing.TypeAlias = iec101.SingleValue
+DoubleValue: typing.TypeAlias = iec101.DoubleValue
+RegulatingValue: typing.TypeAlias = iec101.RegulatingValue
+StepPositionValue: typing.TypeAlias = iec101.StepPositionValue
+BitstringValue: typing.TypeAlias = iec101.BitstringValue
+NormalizedValue: typing.TypeAlias = iec101.NormalizedValue
+ScaledValue: typing.TypeAlias = iec101.ScaledValue
+FloatingValue: typing.TypeAlias = iec101.FloatingValue
+BinaryCounterValue: typing.TypeAlias = iec101.BinaryCounterValue
+ProtectionValue: typing.TypeAlias = iec101.ProtectionValue
+ProtectionStartValue: typing.TypeAlias = iec101.ProtectionStartValue
+ProtectionCommandValue: typing.TypeAlias = iec101.ProtectionCommandValue
+StatusValue: typing.TypeAlias = iec101.StatusValue
 
-OtherCause = int
+OtherCause: typing.TypeAlias = int
 """Other cause in range [0, 63]"""
 
-DataResCause = iec101.DataResCause
-DataCause = iec101.DataCause
+DataResCause: typing.TypeAlias = iec101.DataResCause
+DataCause: typing.TypeAlias = iec101.DataCause
 
-CommandReqCause = iec101.CommandReqCause
-CommandResCause = iec101.CommandResCause
-CommandCause = iec101.CommandCause
-
-InitializationResCause = iec101.InitializationResCause
-InitializationCause = iec101.InitializationCause
-
-ReadReqCause = iec101.ReadReqCause
-ReadResCause = iec101.ReadResCause
-ReadCause = iec101.ReadCause
-
-ClockSyncReqCause = iec101.ClockSyncReqCause
-ClockSyncResCause = iec101.ClockSyncResCause
-ClockSyncCause = iec101.ClockSyncCause
-
-ActivationReqCause = iec101.ActivationReqCause
-ActivationResCause = iec101.ActivationResCause
-ActivationCause = iec101.ActivationCause
-
-DelayReqCause = iec101.DelayReqCause
-DelayResCause = iec101.DelayResCause
-DelayCause = iec101.DelayCause
-
-ParameterReqCause = iec101.ParameterReqCause
-ParameterResCause = iec101.ParameterResCause
-ParameterCause = iec101.ParameterCause
-
-ParameterActivationReqCause = iec101.ParameterActivationReqCause
-ParameterActivationResCause = iec101.ParameterActivationResCause
-ParameterActivationCause = iec101.ParameterActivationCause
-
-SingleData = iec101.SingleData
-DoubleData = iec101.DoubleData
-StepPositionData = iec101.StepPositionData
-BitstringData = iec101.BitstringData
-NormalizedData = iec101.NormalizedData
-ScaledData = iec101.ScaledData
-FloatingData = iec101.FloatingData
-BinaryCounterData = iec101.BinaryCounterData
-ProtectionData = iec101.ProtectionData
-ProtectionStartData = iec101.ProtectionStartData
-ProtectionCommandData = iec101.ProtectionCommandData
-StatusData = iec101.StatusData
-Data = iec101.Data
-
-SingleCommand = iec101.SingleCommand
-DoubleCommand = iec101.DoubleCommand
-RegulatingCommand = iec101.RegulatingCommand
-NormalizedCommand = iec101.NormalizedCommand
-ScaledCommand = iec101.ScaledCommand
-FloatingCommand = iec101.FloatingCommand
-BitstringCommand = iec101.BitstringCommand
-Command = iec101.Command
-
-NormalizedParameter = iec101.NormalizedParameter
-ScaledParameter = iec101.ScaledParameter
-FloatingParameter = iec101.FloatingParameter
-Parameter = iec101.Parameter
-
-DataMsg = iec101.DataMsg
-InitializationMsg = iec101.InitializationMsg
-InterrogationMsg = iec101.InterrogationMsg
-CounterInterrogationMsg = iec101.CounterInterrogationMsg
-ReadMsg = iec101.ReadMsg
-ClockSyncMsg = iec101.ClockSyncMsg
-ResetMsg = iec101.ResetMsg
-ParameterMsg = iec101.ParameterMsg
-ParameterActivationMsg = iec101.ParameterActivationMsg
+CommandReqCause: typing.TypeAlias = iec101.CommandReqCause
+CommandResCause: typing.TypeAlias = iec101.CommandResCause
+CommandCause: typing.TypeAlias = iec101.CommandCause
+
+InitializationResCause: typing.TypeAlias = iec101.InitializationResCause
+InitializationCause: typing.TypeAlias = iec101.InitializationCause
+
+ReadReqCause: typing.TypeAlias = iec101.ReadReqCause
+ReadResCause: typing.TypeAlias = iec101.ReadResCause
+ReadCause: typing.TypeAlias = iec101.ReadCause
+
+ClockSyncReqCause: typing.TypeAlias = iec101.ClockSyncReqCause
+ClockSyncResCause: typing.TypeAlias = iec101.ClockSyncResCause
+ClockSyncCause: typing.TypeAlias = iec101.ClockSyncCause
+
+ActivationReqCause: typing.TypeAlias = iec101.ActivationReqCause
+ActivationResCause: typing.TypeAlias = iec101.ActivationResCause
+ActivationCause: typing.TypeAlias = iec101.ActivationCause
+
+DelayReqCause: typing.TypeAlias = iec101.DelayReqCause
+DelayResCause: typing.TypeAlias = iec101.DelayResCause
+DelayCause: typing.TypeAlias = iec101.DelayCause
+
+ParameterReqCause: typing.TypeAlias = iec101.ParameterReqCause
+ParameterResCause: typing.TypeAlias = iec101.ParameterResCause
+ParameterCause: typing.TypeAlias = iec101.ParameterCause
+
+ParameterActivationReqCause: typing.TypeAlias = iec101.ParameterActivationReqCause  # NOQA
+ParameterActivationResCause: typing.TypeAlias = iec101.ParameterActivationResCause  # NOQA
+ParameterActivationCause: typing.TypeAlias = iec101.ParameterActivationCause
+
+SingleData: typing.TypeAlias = iec101.SingleData
+DoubleData: typing.TypeAlias = iec101.DoubleData
+StepPositionData: typing.TypeAlias = iec101.StepPositionData
+BitstringData: typing.TypeAlias = iec101.BitstringData
+NormalizedData: typing.TypeAlias = iec101.NormalizedData
+ScaledData: typing.TypeAlias = iec101.ScaledData
+FloatingData: typing.TypeAlias = iec101.FloatingData
+BinaryCounterData: typing.TypeAlias = iec101.BinaryCounterData
+ProtectionData: typing.TypeAlias = iec101.ProtectionData
+ProtectionStartData: typing.TypeAlias = iec101.ProtectionStartData
+ProtectionCommandData: typing.TypeAlias = iec101.ProtectionCommandData
+StatusData: typing.TypeAlias = iec101.StatusData
+Data: typing.TypeAlias = iec101.Data
+
+SingleCommand: typing.TypeAlias = iec101.SingleCommand
+DoubleCommand: typing.TypeAlias = iec101.DoubleCommand
+RegulatingCommand: typing.TypeAlias = iec101.RegulatingCommand
+NormalizedCommand: typing.TypeAlias = iec101.NormalizedCommand
+ScaledCommand: typing.TypeAlias = iec101.ScaledCommand
+FloatingCommand: typing.TypeAlias = iec101.FloatingCommand
+BitstringCommand: typing.TypeAlias = iec101.BitstringCommand
+Command: typing.TypeAlias = iec101.Command
+
+NormalizedParameter: typing.TypeAlias = iec101.NormalizedParameter
+ScaledParameter: typing.TypeAlias = iec101.ScaledParameter
+FloatingParameter: typing.TypeAlias = iec101.FloatingParameter
+Parameter: typing.TypeAlias = iec101.Parameter
+
+DataMsg: typing.TypeAlias = iec101.DataMsg
+InitializationMsg: typing.TypeAlias = iec101.InitializationMsg
+InterrogationMsg: typing.TypeAlias = iec101.InterrogationMsg
+CounterInterrogationMsg: typing.TypeAlias = iec101.CounterInterrogationMsg
+ReadMsg: typing.TypeAlias = iec101.ReadMsg
+ClockSyncMsg: typing.TypeAlias = iec101.ClockSyncMsg
+ResetMsg: typing.TypeAlias = iec101.ResetMsg
+ParameterMsg: typing.TypeAlias = iec101.ParameterMsg
+ParameterActivationMsg: typing.TypeAlias = iec101.ParameterActivationMsg
 
 
 class CommandMsg(typing.NamedTuple):
     is_test: bool
     originator_address: OriginatorAddress
     asdu_address: AsduAddress
     io_address: IoAddress
     command: Command
     is_negative_confirm: bool
-    time: typing.Optional[Time]
+    time: Time | None
     cause: CommandCause
 
 
 class TestMsg(typing.NamedTuple):
     is_test: bool
     originator_address: OriginatorAddress
     asdu_address: AsduAddress
     counter: int
     """counter in range [0, 65535]"""
     time: Time
     cause: ActivationCause
 
 
-Msg = typing.Union[DataMsg,
-                   CommandMsg,
-                   InitializationMsg,
-                   InterrogationMsg,
-                   CounterInterrogationMsg,
-                   ReadMsg,
-                   ClockSyncMsg,
-                   TestMsg,
-                   ResetMsg,
-                   ParameterMsg,
-                   ParameterActivationMsg]
+Msg: typing.TypeAlias = (DataMsg |
+                         CommandMsg |
+                         InitializationMsg |
+                         InterrogationMsg |
+                         CounterInterrogationMsg |
+                         ReadMsg |
+                         ClockSyncMsg |
+                         TestMsg |
+                         ResetMsg |
+                         ParameterMsg |
+                         ParameterActivationMsg)
 
 
 time_from_datetime = iec101.time_from_datetime
 time_to_datetime = iec101.time_to_datetime
 
 
 class Connection(aio.Resource):
@@ -178,32 +177,28 @@
 
     def register_enabled_cb(self,
                             cb: typing.Callable[[bool], None]
                             ) -> util.RegisterCallbackHandle:
         return self.conn.register_enabled_cb(cb)
 
     @abc.abstractmethod
-    def send(self, msgs: typing.List[Msg]):
-        pass
-
-    @abc.abstractmethod
-    async def send_wait_ack(self, msgs: typing.List[Msg]):
+    async def send(self, msgs: list[Msg], wait_ack: bool):
         pass
 
     @abc.abstractmethod
     async def drain(self, wait_ack: bool = False):
         pass
 
     @abc.abstractmethod
-    async def receive(self) -> typing.List[Msg]:
+    async def receive(self) -> list[Msg]:
         pass
 
 
 class Function(enum.Enum):
-    DATA = 'data',
+    DATA = 'data'
     COMMAND = 'command'
     INITIALIZATION = 'initialization'
     INTERROGATION = 'interrogation'
     COUNTER_INTERROGATION = 'counter_interrogation'
     READ = 'read'
     CLOCK_SYNC = 'clock_sync'
     TEST = 'test'
```

## hat/drivers/iec104/encoder.py

```diff
@@ -1,28 +1,30 @@
 import contextlib
 import enum
 import typing
 
+from hat import util
+
 from hat.drivers.iec104 import common
 from hat.drivers.iec60870.msgs import iec104
 
 
 class Encoder:
 
     def __init__(self):
         self._encoder = iec104.encoder.Encoder()
 
     def encode(self,
-               msgs: typing.List[common.Msg]
-               ) -> typing.Iterable[common.Bytes]:
+               msgs: list[common.Msg]
+               ) -> typing.Iterable[util.Bytes]:
         for asdu in _encode_msgs(msgs):
             yield self._encoder.encode_asdu(asdu)
 
     def decode(self,
-               data: common.Bytes
+               data: util.Bytes
                ) -> typing.Iterable[common.Msg]:
         asdu, _ = self._encoder.decode_asdu(data)
         yield from _decode_asdu(asdu)
 
 
 def _encode_msgs(msgs):
     # TODO: group messages and io elements
```

## hat/drivers/iec104/connection/__init__.py

```diff
@@ -1,39 +1,39 @@
-import ssl
 import typing
 
 from hat import aio
+from hat import util
 
 from hat.drivers import tcp
 from hat.drivers.iec104 import common
 from hat.drivers.iec104.connection import regular
 from hat.drivers.iec104.connection import secure
 from hat.drivers.iec60870 import apci
 
 
-ConnectionCb = aio.AsyncCallable[[common.Connection], None]
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[[common.Connection], None]
 
 
 async def connect(addr: tcp.Address,
                   response_timeout: float = 15,
                   supervisory_timeout: float = 10,
                   test_timeout: float = 20,
                   send_window_size: int = 12,
                   receive_window_size: int = 8,
-                  ssl_ctx: typing.Optional[ssl.SSLContext] = None,
-                  update_key: typing.Optional[common.Bytes] = None,
-                  critical_functions: typing.Set[common.Function] = secure.default_critical_functions  # NOQA
+                  update_key: util.Bytes | None = None,
+                  critical_functions: set[common.Function] = secure.default_critical_functions,  # NOQA
+                  **kwargs
                   ) -> common.Connection:
     apci_conn = await apci.connect(addr=addr,
                                    response_timeout=response_timeout,
                                    supervisory_timeout=supervisory_timeout,
                                    test_timeout=test_timeout,
                                    send_window_size=send_window_size,
                                    receive_window_size=receive_window_size,
-                                   ssl_ctx=ssl_ctx)
+                                   **kwargs)
 
     if update_key is not None:
         return secure.SecureConnection(apci_conn, True, update_key,
                                        critical_functions)
 
     return regular.RegularConnection(apci_conn)
 
@@ -41,30 +41,30 @@
 async def listen(connection_cb: ConnectionCb,
                  addr: tcp.Address = tcp.Address('0.0.0.0', 2404),
                  response_timeout: float = 15,
                  supervisory_timeout: float = 10,
                  test_timeout: float = 20,
                  send_window_size: int = 12,
                  receive_window_size: int = 8,
-                 ssl_ctx: typing.Optional[ssl.SSLContext] = None,
-                 update_key: typing.Optional[common.Bytes] = None,
-                 critical_functions: typing.Set[common.Function] = secure.default_critical_functions  # NOQA
+                 update_key: util.Bytes | None = None,
+                 critical_functions: set[common.Function] = secure.default_critical_functions,  # NOQA
+                 **kwargs
                  ) -> 'Server':
     server = Server()
     server._connection_cb = connection_cb
     server._update_key = update_key
     server._critical_functions = critical_functions
     server._srv = await apci.listen(connection_cb=server._on_connection,
                                     addr=addr,
                                     response_timeout=response_timeout,
                                     supervisory_timeout=supervisory_timeout,
                                     test_timeout=test_timeout,
                                     send_window_size=send_window_size,
                                     receive_window_size=receive_window_size,
-                                    ssl_ctx=ssl_ctx)
+                                    **kwargs)
     return server
 
 
 class Server(aio.Resource):
 
     @property
     def async_group(self):
```

## hat/drivers/iec104/connection/regular.py

```diff
@@ -12,28 +12,22 @@
         self._conn = conn
         self._encoder = encoder.Encoder()
 
     @property
     def conn(self) -> apci.Connection:
         return self._conn
 
-    def send(self, msgs: typing.List[common.Msg]):
-        for data in self._encoder.encode(msgs):
-            self._conn.send(data)
-
-    async def send_wait_ack(self, msgs: typing.List[common.Msg]):
+    async def send(self,
+                   msgs: typing.List[common.Msg],
+                   wait_ack: bool = False):
         data = collections.deque(self._encoder.encode(msgs))
-        if not data:
-            return
-
-        last = data.pop()
-        for i in data:
-            self._conn.send(i)
-
-        await self._conn.send_wait_ack(last)
+        while data:
+            head = data.popleft()
+            head_wait_ack = False if data else wait_ack
+            await self._conn.send(head, head_wait_ack)
 
     async def drain(self, wait_ack: bool = False):
         await self._conn.drain(wait_ack)
 
     async def receive(self) -> typing.List[common.Msg]:
         data = await self._conn.receive()
         return list(self._encoder.decode(data))
```

## hat/drivers/iec104/connection/secure.py

```diff
@@ -1,12 +1,15 @@
+# TODO WIP
+
 import asyncio
 import logging
 import typing
 
 from hat import aio
+from hat import util
 
 from hat.drivers.iec104 import common
 from hat.drivers.iec104 import encoder
 from hat.drivers.iec60870 import apci
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
@@ -20,39 +23,32 @@
 
 
 class SecureConnection(common.Connection):
 
     def __init__(self,
                  conn: apci.Connection,
                  is_master: bool,
-                 update_key: common.Bytes,
+                 update_key: util.Bytes,
                  critical_functions: typing.Set[common.Function] = default_critical_functions):  # NOQA
         self._conn = conn
         self._is_master = is_master
         self._encoder = encoder.Encoder()
         self._send_queue = aio.Queue()
         self._receive_queue = aio.Queue()
 
         self.async_group.spawn(self._send_loop)
         self.async_group.spawn(self._receive_loop)
 
     @property
     def conn(self) -> apci.Connection:
         return self._conn
 
-    def send(self, msgs: typing.List[common.Msg]):
-        try:
-            for msg in msgs:
-                entry = _SendQueueEntry(msg, None, False)
-                self._send_queue.put_nowait(entry)
-
-        except aio.QueueClosedError:
-            raise ConnectionError()
-
-    async def send_wait_ack(self, msgs: typing.List[common.Msg]):
+    async def send(self,
+                   msgs: typing.List[common.Msg],
+                   wait_ack: bool = False):
         try:
             for i, msg in enumerate(msgs):
                 entry = (_SendQueueEntry(msg, asyncio.Future(), True)
                          if i == len(msgs) - 1
                          else _SendQueueEntry(msg, None, False))
 
                 self._send_queue.put_nowait(entry)
```

## hat/drivers/iec60870/apci/__init__.py

```diff
@@ -1,18 +1,16 @@
 """IEC 60870-5 APCI layer"""
 
-from hat.drivers.iec60870.apci.common import (Bytes,
-                                              SequenceNumber)
+from hat.drivers.iec60870.apci.common import SequenceNumber
 from hat.drivers.iec60870.apci.connection import (ConnectionCb,
                                                   ConnectionDisabledError,
                                                   connect,
                                                   listen,
                                                   Connection)
 
 
-__all__ = ['Bytes',
-           'SequenceNumber',
+__all__ = ['SequenceNumber',
            'ConnectionCb',
            'ConnectionDisabledError',
            'connect',
            'listen',
            'Connection']
```

## hat/drivers/iec60870/apci/common.py

```diff
@@ -1,14 +1,14 @@
 import enum
 import typing
 
+from hat import util
 
-Bytes = typing.Union[bytes, bytearray, memoryview]
 
-SequenceNumber = int
+SequenceNumber: typing.TypeAlias = int
 """sequence number in range [0, 0x7FFF]"""
 
 
 class ApduFunction(enum.Enum):
     TESTFR_CON = 0x83
     TESTFR_ACT = 0x43
     STOPDT_CON = 0x23
@@ -16,19 +16,19 @@
     STARTDT_CON = 0x0B
     STARTDT_ACT = 0x07
 
 
 class APDUI(typing.NamedTuple):
     ssn: SequenceNumber
     rsn: SequenceNumber
-    data: Bytes
+    data: util.Bytes
 
 
 class APDUS(typing.NamedTuple):
     rsn: SequenceNumber
 
 
 class APDUU(typing.NamedTuple):
     function: ApduFunction
 
 
-APDU = typing.Union[APDUI, APDUS, APDUU]
+APDU: typing.TypeAlias = APDUI | APDUS | APDUU
```

## hat/drivers/iec60870/apci/connection.py

```diff
@@ -1,119 +1,135 @@
 import asyncio
 import itertools
 import logging
-import ssl
 import typing
 
 from hat import aio
 from hat import util
+
+from hat.drivers import ssl
 from hat.drivers import tcp
 from hat.drivers.iec60870.apci import common
 from hat.drivers.iec60870.apci import encoder
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
 
 
-ConnectionCb = aio.AsyncCallable[['Connection'], None]
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[['Connection'], None]
 """Connection callback"""
 
 
 class ConnectionDisabledError(ConnectionError):
     pass
 
 
 async def connect(addr: tcp.Address,
                   response_timeout: float = 15,
                   supervisory_timeout: float = 10,
                   test_timeout: float = 20,
                   send_window_size: int = 12,
                   receive_window_size: int = 8,
-                  ssl_ctx: typing.Optional[ssl.SSLContext] = None
+                  *,
+                  send_queue_size: int = 1024,
+                  receive_queue_size: int = 1024,
+                  **kwargs
                   ) -> 'Connection':
     """Connect to remote device
 
+    Additional arguments are passed directly to `hat.drivers.tcp.connect`.
+
     Args:
         addr: remote server's address
         response_timeout: response timeout (t1) in seconds
         supervisory_timeout: supervisory timeout (t2) in seconds
         test_timeout: test timeout (t3) in seconds
         send_window_size: send window size (k)
         receive_window_size: receive window size (w)
-        ssl_ctx: optional ssl context argument
+        send_queue_size: size of send queue
+        receive_queue_size: size of receive queue
 
     """
-    conn = await tcp.connect(addr, ssl=ssl_ctx)
+    conn = await tcp.connect(addr, **kwargs)
 
     try:
-        _write_apdu(conn, common.APDUU(common.ApduFunction.STARTDT_ACT))
+        apdu = common.APDUU(common.ApduFunction.STARTDT_ACT)
+        await _write_apdu(conn, apdu)
         await aio.wait_for(_wait_startdt_con(conn), response_timeout)
 
     except Exception:
         await aio.uncancellable(conn.async_close())
         raise
 
     return Connection(conn=conn,
                       always_enabled=True,
                       response_timeout=response_timeout,
                       supervisory_timeout=supervisory_timeout,
                       test_timeout=test_timeout,
                       send_window_size=send_window_size,
-                      receive_window_size=receive_window_size)
+                      receive_window_size=receive_window_size,
+                      send_queue_size=send_queue_size,
+                      receive_queue_size=receive_queue_size)
 
 
 async def listen(connection_cb: ConnectionCb,
                  addr: tcp.Address = tcp.Address('0.0.0.0', 2404),
                  response_timeout: float = 15,
                  supervisory_timeout: float = 10,
                  test_timeout: float = 20,
                  send_window_size: int = 12,
                  receive_window_size: int = 8,
-                 ssl_ctx: typing.Optional[ssl.SSLContext] = None
+                 *,
+                 send_queue_size: int = 1024,
+                 receive_queue_size: int = 1024,
+                 bind_connections: bool = True,
+                 **kwargs
                  ) -> tcp.Server:
     """Create new IEC104 slave and listen for incoming connections
 
-    Closing server closes all incoming connections.
+    Additional arguments are passed directly to `hat.drivers.tcp.listen`.
 
     Args:
         connection_cb: new connection callback
         addr: listening socket address
         response_timeout: response timeout (t1) in seconds
         supervisory_timeout: supervisory timeout (t2) in seconds
         test_timeout: test timeout (t3) in seconds
         send_window_size: send window size (k)
         receive_window_size: receive window size (w)
-        ssl_ctx: optional ssl context argument
+        bind_connections: bind connections (see `hat.drivers.tcp.listen`)
 
     """
 
     async def on_connection(conn):
         try:
-            conn = Connection(conn=conn,
-                              always_enabled=False,
-                              response_timeout=response_timeout,
-                              supervisory_timeout=supervisory_timeout,
-                              test_timeout=test_timeout,
-                              send_window_size=send_window_size,
-                              receive_window_size=receive_window_size)
-
-            await aio.call(connection_cb, conn)
-
-            await conn.wait_closing()
+            try:
+                conn = Connection(conn=conn,
+                                  always_enabled=False,
+                                  response_timeout=response_timeout,
+                                  supervisory_timeout=supervisory_timeout,
+                                  test_timeout=test_timeout,
+                                  send_window_size=send_window_size,
+                                  receive_window_size=receive_window_size,
+                                  send_queue_size=send_queue_size,
+                                  receive_queue_size=receive_queue_size)
+
+                await aio.call(connection_cb, conn)
+
+            except BaseException:
+                await aio.uncancellable(conn.async_close())
+                raise
 
         except Exception as e:
-            mlog.error("connection callback error: %s", e, exc_info=e)
-
-        finally:
-            conn.close()
+            mlog.error("on connection error: %s", e, exc_info=e)
 
     return await tcp.listen(on_connection, addr,
-                            bind_connections=True,
-                            ssl=ssl_ctx)
+                            bind_connections=bind_connections,
+                            **kwargs)
 
 
 class Connection(aio.Resource):
     """Connection
 
     For creating new Connection instances see `connect` or `listen` coroutine.
 
@@ -122,34 +138,37 @@
     def __init__(self,
                  conn: tcp.Connection,
                  always_enabled: bool,
                  response_timeout: float,
                  supervisory_timeout: float,
                  test_timeout: float,
                  send_window_size: int,
-                 receive_window_size: int):
+                 receive_window_size: int,
+                 send_queue_size: int,
+                 receive_queue_size: int):
         self._conn = conn
         self._always_enabled = always_enabled
         self._is_enabled = always_enabled
         self._enabled_cbs = util.CallbackRegistry()
         self._response_timeout = response_timeout
         self._supervisory_timeout = supervisory_timeout
         self._test_timeout = test_timeout
         self._send_window_size = send_window_size
         self._receive_window_size = receive_window_size
-        self._receive_queue = aio.Queue()
-        self._send_queue = aio.Queue()
+        self._receive_queue = aio.Queue(receive_queue_size)
+        self._send_queue = aio.Queue(send_queue_size)
         self._test_event = asyncio.Event()
         self._ssn = 0
         self._rsn = 0
         self._ack = 0
         self._w = 0
         self._supervisory_handle = None
         self._waiting_ack_handles = {}
         self._waiting_ack_cv = asyncio.Condition()
+        self._loop = asyncio.get_running_loop()
 
         self.async_group.spawn(self._read_loop)
         self.async_group.spawn(self._write_loop)
         self.async_group.spawn(self._test_loop)
 
     @property
     def async_group(self) -> aio.Group:
@@ -158,70 +177,69 @@
 
     @property
     def info(self) -> tcp.ConnectionInfo:
         """Connection info"""
         return self._conn.info
 
     @property
+    def ssl_object(self) -> ssl.SSLObject | ssl.SSLSocket | None:
+        """SSL Object"""
+        return self._conn.ssl_object
+
+    @property
     def is_enabled(self) -> bool:
         """Is enabled"""
         return self._is_enabled
 
     def register_enabled_cb(self,
                             cb: typing.Callable[[bool], None]
                             ) -> util.RegisterCallbackHandle:
         """Register enable callback"""
         return self._enabled_cbs.register(cb)
 
-    def send(self, data: common.Bytes):
-        """Send data
-
-        Raises:
-            ConnectionError
-
-        """
-        entry = _SendQueueEntry(data, None, False)
-        try:
-            self._send_queue.put_nowait(entry)
-
-        except aio.QueueClosedError:
-            raise ConnectionError()
-
-    async def send_wait_ack(self, data: common.Bytes):
-        """Send data and wait for acknowledgement
+    async def send(self,
+                   data: util.Bytes,
+                   wait_ack: bool = False):
+        """Send data and optionally wait for acknowledgement
 
         Raises:
             ConnectionDisabledError
             ConnectionError
 
         """
-        entry = _SendQueueEntry(data, asyncio.Future(), True)
+        future = self._loop.create_future() if wait_ack else None
+        entry = _SendQueueEntry(data, future, wait_ack)
+
         try:
-            self._send_queue.put_nowait(entry)
-            await entry.future
+            await self._send_queue.put(entry)
+
+            if wait_ack:
+                await future
 
         except aio.QueueClosedError:
             raise ConnectionError()
 
     async def drain(self, wait_ack: bool = False):
-        """Drain
+        """Drain and optionally wait for acknowledgement
 
         Raises:
             ConnectionError
 
         """
-        entry = _SendQueueEntry(None, asyncio.Future(), wait_ack)
+        future = self._loop.create_future()
+        entry = _SendQueueEntry(None, future, wait_ack)
+
         try:
-            self._send_queue.put_nowait(entry)
-            await entry.future
+            await self._send_queue.put(entry)
+            await future
 
         except aio.QueueClosedError:
             raise ConnectionError()
 
-    async def receive(self) -> common.Bytes:
+    async def receive(self) -> util.Bytes:
         """Receive data
 
         Raises:
             ConnectionError
 
         """
         try:
@@ -231,19 +249,19 @@
             raise ConnectionError()
 
     def _on_response_timeout(self):
         mlog.warning("response timeout occured - closing connection")
         self.close()
 
     def _on_supervisory_timeout(self):
-        self._supervisory_handle = None
+        self.async_group.spawn(self._on_supervisory_timeout_async)
 
+    async def _on_supervisory_timeout_async(self):
         try:
-            _write_apdu(self._conn, common.APDUS(self._rsn))
-            self._w = 0
+            await self._write_apdus()
 
         except Exception as e:
             mlog.warning('supervisory timeout error: %s', e, exc_info=e)
 
     async def _read_loop(self):
         try:
             while True:
@@ -323,50 +341,48 @@
     async def _test_loop(self):
         # TODO: implement reset timeout on received frame (v2 5.2.)
         try:
             while True:
                 await asyncio.sleep(self._test_timeout)
 
                 self._test_event.clear()
-                _write_apdu(self._conn,
-                            common.APDUU(common.ApduFunction.TESTFR_ACT))
+                await _write_apdu(self._conn,
+                                  common.APDUU(common.ApduFunction.TESTFR_ACT))
 
                 await aio.wait_for(self._test_event.wait(),
                                    self._response_timeout)
 
         except Exception as e:
             mlog.warning('test loop error: %s', e, exc_info=e)
 
         finally:
             self.close()
 
     async def _process_apduu(self, apdu):
         if apdu.function == common.ApduFunction.STARTDT_ACT:
             self._is_enabled = True
-            _write_apdu(self._conn,
-                        common.APDUU(common.ApduFunction.STARTDT_CON))
+            await _write_apdu(self._conn,
+                              common.APDUU(common.ApduFunction.STARTDT_CON))
 
             mlog.debug("send data enabled")
             self._enabled_cbs.notify(True)
 
         elif apdu.function == common.ApduFunction.STOPDT_ACT:
             if not self._always_enabled:
-                _write_apdu(self._conn, common.APDUS(self._rsn))
-                self._w = 0
-                self._stop_supervisory_timeout()
+                await self._write_apdus()
                 self._is_enabled = False
-                _write_apdu(self._conn,
-                            common.APDUU(common.ApduFunction.STOPDT_CON))
+                await _write_apdu(self._conn,
+                                  common.APDUU(common.ApduFunction.STOPDT_CON))
 
                 mlog.debug("send data disabled")
                 self._enabled_cbs.notify(False)
 
         elif apdu.function == common.ApduFunction.TESTFR_ACT:
-            _write_apdu(self._conn,
-                        common.APDUU(common.ApduFunction.TESTFR_CON))
+            await _write_apdu(self._conn,
+                              common.APDUU(common.ApduFunction.TESTFR_CON))
 
         elif apdu.function == common.ApduFunction.TESTFR_CON:
             self._test_event.set()
 
     async def _process_apdus(self, apdu):
         await self._set_ack(apdu.rsn)
 
@@ -376,47 +392,50 @@
         if apdu.ssn != self._rsn:
             raise Exception('missing apdu sequence number')
 
         self._rsn = (self._rsn + 1) % 0x8000
         self._start_supervisory_timeout()
 
         if apdu.data:
-            self._receive_queue.put_nowait(apdu.data)
+            await self._receive_queue.put(apdu.data)
 
         self._w += 1
         if self._w >= self._receive_window_size:
-            _write_apdu(self._conn, common.APDUS(self._rsn))
-            self._w = 0
-            self._stop_supervisory_timeout()
+            await self._write_apdus()
 
     async def _write_apdui(self, data):
         if self._ssn in self._waiting_ack_handles:
             raise Exception("can not reuse already registered ssn")
 
         async with self._waiting_ack_cv:
             await self._waiting_ack_cv.wait_for(
                 lambda: (len(self._waiting_ack_handles) <
                          self._send_window_size))
 
         if not self._is_enabled:
             mlog.debug("send data not enabled - discarding message")
             return
 
-        _write_apdu(self._conn, common.APDUI(ssn=self._ssn,
-                                             rsn=self._rsn,
-                                             data=data))
+        await _write_apdu(self._conn, common.APDUI(ssn=self._ssn,
+                                                   rsn=self._rsn,
+                                                   data=data))
         self._w = 0
         self._stop_supervisory_timeout()
 
-        handle = asyncio.get_event_loop().call_later(self._response_timeout,
-                                                     self._on_response_timeout)
+        handle = self._loop.call_later(self._response_timeout,
+                                       self._on_response_timeout)
         self._waiting_ack_handles[self._ssn] = handle
         self._ssn = (self._ssn + 1) % 0x8000
         return handle
 
+    async def _write_apdus(self):
+        await _write_apdu(self._conn, common.APDUS(self._rsn))
+        self._w = 0
+        self._stop_supervisory_timeout()
+
     async def _wait_ack(self, handle, future):
         try:
             async with self._waiting_ack_cv:
                 await self._waiting_ack_cv.wait_for(handle.cancelled)
 
             if not future.done():
                 future.set_result(None)
@@ -441,28 +460,28 @@
         async with self._waiting_ack_cv:
             self._waiting_ack_cv.notify_all()
 
     def _start_supervisory_timeout(self):
         if self._supervisory_handle:
             return
 
-        self._supervisory_handle = asyncio.get_event_loop().call_later(
+        self._supervisory_handle = self._loop.call_later(
             self._supervisory_timeout, self._on_supervisory_timeout)
 
     def _stop_supervisory_timeout(self):
         if not self._supervisory_handle:
             return
 
         self._supervisory_handle.cancel()
         self._supervisory_handle = None
 
 
 class _SendQueueEntry(typing.NamedTuple):
-    data: typing.Optional[common.Bytes]
-    future: typing.Optional[asyncio.Future]
+    data: util.Bytes | None
+    future: asyncio.Future | None
     wait_ack: bool
 
 
 async def _read_apdu(conn):
     data = bytearray()
 
     while True:
@@ -470,17 +489,17 @@
         if size <= len(data):
             break
         data.extend(await conn.readexactly(size - len(data)))
 
     return encoder.decode(memoryview(data))
 
 
-def _write_apdu(conn, apdu):
+async def _write_apdu(conn, apdu):
     data = encoder.encode(apdu)
-    conn.write(data)
+    await conn.write(data)
 
 
 async def _wait_startdt_con(conn):
     while True:
         req = await _read_apdu(conn)
 
         if not isinstance(req, common.APDUU):
```

## hat/drivers/iec60870/apci/encoder.py

```diff
@@ -1,26 +1,28 @@
 import itertools
 
+from hat import util
+
 from hat.drivers.iec60870.apci import common
 
 
-def get_next_apdu_size(data: common.Bytes) -> int:
+def get_next_apdu_size(data: util.Bytes) -> int:
     if len(data) < 2:
         return 2
 
     if data[0] != 0x68:
         raise Exception('invalid start identifier')
 
     if data[1] < 4:
         raise Exception('invalid length')
 
     return data[1] + 2
 
 
-def decode(data: common.Bytes) -> common.APDU:
+def decode(data: util.Bytes) -> common.APDU:
     if data[0] != 0x68:
         raise Exception('invalid start identifier')
 
     length = data[1]
     if length < 4:
         raise Exception("invalid length")
 
@@ -37,15 +39,15 @@
     ssn = (control_fields[1] << 7) | (control_fields[0] >> 1)
     rsn = (control_fields[3] << 7) | (control_fields[2] >> 1)
     return common.APDUI(ssn=ssn,
                         rsn=rsn,
                         data=data)
 
 
-def encode(apdu: common.APDU) -> common.Bytes:
+def encode(apdu: common.APDU) -> util.Bytes:
     if isinstance(apdu, common.APDUI):
         if apdu.ssn > 0x7FFF:
             raise ValueError('invalid send sequence number')
         if apdu.rsn > 0x7FFF:
             raise ValueError('invalid receive sequence number')
         if len(apdu.data) > 249:
             raise ValueError('unsupported data size')
```

## hat/drivers/iec60870/link/__init__.py

```diff
@@ -1,22 +1,20 @@
 """IEC 60870-5 link layer"""
 
 from hat.drivers.iec60870.link import balanced
 from hat.drivers.iec60870.link import common
 from hat.drivers.iec60870.link import endpoint
 from hat.drivers.iec60870.link import unbalanced
-from hat.drivers.iec60870.link.common import (Bytes,
-                                              Address,
+from hat.drivers.iec60870.link.common import (Address,
                                               AddressSize)
 from hat.drivers.iec60870.link.connection import (ConnectionCb,
                                                   Connection)
 
 
 __all__ = ['balanced',
            'common',
            'unbalanced',
            'endpoint',
-           'Bytes',
            'Address',
            'AddressSize',
            'ConnectionCb',
            'Connection']
```

## hat/drivers/iec60870/link/common.py

```diff
@@ -1,14 +1,14 @@
 import enum
 import typing
 
+from hat import util
 
-Bytes = typing.Union[bytes, bytearray, memoryview]
 
-Address = typing.Optional[int]
+Address: typing.TypeAlias = int | None
 """addres is ``None`` or in range [0, 255] or in range [0, 65535]"""
 
 
 class Direction(enum.Enum):
     B_TO_A = 0
     A_TO_B = 1
 
@@ -38,32 +38,32 @@
     RES_NACK = 9
     RES_STATUS = 11
     NOT_FUNCTIONING = 14
     NOT_IMPLEMENTED = 15
 
 
 class ReqFrame(typing.NamedTuple):
-    direction: typing.Optional[Direction]
+    direction: Direction | None
     frame_count_bit: bool
     frame_count_valid: bool
     function: ReqFunction
     address: Address
-    data: Bytes
+    data: util.Bytes
 
 
 class ResFrame(typing.NamedTuple):
-    direction: typing.Optional[Direction]
+    direction: Direction | None
     access_demand: bool
     data_flow_control: bool
     function: ResFunction
     address: Address
-    data: Bytes
+    data: util.Bytes
 
 
-Frame = typing.Union[ReqFrame, ResFrame]
+Frame: typing.TypeAlias = ReqFrame | ResFrame
 
 
 def get_broadcast_address(address_size: AddressSize):
     if address_size == AddressSize.ONE:
         return 0xFF
 
     if address_size == AddressSize.TWO:
```

## hat/drivers/iec60870/link/connection.py

```diff
@@ -1,18 +1,19 @@
 import abc
+import typing
 
 from hat import aio
-from hat.drivers.iec60870.link import common
+from hat import util
 
 
-ConnectionCb = aio.AsyncCallable[['Connection'], None]
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[['Connection'], None]
 
 
 class Connection(aio.Resource):
 
     @abc.abstractmethod
-    async def send(self, data: common.Bytes):
+    async def send(self, data: util.Bytes):
         pass
 
     @abc.abstractmethod
-    async def receive(self) -> common.Bytes:
+    async def receive(self) -> util.Bytes:
         pass
```

## hat/drivers/iec60870/link/encoder.py

```diff
@@ -1,21 +1,23 @@
 import itertools
 
+from hat import util
+
 from hat.drivers.iec60870.link import common
 
 
 class Encoder:
 
     def __init__(self,
                  address_size: common.AddressSize,
                  direction_valid: bool):
         self._address_size = address_size
         self._direction_valid = direction_valid
 
-    def get_next_frame_size(self, data: common.Bytes) -> int:
+    def get_next_frame_size(self, data: util.Bytes) -> int:
         if not data or data[0] == 0xE5:
             return 1
 
         if data[0] == 0x10:
             return 4 + self._address_size.value
 
         if data[0] == 0x68:
@@ -28,15 +30,15 @@
             if data[3] != 0x68:
                 raise Exception('invalid repeated start identifier')
 
             return data[1] + 6
 
         raise Exception('invalid start identifier')
 
-    def decode(self, data: common.Bytes) -> common.Frame:
+    def decode(self, data: util.Bytes) -> common.Frame:
         if data[0] == 0xE5:
             return _short_ack
 
         elif data[0] == 0x10:
             data = data[1:4 + self._address_size.value]
 
         elif data[0] == 0x68:
@@ -87,15 +89,15 @@
                                     data_flow_control=data_flow_control,
                                     function=function,
                                     address=address,
                                     data=data)
 
         return frame
 
-    def encode(self, frame: common.Frame) -> common.Bytes:
+    def encode(self, frame: common.Frame) -> util.Bytes:
         if frame._replace(direction=None) == _short_ack:
             return b'\xE5'
 
         control_field = ((frame.direction.value << 7
                           if self._direction_valid else 0) |
                          frame.function.value)
```

## hat/drivers/iec60870/link/endpoint.py

```diff
@@ -1,10 +1,11 @@
 import logging
 
 from hat import aio
+
 from hat.drivers import serial
 from hat.drivers.iec60870.link import common
 from hat.drivers.iec60870.link import encoder
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
```

## hat/drivers/iec60870/link/balanced/connection.py

```diff
@@ -1,7 +1,9 @@
+from hat import util
+
 from hat.drivers import serial
 from hat.drivers.iec60870.link import common
 from hat.drivers.iec60870.link.connection import Connection
 
 
 async def connect(is_master: bool,
                   port: str,
@@ -23,12 +25,12 @@
 
 class _Connection(Connection):
 
     @property
     def async_group(self):
         return self._async_group
 
-    async def send(self, data: common.Bytes):
+    async def send(self, data: util.Bytes):
         pass
 
-    async def receive(self) -> common.Bytes:
+    async def receive(self) -> util.Bytes:
         pass
```

## hat/drivers/iec60870/link/unbalanced/master.py

```diff
@@ -1,16 +1,17 @@
 import asyncio
 import collections
 import contextlib
 import functools
 import logging
 import time
-import typing
 
 from hat import aio
+from hat import util
+
 from hat.drivers import serial
 from hat.drivers.iec60870.link import common
 from hat.drivers.iec60870.link import endpoint
 from hat.drivers.iec60870.link.connection import Connection
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
@@ -59,16 +60,16 @@
     def async_group(self):
         return self._endpoint.async_group
 
     async def connect(self,
                       addr: common.Address,
                       response_timeout: float = 15,
                       send_retry_count: int = 3,
-                      poll_class1_delay: typing.Optional[float] = 1,
-                      poll_class2_delay: typing.Optional[float] = None
+                      poll_class1_delay: float | None = 1,
+                      poll_class2_delay: float | None = None
                       ) -> Connection:
         if addr >= self._broadcast_address:
             raise ValueError('unsupported address')
 
         conn = _MasterConnection()
         conn._addr = addr
         conn._send_retry_count = send_retry_count
@@ -205,28 +206,28 @@
 
 class _MasterConnection(Connection):
 
     @property
     def async_group(self):
         return self._async_group
 
-    async def send(self, data: common.Bytes):
+    async def send(self, data: util.Bytes):
         if not data:
             return
 
         future = asyncio.Future()
         try:
             self._send_queue.put_nowait(
                 (future, common.ReqFunction.DATA, data))
             await future
 
         except aio.QueueClosedError:
             raise ConnectionError()
 
-    async def receive(self) -> common.Bytes:
+    async def receive(self) -> util.Bytes:
         try:
             return await self._receive_queue.get()
 
         except aio.QueueClosedError:
             raise ConnectionError()
 
     async def _poll_loop_class1(self, delay):
@@ -297,22 +298,23 @@
                     frame_count_valid=True,
                     function=function,
                     address=self._addr,
                     data=data)
 
                 retry_counter = 0
                 while True:
-                    retry_counter += 1
-                    if retry_counter > self._send_retry_count:
-                        raise Exception('send retry count exceeded')
-
                     with contextlib.suppress(asyncio.TimeoutError):
                         res = await send(req)
                         break
 
+                    if retry_counter >= self._send_retry_count:
+                        raise Exception('send retry count exceeded')
+
+                    retry_counter += 1
+
                 if res.access_demand:
                     self._access_demand_event.set()
                 data_flow_control = res.data_flow_control
 
                 # TODO
                 # if data_flow_control and data:
                 #     data_flow_queue.append((future, data))
```

## hat/drivers/iec60870/link/unbalanced/slave.py

```diff
@@ -1,26 +1,27 @@
 import asyncio
 import logging
 import time
 import typing
 
 from hat import aio
+from hat import util
+
 from hat.drivers import serial
 from hat.drivers.iec60870.link import common
 from hat.drivers.iec60870.link import endpoint
-from hat.drivers.iec60870.link.connection import (ConnectionCb,
-                                                  Connection)
+from hat.drivers.iec60870.link.connection import ConnectionCb, Connection
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 
 
 async def create_slave(port: str,
                        addrs: typing.Iterable[common.Address],
-                       connection_cb: typing.Optional[ConnectionCb] = None,
+                       connection_cb: ConnectionCb | None = None,
                        baudrate: int = 9600,
                        bytesize: serial.ByteSize = serial.ByteSize.EIGHTBITS,
                        parity: serial.Parity = serial.Parity.NONE,
                        stopbits: serial.StopBits = serial.StopBits.ONE,
                        xonxoff: bool = False,
                        rtscts: bool = False,
                        dsrdtr: bool = False,
@@ -141,27 +142,27 @@
         self.async_group.spawn(aio.call_on_cancel, self._on_close)
         self.async_group.spawn(self._keep_alive_loop, keep_alive_timeout)
 
     @property
     def async_group(self):
         return self._async_group
 
-    async def send(self, data: common.Bytes):
+    async def send(self, data: util.Bytes):
         if not data:
             return
 
         future = asyncio.Future()
         try:
             self._send_queue.put_nowait((future,  data))
             await future
 
         except aio.QueueClosedError:
             raise ConnectionError()
 
-    async def receive(self) -> common.Bytes:
+    async def receive(self) -> util.Bytes:
         try:
             return await self._receive_queue.get()
 
         except aio.QueueClosedError:
             raise ConnectionError()
 
     def _on_close(self):
```

## hat/drivers/iec60870/msgs/common.py

```diff
@@ -1,16 +1,13 @@
 import datetime
 import enum
 import time
 import typing
 
 
-Bytes = typing.Union[bytes, bytearray, memoryview]
-
-
 class CauseSize(enum.Enum):
     ONE = 1
     TWO = 2
 
 
 class AsduAddressSize(enum.Enum):
     ONE = 1
@@ -30,55 +27,56 @@
     SEVEN = 7
 
 
 class Time(typing.NamedTuple):
     size: TimeSize
     milliseconds: int
     """milliseconds in range [0, 59999]"""
-    invalid: typing.Optional[bool]
+    invalid: bool | None
     """available for size THREE, FOUR, SEVEN"""
-    minutes: typing.Optional[int]
+    minutes: int | None
     """available for size THREE, FOUR, SEVEN (minutes in range [0, 59])"""
-    summer_time: typing.Optional[bool]
+    summer_time: bool | None
     """available for size FOUR, SEVEN"""
-    hours: typing.Optional[int]
+    hours: int | None
     """available for size FOUR, SEVEN (hours in range [0, 23])"""
-    day_of_week: typing.Optional[int]
+    day_of_week: int | None
     """available for size SEVEN (day_of_week in range [1, 7])"""
-    day_of_month: typing.Optional[int]
+    day_of_month: int | None
     """available for size SEVEN (day_of_month in range [1, 31])"""
-    months: typing.Optional[int]
+    months: int | None
     """available for size SEVEN (months in range [1, 12])"""
-    years: typing.Optional[int]
+    years: int | None
     """available for size SEVEN (years in range [0, 99])"""
 
 
 class IO(typing.NamedTuple):
     address: int
-    elements: typing.List
-    time: typing.Optional[Time]
+    elements: list
+    time: Time | None
 
 
 class ASDU(typing.NamedTuple):
     type: int
     cause: int
     address: int
-    ios: typing.List[IO]
+    ios: list[IO]
 
 
 def time_from_datetime(dt: datetime.datetime,
                        invalid: bool = False
                        ) -> Time:
     """Create Time from datetime.datetime"""
     # TODO document edge cases (local time, os implementation, ...)
     #  rounding microseconds to the nearest millisecond
     dt_rounded = (
         dt.replace(microsecond=0) +
         datetime.timedelta(milliseconds=round(dt.microsecond / 1000)))
     local_time = time.localtime(dt_rounded.timestamp())
+
     return Time(
         size=TimeSize.SEVEN,
         milliseconds=(local_time.tm_sec * 1000 +
                       dt_rounded.microsecond // 1000),
         invalid=invalid,
         minutes=local_time.tm_min,
         summer_time=bool(local_time.tm_isdst),
@@ -92,17 +90,19 @@
 def time_to_datetime(t: Time
                      ) -> datetime.datetime:
     """Convert Time to datetime.datetime"""
     # TODO document edge cases (local time, os implementation, ...)
     # TODO maybe allow diferent time size (use now for time)
     if t.size != TimeSize.SEVEN:
         raise ValueError('unsupported time size')
+
     local_dt = datetime.datetime(
         year=2000 + t.years if t.years < 70 else 1900 + t.years,
         month=t.months,
         day=t.day_of_month,
         hour=t.hours,
         minute=t.minutes,
         second=int(t.milliseconds / 1000),
         microsecond=(t.milliseconds % 1000) * 1000,
         fold=not t.summer_time)
+
     return local_dt.astimezone(tz=datetime.timezone.utc)
```

## hat/drivers/iec60870/msgs/encoder.py

```diff
@@ -1,22 +1,25 @@
 import collections
 import typing
 
+from hat import util
+
 from hat.drivers.iec60870.msgs import common
 
 
-AsduType = int
-AsduTypeTimeSizes = typing.Dict[AsduType, common.TimeSize]
-DecodeIoElementCb = typing.Callable[[common.Bytes, AsduType],
-                                    typing.Tuple[typing.Any, common.Bytes]]
-EncodeIoElementCb = typing.Callable[[typing.Any, AsduType],
-                                    typing.Iterable[int]]
+AsduType: typing.TypeAlias = int
+AsduTypeTimeSizes: typing.TypeAlias = dict[AsduType, common.TimeSize]
+DecodeIoElementCb: typing.TypeAlias = typing.Callable[[util.Bytes, AsduType],
+                                                      tuple[typing.Any,
+                                                            util.Bytes]]
+EncodeIoElementCb: typing.TypeAlias = typing.Callable[[typing.Any, AsduType],
+                                                      typing.Iterable[int]]
 
 
-def decode_time(time_bytes: common.Bytes,
+def decode_time(time_bytes: util.Bytes,
                 time_size: common.TimeSize
                 ) -> common.Time:
     milliseconds = (time_bytes[1] << 8) | time_bytes[0]
     invalid = (bool(time_bytes[2] & 0x80) if time_size.value > 2 else None)
     minutes = (time_bytes[2] & 0x3F if time_size.value > 2 else None)
     summer_time = (bool(time_bytes[3] & 0x80) if time_size.value > 3 else None)
     hours = (time_bytes[3] & 0x1F if time_size.value > 3 else None)
@@ -88,16 +91,16 @@
         return self._asdu_address_size
 
     @property
     def io_address_size(self) -> common.IoAddressSize:
         return self._io_address_size
 
     def decode_asdu(self,
-                    asdu_bytes: common.Bytes
-                    ) -> typing.Tuple[common.ASDU, common.Bytes]:
+                    asdu_bytes: util.Bytes
+                    ) -> tuple[common.ASDU, util.Bytes]:
         asdu_type = asdu_bytes[0]
         io_number = asdu_bytes[1] & 0x7F
         is_sequence = bool(asdu_bytes[1] & 0x80)
         if self._inverted_sequence_bit:
             is_sequence = not is_sequence
         io_count = 1 if is_sequence else io_number
         ioe_element_count = io_number if is_sequence else 1
@@ -113,15 +116,15 @@
 
         asdu = common.ASDU(type=asdu_type,
                            cause=cause,
                            address=address,
                            ios=list(ios))
         return asdu, rest
 
-    def encode_asdu(self, asdu: common.ASDU) -> common.Bytes:
+    def encode_asdu(self, asdu: common.ASDU) -> util.Bytes:
         data = collections.deque()
         data.append(asdu.type)
 
         is_sequence = len(asdu.ios) == 1 and len(asdu.ios[0].elements) > 1
         if is_sequence:
             data.append(
                 (0x00 if self._inverted_sequence_bit else 0x80) |
```

## hat/drivers/iec60870/msgs/iec101/common.py

```diff
@@ -1,24 +1,27 @@
+from hat.drivers.iec60870.msgs.common import *  # NOQA
+
 import enum
 import typing
 
-from hat.drivers.iec60870.msgs.common import *  # NOQA
-from hat.drivers.iec60870.msgs.common import Bytes, Time
+from hat import util
+
+from hat.drivers.iec60870.msgs.common import Time
 
 
-OriginatorAddress = int
+OriginatorAddress: typing.TypeAlias = int
 """Originator address in range [0, 255] - 0 if not available"""
 
-AsduAddress = int
+AsduAddress: typing.TypeAlias = int
 """ASDU address in range [0, 255] or [0, 65535]"""
 
-IoAddress = int
+IoAddress: typing.TypeAlias = int
 """IO address in range [0, 255] or [0, 65535] or [0, 16777215]"""
 
-OtherCauseType = int
+OtherCauseType: typing.TypeAlias = int
 """Other cause type in range [0, 63]"""
 
 
 class AsduType(enum.Enum):
     M_SP_NA = 1
     M_SP_TA = 2
     M_DP_NA = 3
@@ -119,15 +122,15 @@
     UNKNOWN_TYPE = 44
     UNKNOWN_CAUSE = 45
     UNKNOWN_ASDU_ADDRESS = 46
     UNKNOWN_IO_ADDRESS = 47
 
 
 class Cause(typing.NamedTuple):
-    type: typing.Union[CauseType, OtherCauseType]
+    type: CauseType | OtherCauseType
     is_negative_confirm: bool
     is_test: bool
     originator_address: OriginatorAddress
 
 
 class QualityType(enum.Enum):
     INDICATION = 0
@@ -163,18 +166,18 @@
     invalid: bool
     not_topical: bool
     substituted: bool
     blocked: bool
     time_invalid: bool
 
 
-Quality = typing.Union[IndicationQuality,
-                       MeasurementQuality,
-                       CounterQuality,
-                       ProtectionQuality]
+Quality: typing.TypeAlias = (IndicationQuality |
+                             MeasurementQuality |
+                             CounterQuality |
+                             ProtectionQuality)
 
 
 class FreezeCode(enum.Enum):
     READ = 0
     FREEZE = 1
     FREEZE_AND_RESET = 2
     RESET = 3
@@ -206,15 +209,15 @@
 class StepPositionValue(typing.NamedTuple):
     value: int
     """value in range [-64, 63]"""
     transient: bool
 
 
 class BitstringValue(typing.NamedTuple):
-    value: Bytes
+    value: util.Bytes
     """bitstring encoded as 4 bytes"""
 
 
 class NormalizedValue(typing.NamedTuple):
     value: float
     """value in range [-1.0, 1.0)"""
 
@@ -251,17 +254,17 @@
     general: bool
     l1: bool
     l2: bool
     l3: bool
 
 
 class StatusValue(typing.NamedTuple):
-    value: typing.List[bool]
+    value: list[bool]
     """value length is 16"""
-    change: typing.List[bool]
+    change: list[bool]
     """change length is 16"""
 
 
 class IoElement_M_SP_NA(typing.NamedTuple):
     value: SingleValue
     quality: IndicationQuality
 
@@ -583,92 +586,92 @@
 
 
 class IoElement_F_SG_NA(typing.NamedTuple):
     file_name: int
     """file_name in range [0, 65535]"""
     section_name: int
     """section_name in range [0, 255]"""
-    segment: Bytes
+    segment: util.Bytes
 
 
 class IoElement_F_DR_TA(typing.NamedTuple):
     file_name: int
     """file_name in range [0, 65535]"""
     file_length: int
     """file_length in range [0, 16777215]"""
     more_follows: bool
     is_directory: bool
     transfer_active: bool
     creation_time: Time
 
 
-IoElement = typing.Union[IoElement_M_SP_NA,
-                         IoElement_M_SP_TA,
-                         IoElement_M_DP_NA,
-                         IoElement_M_DP_TA,
-                         IoElement_M_ST_NA,
-                         IoElement_M_ST_TA,
-                         IoElement_M_BO_NA,
-                         IoElement_M_BO_TA,
-                         IoElement_M_ME_NA,
-                         IoElement_M_ME_TA,
-                         IoElement_M_ME_NB,
-                         IoElement_M_ME_TB,
-                         IoElement_M_ME_NC,
-                         IoElement_M_ME_TC,
-                         IoElement_M_IT_NA,
-                         IoElement_M_IT_TA,
-                         IoElement_M_EP_TA,
-                         IoElement_M_EP_TB,
-                         IoElement_M_EP_TC,
-                         IoElement_M_PS_NA,
-                         IoElement_M_ME_ND,
-                         IoElement_M_SP_TB,
-                         IoElement_M_DP_TB,
-                         IoElement_M_ST_TB,
-                         IoElement_M_BO_TB,
-                         IoElement_M_ME_TD,
-                         IoElement_M_ME_TE,
-                         IoElement_M_ME_TF,
-                         IoElement_M_IT_TB,
-                         IoElement_M_EP_TD,
-                         IoElement_M_EP_TE,
-                         IoElement_M_EP_TF,
-                         IoElement_C_SC_NA,
-                         IoElement_C_DC_NA,
-                         IoElement_C_RC_NA,
-                         IoElement_C_SE_NA,
-                         IoElement_C_SE_NB,
-                         IoElement_C_SE_NC,
-                         IoElement_C_BO_NA,
-                         IoElement_M_EI_NA,
-                         IoElement_C_IC_NA,
-                         IoElement_C_CI_NA,
-                         IoElement_C_RD_NA,
-                         IoElement_C_CS_NA,
-                         IoElement_C_TS_NA,
-                         IoElement_C_RP_NA,
-                         IoElement_C_CD_NA,
-                         IoElement_P_ME_NA,
-                         IoElement_P_ME_NB,
-                         IoElement_P_ME_NC,
-                         IoElement_P_AC_NA,
-                         IoElement_F_FR_NA,
-                         IoElement_F_SR_NA,
-                         IoElement_F_SC_NA,
-                         IoElement_F_LS_NA,
-                         IoElement_F_AF_NA,
-                         IoElement_F_SG_NA,
-                         IoElement_F_DR_TA]
+IoElement: typing.TypeAlias = (IoElement_M_SP_NA |
+                               IoElement_M_SP_TA |
+                               IoElement_M_DP_NA |
+                               IoElement_M_DP_TA |
+                               IoElement_M_ST_NA |
+                               IoElement_M_ST_TA |
+                               IoElement_M_BO_NA |
+                               IoElement_M_BO_TA |
+                               IoElement_M_ME_NA |
+                               IoElement_M_ME_TA |
+                               IoElement_M_ME_NB |
+                               IoElement_M_ME_TB |
+                               IoElement_M_ME_NC |
+                               IoElement_M_ME_TC |
+                               IoElement_M_IT_NA |
+                               IoElement_M_IT_TA |
+                               IoElement_M_EP_TA |
+                               IoElement_M_EP_TB |
+                               IoElement_M_EP_TC |
+                               IoElement_M_PS_NA |
+                               IoElement_M_ME_ND |
+                               IoElement_M_SP_TB |
+                               IoElement_M_DP_TB |
+                               IoElement_M_ST_TB |
+                               IoElement_M_BO_TB |
+                               IoElement_M_ME_TD |
+                               IoElement_M_ME_TE |
+                               IoElement_M_ME_TF |
+                               IoElement_M_IT_TB |
+                               IoElement_M_EP_TD |
+                               IoElement_M_EP_TE |
+                               IoElement_M_EP_TF |
+                               IoElement_C_SC_NA |
+                               IoElement_C_DC_NA |
+                               IoElement_C_RC_NA |
+                               IoElement_C_SE_NA |
+                               IoElement_C_SE_NB |
+                               IoElement_C_SE_NC |
+                               IoElement_C_BO_NA |
+                               IoElement_M_EI_NA |
+                               IoElement_C_IC_NA |
+                               IoElement_C_CI_NA |
+                               IoElement_C_RD_NA |
+                               IoElement_C_CS_NA |
+                               IoElement_C_TS_NA |
+                               IoElement_C_RP_NA |
+                               IoElement_C_CD_NA |
+                               IoElement_P_ME_NA |
+                               IoElement_P_ME_NB |
+                               IoElement_P_ME_NC |
+                               IoElement_P_AC_NA |
+                               IoElement_F_FR_NA |
+                               IoElement_F_SR_NA |
+                               IoElement_F_SC_NA |
+                               IoElement_F_LS_NA |
+                               IoElement_F_AF_NA |
+                               IoElement_F_SG_NA |
+                               IoElement_F_DR_TA)
 
 
 class IO(typing.NamedTuple):
     address: IoAddress
-    elements: typing.List[IoElement]
-    time: typing.Optional[Time]
+    elements: list[IoElement]
+    time: Time | None
 
 
 class ASDU(typing.NamedTuple):
     type: AsduType
     cause: Cause
     address: AsduAddress
-    ios: typing.List[IO]
+    ios: list[IO]
```

## hat/drivers/iec60870/msgs/iec101/encoder.py

```diff
@@ -1,12 +1,13 @@
 import contextlib
 import struct
 import typing
 
 from hat import util
+
 from hat.drivers.iec60870.msgs import encoder
 from hat.drivers.iec60870.msgs.iec101 import common
 
 
 class Encoder:
 
     def __init__(self,
@@ -38,16 +39,16 @@
         return self._encoder.asdu_address_size
 
     @property
     def io_address_size(self) -> common.IoAddressSize:
         return self._encoder.io_address_size
 
     def decode_asdu(self,
-                    asdu_bytes: common.Bytes
-                    ) -> typing.Tuple[common.ASDU, common.Bytes]:
+                    asdu_bytes: util.Bytes
+                    ) -> tuple[common.ASDU, util.Bytes]:
         asdu, rest = self._encoder.decode_asdu(asdu_bytes)
 
         asdu_type = common.AsduType(asdu.type)
         cause = decode_cause(asdu.cause, self._cause_size)
         address = asdu.address
         ios = [common.IO(address=io.address,
                          elements=io.elements,
@@ -56,15 +57,15 @@
 
         asdu = common.ASDU(type=asdu_type,
                            cause=cause,
                            address=address,
                            ios=ios)
         return asdu, rest
 
-    def encode_asdu(self, asdu: common.ASDU) -> common.Bytes:
+    def encode_asdu(self, asdu: common.ASDU) -> util.Bytes:
         asdu_type = asdu.type.value
         cause = encode_cause(asdu.cause, self._cause_size)
         address = asdu.address
         ios = [encoder.common.IO(address=io.address,
                                  elements=io.elements,
                                  time=io.time)
                for io in asdu.ios]
@@ -136,31 +137,29 @@
     if cause_size == common.CauseSize.TWO:
         return result | (cause.originator_address << 8)
 
     raise ValueError('unsupported cause size')
 
 
 def decode_cause_type(value: int
-                      ) -> typing.Union[common.CauseType,
-                                        common.OtherCauseType]:
+                      ) -> common.CauseType | common.OtherCauseType:
     with contextlib.suppress(ValueError):
         return common.CauseType(value)
     return value
 
 
-def encode_cause_type(cause_type: typing.Union[common.CauseType,
-                                               common.OtherCauseType]
+def encode_cause_type(cause_type: common.CauseType | common.OtherCauseType
                       ) -> int:
     return (cause_type.value if isinstance(cause_type, common.CauseType)
             else cause_type)
 
 
-def decode_io_element(io_bytes: common.Bytes,
+def decode_io_element(io_bytes: util.Bytes,
                       asdu_type: int
-                      ) -> typing.Tuple[common.IoElement, common.Bytes]:
+                      ) -> tuple[common.IoElement, util.Bytes]:
     asdu_type = common.AsduType(asdu_type)
 
     if asdu_type == common.AsduType.M_SP_NA:
         value = common.SingleValue(io_bytes[0] & 1)
         quality, io_bytes = decode_quality(io_bytes,
                                            common.QualityType.INDICATION)
 
@@ -956,17 +955,17 @@
         yield from encoder.encode_time(element.creation_time,
                                        common.TimeSize.SEVEN)
 
     else:
         raise ValueError('unsupported IO element')
 
 
-def decode_quality(io_bytes: common.Bytes,
+def decode_quality(io_bytes: util.Bytes,
                    quality_type: common.QualityType
-                   ) -> typing.Tuple[common.Quality, common.Bytes]:
+                   ) -> tuple[common.Quality, util.Bytes]:
     if quality_type == common.QualityType.INDICATION:
         invalid = bool(io_bytes[0] & 0x80)
         not_topical = bool(io_bytes[0] & 0x40)
         substituted = bool(io_bytes[0] & 0x20)
         blocked = bool(io_bytes[0] & 0x10)
         quality = common.IndicationQuality(invalid=invalid,
                                            not_topical=not_topical,
@@ -1041,101 +1040,98 @@
                (0x10 if quality.blocked else 0) |
                (0x08 if quality.time_invalid else 0))
 
     else:
         raise ValueError('unsupported quality')
 
 
-def decode_step_position_value(io_bytes: common.Bytes
-                               ) -> typing.Tuple[common.StepPositionValue,
-                                                 common.Bytes]:
+def decode_step_position_value(io_bytes: util.Bytes
+                               ) -> tuple[common.StepPositionValue,
+                                          util.Bytes]:
     value = (((-1 << 7) if io_bytes[0] & 0x40 else 0) |
              (io_bytes[0] & 0x7F))
     transient = bool(io_bytes[0] & 0x80)
     step_position_value = common.StepPositionValue(value=value,
                                                    transient=transient)
     return step_position_value, io_bytes[1:]
 
 
 def encode_step_position_value(value: common.StepPositionValue
                                ) -> typing.Iterable[int]:
     yield ((0x80 if value.transient else 0) |
            (value.value & 0x7F))
 
 
-def decode_bitstring_value(io_bytes: common.Bytes
-                           ) -> typing.Tuple[common.BitstringValue,
-                                             common.Bytes]:
+def decode_bitstring_value(io_bytes: util.Bytes
+                           ) -> tuple[common.BitstringValue, util.Bytes]:
     value = io_bytes[:4]
     bitstring_value = common.BitstringValue(value)
     return bitstring_value, io_bytes[4:]
 
 
 def encode_bitstring_value(value: common.BitstringValue
                            ) -> typing.Iterable[int]:
     yield value.value[0]
     yield value.value[1]
     yield value.value[2]
     yield value.value[3]
 
 
-def decode_normalized_value(io_bytes: common.Bytes
-                            ) -> typing.Tuple[common.NormalizedValue,
-                                              common.Bytes]:
+def decode_normalized_value(io_bytes: util.Bytes
+                            ) -> tuple[common.NormalizedValue, util.Bytes]:
     value = struct.unpack('<h', io_bytes[:2])[0] / 0x7fff
     normalized_value = common.NormalizedValue(value)
     return normalized_value, io_bytes[2:]
 
 
 def encode_normalized_value(value: common.NormalizedValue
                             ) -> typing.Iterable[int]:
     yield from struct.pack('<h', round(value.value * 0x7fff))
 
 
-def decode_scaled_value(io_bytes: common.Bytes
-                        ) -> typing.Tuple[common.ScaledValue, common.Bytes]:
+def decode_scaled_value(io_bytes: util.Bytes
+                        ) -> tuple[common.ScaledValue, util.Bytes]:
     value = struct.unpack('<h', io_bytes[:2])[0]
     scaled_value = common.ScaledValue(value)
     return scaled_value, io_bytes[2:]
 
 
 def encode_scaled_value(value: common.ScaledValue
                         ) -> typing.Iterable[int]:
     yield from struct.pack('<h', value.value)
 
 
-def decode_floating_value(io_bytes: common.Bytes
-                          ) -> typing.Tuple[common.FloatingValue,
-                                            common.Bytes]:
+def decode_floating_value(io_bytes: util.Bytes
+                          ) -> tuple[common.FloatingValue, util.Bytes]:
     value = struct.unpack('<f', io_bytes[:4])[0]
     floating_value = common.FloatingValue(value)
     return floating_value, io_bytes[4:]
 
 
 def encode_floating_value(value: common.FloatingValue
                           ) -> typing.Iterable[int]:
     yield from struct.pack('<f', value.value)
 
 
-def decode_binary_counter_value(io_bytes: common.Bytes
-                                ) -> typing.Tuple[common.BinaryCounterValue,
-                                                  common.Bytes]:
+def decode_binary_counter_value(io_bytes: util.Bytes
+                                ) -> tuple[common.BinaryCounterValue,
+                                           util.Bytes]:
     value = struct.unpack('<i', io_bytes[:4])[0]
     binary_counter_value = common.BinaryCounterValue(value)
     return binary_counter_value, io_bytes[4:]
 
 
 def encode_binary_counter_value(value: common.BinaryCounterValue
                                 ) -> typing.Iterable[int]:
     yield from struct.pack('<i', value.value)
 
 
-def decode_protection_start_value(io_bytes: common.Bytes
-                                  ) -> typing.Tuple[common.ProtectionStartValue,  # NOQA
-                                                    common.Bytes]:
+def decode_protection_start_value(io_bytes: util.Bytes
+                                  ) -> tuple[common.ProtectionStartValue,
+                                             util.Bytes]:
     general = bool(io_bytes[0] & 0x01)
     l1 = bool(io_bytes[0] & 0x02)
     l2 = bool(io_bytes[0] & 0x04)
     l3 = bool(io_bytes[0] & 0x08)
     ie = bool(io_bytes[0] & 0x10)
     reverse = bool(io_bytes[0] & 0x20)
     protection_start_value = common.ProtectionStartValue(general=general,
@@ -1153,17 +1149,17 @@
            (0x02 if value.l1 else 0x00) |
            (0x04 if value.l2 else 0x00) |
            (0x08 if value.l3 else 0x00) |
            (0x10 if value.ie else 0x00) |
            (0x20 if value.reverse else 0x00))
 
 
-def decode_protection_command_value(io_bytes: common.Bytes
-                                    ) -> typing.Tuple[common.ProtectionCommandValue,  # NOQA
-                                                      common.Bytes]:
+def decode_protection_command_value(io_bytes: util.Bytes
+                                    ) -> tuple[common.ProtectionCommandValue,
+                                               util.Bytes]:
     general = bool(io_bytes[0] & 0x01)
     l1 = bool(io_bytes[0] & 0x02)
     l2 = bool(io_bytes[0] & 0x04)
     l3 = bool(io_bytes[0] & 0x08)
     protection_command_value = common.ProtectionCommandValue(general=general,
                                                              l1=l1,
                                                              l2=l2,
@@ -1175,17 +1171,16 @@
                                     ) -> typing.Iterable[int]:
     yield ((0x01 if value.general else 0x00) |
            (0x02 if value.l1 else 0x00) |
            (0x04 if value.l2 else 0x00) |
            (0x08 if value.l3 else 0x00))
 
 
-def decode_status_value(io_bytes: common.Bytes
-                        ) -> typing.Tuple[common.StatusValue,
-                                          common.Bytes]:
+def decode_status_value(io_bytes: util.Bytes
+                        ) -> tuple[common.StatusValue, util.Bytes]:
     value = [bool(io_bytes[i // 8] & (1 << (i % 8)))
              for i in range(16)]
     change = [bool(io_bytes[2 + i // 8] & (1 << (i % 8)))
               for i in range(16)]
     status_value = common.StatusValue(value=value,
                                       change=change)
     return status_value, io_bytes[4:]
```

## hat/drivers/iec60870/msgs/iec103/common.py

```diff
@@ -1,18 +1,21 @@
+from hat.drivers.iec60870.msgs.common import *  # NOQA
+
 import enum
 import typing
 
-from hat.drivers.iec60870.msgs.common import *  # NOQA
-from hat.drivers.iec60870.msgs.common import Bytes, Time
+from hat import util
+
+from hat.drivers.iec60870.msgs.common import Time
 
 
-AsduAddress = int
+AsduAddress: typing.TypeAlias = int
 """ASDU address in range [0, 255]"""
 
-OtherCause = int
+OtherCause: typing.TypeAlias = int
 """Other cause in range [0, 255]"""
 
 
 class AsduType(enum.Enum):
     TIME_TAGGED_MESSAGE = 1
     TIME_TAGGED_MESSAGE_WITH_RELATIVE_TIME = 2
     MEASURANDS_1 = 3
@@ -161,19 +164,19 @@
 
 
 class NoneValue(typing.NamedTuple):
     pass
 
 
 class TextValue(typing.NamedTuple):
-    value: Bytes
+    value: util.Bytes
 
 
 class BitstringValue(typing.NamedTuple):
-    value: typing.List[bool]
+    value: list[bool]
 
 
 class UIntValue(typing.NamedTuple):
     value: int
 
 
 class IntValue(typing.NamedTuple):
@@ -297,38 +300,38 @@
     values: typing.List['Value']
 
 
 class IndexValue(typing.NamedTuple):
     value: int
 
 
-Value = typing.Union[NoneValue,
-                     TextValue,
-                     BitstringValue,
-                     UIntValue,
-                     IntValue,
-                     FixedValue,
-                     UFixedValue,
-                     Real32Value,
-                     Real64Value,
-                     DoubleValue,
-                     SingleValue,
-                     ExtendedDoubleValue,
-                     MeasurandValue,
-                     TimeValue,
-                     IdentificationValue,
-                     RelativeTimeValue,
-                     IoAddressValue,
-                     DoubleWithTimeValue,
-                     DoubleWithRelativeTimeValue,
-                     MeasurandWithRelativeTimeValue,
-                     TextNumberValue,
-                     ReplyValue,
-                     ArrayValue,
-                     IndexValue]
+Value: typing.TypeAlias = (NoneValue |
+                           TextValue |
+                           BitstringValue |
+                           UIntValue |
+                           IntValue |
+                           FixedValue |
+                           UFixedValue |
+                           Real32Value |
+                           Real64Value |
+                           DoubleValue |
+                           SingleValue |
+                           ExtendedDoubleValue |
+                           MeasurandValue |
+                           TimeValue |
+                           IdentificationValue |
+                           RelativeTimeValue |
+                           IoAddressValue |
+                           DoubleWithTimeValue |
+                           DoubleWithRelativeTimeValue |
+                           MeasurandWithRelativeTimeValue |
+                           TextNumberValue |
+                           ReplyValue |
+                           ArrayValue |
+                           IndexValue)
 
 
 class DescriptiveData(typing.NamedTuple):
     description: Description
     value: ArrayValue
 
 
@@ -347,17 +350,17 @@
 class IoElement_TIME_TAGGED_MEASURANDS_WITH_RELATIVE_TIME(typing.NamedTuple):
     value: MeasurandWithRelativeTimeValue
 
 
 class IoElement_IDENTIFICATION(typing.NamedTuple):
     compatibility: int
     """compatibility in range [0, 255]"""
-    value: Bytes
+    value: util.Bytes
     """value length is 8"""
-    software: Bytes
+    software: util.Bytes
     """software length is 4"""
 
 
 class IoElement_TIME_SYNCHRONIZATION(typing.NamedTuple):
     time: Time
     """time size is SEVEN"""
 
@@ -377,36 +380,36 @@
 
 
 class IoElement_GENERIC_DATA(typing.NamedTuple):
     return_identifier: int
     """return_identifier in range [0, 255]"""
     counter: bool
     more_follows: bool
-    data: typing.List[typing.Tuple[Identification, DescriptiveData]]
+    data: list[tuple[Identification, DescriptiveData]]
 
 
 class IoElement_GENERIC_IDENTIFICATION(typing.NamedTuple):
     return_identifier: int
     """return_identifier in range [0, 255]"""
     identification: Identification
     counter: bool
     more_follows: bool
-    data: typing.List[DescriptiveData]
+    data: list[DescriptiveData]
 
 
 class IoElement_GENERAL_COMMAND(typing.NamedTuple):
     value: DoubleValue
     return_identifier: int
     """return_identifier in range [0, 255]"""
 
 
 class IoElement_GENERIC_COMMAND(typing.NamedTuple):
     return_identifier: int
     """return_identifier in range [0, 255]"""
-    data: typing.List[typing.Tuple[Identification, Description]]
+    data: list[tuple[Identification, Description]]
 
 
 class IoElement_LIST_OF_RECORDED_DISTURBANCES(typing.NamedTuple):
     fault_number: int
     """fault_number in range [0, 65535]"""
     trip: bool
     transmitted: bool
@@ -460,61 +463,62 @@
 
 
 class IoElement_TRANSMISSION_OF_TAGS(typing.NamedTuple):
     fault_number: int
     """fault_number in range [0, 65535]"""
     tag_position: int
     """tag_position in range [0, 65535]"""
-    values: typing.List[typing.Tuple[IoAddress, DoubleValue]]
+    values: list[tuple[IoAddress, DoubleValue]]
 
 
 class IoElement_TRANSMISSION_OF_DISTURBANCE_VALUES(typing.NamedTuple):
     fault_number: int
     """fault_number in range [0, 65535]"""
     channel: Channel
     element_number: int
     """element_number in range [0, 65535]"""
-    values: typing.List[float]
+    values: list[float]
     """values are in range [-1.0, 1.0)"""
 
 
 class IoElement_END_OF_TRANSMISSION(typing.NamedTuple):
     order_type: OrderType
     fault_number: int
     """fault_number in range [0, 65535]"""
     channel: Channel
 
 
-IoElement = typing.Union[IoElement_TIME_TAGGED_MESSAGE,
-                         IoElement_TIME_TAGGED_MESSAGE_WITH_RELATIVE_TIME,
-                         IoElement_MEASURANDS_1,
-                         IoElement_TIME_TAGGED_MEASURANDS_WITH_RELATIVE_TIME,
-                         IoElement_IDENTIFICATION,
-                         IoElement_TIME_SYNCHRONIZATION,
-                         IoElement_GENERAL_INTERROGATION,
-                         IoElement_GENERAL_INTERROGATION_TERMINATION,
-                         IoElement_MEASURANDS_2,
-                         IoElement_GENERIC_DATA,
-                         IoElement_GENERIC_IDENTIFICATION,
-                         IoElement_GENERAL_COMMAND,
-                         IoElement_GENERIC_COMMAND,
-                         IoElement_LIST_OF_RECORDED_DISTURBANCES,
-                         IoElement_ORDER_FOR_DISTURBANCE_DATA_TRANSMISSION,
-                         IoElement_ACKNOWLEDGEMENT_FOR_DISTURBANCE_DATA_TRANSMISSION,  # NOQA
-                         IoElement_READY_FOR_TRANSMISSION_OF_DISTURBANCE_DATA,
-                         IoElement_READY_FOR_TRANSMISSION_OF_A_CHANNEL,
-                         IoElement_READY_FOR_TRANSMISSION_OF_TAGS,
-                         IoElement_TRANSMISSION_OF_TAGS,
-                         IoElement_TRANSMISSION_OF_DISTURBANCE_VALUES,
-                         IoElement_END_OF_TRANSMISSION]
+IoElement: typing.TypeAlias = (
+    IoElement_TIME_TAGGED_MESSAGE |
+    IoElement_TIME_TAGGED_MESSAGE_WITH_RELATIVE_TIME |
+    IoElement_MEASURANDS_1 |
+    IoElement_TIME_TAGGED_MEASURANDS_WITH_RELATIVE_TIME |
+    IoElement_IDENTIFICATION |
+    IoElement_TIME_SYNCHRONIZATION |
+    IoElement_GENERAL_INTERROGATION |
+    IoElement_GENERAL_INTERROGATION_TERMINATION |
+    IoElement_MEASURANDS_2 |
+    IoElement_GENERIC_DATA |
+    IoElement_GENERIC_IDENTIFICATION |
+    IoElement_GENERAL_COMMAND |
+    IoElement_GENERIC_COMMAND |
+    IoElement_LIST_OF_RECORDED_DISTURBANCES |
+    IoElement_ORDER_FOR_DISTURBANCE_DATA_TRANSMISSION |
+    IoElement_ACKNOWLEDGEMENT_FOR_DISTURBANCE_DATA_TRANSMISSION |
+    IoElement_READY_FOR_TRANSMISSION_OF_DISTURBANCE_DATA |
+    IoElement_READY_FOR_TRANSMISSION_OF_A_CHANNEL |
+    IoElement_READY_FOR_TRANSMISSION_OF_TAGS |
+    IoElement_TRANSMISSION_OF_TAGS |
+    IoElement_TRANSMISSION_OF_DISTURBANCE_VALUES |
+    IoElement_END_OF_TRANSMISSION)
 
 
 class IO(typing.NamedTuple):
     address: IoAddress
-    elements: typing.List[IoElement]
+    elements: list[IoElement]
 
 
 class ASDU(typing.NamedTuple):
     type: AsduType
-    cause: typing.Union[Cause, OtherCause]
+    cause: Cause | OtherCause
     address: AsduAddress
-    ios: typing.List[IO]
+    ios: list[IO]
```

## hat/drivers/iec60870/msgs/iec103/encoder.py

```diff
@@ -1,13 +1,14 @@
 import collections
 import contextlib
 import itertools
 import math
 import struct
-import typing
+
+from hat import util
 
 from hat.drivers.iec60870.msgs import encoder
 from hat.drivers.iec60870.msgs.iec103 import common
 
 
 class Encoder:
 
@@ -18,16 +19,16 @@
             io_address_size=common.IoAddressSize.TWO,
             asdu_type_time_sizes={},
             inverted_sequence_bit=True,
             decode_io_element_cb=_decode_io_element,
             encode_io_element_cb=_encode_io_element)
 
     def decode_asdu(self,
-                    asdu_bytes: common.Bytes
-                    ) -> typing.Tuple[common.ASDU, common.Bytes]:
+                    asdu_bytes: util.Bytes
+                    ) -> tuple[common.ASDU, util.Bytes]:
         asdu, rest = self._encoder.decode_asdu(asdu_bytes)
 
         asdu_type = common.AsduType(asdu.type)
         cause = _decode_cause(asdu.cause)
         address = asdu.address
         ios = [common.IO(address=_decode_io_address(io.address),
                          elements=io.elements)
@@ -37,15 +38,15 @@
 
         asdu = common.ASDU(type=asdu_type,
                            cause=cause,
                            address=address,
                            ios=ios)
         return asdu, rest
 
-    def encode_asdu(self, asdu: common.ASDU) -> common.Bytes:
+    def encode_asdu(self, asdu: common.ASDU) -> util.Bytes:
         asdu_type = asdu.type.value
         cause = _encode_cause(asdu.cause)
         address = asdu.address
         ios = [encoder.common.IO(address=_encode_io_address(io.address),
                                  elements=io.elements,
                                  time=None)
                for io in asdu.ios]
```

## hat/drivers/iec60870/msgs/iec104/common.py

```diff
@@ -1,23 +1,23 @@
+from hat.drivers.iec60870.msgs.common import *  # NOQA
+
 import enum
 import typing
 
 from hat.drivers.iec60870.msgs import iec101
-
-from hat.drivers.iec60870.msgs.common import *  # NOQA
 from hat.drivers.iec60870.msgs.common import Time
 
 
-OriginatorAddress = int
+OriginatorAddress: typing.TypeAlias = int
 """Originator address in range [0, 255] - 0 if not available"""
 
-AsduAddress = int
+AsduAddress: typing.TypeAlias = int
 """ASDU address in range [0, 65535]"""
 
-IoAddress = int
+IoAddress: typing.TypeAlias = int
 """IO address in range [0, 16777215]"""
 
 
 class AsduType(enum.Enum):
     M_SP_NA = iec101.common.AsduType.M_SP_NA.value
     M_DP_NA = iec101.common.AsduType.M_DP_NA.value
     M_ST_NA = iec101.common.AsduType.M_ST_NA.value
@@ -69,86 +69,86 @@
     F_SC_NA = iec101.common.AsduType.F_SC_NA.value
     F_LS_NA = iec101.common.AsduType.F_LS_NA.value
     F_AF_NA = iec101.common.AsduType.F_AF_NA.value
     F_SG_NA = iec101.common.AsduType.F_SG_NA.value
     F_DR_TA = iec101.common.AsduType.F_DR_TA.value
 
 
-CauseType = iec101.common.CauseType
-OtherCauseType = iec101.common.OtherCauseType
-Cause = iec101.common.Cause
-
-QualityType = iec101.common.QualityType
-IndicationQuality = iec101.common.IndicationQuality
-MeasurementQuality = iec101.common.MeasurementQuality
-CounterQuality = iec101.common.CounterQuality
-ProtectionQuality = iec101.common.ProtectionQuality
-Quality = iec101.common.Quality
-
-FreezeCode = iec101.common.FreezeCode
-
-SingleValue = iec101.common.SingleValue
-DoubleValue = iec101.common.DoubleValue
-RegulatingValue = iec101.common.RegulatingValue
-StepPositionValue = iec101.common.StepPositionValue
-BitstringValue = iec101.common.BitstringValue
-NormalizedValue = iec101.common.NormalizedValue
-ScaledValue = iec101.common.ScaledValue
-FloatingValue = iec101.common.FloatingValue
-BinaryCounterValue = iec101.common.BinaryCounterValue
-ProtectionValue = iec101.common.ProtectionValue
-ProtectionStartValue = iec101.common.ProtectionStartValue
-ProtectionCommandValue = iec101.common.ProtectionCommandValue
-StatusValue = iec101.common.StatusValue
-
-IoElement_M_SP_NA = iec101.common.IoElement_M_SP_NA
-IoElement_M_DP_NA = iec101.common.IoElement_M_DP_NA
-IoElement_M_ST_NA = iec101.common.IoElement_M_ST_NA
-IoElement_M_BO_NA = iec101.common.IoElement_M_BO_NA
-IoElement_M_ME_NA = iec101.common.IoElement_M_ME_NA
-IoElement_M_ME_NB = iec101.common.IoElement_M_ME_NB
-IoElement_M_ME_NC = iec101.common.IoElement_M_ME_NC
-IoElement_M_IT_NA = iec101.common.IoElement_M_IT_NA
-IoElement_M_PS_NA = iec101.common.IoElement_M_PS_NA
-IoElement_M_ME_ND = iec101.common.IoElement_M_ME_ND
-IoElement_M_SP_TB = iec101.common.IoElement_M_SP_TB
-IoElement_M_DP_TB = iec101.common.IoElement_M_DP_TB
-IoElement_M_ST_TB = iec101.common.IoElement_M_ST_TB
-IoElement_M_BO_TB = iec101.common.IoElement_M_BO_TB
-IoElement_M_ME_TD = iec101.common.IoElement_M_ME_TD
-IoElement_M_ME_TE = iec101.common.IoElement_M_ME_TE
-IoElement_M_ME_TF = iec101.common.IoElement_M_ME_TF
-IoElement_M_IT_TB = iec101.common.IoElement_M_IT_TB
-IoElement_M_EP_TD = iec101.common.IoElement_M_EP_TD
-IoElement_M_EP_TE = iec101.common.IoElement_M_EP_TE
-IoElement_M_EP_TF = iec101.common.IoElement_M_EP_TF
-IoElement_C_SC_NA = iec101.common.IoElement_C_SC_NA
-IoElement_C_DC_NA = iec101.common.IoElement_C_DC_NA
-IoElement_C_RC_NA = iec101.common.IoElement_C_RC_NA
-IoElement_C_SE_NA = iec101.common.IoElement_C_SE_NA
-IoElement_C_SE_NB = iec101.common.IoElement_C_SE_NB
-IoElement_C_SE_NC = iec101.common.IoElement_C_SE_NC
-IoElement_C_BO_NA = iec101.common.IoElement_C_BO_NA
-IoElement_M_EI_NA = iec101.common.IoElement_M_EI_NA
-IoElement_C_IC_NA = iec101.common.IoElement_C_IC_NA
-IoElement_C_CI_NA = iec101.common.IoElement_C_CI_NA
-IoElement_C_RD_NA = iec101.common.IoElement_C_RD_NA
-IoElement_C_CS_NA = iec101.common.IoElement_C_CS_NA
-IoElement_C_RP_NA = iec101.common.IoElement_C_RP_NA
-IoElement_P_ME_NA = iec101.common.IoElement_P_ME_NA
-IoElement_P_ME_NB = iec101.common.IoElement_P_ME_NB
-IoElement_P_ME_NC = iec101.common.IoElement_P_ME_NC
-IoElement_P_AC_NA = iec101.common.IoElement_P_AC_NA
-IoElement_F_FR_NA = iec101.common.IoElement_F_FR_NA
-IoElement_F_SR_NA = iec101.common.IoElement_F_SR_NA
-IoElement_F_SC_NA = iec101.common.IoElement_F_SC_NA
-IoElement_F_LS_NA = iec101.common.IoElement_F_LS_NA
-IoElement_F_AF_NA = iec101.common.IoElement_F_AF_NA
-IoElement_F_SG_NA = iec101.common.IoElement_F_SG_NA
-IoElement_F_DR_TA = iec101.common.IoElement_F_DR_TA
+CauseType: typing.TypeAlias = iec101.common.CauseType
+OtherCauseType: typing.TypeAlias = iec101.common.OtherCauseType
+Cause: typing.TypeAlias = iec101.common.Cause
+
+QualityType: typing.TypeAlias = iec101.common.QualityType
+IndicationQuality: typing.TypeAlias = iec101.common.IndicationQuality
+MeasurementQuality: typing.TypeAlias = iec101.common.MeasurementQuality
+CounterQuality: typing.TypeAlias = iec101.common.CounterQuality
+ProtectionQuality: typing.TypeAlias = iec101.common.ProtectionQuality
+Quality: typing.TypeAlias = iec101.common.Quality
+
+FreezeCode: typing.TypeAlias = iec101.common.FreezeCode
+
+SingleValue: typing.TypeAlias = iec101.common.SingleValue
+DoubleValue: typing.TypeAlias = iec101.common.DoubleValue
+RegulatingValue: typing.TypeAlias = iec101.common.RegulatingValue
+StepPositionValue: typing.TypeAlias = iec101.common.StepPositionValue
+BitstringValue: typing.TypeAlias = iec101.common.BitstringValue
+NormalizedValue: typing.TypeAlias = iec101.common.NormalizedValue
+ScaledValue: typing.TypeAlias = iec101.common.ScaledValue
+FloatingValue: typing.TypeAlias = iec101.common.FloatingValue
+BinaryCounterValue: typing.TypeAlias = iec101.common.BinaryCounterValue
+ProtectionValue: typing.TypeAlias = iec101.common.ProtectionValue
+ProtectionStartValue: typing.TypeAlias = iec101.common.ProtectionStartValue
+ProtectionCommandValue: typing.TypeAlias = iec101.common.ProtectionCommandValue
+StatusValue: typing.TypeAlias = iec101.common.StatusValue
+
+IoElement_M_SP_NA: typing.TypeAlias = iec101.common.IoElement_M_SP_NA
+IoElement_M_DP_NA: typing.TypeAlias = iec101.common.IoElement_M_DP_NA
+IoElement_M_ST_NA: typing.TypeAlias = iec101.common.IoElement_M_ST_NA
+IoElement_M_BO_NA: typing.TypeAlias = iec101.common.IoElement_M_BO_NA
+IoElement_M_ME_NA: typing.TypeAlias = iec101.common.IoElement_M_ME_NA
+IoElement_M_ME_NB: typing.TypeAlias = iec101.common.IoElement_M_ME_NB
+IoElement_M_ME_NC: typing.TypeAlias = iec101.common.IoElement_M_ME_NC
+IoElement_M_IT_NA: typing.TypeAlias = iec101.common.IoElement_M_IT_NA
+IoElement_M_PS_NA: typing.TypeAlias = iec101.common.IoElement_M_PS_NA
+IoElement_M_ME_ND: typing.TypeAlias = iec101.common.IoElement_M_ME_ND
+IoElement_M_SP_TB: typing.TypeAlias = iec101.common.IoElement_M_SP_TB
+IoElement_M_DP_TB: typing.TypeAlias = iec101.common.IoElement_M_DP_TB
+IoElement_M_ST_TB: typing.TypeAlias = iec101.common.IoElement_M_ST_TB
+IoElement_M_BO_TB: typing.TypeAlias = iec101.common.IoElement_M_BO_TB
+IoElement_M_ME_TD: typing.TypeAlias = iec101.common.IoElement_M_ME_TD
+IoElement_M_ME_TE: typing.TypeAlias = iec101.common.IoElement_M_ME_TE
+IoElement_M_ME_TF: typing.TypeAlias = iec101.common.IoElement_M_ME_TF
+IoElement_M_IT_TB: typing.TypeAlias = iec101.common.IoElement_M_IT_TB
+IoElement_M_EP_TD: typing.TypeAlias = iec101.common.IoElement_M_EP_TD
+IoElement_M_EP_TE: typing.TypeAlias = iec101.common.IoElement_M_EP_TE
+IoElement_M_EP_TF: typing.TypeAlias = iec101.common.IoElement_M_EP_TF
+IoElement_C_SC_NA: typing.TypeAlias = iec101.common.IoElement_C_SC_NA
+IoElement_C_DC_NA: typing.TypeAlias = iec101.common.IoElement_C_DC_NA
+IoElement_C_RC_NA: typing.TypeAlias = iec101.common.IoElement_C_RC_NA
+IoElement_C_SE_NA: typing.TypeAlias = iec101.common.IoElement_C_SE_NA
+IoElement_C_SE_NB: typing.TypeAlias = iec101.common.IoElement_C_SE_NB
+IoElement_C_SE_NC: typing.TypeAlias = iec101.common.IoElement_C_SE_NC
+IoElement_C_BO_NA: typing.TypeAlias = iec101.common.IoElement_C_BO_NA
+IoElement_M_EI_NA: typing.TypeAlias = iec101.common.IoElement_M_EI_NA
+IoElement_C_IC_NA: typing.TypeAlias = iec101.common.IoElement_C_IC_NA
+IoElement_C_CI_NA: typing.TypeAlias = iec101.common.IoElement_C_CI_NA
+IoElement_C_RD_NA: typing.TypeAlias = iec101.common.IoElement_C_RD_NA
+IoElement_C_CS_NA: typing.TypeAlias = iec101.common.IoElement_C_CS_NA
+IoElement_C_RP_NA: typing.TypeAlias = iec101.common.IoElement_C_RP_NA
+IoElement_P_ME_NA: typing.TypeAlias = iec101.common.IoElement_P_ME_NA
+IoElement_P_ME_NB: typing.TypeAlias = iec101.common.IoElement_P_ME_NB
+IoElement_P_ME_NC: typing.TypeAlias = iec101.common.IoElement_P_ME_NC
+IoElement_P_AC_NA: typing.TypeAlias = iec101.common.IoElement_P_AC_NA
+IoElement_F_FR_NA: typing.TypeAlias = iec101.common.IoElement_F_FR_NA
+IoElement_F_SR_NA: typing.TypeAlias = iec101.common.IoElement_F_SR_NA
+IoElement_F_SC_NA: typing.TypeAlias = iec101.common.IoElement_F_SC_NA
+IoElement_F_LS_NA: typing.TypeAlias = iec101.common.IoElement_F_LS_NA
+IoElement_F_AF_NA: typing.TypeAlias = iec101.common.IoElement_F_AF_NA
+IoElement_F_SG_NA: typing.TypeAlias = iec101.common.IoElement_F_SG_NA
+IoElement_F_DR_TA: typing.TypeAlias = iec101.common.IoElement_F_DR_TA
 
 
 class IoElement_C_SC_TA(typing.NamedTuple):
     value: SingleValue
     select: bool
     qualifier: int
     """qualifier in range [0, 31]"""
@@ -188,73 +188,74 @@
 
 
 class IoElement_C_TS_TA(typing.NamedTuple):
     counter: int
     """counter in range [0, 65535]"""
 
 
-IoElement = typing.Union[IoElement_M_SP_NA,
-                         IoElement_M_DP_NA,
-                         IoElement_M_ST_NA,
-                         IoElement_M_BO_NA,
-                         IoElement_M_ME_NA,
-                         IoElement_M_ME_NB,
-                         IoElement_M_ME_NC,
-                         IoElement_M_IT_NA,
-                         IoElement_M_PS_NA,
-                         IoElement_M_ME_ND,
-                         IoElement_M_SP_TB,
-                         IoElement_M_DP_TB,
-                         IoElement_M_ST_TB,
-                         IoElement_M_BO_TB,
-                         IoElement_M_ME_TD,
-                         IoElement_M_ME_TE,
-                         IoElement_M_ME_TF,
-                         IoElement_M_IT_TB,
-                         IoElement_M_EP_TD,
-                         IoElement_M_EP_TE,
-                         IoElement_M_EP_TF,
-                         IoElement_C_SC_NA,
-                         IoElement_C_DC_NA,
-                         IoElement_C_RC_NA,
-                         IoElement_C_SE_NA,
-                         IoElement_C_SE_NB,
-                         IoElement_C_SE_NC,
-                         IoElement_C_BO_NA,
-                         IoElement_C_SC_TA,
-                         IoElement_C_DC_TA,
-                         IoElement_C_RC_TA,
-                         IoElement_C_SE_TA,
-                         IoElement_C_SE_TB,
-                         IoElement_C_SE_TC,
-                         IoElement_C_BO_TA,
-                         IoElement_M_EI_NA,
-                         IoElement_C_IC_NA,
-                         IoElement_C_CI_NA,
-                         IoElement_C_RD_NA,
-                         IoElement_C_CS_NA,
-                         IoElement_C_RP_NA,
-                         IoElement_C_TS_TA,
-                         IoElement_P_ME_NA,
-                         IoElement_P_ME_NB,
-                         IoElement_P_ME_NC,
-                         IoElement_P_AC_NA,
-                         IoElement_F_FR_NA,
-                         IoElement_F_SR_NA,
-                         IoElement_F_SC_NA,
-                         IoElement_F_LS_NA,
-                         IoElement_F_AF_NA,
-                         IoElement_F_SG_NA,
-                         IoElement_F_DR_TA]
+IoElement: typing.TypeAlias = (
+    IoElement_M_SP_NA |
+    IoElement_M_DP_NA |
+    IoElement_M_ST_NA |
+    IoElement_M_BO_NA |
+    IoElement_M_ME_NA |
+    IoElement_M_ME_NB |
+    IoElement_M_ME_NC |
+    IoElement_M_IT_NA |
+    IoElement_M_PS_NA |
+    IoElement_M_ME_ND |
+    IoElement_M_SP_TB |
+    IoElement_M_DP_TB |
+    IoElement_M_ST_TB |
+    IoElement_M_BO_TB |
+    IoElement_M_ME_TD |
+    IoElement_M_ME_TE |
+    IoElement_M_ME_TF |
+    IoElement_M_IT_TB |
+    IoElement_M_EP_TD |
+    IoElement_M_EP_TE |
+    IoElement_M_EP_TF |
+    IoElement_C_SC_NA |
+    IoElement_C_DC_NA |
+    IoElement_C_RC_NA |
+    IoElement_C_SE_NA |
+    IoElement_C_SE_NB |
+    IoElement_C_SE_NC |
+    IoElement_C_BO_NA |
+    IoElement_C_SC_TA |
+    IoElement_C_DC_TA |
+    IoElement_C_RC_TA |
+    IoElement_C_SE_TA |
+    IoElement_C_SE_TB |
+    IoElement_C_SE_TC |
+    IoElement_C_BO_TA |
+    IoElement_M_EI_NA |
+    IoElement_C_IC_NA |
+    IoElement_C_CI_NA |
+    IoElement_C_RD_NA |
+    IoElement_C_CS_NA |
+    IoElement_C_RP_NA |
+    IoElement_C_TS_TA |
+    IoElement_P_ME_NA |
+    IoElement_P_ME_NB |
+    IoElement_P_ME_NC |
+    IoElement_P_AC_NA |
+    IoElement_F_FR_NA |
+    IoElement_F_SR_NA |
+    IoElement_F_SC_NA |
+    IoElement_F_LS_NA |
+    IoElement_F_AF_NA |
+    IoElement_F_SG_NA |
+    IoElement_F_DR_TA)
 
 
 class IO(typing.NamedTuple):
     address: IoAddress
-    elements: typing.List[IoElement]
-    time: typing.Optional[Time]
+    elements: list[IoElement]
+    time: Time | None
 
 
 class ASDU(typing.NamedTuple):
     type: AsduType
     cause: Cause
     address: AsduAddress
-    ios: typing.List[IO]
+    ios: list[IO]
```

## hat/drivers/iec60870/msgs/iec104/encoder.py

```diff
@@ -1,8 +1,8 @@
-import typing
+from hat import util
 
 from hat.drivers.iec60870.msgs import encoder
 from hat.drivers.iec60870.msgs import iec101
 from hat.drivers.iec60870.msgs.iec104 import common
 
 
 iec101_asdu_types = {common.AsduType.M_SP_NA.value,
@@ -78,16 +78,16 @@
         return self._encoder.asdu_address_size
 
     @property
     def io_address_size(self) -> common.IoAddressSize:
         return self._encoder.io_address_size
 
     def decode_asdu(self,
-                    asdu_bytes: common.Bytes
-                    ) -> typing.Tuple[common.ASDU, common.Bytes]:
+                    asdu_bytes: util.Bytes
+                    ) -> tuple[common.ASDU, util.Bytes]:
         asdu, rest = self._encoder.decode_asdu(asdu_bytes)
 
         asdu_type = common.AsduType(asdu.type)
         cause = iec101.encoder.decode_cause(asdu.cause, common.CauseSize.TWO)
         address = asdu.address
         ios = [common.IO(address=io.address,
                          elements=io.elements,
@@ -96,15 +96,15 @@
 
         asdu = common.ASDU(type=asdu_type,
                            cause=cause,
                            address=address,
                            ios=ios)
         return asdu, rest
 
-    def encode_asdu(self, asdu: common.ASDU) -> common.Bytes:
+    def encode_asdu(self, asdu: common.ASDU) -> util.Bytes:
         asdu_type = asdu.type.value
         cause = iec101.encoder.encode_cause(asdu.cause, common.CauseSize.TWO)
         address = asdu.address
         ios = [encoder.common.IO(address=io.address,
                                  elements=io.elements,
                                  time=io.time)
                for io in asdu.ios]
```

## hat/drivers/iec60870/msgs/security/common.py

```diff
@@ -1,39 +1,40 @@
+from hat.drivers.iec60870.msgs.common import *  # NOQA
+
 import enum
 import typing
 
+from hat import util
+
 from hat.drivers.iec60870.msgs import iec101
 from hat.drivers.iec60870.msgs import iec104
-
-from hat.drivers.iec60870.msgs.common import *  # NOQA
-from hat.drivers.iec60870.msgs.common import Bytes, Time
+from hat.drivers.iec60870.msgs.common import Time
 
 
-OriginatorAddress = iec101.common.OriginatorAddress
+OriginatorAddress: typing.TypeAlias = iec101.common.OriginatorAddress
 
 # different sizes for iec101 and iec104
-AsduAddress = typing.Union[iec101.common.AsduAddress,
-                           iec104.common.AsduAddress]
+AsduAddress: typing.TypeAlias = (iec101.common.AsduAddress |
+                                 iec104.common.AsduAddress)
 
 # different sizes for iec101 and iec104
-IoAddress = typing.Union[iec101.common.IoAddress,
-                         iec104.common.IoAddress]
+IoAddress: typing.TypeAlias = iec101.common.IoAddress | iec104.common.IoAddress
 
-OtherCauseType = iec101.common.OriginatorAddress
+OtherCauseType: typing.TypeAlias = iec101.common.OriginatorAddress
 
-BinaryCounterValue = iec101.common.BinaryCounterValue
+BinaryCounterValue: typing.TypeAlias = iec101.common.BinaryCounterValue
 
 
-AssociationId = int
+AssociationId: typing.TypeAlias = int
 """Association ID in range [0, 65535]"""
 
-SequenceNumber = int
+SequenceNumber: typing.TypeAlias = int
 """Sequnce number in range [0, 4294967295]"""
 
-UserNumber = int
+UserNumber: typing.TypeAlias = int
 """User number in range [0, 65535]"""
 
 
 class AsduType(enum.Enum):
     S_IT_TC = 41
     S_CH_NA = 81
     S_RP_NA = 82
@@ -113,170 +114,170 @@
     *((cause.name, cause.value) for cause in iec101.common.CauseType),
     ('AUTHENTICATION', 14),
     ('SESSION_KEY_MAINTENANCE', 15),
     ('UPDATE_KEY_MAINTENANCE', 16)])
 
 
 class Cause(typing.NamedTuple):
-    type: typing.Union[CauseType, OtherCauseType]
+    type: CauseType | OtherCauseType
     is_negative_confirm: bool
     is_test: bool
     originator_address: OriginatorAddress
 
 
 class IoElement_S_IT_TC(typing.NamedTuple):
     association_id: AssociationId
     value: BinaryCounterValue
 
 
 class IoElement_S_CH_NA(typing.NamedTuple):
     sequence: SequenceNumber
     user: UserNumber
-    mac_algorithm: typing.Union[MacAlgorithm, int]
+    mac_algorithm: MacAlgorithm | int
     """MAC algorithm can be value in range [0, 255]"""
     reason: int
     """reason in range [0, 255] - only valid value is 1"""
-    data: Bytes
+    data: util.Bytes
     """data length in range [4, 65535]"""
 
 
 class IoElement_S_RP_NA(typing.NamedTuple):
     sequence: SequenceNumber
     user: UserNumber
-    mac: Bytes
+    mac: util.Bytes
 
 
 class IoElement_S_AR_NA(typing.NamedTuple):
-    asdu: Bytes
+    asdu: util.Bytes
     sequence: SequenceNumber
     user: UserNumber
-    mac: Bytes
+    mac: util.Bytes
 
 
 class IoElement_S_KR_NA(typing.NamedTuple):
     user: UserNumber
 
 
 class IoElement_S_KS_NA(typing.NamedTuple):
     sequence: SequenceNumber
     user: UserNumber
-    key_wrap_algorithm: typing.Union[KeyWrapAlgorithm, int]
+    key_wrap_algorithm: KeyWrapAlgorithm | int
     """Key wrap algorithm can be value in range [0, 255]"""
-    key_status: typing.Union[KeyStatus, int]
+    key_status: KeyStatus | int
     """Key status can be value in range [0, 255]"""
-    mac_algorithm: typing.Union[MacAlgorithm, int]
+    mac_algorithm: MacAlgorithm | int
     """MAC algorithm can be value in range [0, 255]"""
-    data: Bytes
+    data: util.Bytes
     """data length in range [8, 65535]"""
-    mac: Bytes
+    mac: util.Bytes
 
 
 class IoElement_S_KC_NA(typing.NamedTuple):
     sequence: SequenceNumber
     user: UserNumber
-    wrapped_key: Bytes
+    wrapped_key: util.Bytes
     """wrapped key length in range [8, 65535]"""
 
 
 class IoElement_S_ER_NA(typing.NamedTuple):
     challenge_sequence: SequenceNumber
     key_change_sequence: SequenceNumber
     user: UserNumber
     association_id: AssociationId
-    code: typing.Union[ErrorCode, int]
+    code: ErrorCode | int
     """Code can be value in range [0, 255]"""
     time: Time
     """Time size SEVEN"""
-    text: Bytes
+    text: util.Bytes
     """Text length in range [0, 65535]"""
 
 
 class IoElement_S_UC_NA_X(typing.NamedTuple):
-    key_change_method: typing.Union[KeyChangeMethod, int]
+    key_change_method: KeyChangeMethod | int
     """Key change method can be value in range [0, 255]"""
-    data: Bytes
+    data: util.Bytes
     """Data length in range [0, 65535]"""
 
 
 class IoElement_S_US_NA(typing.NamedTuple):
-    key_change_method: typing.Union[KeyChangeMethod, int]
+    key_change_method: KeyChangeMethod | int
     """Key change method can be value in range [0, 255]"""
-    operation: typing.Union[Operation, int]
+    operation: Operation | int
     """Operation can be value in range [0, 255]"""
     sequence: SequenceNumber
-    role: typing.Union[UserRole, int]
+    role: UserRole | int
     """Role can be value in range [0, 65535]"""
     role_expiry: int
     """Role expiry in range [0, 65535]"""
-    name: Bytes
+    name: util.Bytes
     """Name length in range [0, 65535]"""
-    public_key: Bytes
+    public_key: util.Bytes
     """Public key length in range [0, 65535]"""
-    certification: Bytes
+    certification: util.Bytes
     """Certification length in range [0, 65535]"""
 
 
 class IoElement_S_UQ_NA(typing.NamedTuple):
-    key_change_method: typing.Union[KeyChangeMethod, int]
+    key_change_method: KeyChangeMethod | int
     """Key change method can be value in range [0, 255]"""
-    name: Bytes
+    name: util.Bytes
     """Name length in range [0, 65535]"""
-    data: Bytes
+    data: util.Bytes
     """Data length in range [4, 65535]"""
 
 
 class IoElement_S_UR_NA(typing.NamedTuple):
     sequence: SequenceNumber
     user: UserNumber
-    data: Bytes
+    data: util.Bytes
     """Data length in range [4, 65535]"""
 
 
 class IoElement_S_UK_NA(typing.NamedTuple):
     sequence: SequenceNumber
     user: UserNumber
-    encrypted_update_key: Bytes
+    encrypted_update_key: util.Bytes
     """Encrypted update key length in range [16, 65535]"""
-    mac: Bytes
+    mac: util.Bytes
 
 
 class IoElement_S_UA_NA(typing.NamedTuple):
     sequence: SequenceNumber
     user: UserNumber
-    encrypted_update_key: Bytes
+    encrypted_update_key: util.Bytes
     """Encrypted update key length in range [16, 65535]"""
-    signature: Bytes
+    signature: util.Bytes
 
 
 class IoElement_S_UC_NA(typing.NamedTuple):
-    mac: Bytes
+    mac: util.Bytes
 
 
-IoElement = typing.Union[IoElement_S_IT_TC,
-                         IoElement_S_CH_NA,
-                         IoElement_S_RP_NA,
-                         IoElement_S_AR_NA,
-                         IoElement_S_KR_NA,
-                         IoElement_S_KS_NA,
-                         IoElement_S_KC_NA,
-                         IoElement_S_ER_NA,
-                         IoElement_S_UC_NA_X,
-                         IoElement_S_US_NA,
-                         IoElement_S_UQ_NA,
-                         IoElement_S_UR_NA,
-                         IoElement_S_UK_NA,
-                         IoElement_S_UA_NA,
-                         IoElement_S_UC_NA]
+IoElement: typing.TypeAlias = (IoElement_S_IT_TC |
+                               IoElement_S_CH_NA |
+                               IoElement_S_RP_NA |
+                               IoElement_S_AR_NA |
+                               IoElement_S_KR_NA |
+                               IoElement_S_KS_NA |
+                               IoElement_S_KC_NA |
+                               IoElement_S_ER_NA |
+                               IoElement_S_UC_NA_X |
+                               IoElement_S_US_NA |
+                               IoElement_S_UQ_NA |
+                               IoElement_S_UR_NA |
+                               IoElement_S_UK_NA |
+                               IoElement_S_UA_NA |
+                               IoElement_S_UC_NA)
 
 
 class IO(typing.NamedTuple):
-    address: typing.Optional[IoAddress]
+    address: IoAddress | None
     element: IoElement
-    time: typing.Optional[Time]
+    time: Time | None
     """Time size SEVEN"""
 
 
 class ASDU(typing.NamedTuple):
     type: AsduType
     cause: Cause
     address: AsduAddress
-    ios: typing.List[IO]
+    ios: list[IO]
```

## hat/drivers/iec60870/msgs/security/encoder.py

```diff
@@ -1,52 +1,52 @@
 import collections
 import contextlib
 import enum
 import itertools
 import logging
 import typing
 
+from hat import util
+
 from hat.drivers.iec60870.msgs import iec101
 from hat.drivers.iec60870.msgs import iec104
 from hat.drivers.iec60870.msgs.encoder import encode_time, decode_time
 from hat.drivers.iec60870.msgs.security import common
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 
 
-ASDU = typing.Union[common.ASDU,
-                    iec101.common.ASDU,
-                    iec104.common.ASDU]
+ASDU: typing.TypeAlias = common.ASDU | iec101.common.ASDU | iec104.common.ASDU
 
 
 class Encoder:
 
-    def __init__(self, encoder: typing.Union[iec101.encoder.Encoder,
-                                             iec104.encoder.Encoder]):
+    def __init__(self, encoder: (iec101.encoder.Encoder |
+                                 iec104.encoder.Encoder)):
         self._encoder = encoder
         self._buffer = None
 
     def decode_asdu(self,
-                    asdu_bytes: common.Bytes
-                    ) -> typing.Tuple[typing.Optional[ASDU], common.Bytes]:
+                    asdu_bytes: util.Bytes
+                    ) -> tuple[ASDU | None, util.Bytes]:
         asdu_type = asdu_bytes[0]
         with contextlib.suppress(ValueError):
             asdu_type = common.AsduType(asdu_type)
 
         if isinstance(asdu_type, common.AsduType):
             return self._decode_asdu(asdu_bytes, asdu_type)
 
         if self._buffer:
             mlog.warning('unsegmented asdu - discarding buffer')
             self._buffer = None
 
         return self._encoder.decode_asdu(asdu_bytes)
 
-    def encode_asdu(self, asdu: ASDU) -> typing.List[common.Bytes]:
+    def encode_asdu(self, asdu: ASDU) -> list[util.Bytes]:
         if isinstance(asdu, common.ASDU):
             return list(self._encode_asdu(asdu))
 
         return [self._encoder.encode_asdu(asdu)]
 
     def _decode_asdu(self, asdu_bytes, asdu_type):
         io_count, rest = _decode_io_count(asdu_bytes[1:], asdu_type)
@@ -225,15 +225,15 @@
 
 class _Buffer(typing.NamedTuple):
     asdu_type: common.AsduType
     cause: common.Cause
     asdu_address: common.AsduAddress
     prev_first: bool
     prev_segment: int
-    prev_io_bytes: common.Bytes
+    prev_io_bytes: util.Bytes
     all_io_bytes: typing.Iterable[int]
 
 
 def _decode_io_count(qualifier_bytes, asdu_type):
     qualifier, rest = qualifier_bytes[0], qualifier_bytes[1:]
 
     if qualifier & 0x80:
```

## hat/drivers/mms/__init__.py

```diff
@@ -1,14 +1,13 @@
 """Manufacturing Message Specification"""
 
 from hat.drivers.mms.connection import (
-    Address,
-    ConnectionInfo,
-    RequestCb,
     ConnectionCb,
+    RequestCb,
+    UnconfirmedCb,
     connect,
     listen,
     Server,
     Connection)
 
 from hat.drivers.mms.common import (
     DataAccessError,
@@ -85,18 +84,17 @@
     NameVariableSpecification,
     ScatteredAccessDescriptionVariableSpecification,
     VariableDescriptionVariableSpecification,
     VariableSpecification)
 
 
 __all__ = [
-    'Address',
-    'ConnectionInfo',
-    'RequestCb',
     'ConnectionCb',
+    'RequestCb',
+    'UnconfirmedCb',
     'connect',
     'listen',
     'Server',
     'Connection',
     'DataAccessError',
     'ObjectClass',
     'ErrorClass',
```

## hat/drivers/mms/common.py

```diff
@@ -1,13 +1,64 @@
 import abc
 import enum
 import typing
 import datetime
 
 from hat import asn1
+from hat import util
+
+
+Request = type('Request', (abc.ABC, ), {})
+Response = type('Response', (abc.ABC, ), {})
+Unconfirmed = type('Unconfirmed', (abc.ABC, ), {})
+Data = type('Data', (abc.ABC, ), {})
+TypeDescription = type('TypeDescription', (abc.ABC, ), {})
+ObjectName = type('ObjectName', (abc.ABC, ), {})
+ObjectScope = type('ObjectScope', (abc.ABC, ), {})
+VariableSpecification = type('VariableSpecification', (abc.ABC, ), {})
+
+
+def request(cls):
+    Request.register(cls)
+    return cls
+
+
+def response(cls):
+    Response.register(cls)
+    return cls
+
+
+def unconfirmed(cls):
+    Unconfirmed.register(cls)
+    return cls
+
+
+def data(cls):
+    Data.register(cls)
+    return cls
+
+
+def type_description(cls):
+    TypeDescription.register(cls)
+    return cls
+
+
+def object_name(cls):
+    ObjectName.register(cls)
+    return cls
+
+
+def object_scope(cls):
+    ObjectScope.register(cls)
+    return cls
+
+
+def variable_specification(cls):
+    VariableSpecification.register(cls)
+    return cls
 
 
 class DataAccessError(enum.Enum):
     OBJECT_INVALIDATED = 0
     HARDWARE_FAULT = 1
     TEMPORARILY_UNAVAILABLE = 2
     OBJECT_ACCESS_DENIED = 3
@@ -41,380 +92,352 @@
     RESOURCE = 'resource'
     SERVICE = 'service'
     SERVICE_PREEMPT = 'service-preempt'
     TIME_RESOLUTION = 'time-resolution'
     VMD_STATE = 'vmd-state'
 
 
+@request
 class StatusRequest(typing.NamedTuple):
     pass
 
 
+@request
 class GetNameListRequest(typing.NamedTuple):
     object_class: ObjectClass
-    object_scope: 'ObjectScope'
-    continue_after: typing.Optional[str]
+    object_scope: ObjectScope
+    continue_after: str | None
 
 
+@request
 class IdentifyRequest(typing.NamedTuple):
     pass
 
 
+@request
 class GetVariableAccessAttributesRequest(typing.NamedTuple):
-    value: typing.Union['ObjectName', int, str, asn1.Bytes]
+    value: ObjectName | int | str | util.Bytes
 
 
+@request
 class GetNamedVariableListAttributesRequest(typing.NamedTuple):
-    value: 'ObjectName'
+    value: ObjectName
 
 
+@request
 class ReadRequest(typing.NamedTuple):
-    value: typing.Union[typing.List['VariableSpecification'], 'ObjectName']
+    value: list[VariableSpecification] | ObjectName
 
 
+@request
 class WriteRequest(typing.NamedTuple):
-    specification: typing.Union[typing.List['VariableSpecification'],
-                                'ObjectName']
-    data: typing.List['Data']
+    specification: list[VariableSpecification] | ObjectName
+    data: list[Data]
 
 
+@request
 class DefineNamedVariableListRequest(typing.NamedTuple):
-    name: 'ObjectName'
-    specification: typing.List['VariableSpecification']
+    name: ObjectName
+    specification: list[VariableSpecification]
 
 
+@request
 class DeleteNamedVariableListRequest(typing.NamedTuple):
-    names: typing.List['ObjectName']
-
-
-Request = type('Request', (abc.ABC, ), {})
-Request.register(StatusRequest)
-Request.register(GetNameListRequest)
-Request.register(IdentifyRequest)
-Request.register(GetVariableAccessAttributesRequest)
-Request.register(GetNamedVariableListAttributesRequest)
-Request.register(ReadRequest)
-Request.register(WriteRequest)
-Request.register(DefineNamedVariableListRequest)
-Request.register(DeleteNamedVariableListRequest)
+    names: list[ObjectName]
 
 
+@response
 class ErrorResponse(typing.NamedTuple):
     error_class: ErrorClass
     value: int
 
 
+@response
 class StatusResponse(typing.NamedTuple):
     logical: int
     physical: int
 
 
+@response
 class GetNameListResponse(typing.NamedTuple):
-    identifiers: typing.List[str]
+    identifiers: list[str]
     more_follows: bool
 
 
+@response
 class IdentifyResponse(typing.NamedTuple):
     vendor: str
     model: str
     revision: str
-    syntaxes: typing.Optional[typing.List[asn1.ObjectIdentifier]]
+    syntaxes: list[asn1.ObjectIdentifier] | None
 
 
+@response
 class GetVariableAccessAttributesResponse(typing.NamedTuple):
     mms_deletable: bool
-    type_description: 'TypeDescription'
+    type_description: TypeDescription
 
 
+@response
 class GetNamedVariableListAttributesResponse(typing.NamedTuple):
     mms_deletable: bool
-    specification: typing.List['VariableSpecification']
+    specification: list[VariableSpecification]
 
 
+@response
 class ReadResponse(typing.NamedTuple):
-    results: typing.List[typing.Union[DataAccessError, 'Data']]
+    results: list[DataAccessError | Data]
 
 
+@response
 class WriteResponse(typing.NamedTuple):
-    results: typing.List[typing.Optional[DataAccessError]]
+    results: list[DataAccessError | None]
 
 
+@response
 class DefineNamedVariableListResponse(typing.NamedTuple):
     pass
 
 
+@response
 class DeleteNamedVariableListResponse(typing.NamedTuple):
     matched: int
     deleted: int
 
 
-Response = type('Response', (abc.ABC, ), {})
-Response.register(ErrorResponse)
-Response.register(StatusResponse)
-Response.register(GetNameListResponse)
-Response.register(IdentifyResponse)
-Response.register(GetVariableAccessAttributesResponse)
-Response.register(GetNamedVariableListAttributesResponse)
-Response.register(ReadResponse)
-Response.register(WriteResponse)
-Response.register(DefineNamedVariableListResponse)
-Response.register(DeleteNamedVariableListResponse)
-
-
+@unconfirmed
 class EventNotificationUnconfirmed(typing.NamedTuple):
-    enrollment: 'ObjectName'
-    condition: 'ObjectName'
+    enrollment: ObjectName
+    condition: ObjectName
     severity: int
-    time: typing.Optional[typing.Union['Data', int]]
+    time: Data | int | None
 
 
+@unconfirmed
 class InformationReportUnconfirmed(typing.NamedTuple):
-    specification: typing.Union[typing.List['VariableSpecification'],
-                                'ObjectName']
-    data: typing.List[typing.Union[DataAccessError, 'Data']]
+    specification: list[VariableSpecification] | ObjectName
+    data: list[DataAccessError | Data]
 
 
+@unconfirmed
 class UnsolicitedStatusUnconfirmed(typing.NamedTuple):
     logical: int
     physical: int
 
 
-Unconfirmed = type('Unconfirmed', (abc.ABC, ), {})
-Unconfirmed.register(EventNotificationUnconfirmed)
-Unconfirmed.register(InformationReportUnconfirmed)
-Unconfirmed.register(UnsolicitedStatusUnconfirmed)
-
-
+@data
 class ArrayData(typing.NamedTuple):
-    elements: typing.List['Data']
+    elements: list[Data]
 
 
+@data
 class BcdData(typing.NamedTuple):
     value: int
 
 
+@data
 class BinaryTimeData(typing.NamedTuple):
     value: datetime.datetime
 
 
+@data
 class BitStringData(typing.NamedTuple):
-    value: typing.List[bool]
+    value: list[bool]
 
 
+@data
 class BooleanData(typing.NamedTuple):
     value: bool
 
 
+@data
 class BooleanArrayData(typing.NamedTuple):
-    value: typing.List[bool]
+    value: list[bool]
 
 
+@data
 class FloatingPointData(typing.NamedTuple):
     value: float
 
 
+@data
 class GeneralizedTimeData(typing.NamedTuple):
     value: str
 
 
+@data
 class IntegerData(typing.NamedTuple):
     value: int
 
 
+@data
 class MmsStringData(typing.NamedTuple):
     value: str
 
 
+@data
 class ObjIdData(typing.NamedTuple):
     value: asn1.ObjectIdentifier
 
 
+@data
 class OctetStringData(typing.NamedTuple):
     value: asn1.Bytes
 
 
+@data
 class StructureData(typing.NamedTuple):
-    elements: typing.List['Data']
+    elements: list[Data]
 
 
+@data
 class UnsignedData(typing.NamedTuple):
     value: int
 
 
+@data
 class UtcTimeData(typing.NamedTuple):
     value: datetime.datetime
     leap_second: bool
     clock_failure: bool
     not_synchronized: bool
-    accuracy: typing.Optional[int]
+    accuracy: int | None
     """accurate fraction bits [0,24]"""
 
 
+@data
 class VisibleStringData(typing.NamedTuple):
     value: str
 
 
-Data = type('Data', (abc.ABC, ), {})
-Data.register(ArrayData)
-Data.register(BcdData)
-Data.register(BinaryTimeData)
-Data.register(BitStringData)
-Data.register(BooleanData)
-Data.register(BooleanArrayData)
-Data.register(FloatingPointData)
-Data.register(GeneralizedTimeData)
-Data.register(IntegerData)
-Data.register(MmsStringData)
-Data.register(ObjIdData)
-Data.register(OctetStringData)
-Data.register(StructureData)
-Data.register(UnsignedData)
-Data.register(UtcTimeData)
-Data.register(VisibleStringData)
-
-
+@type_description
 class ArrayTypeDescription(typing.NamedTuple):
     number_of_elements: int
-    element_type: typing.Union['TypeDescription', 'ObjectName']
+    element_type: TypeDescription | ObjectName
 
 
+@type_description
 class BcdTypeDescription(typing.NamedTuple):
     xyz: int
 
 
+@type_description
 class BinaryTimeTypeDescription(typing.NamedTuple):
     xyz: bool
 
 
+@type_description
 class BitStringTypeDescription(typing.NamedTuple):
     xyz: int
 
 
+@type_description
 class BooleanTypeDescription(typing.NamedTuple):
     pass
 
 
+@type_description
 class FloatingPointTypeDescription(typing.NamedTuple):
     format_width: int
     exponent_width: int
 
 
+@type_description
 class GeneralizedTimeTypeDescription(typing.NamedTuple):
     pass
 
 
+@type_description
 class IntegerTypeDescription(typing.NamedTuple):
     xyz: int
 
 
+@type_description
 class MmsStringTypeDescription(typing.NamedTuple):
     xyz: int
 
 
+@type_description
 class ObjIdTypeDescription(typing.NamedTuple):
     pass
 
 
+@type_description
 class OctetStringTypeDescription(typing.NamedTuple):
     xyz: int
 
 
+@type_description
 class StructureTypeDescription(typing.NamedTuple):
-    components: typing.List[typing.Tuple[typing.Optional[str],
-                                         typing.Union['TypeDescription',
-                                                      'ObjectName']]]
+    components: list[tuple[str | None, TypeDescription | ObjectName]]
 
 
+@type_description
 class UnsignedTypeDescription(typing.NamedTuple):
     xyz: int
 
 
+@type_description
 class UtcTimeTypeDescription(typing.NamedTuple):
     pass
 
 
+@type_description
 class VisibleStringTypeDescription(typing.NamedTuple):
     xyz: int
 
 
-TypeDescription = type('TypeDescription', (abc.ABC, ), {})
-TypeDescription.register(ArrayTypeDescription)
-TypeDescription.register(BcdTypeDescription)
-TypeDescription.register(BinaryTimeTypeDescription)
-TypeDescription.register(BitStringTypeDescription)
-TypeDescription.register(BooleanTypeDescription)
-TypeDescription.register(FloatingPointTypeDescription)
-TypeDescription.register(GeneralizedTimeTypeDescription)
-TypeDescription.register(IntegerTypeDescription)
-TypeDescription.register(MmsStringTypeDescription)
-TypeDescription.register(ObjIdTypeDescription)
-TypeDescription.register(OctetStringTypeDescription)
-TypeDescription.register(StructureTypeDescription)
-TypeDescription.register(UnsignedTypeDescription)
-TypeDescription.register(UtcTimeTypeDescription)
-TypeDescription.register(VisibleStringTypeDescription)
-
-
+@object_name
 class AaSpecificObjectName(typing.NamedTuple):
     identifier: str
 
 
+@object_name
 class DomainSpecificObjectName(typing.NamedTuple):
     domain_id: str
     item_id: str
 
 
+@object_name
 class VmdSpecificObjectName(typing.NamedTuple):
     identifier: str
 
 
-ObjectName = type('ObjectName', (abc.ABC, ), {})
-ObjectName.register(AaSpecificObjectName)
-ObjectName.register(DomainSpecificObjectName)
-ObjectName.register(VmdSpecificObjectName)
-
-
+@object_scope
 class AaSpecificObjectScope(typing.NamedTuple):
     pass
 
 
+@object_scope
 class DomainSpecificObjectScope(typing.NamedTuple):
     identifier: str
 
 
+@object_scope
 class VmdSpecificObjectScope(typing.NamedTuple):
     pass
 
 
-ObjectScope = type('ObjectScope', (abc.ABC, ), {})
-ObjectScope.register(AaSpecificObjectScope)
-ObjectScope.register(DomainSpecificObjectScope)
-ObjectScope.register(VmdSpecificObjectScope)
-
-
+@variable_specification
 class AddressVariableSpecification(typing.NamedTuple):
-    address: typing.Union[int, str, asn1.Bytes]
+    address: int | str | asn1.Bytes
 
 
+@variable_specification
 class InvalidatedVariableSpecification(typing.NamedTuple):
     pass
 
 
+@variable_specification
 class NameVariableSpecification(typing.NamedTuple):
     name: ObjectName
 
 
+@variable_specification
 class ScatteredAccessDescriptionVariableSpecification(typing.NamedTuple):
-    specifications: typing.List['VariableSpecification']
+    specifications: list[VariableSpecification]
 
 
+@variable_specification
 class VariableDescriptionVariableSpecification(typing.NamedTuple):
-    address: typing.Union[int, str, asn1.Bytes]
-    type_specification: typing.Union[TypeDescription, ObjectName]
-
-
-VariableSpecification = type('VariableSpecification', (abc.ABC, ), {})
-VariableSpecification.register(AddressVariableSpecification)
-VariableSpecification.register(InvalidatedVariableSpecification)
-VariableSpecification.register(NameVariableSpecification)
-VariableSpecification.register(ScatteredAccessDescriptionVariableSpecification)
-VariableSpecification.register(VariableDescriptionVariableSpecification)
+    address: int | str | asn1.Bytes
+    type_specification: TypeDescription | ObjectName
```

## hat/drivers/mms/connection.py

```diff
@@ -1,368 +1,403 @@
 """Manufacturing Message Specification"""
 
 import asyncio
 import importlib.resources
+import itertools
 import logging
 import typing
 
 from hat import aio
 from hat import asn1
+
 from hat.drivers import acse
+from hat.drivers import tcp
 from hat.drivers.mms import common
 from hat.drivers.mms import encoder
 
 
 mlog = logging.getLogger(__name__)
 
+_parameter_cbb = [False] * 10  # 18
+_parameter_cbb[0] = True  # str1
+_parameter_cbb[1] = True  # str2
+_parameter_cbb[2] = True  # vnam
+_parameter_cbb[3] = True  # valt
+_parameter_cbb[4] = True  # vadr
+_parameter_cbb[6] = True  # tpy
+_parameter_cbb[7] = True  # vlis
+
+_service_support = [False] * 85  # 93
+_service_support[0] = True  # status
+_service_support[1] = True  # getNameList
+_service_support[2] = True  # identify
+_service_support[4] = True  # read
+_service_support[5] = True  # write
+_service_support[6] = True  # getVariableAccessAttributes
+_service_support[11] = True  # defineNamedVariableList
+_service_support[12] = True  # getNamedVariableListAttributes
+_service_support[13] = True  # deleteNamedVariableList
+_service_support[79] = True  # informationReport
 
-Address = acse.Address
-"""Address"""
+# not supported - compatibility flags
+_service_support[18] = True  # output
+_service_support[83] = True  # conclude
 
+# (iso, standard, iso9506, part, mms-abstract-syntax-version1)
+_mms_syntax_name = (1, 0, 9506, 2, 1)
 
-IdentifiedEntity = acse.IdentifiedEntity
-"""Identified entity"""
+# (iso, standard, iso9506, part, mms-annex-version1)
+_mms_app_context_name = (1, 0, 9506, 2, 3)
 
+with importlib.resources.as_file(importlib.resources.files(__package__) /
+                                 'asn1_repo.json') as _path:
+    _encoder = asn1.Encoder(asn1.Encoding.BER,
+                            asn1.Repository.from_json(_path))
 
-ConnectionInfo = acse.ConnectionInfo
-"""Connection info"""
 
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[['Connection'], None]
+"""Connection callback"""
 
-RequestCb = aio.AsyncCallable[['Connection', common.Request], common.Response]
+RequestCb: typing.TypeAlias = aio.AsyncCallable[['Connection', common.Request],
+                                                common.Response]
 """Request callback"""
 
+UnconfirmedCb: typing.TypeAlias = aio.AsyncCallable[['Connection',
+                                                     common.Unconfirmed],
+                                                    None]
+"""Unconfirmed callback"""
 
-ConnectionCb = aio.AsyncCallable[['Connection'], None]
-"""Connection callback"""
 
-
-async def connect(request_cb: RequestCb,
-                  addr: Address,
-                  local_tsel: typing.Optional[int] = None,
-                  remote_tsel: typing.Optional[int] = None,
-                  local_ssel: typing.Optional[int] = None,
-                  remote_ssel: typing.Optional[int] = None,
-                  local_psel: typing.Optional[int] = None,
-                  remote_psel: typing.Optional[int] = None,
-                  local_ap_title: typing.Optional[asn1.ObjectIdentifier] = None,  # NOQA
-                  remote_ap_title: typing.Optional[asn1.ObjectIdentifier] = None,  # NOQA
-                  local_ae_qualifier: typing.Optional[int] = None,
-                  remote_ae_qualifier: typing.Optional[int] = None,
-                  user_data: typing.Optional[IdentifiedEntity] = None
+async def connect(addr: tcp.Address,
+                  request_cb: RequestCb | None = None,
+                  unconfirmed_cb: UnconfirmedCb | None = None,
+                  **kwargs
                   ) -> 'Connection':
-    """Connect to ACSE server"""
+    """Connect to MMS server
+
+    Additional arguments are passed directly to `hat.drivers.acse.connect`
+    (`syntax_name_list`, `app_context_name` and `user_data` are set by
+    this coroutine).
+
+    """
     initiate_req = 'initiate-RequestPDU', {
         'proposedMaxServOutstandingCalling': 5,
         'proposedMaxServOutstandingCalled': 5,
         'initRequestDetail': {
             'proposedVersionNumber': 1,
             'proposedParameterCBB': _parameter_cbb,
             'servicesSupportedCalling': _service_support}}
     req_user_data = _encode(initiate_req)
-    acse_conn = await acse.connect(syntax_name_list=[_mms_syntax_name],
-                                   app_context_name=_mms_app_context_name,
-                                   addr=addr,
-                                   local_tsel=local_tsel,
-                                   remote_tsel=remote_tsel,
-                                   local_ssel=local_ssel,
-                                   remote_ssel=remote_ssel,
-                                   local_psel=local_psel,
-                                   remote_psel=remote_psel,
-                                   local_ap_title=local_ap_title,
-                                   remote_ap_title=remote_ap_title,
-                                   local_ae_qualifier=local_ae_qualifier,
-                                   remote_ae_qualifier=remote_ae_qualifier,
-                                   user_data=(_mms_syntax_name, req_user_data))
+    conn = await acse.connect(addr, [_mms_syntax_name], _mms_app_context_name,
+                              (_mms_syntax_name, req_user_data), **kwargs)
+
     try:
-        res_syntax_name, res_user_data = acse_conn.conn_res_user_data
+        res_syntax_name, res_user_data = conn.conn_res_user_data
         if res_syntax_name != _mms_syntax_name:
             raise Exception("invalid syntax name")
+
         initiate_res = _decode(res_user_data)
         if initiate_res[0] != 'initiate-ResponsePDU':
             raise Exception("invalid initiate response")
-        return _create_connection(request_cb, acse_conn)
+
+        return Connection(conn, request_cb, unconfirmed_cb)
+
     except Exception:
-        await aio.uncancellable(acse_conn.async_close())
+        await aio.uncancellable(conn.async_close())
         raise
 
 
 async def listen(connection_cb: ConnectionCb,
-                 request_cb: RequestCb,
-                 addr: Address = Address('0.0.0.0', 102)
+                 addr: tcp.Address = tcp.Address('0.0.0.0', 102),
+                 request_cb: RequestCb | None = None,
+                 unconfirmed_cb: UnconfirmedCb | None = None,
+                 *,
+                 bind_connections: bool = False,
+                 **kwargs
                  ) -> 'Server':
     """Create MMS listening server
 
+    Additional arguments are passed directly to `hat.drivers.acse.listen`.
+
     Args:
         connection_cb: new connection callback
         request_cb: received request callback
         addr: local listening address
 
     """
+    server = Server()
+    server._connection_cb = connection_cb
+    server._request_cb = request_cb
+    server._unconfirmed_cb = unconfirmed_cb
+    server._bind_connections = bind_connections
+
+    server._srv = await acse.listen(server._on_validate,
+                                    server._on_connection,
+                                    addr,
+                                    bind_connections=False,
+                                    **kwargs)
+
+    return server
+
+
+class Server(aio.Resource):
+    """MMS listening server
+
+    For creating new server see `listen`.
+
+    """
+
+    @property
+    def async_group(self) -> aio.Group:
+        """Async group"""
+        return self._srv.async_group
+
+    @property
+    def addresses(self) -> list[tcp.Address]:
+        """Listening addresses"""
+        return self._srv.addresses
 
-    async def on_validate(syntax_names, user_data):
+    async def _on_validate(self, syntax_names, user_data):
         syntax_name, req_user_data = user_data
         if syntax_name != _mms_syntax_name:
             raise Exception('invalid mms syntax name')
+
         initiate_req = _decode(req_user_data)
         if initiate_req[0] != 'initiate-RequestPDU':
             raise Exception('invalid initiate request')
+
         initiate_res = 'initiate-ResponsePDU', {
             'negotiatedMaxServOutstandingCalling': 5,
             'negotiatedMaxServOutstandingCalled': 5,
             'negotiatedDataStructureNestingLevel': 4,  # TODO compatibility
             'initResponseDetail': {
                 'negotiatedVersionNumber': 1,
                 'negotiatedParameterCBB': _parameter_cbb,
                 'servicesSupportedCalled': _service_support}}
         if 'localDetailCalling' in initiate_req[1]:
             initiate_res[1]['localDetailCalled'] = \
                 initiate_req[1]['localDetailCalling']
+
         res_user_data = _encode(initiate_res)
         return _mms_syntax_name, res_user_data
 
-    async def on_connection(acse_conn):
+    async def _on_connection(self, acse_conn):
         try:
             try:
-                conn = _create_connection(request_cb, acse_conn)
+                conn = Connection(acse_conn, self._request_cb,
+                                  self._unconfirmed_cb)
+
             except Exception:
                 await aio.uncancellable(acse_conn.async_close())
                 raise
+
             try:
-                await aio.call(connection_cb, conn)
+                await aio.call(self._connection_cb, conn)
+
             except BaseException:
                 await aio.uncancellable(conn.async_close())
                 raise
+
         except Exception as e:
             mlog.error("error creating new incomming connection: %s",
                        e, exc_info=e)
+            return
 
-    async def wait_acse_server_closed():
-        try:
-            await acse_server.wait_closed()
-        finally:
-            async_group.close()
-
-    async_group = aio.Group()
-    acse_server = await acse.listen(on_validate, on_connection, addr)
-    async_group.spawn(aio.call_on_cancel, acse_server.async_close)
-    async_group.spawn(wait_acse_server_closed)
-
-    srv = Server()
-    srv._async_group = async_group
-    srv._acse_server = acse_server
-    return srv
-
-
-class Server(aio.Resource):
-    """MMS listening server
-
-    For creating new server see :func:`listen`
-
-    Closing server doesn't close active incomming connections
-
-    """
-
-    @property
-    def async_group(self) -> aio.Group:
-        """Async group"""
-        return self._async_group
-
-    @property
-    def addresses(self) -> typing.List[Address]:
-        """Listening addresses"""
-        return self._acse_server.addresses
+        if not self._bind_connections:
+            return
 
+        try:
+            await conn.wait_closed()
 
-def _create_connection(request_cb, acse_conn):
-    conn = Connection()
-    conn._request_cb = request_cb
-    conn._acse_conn = acse_conn
-    conn._last_invoke_id = 0
-    conn._unconfirmed_queue = aio.Queue()
-    conn._response_futures = {}
-    conn._async_group = aio.Group()
-    conn._async_group.spawn(conn._read_loop)
-    return conn
+        except BaseException:
+            await aio.uncancellable(conn.async_close())
+            raise
 
 
 class Connection(aio.Resource):
     """MMS connection
 
-    For creating new connection see :func:`connect`
+    For creating new connection see `connect` or `listen`.
 
     """
 
+    def __init__(self,
+                 conn: acse.Connection,
+                 request_cb: RequestCb,
+                 unconfirmed_cb: UnconfirmedCb):
+        self._conn = conn
+        self._request_cb = request_cb
+        self._unconfirmed_cb = unconfirmed_cb
+        self._loop = asyncio.get_running_loop()
+        self._next_invoke_ids = itertools.count(0)
+        self._response_futures = {}
+        self._close_pdu = 'conclude-RequestPDU', None
+        self._async_group = aio.Group()
+
+        self.async_group.spawn(aio.call_on_cancel, self._on_close)
+        self.async_group.spawn(self._receive_loop)
+        self.async_group.spawn(aio.call_on_done, conn.wait_closing(),
+                               self.close)
+
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._async_group
 
     @property
-    def info(self) -> ConnectionInfo:
+    def info(self) -> acse.ConnectionInfo:
         """Connection info"""
-        return self._acse_conn.info
-
-    async def receive_unconfirmed(self) -> common.Unconfirmed:
-        """Receive unconfirmed message
+        return self._conn.info
 
-        Raises:
-            ConnectionError: in case connection is not open
-
-        """
-        try:
-            return await self._unconfirmed_queue.get()
-        except aio.QueueClosedError:
-            raise ConnectionError('connection is not open')
-
-    def send_unconfirmed(self, unconfirmed: common.Unconfirmed):
+    async def send_unconfirmed(self, unconfirmed: common.Unconfirmed):
         """Send unconfirmed message"""
+        if not self.is_open:
+            raise ConnectionError()
+
         pdu = 'unconfirmed-PDU', {
             'service': encoder.encode_unconfirmed(unconfirmed)}
         data = _mms_syntax_name, _encode(pdu)
-        self._acse_conn.write(data)
+        await self._conn.send(data)
 
     async def send_confirmed(self,
                              req: common.Request
                              ) -> common.Response:
-        """Send confirmed request and wait for response
+        """Send confirmed request and wait for response"""
+        if not self.is_open:
+            raise ConnectionError()
 
-        Raises:
-            ConnectionError: in case connection is not open
-
-        """
-        if self._async_group.is_closing:
-            raise ConnectionError('connection is not open')
-        invoke_id = self._last_invoke_id + 1
+        invoke_id = next(self._next_invoke_ids)
         pdu = 'confirmed-RequestPDU', {
             'invokeID': invoke_id,
             'service': encoder.encode_request(req)}
         data = _mms_syntax_name, _encode(pdu)
-        self._acse_conn.write(data)
-        self._last_invoke_id = invoke_id
-        self._response_futures[invoke_id] = asyncio.Future()
+        await self._conn.send(data)
+
+        if not self.is_open:
+            raise ConnectionError()
+
         try:
-            return await self._response_futures[invoke_id]
+            future = self._loop.create_future()
+            self._response_futures[invoke_id] = future
+            return await future
+
         finally:
-            del self._response_futures[invoke_id]
+            self._response_futures.pop(invoke_id, None)
+
+    async def _on_close(self):
+        if self._conn.is_open:
+            try:
+                data = _mms_syntax_name, _encode(self._close_pdu)
+                await self._conn.send(data)
+                await self._conn.drain()
+
+                # TODO: wait for response in case of conclude-RequestPDU
 
-    async def _read_loop(self):
-        running = True
+            except Exception as e:
+                mlog.error("on close error: %s", e, exc_info=e)
+
+        await self._conn.async_close()
+
+    async def _receive_loop(self):
         try:
-            while running:
-                syntax_name, entity = await self._acse_conn.read()
+            while True:
+                syntax_name, entity = await self._conn.receive()
                 if syntax_name != _mms_syntax_name:
                     continue
+
                 pdu = _decode(entity)
-                running = await self._process_pdu(pdu)
-        except asyncio.CancelledError:
-            pdu = 'conclude-RequestPDU', None
-            data = _mms_syntax_name, _encode(pdu)
-            self._acse_conn.write(data)
-            # TODO: wait for response
-            raise
+                name, data = pdu
+
+                if name == 'unconfirmed-PDU':
+                    await self._process_unconfirmed(data)
+
+                elif name == 'confirmed-RequestPDU':
+                    await self._process_request(data)
+
+                elif name == 'confirmed-ResponsePDU':
+                    await self._process_response(data)
+
+                elif name == 'confirmed-ErrorPDU':
+                    await self._process_error(data)
+
+                elif name == 'conclude-RequestPDU':
+                    self._close_pdu = 'conclude-ResponsePDU', None
+                    break
+
+                else:
+                    raise Exception('unsupported pdu')
+
+        except ConnectionError:
+            pass
+
+        except Exception as e:
+            mlog.error("receive loop error: %s", e, exc_info=e)
+
         finally:
-            self._async_group.close()
-            self._unconfirmed_queue.close()
+            self.close()
+
             for response_future in self._response_futures.values():
                 if not response_future.done():
-                    response_future.set_exception(
-                        ConnectionError('connection is not open'))
-            await aio.uncancellable(self._acse_conn.async_close())
-
-    async def _process_pdu(self, pdu):
-        name, data = pdu
-
-        if name == 'unconfirmed-PDU':
-            unconfirmed = encoder.decode_unconfirmed(data['service'])
-            await self._unconfirmed_queue.put(unconfirmed)
-            return True
-
-        elif name == 'confirmed-RequestPDU':
-            invoke_id = data['invokeID']
-            req = encoder.decode_request(data['service'])
-            res = await aio.call(self._request_cb, self, req)
-            if isinstance(res, common.ErrorResponse):
-                res_pdu = 'confirmed-ErrorPDU', {
-                    'invokeID': invoke_id,
-                    'serviceError': {
-                        'errorClass': (res.error_class.value, res.value)}}
-            else:
-                res_pdu = 'confirmed-ResponsePDU', {
-                    'invokeID': invoke_id,
-                    'service': encoder.encode_response(res)}
-            res_data = _mms_syntax_name, _encode(res_pdu)
-            self._acse_conn.write(res_data)
-            return True
-
-        elif name == 'confirmed-ResponsePDU':
-            invoke_id = data['invokeID']
-            res = encoder.decode_response(data['service'])
-            future = self._response_futures.get(invoke_id)
-            if future and not future.done():
-                future.set_result(res)
-            else:
-                mlog.warn(f"dropping confirmed response "
-                          f"(invoke_id: {invoke_id})")
-            return True
-
-        elif name == 'confirmed-ErrorPDU':
-            invoke_id = data['invokeID']
-            error_class_name, value = data['serviceError']['errorClass']
-            error_class = common.ErrorClass(error_class_name)
-            res = common.ErrorResponse(error_class, value)
-            future = self._response_futures.get(invoke_id)
-            if future and not future.done():
-                future.set_result(res)
-            else:
-                mlog.warn(f"dropping confirmed error "
-                          f"(invoke_id: {invoke_id})")
-            return True
-
-        elif name == 'conclude-RequestPDU':
-            res_pdu = 'conclude-ResponsePDU', None
-            res_data = _mms_syntax_name, _encode(res_pdu)
-            self._acse_conn.write(res_data)
-            return False
+                    response_future.set_exception(ConnectionError())
 
-        return False
+    async def _process_unconfirmed(self, data):
+        unconfirmed = encoder.decode_unconfirmed(data['service'])
 
+        if self._unconfirmed_cb is None:
+            raise Exception('unconfirmed_cb not defined')
 
-_parameter_cbb = [False] * 10  # 18
-_parameter_cbb[0] = True  # str1
-_parameter_cbb[1] = True  # str2
-_parameter_cbb[2] = True  # vnam
-_parameter_cbb[3] = True  # valt
-_parameter_cbb[4] = True  # vadr
-_parameter_cbb[6] = True  # tpy
-_parameter_cbb[7] = True  # vlis
+        await aio.call(self._unconfirmed_cb, self, unconfirmed)
 
-_service_support = [False] * 85  # 93
-_service_support[0] = True  # status
-_service_support[1] = True  # getNameList
-_service_support[2] = True  # identify
-_service_support[4] = True  # read
-_service_support[5] = True  # write
-_service_support[6] = True  # getVariableAccessAttributes
-_service_support[11] = True  # defineNamedVariableList
-_service_support[12] = True  # getNamedVariableListAttributes
-_service_support[13] = True  # deleteNamedVariableList
-_service_support[79] = True  # informationReport
+    async def _process_request(self, data):
+        invoke_id = data['invokeID']
+        req = encoder.decode_request(data['service'])
 
-# not supported - compatibility flags
-_service_support[18] = True  # output
-_service_support[83] = True  # conclude
+        if self._request_cb is None:
+            raise Exception('request_cb not defined')
 
+        res = await aio.call(self._request_cb, self, req)
 
-# (iso, standard, iso9506, part, mms-abstract-syntax-version1)
-_mms_syntax_name = (1, 0, 9506, 2, 1)
-# (iso, standard, iso9506, part, mms-annex-version1)
-_mms_app_context_name = (1, 0, 9506, 2, 3)
-with importlib.resources.path(__package__, 'asn1_repo.json') as _path:
-    _encoder = asn1.Encoder(asn1.Encoding.BER,
-                            asn1.Repository.from_json(_path))
+        if isinstance(res, common.ErrorResponse):
+            res_pdu = 'confirmed-ErrorPDU', {
+                'invokeID': invoke_id,
+                'serviceError': {
+                    'errorClass': (res.error_class.value, res.value)}}
+
+        else:
+            res_pdu = 'confirmed-ResponsePDU', {
+                'invokeID': invoke_id,
+                'service': encoder.encode_response(res)}
+
+        res_data = _mms_syntax_name, _encode(res_pdu)
+        await self._conn.send(res_data)
+
+    async def _process_response(self, data):
+        invoke_id = data['invokeID']
+        res = encoder.decode_response(data['service'])
+
+        future = self._response_futures.get(invoke_id)
+        if not future or future.done():
+            mlog.warning("dropping confirmed response (invoke_id: %s)",
+                         invoke_id)
+            return
+
+        future.set_result(res)
+
+    async def _process_error(self, data):
+        invoke_id = data['invokeID']
+        error_class_name, value = data['serviceError']['errorClass']
+        error_class = common.ErrorClass(error_class_name)
+        res = common.ErrorResponse(error_class, value)
+
+        future = self._response_futures.get(invoke_id)
+        if not future or future.done():
+            mlog.warning("dropping confirmed error (invoke_id: %s)", invoke_id)
+            return
+
+        future.set_result(res)
 
 
 def _encode(value):
     return _encoder.encode_value('ISO-9506-MMS-1', 'MMSpdu', value)
 
 
 def _decode(entity):
```

## hat/drivers/mms/encoder.py

```diff
@@ -1,11 +1,12 @@
 import datetime
 import struct
 
 from hat import asn1
+
 from hat.drivers.mms import common
 
 
 def encode_request(req: common.Request) -> asn1.Value:
     """Encode request"""
     if isinstance(req, common.StatusRequest):
         return 'status', False
```

## hat/drivers/modbus/master.py

```diff
@@ -14,89 +14,101 @@
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
 
 
 async def create_tcp_master(modbus_type: common.ModbusType,
                             addr: tcp.Address,
+                            response_timeout: float | None = None,
                             **kwargs
                             ) -> 'Master':
     """Create TCP master
 
     Args:
         modbus_type: modbus type
         addr: remote host address
+        response_timeout: response timeout in seconds
         kwargs: additional arguments used for creating TCP connection
             (see `tcp.connect`)
 
     """
     conn = await transport.tcp_connect(addr, **kwargs)
-    return Master(conn, modbus_type)
+    return Master(conn, modbus_type, response_timeout)
 
 
 async def create_serial_master(modbus_type: common.ModbusType,
                                port: str, *,
                                silent_interval: float = 0.005,
+                               response_timeout: float | None = None,
                                **kwargs
                                ) -> 'Master':
     """Create serial master
 
     Args:
         modbus_type: modbus type
         port: port name (see `serial.create`)
         silent_interval: silent interval (see `serial.create`)
+        response_timeout: response timeout in seconds
         kwargs: additional arguments used for opening serial connection
             (see `serial.create`)
 
     """
     conn = await transport.serial_create(port,
                                          silent_interval=silent_interval,
                                          **kwargs)
-    return Master(conn, modbus_type)
+    return Master(conn, modbus_type, response_timeout)
 
 
 class Master(aio.Resource):
     """Modbus master"""
 
     def __init__(self,
                  conn: transport.Connection,
-                 modbus_type: common.ModbusType):
+                 modbus_type: common.ModbusType,
+                 response_timeout: float | None):
         self._conn = conn
         self._modbus_type = modbus_type
+        self._response_timeout = response_timeout
         self._send_queue = aio.Queue()
 
         if modbus_type == common.ModbusType.TCP:
             self._next_transaction_ids = iter(i % 0x10000
                                               for i in itertools.count(1))
 
         self.async_group.spawn(self._send_loop)
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._conn.async_group
 
+    @property
+    def log_prefix(self) -> str:
+        """Logging prefix"""
+        return self._conn.log_prefix
+
     async def read(self,
                    device_id: int,
                    data_type: common.DataType,
                    start_address: int,
                    quantity: int = 1
-                   ) -> typing.Union[typing.List[int], common.Error]:
+                   ) -> list[int] | common.Error:
         """Read data from modbus device
 
         Argument `quantity` is ignored if `data_type` is `QUEUE`.
 
         Args:
             device_id: slave device identifier
             data_type: data type
             start_address: starting modbus data address
             quantity: number of data values
 
         Raises:
             ConnectionError
+            TimeoutError
 
         """
         if device_id == 0:
             raise ValueError('unsupported device id')
 
         if data_type == common.DataType.COIL:
             req = transport.ReadCoilsReq(address=start_address,
@@ -137,28 +149,29 @@
         raise ValueError("unsupported response pdu")
 
     async def write(self,
                     device_id: int,
                     data_type: common.DataType,
                     start_address: int,
                     values: typing.List[int]
-                    ) -> typing.Optional[common.Error]:
+                    ) -> common.Error | None:
         """Write data to modbus device
 
         Data types `DISCRETE_INPUT`, `INPUT_REGISTER` and `QUEUE` are not
         supported.
 
         Args:
             device_id: slave device identifier
             data_type: data type
             start_address: starting modbus data address
             values: values
 
         Raises:
             ConnectionError
+            TimeoutError
 
         """
         if data_type == common.DataType.COIL:
             if len(values) == 1:
                 req = transport.WriteSingleCoilReq(address=start_address,
                                                    value=values[0])
 
@@ -204,25 +217,26 @@
                 raise Exception("invalid response pdu quantity")
 
     async def write_mask(self,
                          device_id: int,
                          address: int,
                          and_mask: int,
                          or_mask: int
-                         ) -> typing.Optional[common.Error]:
+                         ) -> common.Error | None:
         """Write mask to modbus device HOLDING_REGISTER
 
         Args:
             device_id: slave device identifier
             address: modbus data address
             and_mask: and mask
             or_mask: or mask
 
         Raises:
             ConnectionError
+            TimeoutError
 
         """
         req = transport.MaskWriteRegisterReq(address=address,
                                              and_mask=and_mask,
                                              or_mask=or_mask)
 
         res = await self._send(device_id, req)
@@ -279,82 +293,90 @@
         res_fc = transport.get_pdu_function_code(res_adu.pdu)
         if req_fc != res_fc:
             raise Exception("invalid response function code")
 
         return res_adu.pdu
 
     async def _send_loop(self):
-        mlog.debug("starting master send loop")
+        self._log(logging.DEBUG, "starting master send loop")
         future = None
         try:
             while self.is_open:
+                # req_adu, future = await self._send_queue.get()
+
                 async with self.async_group.create_subgroup() as subgroup:
                     subgroup.spawn(self._reset_input_buffer_loop)
-                    mlog.debug("started discarding incomming data")
+                    self._log(logging.DEBUG,
+                              "started discarding incomming data")
 
                     while not future or future.done():
                         req_adu, future = await self._send_queue.get()
 
                 await self._reset_input_buffer()
-                mlog.debug("stopped discarding incomming data")
+                self._log(logging.DEBUG, "stopped discarding incomming data")
 
                 await self._conn.send(req_adu)
 
-                async with self.async_group.create_subgroup() as subgroup:
-                    task = subgroup.spawn(self._receive)
+                async with self.async_group.create_subgroup(
+                        log_exceptions=False) as subgroup:
+                    receive_task = subgroup.spawn(self._conn.receive,
+                                                  self._modbus_type,
+                                                  transport.Direction.RESPONSE)
 
-                    await asyncio.wait([task, future],
+                    await asyncio.wait([receive_task, future],
+                                       timeout=self._response_timeout,
                                        return_when=asyncio.FIRST_COMPLETED)
 
-                    if task.done() and self.is_open and not future.done():
-                        future.set_result(task.result())
+                    if future.done():
+                        continue
+
+                    if receive_task.done():
+                        future.set_result(receive_task.result())
+
+                    else:
+                        future.set_exception(TimeoutError())
 
         except ConnectionError:
             pass
 
         except Exception as e:
-            mlog.error("error in send loop: %s", e, exc_info=e)
+            self._log(logging.ERROR, "error in send loop: %s", e, exc_info=e)
 
         finally:
-            mlog.debug("stopping master send loop")
+            self._log(logging.DEBUG, "stopping master send loop")
             self.close()
             self._send_queue.close()
 
             while True:
                 if future and not future.done():
                     future.set_exception(ConnectionError())
                 if self._send_queue.empty():
                     break
                 _, future = self._send_queue.get_nowait()
 
     async def _reset_input_buffer_loop(self):
         try:
             while True:
                 await self._reset_input_buffer()
+
                 await self._conn.read_byte()
-                mlog.debug("discarded 1 byte from input buffer")
+                self._log(logging.DEBUG, "discarded 1 byte from input buffer")
 
         except ConnectionError:
             self.close()
 
         except Exception as e:
-            mlog.error("error in reset input buffer loop: %s", e, exc_info=e)
+            self._log(logging.ERROR, "error in reset input buffer loop: %s", e,
+                      exc_info=e)
             self.close()
 
     async def _reset_input_buffer(self):
         count = await self._conn.reset_input_buffer()
         if not count:
             return
-        mlog.debug("discarded %s bytes from input buffer", count)
+        self._log(logging.DEBUG, "discarded %s bytes from input buffer", count)
 
-    async def _receive(self):
-        try:
-            return await self._conn.receive(
-                modbus_type=self._modbus_type,
-                direction=transport.Direction.RESPONSE)
-
-        except ConnectionError:
-            self.close()
+    def _log(self, level, msg, *args, **kwargs):
+        if not mlog.isEnabledFor(level):
+            return
 
-        except Exception as e:
-            mlog.error("receive error: %s", e, exc_info=e)
-            self.close()
+        mlog.log(level, f"{self.log_prefix}: {msg}", *args, **kwargs)
```

## hat/drivers/modbus/slave.py

```diff
@@ -9,63 +9,63 @@
 from hat.drivers.modbus import common
 from hat.drivers.modbus import transport
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
 
-SlaveCb = aio.AsyncCallable[['Slave'], None]
+SlaveCb: typing.TypeAlias = aio.AsyncCallable[['Slave'], None]
 """Slave callback"""
 
-ReadCb = aio.AsyncCallable[['Slave',
-                            int,
-                            common.DataType,
-                            int,
-                            typing.Optional[int]
-                            ], typing.Union[typing.List[int], common.Error]]
+ReadCb: typing.TypeAlias = aio.AsyncCallable[['Slave',
+                                              int,
+                                              common.DataType,
+                                              int,
+                                              int | None
+                                              ], list[int] | common.Error]
 """Read callback
 
 Args:
     slave: slave instance
     device_id: device identifier
     data_type: data type
     start_address: staring address
     quantity: number of registers
 
 Returns:
     list of register values or error
 
 """
 
-WriteCb = aio.AsyncCallable[['Slave',
-                             int,
-                             common.DataType,
-                             int,
-                             typing.List[int]
-                             ], typing.Optional[common.Error]]
+WriteCb: typing.TypeAlias = aio.AsyncCallable[['Slave',
+                                               int,
+                                               common.DataType,
+                                               int,
+                                               list[int]
+                                               ], common.Error | None]
 """Write callback
 
 Args:
     slave: slave instance
     device_id: device identifier
     data_type: data type
     start_address: staring address
     values: register values
 
 Returns:
     `None` on success or error
 
 """
 
-WriteMaskCb = aio.AsyncCallable[['Slave',
-                                 int,
-                                 int,
-                                 int,
-                                 int
-                                 ], typing.Optional[common.Error]]
+WriteMaskCb: typing.TypeAlias = aio.AsyncCallable[['Slave',
+                                                   int,
+                                                   int,
+                                                   int,
+                                                   int
+                                                   ], common.Error | None]
 """Write mask callback
 
 Args:
     slave: slave instance
     device_id: device identifier
     address: address
     and_mask: and mask
@@ -111,15 +111,17 @@
         try:
             if slave_cb:
                 await aio.call(slave_cb, slave)
 
             await slave.wait_closing()
 
         except Exception as e:
-            mlog.error("error in slave callback: %s", e, exc_info=e)
+            if mlog.isEnabledFor(logging.ERROR):
+                mlog.error(f"tcp local ({addr.host}:{addr.port}): "
+                           f"error in slave callback: %s", e, exc_info=e)
 
         finally:
             slave.close()
 
     return await transport.tcp_listen(on_connection, addr, **kwargs)
 
 
@@ -172,49 +174,58 @@
         self.async_group.spawn(self._receive_loop)
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._conn.async_group
 
+    @property
+    def log_prefix(self) -> str:
+        """Logging prefix"""
+        return self._conn.log_prefix
+
     async def _receive_loop(self):
-        mlog.debug("starting slave receive loop")
+        self._log(logging.DEBUG, "starting slave receive loop")
         try:
             while True:
                 try:
-                    mlog.debug("waiting for request")
+                    self._log(logging.DEBUG, "waiting for request")
                     req_adu = await self._conn.receive(
                         modbus_type=self._modbus_type,
                         direction=transport.Direction.REQUEST)
 
                 except ConnectionError:
                     break
 
                 except Exception as e:
-                    mlog.warning("error receiving request: %s", e, exc_info=e)
+                    self._log(logging.WARNING, "error receiving request: %s",
+                              e, exc_info=e)
                     continue
 
                 device_id = req_adu.device_id
                 req = req_adu.pdu
 
                 try:
-                    mlog.debug("processing request (device_id %s): %s",
-                               device_id, req)
+                    self._log(logging.DEBUG,
+                              "processing request (device_id %s): %s",
+                              device_id, req)
                     res = await self._process_request(device_id, req)
 
                 except Exception as e:
-                    mlog.warning("error processing request: %s", e, exc_info=e)
+                    self._log(logging.WARNING, "error processing request: %s",
+                              e, exc_info=e)
                     continue
 
                 if device_id == 0:
-                    mlog.debug("skip sending response (broadcast request): %s",
-                               res)
+                    self._log(logging.DEBUG,
+                              "skip sending response (broadcast request): %s",
+                              res)
                     continue
 
-                mlog.debug("sending response: %s", res)
+                self._log(logging.DEBUG, "sending response: %s", res)
 
                 if self._modbus_type == common.ModbusType.TCP:
                     res_adu = transport.TcpAdu(
                         transaction_id=req_adu.transaction_id,
                         device_id=req_adu.device_id,
                         pdu=res)
 
@@ -232,22 +243,23 @@
                 try:
                     await self._conn.send(res_adu)
 
                 except ConnectionError:
                     break
 
                 except Exception as e:
-                    mlog.warning("error sending response: %s", e, exc_info=e)
+                    self._log(logging.WARNING, "error sending response: %s", e,
+                              exc_info=e)
                     continue
 
         except Exception as e:
-            mlog.error("receive loop error: %s", e, exc_info=e)
+            self._log(logging.ERROR, "receive loop error: %s", e, exc_info=e)
 
         finally:
-            mlog.debug("closing slave receive loop")
+            self._log(logging.DEBUG, "closing slave receive loop")
             self.close()
 
     async def _process_request(self, device_id, req):
         if isinstance(req, transport.ReadCoilsReq):
             result = await self._call_read_cb(
                 device_id=device_id,
                 data_type=common.DataType.COIL,
@@ -396,45 +408,54 @@
 
         return transport.ErrorRes(fc=transport.get_pdu_function_code(req),
                                   error=common.Error.INVALID_FUNCTION_CODE)
 
     async def _call_read_cb(self, device_id, data_type, start_address,
                             quantity):
         if not self._read_cb:
-            mlog.debug("read callback not defined")
+            self._log(logging.DEBUG, "read callback not defined")
             return common.Error.FUNCTION_ERROR
 
         try:
             return await aio.call(self._read_cb, self, device_id, data_type,
                                   start_address, quantity)
 
         except Exception as e:
-            mlog.warning("error in read callback: %s", e, exc_info=e)
+            self._log(logging.WARNING, "error in read callback: %s", e,
+                      exc_info=e)
             return common.Error.FUNCTION_ERROR
 
     async def _call_write_cb(self, device_id, data_type, start_address,
                              values):
         if not self._write_cb:
-            mlog.debug("write callback not defined")
+            self._log(logging.DEBUG, "write callback not defined")
             return common.Error.FUNCTION_ERROR
 
         try:
             return await aio.call(self._write_cb, self, device_id, data_type,
                                   start_address, values)
 
         except Exception as e:
-            mlog.warning("error in write callback: %s", e, exc_info=e)
+            self._log(logging.WARNING, "error in write callback: %s", e,
+                      exc_info=e)
             return common.Error.FUNCTION_ERROR
 
     async def _call_write_mask_cb(self, device_id, address, and_mask,
                                   or_mask):
         if not self._write_mask_cb:
-            mlog.debug("write mask callback not defined")
+            self._log(logging.DEBUG, "write mask callback not defined")
             return common.Error.FUNCTION_ERROR
 
         try:
             return await aio.call(self._write_mask_cb, self, device_id,
                                   address, and_mask, or_mask)
 
         except Exception as e:
-            mlog.warning("error in write mask callback: %s", e, exc_info=e)
+            self._log(logging.WARNING, "error in write mask callback: %s", e,
+                      exc_info=e)
             return common.Error.FUNCTION_ERROR
+
+    def _log(self, level, msg, *args, **kwargs):
+        if not mlog.isEnabledFor(level):
+            return
+
+        mlog.log(level, f"{self.log_prefix}: {msg}", *args, **kwargs)
```

## hat/drivers/modbus/transport/common.py

```diff
@@ -1,16 +1,28 @@
 from hat.drivers.modbus.common import *  # NOQA
-from hat.drivers.modbus.common import Error
 
 import abc
 import enum
 import typing
 
+from hat.drivers.modbus.common import Error
+
+
+Request = type('Request', (abc.ABC, ), {})
+Response = type('Response', (abc.ABC, ), {})
+
+
+def request(cls):
+    Request.register(cls)
+    return cls
 
-Bytes = typing.Union[bytes, bytearray, memoryview]
+
+def response(cls):
+    Response.register(cls)
+    return cls
 
 
 class Direction(enum.Enum):
     REQUEST = 0
     RESPONSE = 1
 
 
@@ -23,143 +35,137 @@
     WRITE_SINGLE_REGISTER = 6
     WRITE_MULTIPLE_COILS = 15
     WRITE_MULTIPLE_REGISTER = 16
     MASK_WRITE_REGISTER = 22
     READ_FIFO_QUEUE = 24
 
 
+@response
 class ErrorRes(typing.NamedTuple):
     fc: FunctionCode
     error: Error
 
 
+@request
 class ReadCoilsReq(typing.NamedTuple):
     address: int
-    quantity: typing.Optional[int]
+    quantity: int | None
 
 
+@response
 class ReadCoilsRes(typing.NamedTuple):
-    values: typing.List[int]
+    values: list[int]
 
 
+@request
 class ReadDiscreteInputsReq(typing.NamedTuple):
     address: int
-    quantity: typing.Optional[int]
+    quantity: int | None
 
 
+@response
 class ReadDiscreteInputsRes(typing.NamedTuple):
-    values: typing.List[int]
+    values: list[int]
 
 
+@request
 class ReadHoldingRegistersReq(typing.NamedTuple):
     address: int
-    quantity: typing.Optional[int]
+    quantity: int | None
 
 
+@response
 class ReadHoldingRegistersRes(typing.NamedTuple):
-    values: typing.List[int]
+    values: list[int]
 
 
+@request
 class ReadInputRegistersReq(typing.NamedTuple):
     address: int
-    quantity: typing.Optional[int]
+    quantity: int | None
 
 
+@response
 class ReadInputRegistersRes(typing.NamedTuple):
-    values: typing.List[int]
+    values: list[int]
 
 
+@request
 class WriteSingleCoilReq(typing.NamedTuple):
     address: int
     value: int
 
 
+@response
 class WriteSingleCoilRes(typing.NamedTuple):
     address: int
     value: int
 
 
+@request
 class WriteSingleRegisterReq(typing.NamedTuple):
     address: int
     value: int
 
 
+@response
 class WriteSingleRegisterRes(typing.NamedTuple):
     address: int
     value: int
 
 
+@request
 class WriteMultipleCoilsReq(typing.NamedTuple):
     address: int
-    values: typing.List[int]
+    values: list[int]
 
 
+@response
 class WriteMultipleCoilsRes(typing.NamedTuple):
     address: int
     quantity: int
 
 
+@request
 class WriteMultipleRegistersReq(typing.NamedTuple):
     address: int
-    values: typing.List[int]
+    values: list[int]
 
 
+@response
 class WriteMultipleRegistersRes(typing.NamedTuple):
     address: int
     quantity: int
 
 
+@request
 class MaskWriteRegisterReq(typing.NamedTuple):
     address: int
     and_mask: int
     or_mask: int
 
 
+@response
 class MaskWriteRegisterRes(typing.NamedTuple):
     address: int
     and_mask: int
     or_mask: int
 
 
+@request
 class ReadFifoQueueReq(typing.NamedTuple):
     address: int
 
 
+@response
 class ReadFifoQueueRes(typing.NamedTuple):
-    values: typing.List[int]
-
-
-Request = type('Request', (abc.ABC, ), {})
-Request.register(ReadCoilsReq)
-Request.register(ReadDiscreteInputsReq)
-Request.register(ReadHoldingRegistersReq)
-Request.register(ReadInputRegistersReq)
-Request.register(WriteSingleCoilReq)
-Request.register(WriteSingleRegisterReq)
-Request.register(WriteMultipleCoilsReq)
-Request.register(WriteMultipleRegistersReq)
-Request.register(MaskWriteRegisterReq)
-Request.register(ReadFifoQueueReq)
-
-
-Response = type('Response', (abc.ABC, ), {})
-Response.register(ErrorRes)
-Response.register(ReadCoilsRes)
-Response.register(ReadDiscreteInputsRes)
-Response.register(ReadHoldingRegistersRes)
-Response.register(ReadInputRegistersRes)
-Response.register(WriteSingleCoilRes)
-Response.register(WriteSingleRegisterRes)
-Response.register(WriteMultipleCoilsRes)
-Response.register(WriteMultipleRegistersRes)
-Response.register(MaskWriteRegisterRes)
-Response.register(ReadFifoQueueRes)
+    values: list[int]
 
 
-Pdu = typing.Union[Request, Response]
+Pdu: typing.TypeAlias = Request | Response
 
 
 class TcpAdu(typing.NamedTuple):
     transaction_id: int
     device_id: int
     pdu: Pdu
 
@@ -170,15 +176,15 @@
 
 
 class AsciiAdu(typing.NamedTuple):
     device_id: int
     pdu: Pdu
 
 
-Adu = typing.Union[TcpAdu, RtuAdu, AsciiAdu]
+Adu: typing.TypeAlias = TcpAdu | RtuAdu | AsciiAdu
 
 
 def get_pdu_function_code(pdu: Pdu) -> FunctionCode:
     if isinstance(pdu, ErrorRes):
         return pdu.fc
 
     if isinstance(pdu, (ReadCoilsReq,
```

## hat/drivers/modbus/transport/connection.py

```diff
@@ -1,29 +1,36 @@
 import abc
 import logging
 
 from hat import aio
+from hat import util
 
 from hat.drivers import serial
 from hat.drivers import tcp
 from hat.drivers.modbus.transport import common
 from hat.drivers.modbus.transport import encoder
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 
 
 class Connection(aio.Resource):
 
+    @property
+    @abc.abstractmethod
+    def log_prefix(self) -> str:
+        pass
+
     async def send(self, adu: common.Adu):
-        mlog.debug("sending adu: %s", adu)
+        self._log(logging.DEBUG, "sending adu: %s", adu)
         adu_bytes = encoder.encode_adu(adu)
 
         if mlog.isEnabledFor(logging.DEBUG):
-            mlog.debug("writing bytes: %s", bytes(adu_bytes).hex(' '))
+            self._log(logging.DEBUG, "writing bytes: %s",
+                      bytes(adu_bytes).hex(' '))
 
         await self._write(adu_bytes)
 
     async def receive(self,
                       modbus_type: common.ModbusType,
                       direction: common.Direction
                       ) -> common.Adu:
@@ -33,20 +40,20 @@
             next_adu_size = encoder.get_next_adu_size(modbus_type, direction,
                                                       buff)
             if len(buff) >= next_adu_size:
                 break
             buff.extend(await self._read(next_adu_size - len(buff)))
 
         if mlog.isEnabledFor(logging.DEBUG):
-            mlog.debug("received bytes: %s", buff.hex(' '))
+            self._log(logging.DEBUG, "received bytes: %s", buff.hex(' '))
 
         buff = memoryview(buff)
         adu, _ = encoder.decode_adu(modbus_type, direction, buff)
 
-        mlog.debug("received adu: %s", adu)
+        self._log(logging.DEBUG, "received adu: %s", adu)
         return adu
 
     async def reset_input_buffer(self) -> int:
         counter = 0
 
         while True:
             i = await self._reset_input_buffer()
@@ -55,20 +62,26 @@
             counter += i
 
         return counter
 
     async def read_byte(self) -> bytes:
         return await self._read(1)
 
+    def _log(self, level, msg, *args, **kwargs):
+        if not mlog.isEnabledFor(level):
+            return
+
+        mlog.log(level, f"{self.log_prefix}: {msg}", *args, **kwargs)
+
     @abc.abstractmethod
-    async def _write(self, data: common.Bytes):
+    async def _write(self, data: util.Bytes):
         pass
 
     @abc.abstractmethod
-    async def _read(self, size: int) -> common.Bytes:
+    async def _read(self, size: int) -> util.Bytes:
         pass
 
     @abc.abstractmethod
     async def _reset_input_buffer(self):
         pass
 
 
@@ -76,15 +89,15 @@
 
 
 async def serial_create(port: str,
                         **kwargs
                         ) -> Connection:
     endpoint = await serial.create(port, **kwargs)
 
-    mlog.debug("serial endpoint opened: %s", port)
+    mlog.debug("serial endpoint opened: %s", endpoint.port)
     return _SerialConnection(endpoint)
 
 
 async def tcp_connect(addr: tcp.Address,
                       **kwargs
                       ) -> Connection:
     conn = await tcp.connect(addr, **kwargs)
@@ -110,40 +123,54 @@
     return server
 
 
 class _SerialConnection(Connection):
 
     def __init__(self, endpoint):
         self._endpoint = endpoint
+        self._log_prefix = f'serial port {endpoint.port}'
 
     @property
     def async_group(self):
         return self._endpoint.async_group
 
+    @property
+    def log_prefix(self):
+        return self._log_prefix
+
     async def _write(self, data):
         await self._endpoint.write(data)
 
     async def _read(self, size):
         return await self._endpoint.read(size)
 
     async def _reset_input_buffer(self):
         return await self._endpoint.reset_input_buffer()
 
 
 class _TcpConnection(Connection):
 
     def __init__(self, conn):
         self._conn = conn
+        self._log_prefix = (
+            f'tcp local ('
+            f'{conn.info.local_addr.host}:{conn.info.local_addr.port}'
+            f') remote ('
+            f'{conn.info.remote_addr.host}:{conn.info.remote_addr.port})')
 
     @property
     def async_group(self):
         return self._conn.async_group
 
+    @property
+    def log_prefix(self):
+        return self._log_prefix
+
     async def _write(self, data):
-        self._conn.write(data)
+        await self._conn.write(data)
         await self._conn.drain()
 
     async def _read(self, size):
         return await self._conn.readexactly(size)
 
     async def _reset_input_buffer(self):
-        return await self._conn.reset_input_buffer()
+        return self._conn.reset_input_buffer()
```

## hat/drivers/modbus/transport/encoder.py

```diff
@@ -1,17 +1,24 @@
 import itertools
 import struct
-import typing
+
+from hat import util
 
 from hat.drivers.modbus.transport import common
 
+try:
+    from hat.drivers.modbus.transport import _encoder
+
+except ImportError:
+    _encoder = None
+
 
 def get_next_adu_size(modbus_type: common.ModbusType,
                       direction: common.Direction,
-                      data: common.Bytes
+                      data: util.Bytes
                       ) -> int:
     if modbus_type == common.ModbusType.TCP:
         return _get_next_tcp_adu_size(data)
 
     if modbus_type == common.ModbusType.RTU:
         return _get_next_rtu_adu_size(direction, data)
 
@@ -19,29 +26,29 @@
         return _get_next_ascii_adu_size(direction, data)
 
     raise ValueError("unsupported modbus type")
 
 
 def decode_adu(modbus_type: common.ModbusType,
                direction: common.Direction,
-               data: common.Bytes
-               ) -> typing.Tuple[common.Adu, common.Bytes]:
+               data: util.Bytes
+               ) -> tuple[common.Adu, util.Bytes]:
     if modbus_type == common.ModbusType.TCP:
         return _decode_tcp_adu(direction, data)
 
     if modbus_type == common.ModbusType.RTU:
         return _decode_rtu_adu(direction, data)
 
     if modbus_type == common.ModbusType.ASCII:
         return _decode_ascii_adu(direction, data)
 
     raise ValueError("unsupported modbus type")
 
 
-def encode_adu(adu: common.Adu) -> common.Bytes:
+def encode_adu(adu: common.Adu) -> util.Bytes:
     if isinstance(adu, common.TcpAdu):
         return _encode_tcp_adu(adu)
 
     if isinstance(adu, common.RtuAdu):
         return _encode_rtu_adu(adu)
 
     if isinstance(adu, common.AsciiAdu):
@@ -556,14 +563,17 @@
             yield from [(i >> 8) & 0xFF, i & 0xFF]
 
     else:
         raise ValueError('unsupported request type')
 
 
 def _calculate_crc(data):
+    if _encoder:
+        return _encoder.calculate_crc(data)
+
     crc = 0xFFFF
     for i in data:
         crc ^= i
         for _ in range(8):
             lsb = crc & 1
             crc >>= 1
             if lsb:
```

## hat/drivers/pnetgateway/client.py

```diff
@@ -1,38 +1,42 @@
 import asyncio
 import itertools
 import logging
 import typing
 
 from hat import aio
+
 from hat.drivers import tcp
 from hat.drivers.pnetgateway import common
 from hat.drivers.pnetgateway import encoder
 from hat.drivers.pnetgateway import transport
 
 
 mlog = logging.getLogger(__name__)
 
 
-StatusCb = aio.AsyncCallable[[common.Status], None]
+StatusCb: typing.TypeAlias = aio.AsyncCallable[[common.Status], None]
 """Status change callback"""
 
-DataCb = aio.AsyncCallable[[typing.List[common.Data]], None]
+DataCb: typing.TypeAlias = aio.AsyncCallable[[list[common.Data]], None]
 """Data change callback"""
 
 
 async def connect(addr: tcp.Address,
                   username: str,
                   password: str,
                   status_cb: StatusCb,
                   data_cb: DataCb,
-                  subscriptions: typing.Optional[typing.List[str]] = None,
+                  subscriptions: list[str] | None = None,
+                  **kwargs
                   ) -> 'Connection':
     """Connect to PNET Gateway server
 
+    Additional arguments are passed directly to `hat.drivers.tcp.connect`.
+
     Args:
         address: PNET Gateway server address
         username: user name
         password: password
         status_cb: status change callback
         data_cb: data change callback
         subscriptions: list of data keys for subscriptions
@@ -45,21 +49,21 @@
     conn._pnet_status = common.Status.DISCONNECTED
     conn._data = {}
     conn._status_cb = status_cb
     conn._data_cb = data_cb
     conn._next_ids = itertools.count(0)
     conn._id_futures = {}
 
-    conn._conn = transport.Transport(await tcp.connect(addr))
+    conn._conn = transport.Transport(await tcp.connect(addr, **kwargs))
 
     try:
-        conn._conn.send({'type': 'authentication_request',
-                         'body': {'username': username,
-                                  'password': password,
-                                  'subscriptions': subscriptions}})
+        await conn._conn.send({'type': 'authentication_request',
+                               'body': {'username': username,
+                                        'password': password,
+                                        'subscriptions': subscriptions}})
 
         msg = None
         while msg is None or msg['type'] != 'authentication_response':
             msg = await conn._conn.receive()
 
         if not msg['body']['success']:
             raise Exception('authentication failed')
@@ -92,29 +96,29 @@
 
     @property
     def pnet_status(self) -> common.Status:
         """PNET Gateway server's status"""
         return self._pnet_status
 
     @property
-    def data(self) -> typing.Dict[str, common.Data]:
+    def data(self) -> dict[str, common.Data]:
         """Subscribed data"""
         return self._data
 
     async def change_data(self,
                           changes: typing.Iterable[common.Change]
-                          ) -> typing.List[bool]:
+                          ) -> list[bool]:
         """Send change data request to PNET Gateway server"""
         return await self._send_with_response(
             'change_data_request',
             [encoder.change_to_json(i) for i in changes])
 
     async def send_commands(self,
                             commands: typing.Iterable[common.Command]
-                            ) -> typing.List[bool]:
+                            ) -> list[bool]:
         """Send commands to PNET Gateway"""
         return await self._send_with_response(
             'command_request',
             [encoder.command_to_json(i) for i in commands])
 
     async def _send_with_response(self, msg_type, msg_data):
         if not self.is_open:
@@ -125,15 +129,15 @@
                'body': {'id': msg_id,
                         'data': msg_data}}
 
         future = asyncio.Future()
         self._id_futures[msg_id] = future
 
         try:
-            self._conn.send(msg)
+            await self._conn.send(msg)
             return await future
 
         finally:
             self._id_futures.pop(msg_id)
 
     async def _read_loop(self):
         try:
```

## hat/drivers/pnetgateway/common.py

```diff
@@ -46,16 +46,16 @@
     timestamp: float
     type: DataType
     source: Source
 
 
 class Change(typing.NamedTuple):
     key: str
-    value: typing.Optional[json.Data]
-    quality: typing.Optional[Quality]
-    timestamp: typing.Optional[float]
-    source: typing.Optional[Source]
+    value: json.Data | None
+    quality: Quality | None
+    timestamp: float | None
+    source: Source | None
 
 
 class Command(typing.NamedTuple):
     key: str
     value: json.Data
```

## hat/drivers/pnetgateway/encoder.py

```diff
@@ -1,8 +1,9 @@
 from hat import json
+
 from hat.drivers.pnetgateway import common
 
 
 def data_to_json(data: common.Data) -> json.Data:
     return {'key': data.key,
             'value': data.value,
             'quality': data.quality.value,
```

## hat/drivers/pnetgateway/transport.py

```diff
@@ -16,13 +16,13 @@
         size_bytes = await self._conn.readexactly(4)
         size = int.from_bytes(size_bytes, 'big')
         msg_bytes = await self._conn.readexactly(size)
         msg_str = str(msg_bytes, 'utf-8')
         msg = json.decode(msg_str)
         return msg
 
-    def send(self, msg: json.Data):
+    async def send(self, msg: json.Data):
         msg_str = json.encode(msg)
         msg_bytes = msg_str.encode('utf-8')
         size = len(msg_bytes)
         size_bytes = size.to_bytes(4, 'big')
-        self._conn.write(size_bytes + msg_bytes)
+        await self._conn.write(size_bytes + msg_bytes)
```

## hat/drivers/snmp/__init__.py

```diff
@@ -1,10 +1,8 @@
-from hat.drivers.snmp.common import (Bytes,
-                                     ObjectIdentifier,
-                                     Version,
+from hat.drivers.snmp.common import (Version,
                                      ErrorType,
                                      CauseType,
                                      DataType,
                                      Error,
                                      Cause,
                                      Data,
                                      Context,
@@ -24,17 +22,15 @@
 from hat.drivers.snmp.manager import (create_manager,
                                       Manager)
 from hat.drivers.snmp.agent import (RequestCb,
                                     create_agent,
                                     Agent)
 
 
-__all__ = ['Bytes',
-           'ObjectIdentifier',
-           'Version',
+__all__ = ['Version',
            'ErrorType',
            'CauseType',
            'DataType',
            'Error',
            'Cause',
            'Data',
            'Context',
```

## hat/drivers/snmp/agent.py

```diff
@@ -1,10 +1,11 @@
 import logging
 
 from hat import aio
+
 from hat.drivers import udp
 from hat.drivers.snmp import common
 from hat.drivers.snmp import encoder
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
```

## hat/drivers/snmp/common.py

```diff
@@ -1,18 +1,13 @@
 import enum
 import typing
 
 from hat import asn1
 
 
-Bytes = asn1.Bytes
-
-ObjectIdentifier = asn1.ObjectIdentifier
-
-
 class Version(enum.Enum):
     V1 = 0
     V2C = 1
     V3 = 3
 
 
 class ErrorType(enum.Enum):
@@ -109,54 +104,54 @@
         | NO_SUCH_INSTANCE | NoneType                  |
         +------------------+---------------------------+
         | END_OF_MIB_VIEW  | NoneType                  |
         +------------------+---------------------------+
 
     """
     type: DataType
-    name: ObjectIdentifier
+    name: asn1.ObjectIdentifier
     value: typing.Any
 
 
 class Context(typing.NamedTuple):
-    engine_id: typing.Optional[str]
+    engine_id: str | None
     """engine id is not available in case of v1 and v2c"""
     name: str
     """name is used as community name in case of v1 and v2c"""
 
 
 class Trap(typing.NamedTuple):
     context: Context
-    cause: typing.Optional[Cause]
+    cause: Cause | None
     """cause is available in case of v1"""
-    oid: ObjectIdentifier
+    oid: asn1.ObjectIdentifier
     timestamp: int
-    data: typing.List[Data]
+    data: Data | None
 
 
 class Inform(typing.NamedTuple):
     context: Context
-    data: typing.List[Data]
+    data: Data | None
 
 
 class GetDataReq(typing.NamedTuple):
-    names: typing.List[ObjectIdentifier]
+    names: list[asn1.ObjectIdentifier]
 
 
 class GetNextDataReq(typing.NamedTuple):
-    names: typing.List[ObjectIdentifier]
+    names: list[asn1.ObjectIdentifier]
 
 
 class GetBulkDataReq(typing.NamedTuple):
-    names: typing.List[ObjectIdentifier]
+    names: list[asn1.ObjectIdentifier]
 
 
 class SetDataReq(typing.NamedTuple):
-    data: typing.List[Data]
+    data: Data | None
 
 
-Request = typing.Union[GetDataReq,
-                       GetNextDataReq,
-                       GetBulkDataReq,
-                       SetDataReq]
+Request: typing.TypeAlias = (GetDataReq |
+                             GetNextDataReq |
+                             GetBulkDataReq |
+                             SetDataReq)
 
-Response = typing.Union[Error, typing.List[Data]]
+Response: typing.TypeAlias = Error | Data | None
```

## hat/drivers/snmp/manager.py

```diff
@@ -1,12 +1,13 @@
 import asyncio
 import itertools
 import logging
 
 from hat import aio
+
 from hat.drivers import udp
 from hat.drivers.snmp import common
 from hat.drivers.snmp import encoder
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
```

## hat/drivers/snmp/trap.py

```diff
@@ -1,24 +1,24 @@
 import asyncio
 import itertools
 import logging
-import typing
 
 from hat import aio
+
 from hat.drivers import udp
 from hat.drivers.snmp import common
 from hat.drivers.snmp import encoder
 
 
 mlog: logging.Logger = logging.getLogger(__name__)
 """Module logger"""
 
 
 InformCb = aio.AsyncCallable[[common.Version, common.Inform, udp.Address],
-                             typing.Optional[common.Error]]
+                             common.Error | None]
 """Inform callback"""
 
 
 async def create_trap_sender(remote_addr: udp.Address,
                              version: common.Version = common.Version.V2C
                              ) -> 'TrapSender':
     """Create trap sender"""
@@ -35,15 +35,15 @@
     local_addr = sender._endpoint.info.local_addr
     sender._addr = tuple(int(i) for i in local_addr.host.split('.'))
 
     return sender
 
 
 async def create_trap_listener(local_addr: udp.Address = udp.Address('0.0.0.0', 162),  # NOQA
-                               inform_cb: typing.Optional[InformCb] = None
+                               inform_cb: InformCb | None = None
                                ) -> 'TrapListener':
     """Create trap listener"""
     listener = TrapListener()
     listener._inform_cb = inform_cb
     listener._receive_queue = aio.Queue()
 
     listener._endpoint = await udp.create(local_addr=local_addr,
@@ -70,15 +70,15 @@
         msg = _encode_trap_req(self._version, self._addr, request_id, trap)
         msg_bytes = encoder.encode(msg)
 
         self._endpoint.send(msg_bytes)
 
     async def send_inform(self,
                           inform: common.Inform
-                          ) -> typing.Optional[common.Error]:
+                          ) -> common.Error | None:
         """Send inform"""
         if not self.is_open:
             raise ConnectionError()
 
         request_id = next(self._next_request_id)
         req_msg = _encode_inform_req(self._version, request_id, inform)
         req_msg_bytes = encoder.encode(req_msg)
@@ -131,16 +131,15 @@
 class TrapListener(aio.Resource):
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._endpoint.async_group
 
-    async def receive(self) -> typing.Tuple[common.Trap,
-                                            udp.Address]:
+    async def receive(self) -> tuple[common.Trap, udp.Address]:
         """Receive trap"""
         try:
             return await self._receive_queue.get()
 
         except aio.QueueClosedError:
             raise ConnectionError()
```

## hat/drivers/snmp/encoder/__init__.py

```diff
@@ -1,11 +1,12 @@
 import importlib.resources
 import typing
 
 from hat import asn1
+from hat import util
 import hat.asn1.ber
 import hat.asn1.common
 
 from hat.drivers.snmp import common
 from hat.drivers.snmp.encoder import v1
 from hat.drivers.snmp.encoder import v2c
 from hat.drivers.snmp.encoder import v3
@@ -15,23 +16,24 @@
            'v2c',
            'v3',
            'Msg',
            'encode',
            'decode']
 
 
-with importlib.resources.path(__package__, 'asn1_repo.json') as _path:
+with importlib.resources.as_file(importlib.resources.files(__package__) /
+                                 'asn1_repo.json') as _path:
     _encoder = asn1.Encoder(asn1.Encoding.BER,
                             asn1.Repository.from_json(_path))
 
 
-Msg = typing.Union[v1.Msg, v2c.Msg, v3.Msg]
+Msg: typing.TypeAlias = v1.Msg | v2c.Msg | v3.Msg
 
 
-def encode(msg: Msg) -> common.Bytes:
+def encode(msg: Msg) -> util.Bytes:
     if isinstance(msg, v1.Msg):
         data = v1.encode_msg(msg)
         return _encoder.encode('RFC1157-SNMP', 'Message', data)
 
     elif isinstance(msg, v2c.Msg):
         data = v2c.encode_msg(msg)
         return _encoder.encode('COMMUNITY-BASED-SNMPv2', 'Message', data)
@@ -39,15 +41,15 @@
     elif isinstance(msg, v3.Msg):
         data = v3.encode_msg(msg)
         return _encoder.encode('SNMPv3MessageSyntax', 'SNMPv3Message', data)
 
     raise ValueError('unsupported message')
 
 
-def decode(msg_bytes: common.Bytes) -> Msg:
+def decode(msg_bytes: util.Bytes) -> Msg:
     entity, _ = _encoder.decode_entity(msg_bytes)
     version = _get_version(entity)
 
     if version == common.Version.V1:
         msg = _encoder.decode_value('RFC1157-SNMP', 'Message', entity)
         return v1.decode_msg(msg)
```

## hat/drivers/snmp/encoder/v1.py

```diff
@@ -13,26 +13,26 @@
     SET_REQUEST = 'set-request'
     TRAP = 'trap'
 
 
 class BasicPdu(typing.NamedTuple):
     request_id: int
     error: common.Error
-    data: typing.List[common.Data]
+    data: list[common.Data]
 
 
 class TrapPdu(typing.NamedTuple):
-    enterprise: common.ObjectIdentifier
-    addr: typing.Tuple[int, int, int, int]
+    enterprise: asn1.ObjectIdentifier
+    addr: tuple[int, int, int, int]
     cause: common.Cause
     timestamp: int
-    data: typing.List[common.Data]
+    data: list[common.Data]
 
 
-Pdu = typing.Union[BasicPdu, TrapPdu]
+Pdu: typing.TypeAlias = BasicPdu | TrapPdu
 
 
 class Msg(typing.NamedTuple):
     type: MsgType
     community: str
     pdu: Pdu
```

## hat/drivers/snmp/encoder/v2c.py

```diff
@@ -21,18 +21,18 @@
 BasicPdu = v1.BasicPdu
 
 
 class BulkPdu(typing.NamedTuple):
     request_id: int
     non_repeaters: int
     max_repetitions: int
-    data: typing.List[common.Data]
+    data: list[common.Data]
 
 
-Pdu = typing.Union[BasicPdu, BulkPdu]
+Pdu: typing.TypeAlias = BasicPdu | BulkPdu
 
 
 class Msg(typing.NamedTuple):
     type: MsgType
     community: str
     pdu: Pdu
```

## hat/drivers/upnp/description.py

```diff
@@ -13,26 +13,26 @@
     width: int
     height: int
     depth: int
     url: str
 
 
 class DeviceDescription(typing.NamedTuple):
-    url: typing.Optional[str]
+    url: str | None
     dev_type: str
     dev_name: str
     manufacturer: str
-    manufacturer_url: typing.Optional[str]
-    model_desc: typing.Optional[str]
+    manufacturer_url: str | None
+    model_desc: str | None
     model_name: str
-    model_number: typing.Optional[str]
-    model_url: typing.Optional[str]
-    serial_number: typing.Optional[str]
+    model_number: str | None
+    model_url: str | None
+    serial_number: str | None
     unique_dev_name: str
-    icons: typing.List[Icon]
+    icons: list[Icon]
 
 
 async def get_description(location: str) -> DeviceDescription:
     async with aiohttp.ClientSession() as session:
         async with session.get(location) as res:
             text = await res.text()
         data = _decode_xml(text)
```

## Comparing `hat/drivers/cosp.py` & `hat/drivers/cosp/connection.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,445 +1,411 @@
-"""Connection oriented session protocol
-
-Attributes:
-    mlog (logging.Logger): module logger
-
-"""
-
-import contextlib
-import enum
+import asyncio
+import itertools
 import logging
 import typing
 
 from hat import aio
+from hat import util
+
 from hat.drivers import cotp
+from hat.drivers import tcp
+from hat.drivers.cosp import common
+from hat.drivers.cosp import encoder
 
 
 mlog = logging.getLogger(__name__)
 
+_params_requirements = b'\x00\x02'
 
-Data = typing.Union[bytes, bytearray, memoryview]
-"""Data"""
+_params_version = 2
 
+_ab_spdu = common.Spdu(type=common.SpduType.AB,
+                       transport_disconnect=True)
 
-Address = cotp.Address
-"""Address"""
+_dn_spdu = common.Spdu(type=common.SpduType.DN)
 
 
 class ConnectionInfo(typing.NamedTuple):
-    local_addr: Address
-    local_tsel: typing.Optional[int]
-    local_ssel: typing.Optional[int]
-    remote_addr: Address
-    remote_tsel: typing.Optional[int]
-    remote_ssel: typing.Optional[int]
-
+    local_addr: tcp.Address
+    local_tsel: int | None
+    local_ssel: int | None
+    remote_addr: tcp.Address
+    remote_tsel: int | None
+    remote_ssel: int | None
 
-ValidateResult = typing.Optional[Data]
-"""Validate result"""
 
-
-ValidateCb = aio.AsyncCallable[[Data], ValidateResult]
+ValidateCb: typing.TypeAlias = aio.AsyncCallable[[util.Bytes],
+                                                 util.Bytes | None]
 """Validate callback"""
 
-
-ConnectionCb = aio.AsyncCallable[['Connection'], None]
+ConnectionCb: typing.TypeAlias = aio.AsyncCallable[['Connection'], None]
 """Connection callback"""
 
 
-async def connect(addr: Address,
-                  local_tsel: typing.Optional[int] = None,
-                  remote_tsel: typing.Optional[int] = None,
-                  local_ssel: typing.Optional[int] = None,
-                  remote_ssel: typing.Optional[int] = None,
-                  user_data: typing.Optional[Data] = None
+async def connect(addr: tcp.Address,
+                  user_data: util.Bytes | None = None,
+                  *,
+                  local_ssel: int | None = None,
+                  remote_ssel: int | None = None,
+                  cosp_receive_queue_size: int = 1024,
+                  cosp_send_queue_size: int = 1024,
+                  **kwargs
                   ) -> 'Connection':
-    """Connect to COSP server"""
-    cotp_conn = await cotp.connect(addr=addr,
-                                   local_tsel=local_tsel,
-                                   remote_tsel=remote_tsel)
+    """Connect to COSP server
+
+    Additional arguments are passed directly to `hat.drivers.cotp.connect`.
+
+    """
+    conn = await cotp.connect(addr, **kwargs)
+
     try:
-        conn = await _create_outgoing_connection(cotp_conn, local_ssel,
-                                                 remote_ssel, user_data)
-        return conn
+        cn_spdu = common.Spdu(type=common.SpduType.CN,
+                              extended_spdus=False,
+                              version_number=_params_version,
+                              requirements=_params_requirements,
+                              calling_ssel=local_ssel,
+                              called_ssel=remote_ssel,
+                              user_data=user_data)
+        cn_spdu_bytes = encoder.encode(cn_spdu)
+        await conn.send(cn_spdu_bytes)
+
+        ac_spdu_bytes = await conn.receive()
+        ac_spdu = encoder.decode(memoryview(ac_spdu_bytes))
+        _validate_connect_response(cn_spdu, ac_spdu)
+
+        calling_ssel, called_ssel = _get_ssels(cn_spdu, ac_spdu)
+        return Connection(conn, cn_spdu, ac_spdu, calling_ssel, called_ssel,
+                          cosp_receive_queue_size, cosp_send_queue_size)
+
     except BaseException:
-        await aio.uncancellable(_close_connection(cotp_conn, _ab_spdu))
+        await aio.uncancellable(_close_cotp(conn, _ab_spdu))
         raise
 
 
 async def listen(validate_cb: ValidateCb,
                  connection_cb: ConnectionCb,
-                 addr: Address = Address('0.0.0.0', 102)
+                 addr: tcp.Address = tcp.Address('0.0.0.0', 102),
+                 *,
+                 bind_connections: bool = False,
+                 cosp_receive_queue_size: int = 1024,
+                 cosp_send_queue_size: int = 1024,
+                 **kwargs
                  ) -> 'Server':
     """Create COSP listening server
 
+    Additional arguments are passed directly to `hat.drivers.cotp.listen`.
+
     Args:
         validate_cb: callback function or coroutine called on new
             incomming connection request prior to creating new connection
         connection_cb: new connection callback
         addr: local listening address
 
     """
+    server = Server()
+    server._validate_cb = validate_cb
+    server._connection_cb = connection_cb
+    server._bind_connections = bind_connections
+    server._receive_queue_size = cosp_receive_queue_size
+    server._send_queue_size = cosp_send_queue_size
+
+    server._srv = await cotp.listen(server._on_connection, addr,
+                                    bind_connections=False,
+                                    **kwargs)
 
-    async def on_connection(cotp_conn):
-        try:
-            try:
-                conn = await _create_incomming_connection(validate_cb,
-                                                          cotp_conn)
-            except BaseException:
-                await aio.uncancellable(_close_connection(cotp_conn, _ab_spdu))
-                raise
-            try:
-                await aio.call(connection_cb, conn)
-            except BaseException:
-                await aio.uncancellable(conn.async_close())
-                raise
-        except Exception as e:
-            mlog.error("error creating new incomming connection: %s", e,
-                       exc_info=e)
-
-    async def wait_cotp_server_closed():
-        try:
-            await cotp_server.wait_closed()
-        finally:
-            async_group.close()
-
-    async_group = aio.Group()
-    cotp_server = await cotp.listen(on_connection, addr)
-    async_group.spawn(aio.call_on_cancel, cotp_server.async_close)
-    async_group.spawn(wait_cotp_server_closed)
-
-    srv = Server()
-    srv._async_group = async_group
-    srv._cotp_server = cotp_server
-    return srv
+    return server
 
 
 class Server(aio.Resource):
     """COSP listening server
 
-    For creating new server see :func:`listen`
-
-    Closing server doesn't close active incomming connections
+    For creating new server see `listen`.
 
     """
 
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
-        return self._async_group
+        return self._srv.async_group
 
     @property
-    def addresses(self) -> typing.List[Address]:
+    def addresses(self) -> list[tcp.Address]:
         """Listening addresses"""
-        return self._cotp_server.addresses
+        return self._srv.addresses
+
+    async def _on_connection(self, cotp_conn):
+        try:
+            try:
+                cn_spdu_bytes = await cotp_conn.receive()
+                cn_spdu = encoder.decode(memoryview(cn_spdu_bytes))
+                _validate_connect_request(cn_spdu)
+
+                res_user_data = await aio.call(self._validate_cb,
+                                               cn_spdu.user_data)
+
+                ac_spdu = common.Spdu(type=common.SpduType.AC,
+                                      extended_spdus=False,
+                                      version_number=_params_version,
+                                      requirements=_params_requirements,
+                                      calling_ssel=cn_spdu.calling_ssel,
+                                      called_ssel=cn_spdu.called_ssel,
+                                      user_data=res_user_data)
+                ac_spdu_bytes = encoder.encode(ac_spdu)
+                await cotp_conn.send(ac_spdu_bytes)
+
+                calling_ssel, called_ssel = _get_ssels(cn_spdu, ac_spdu)
+                conn = Connection(cotp_conn, cn_spdu, ac_spdu,
+                                  called_ssel, calling_ssel,
+                                  self._receive_queue_size,
+                                  self._send_queue_size)
+
+            except BaseException:
+                await aio.uncancellable(_close_cotp(cotp_conn, _ab_spdu))
+                raise
+
+            try:
+                await aio.call(self._connection_cb, conn)
 
+            except BaseException:
+                await aio.uncancellable(conn.async_close())
+                raise
 
-def _create_connection(cotp_conn, cn_spdu, ac_spdu, local_ssel, remote_ssel):
-    conn = Connection()
-    conn._cotp_conn = cotp_conn
-    conn._conn_req_user_data = cn_spdu.user_data
-    conn._conn_res_user_data = ac_spdu.user_data
-    conn._info = ConnectionInfo(local_ssel=local_ssel,
-                                remote_ssel=remote_ssel,
-                                **cotp_conn.info._asdict())
-    conn._close_spdu = None
-    conn._read_queue = aio.Queue()
-    conn._async_group = aio.Group()
-    conn._async_group.spawn(conn._read_loop)
-    return conn
+        except Exception as e:
+            mlog.error("error creating new incomming connection: %s", e,
+                       exc_info=e)
+            return
+
+        if not self._bind_connections:
+            return
+
+        try:
+            await conn.wait_closed()
+
+        except BaseException:
+            await aio.uncancellable(conn.async_close())
+            raise
 
 
 class Connection(aio.Resource):
     """COSP connection
 
-    For creating new connection see :func:`hat.drivers.cosp.connect`
+    For creating new connection see `connect` or `listen`.
 
     """
 
+    def __init__(self,
+                 conn: cotp.Connection,
+                 cn_spdu: common.Spdu,
+                 ac_spdu: common.Spdu,
+                 local_ssel: int | None,
+                 remote_ssel: int | None,
+                 receive_queue_size: int,
+                 send_queue_size: int):
+        self._conn = conn
+        self._conn_req_user_data = cn_spdu.user_data
+        self._conn_res_user_data = ac_spdu.user_data
+        self._loop = asyncio.get_running_loop()
+        self._info = ConnectionInfo(local_ssel=local_ssel,
+                                    remote_ssel=remote_ssel,
+                                    **conn.info._asdict())
+        self._close_spdu = None
+        self._receive_queue = aio.Queue(receive_queue_size)
+        self._send_queue = aio.Queue(send_queue_size)
+        self._async_group = aio.Group()
+
+        self.async_group.spawn(aio.call_on_cancel, self._on_close)
+        self.async_group.spawn(self._receive_loop)
+        self.async_group.spawn(self._send_loop)
+        self.async_group.spawn(aio.call_on_done, conn.wait_closing(),
+                               self.close)
+
     @property
     def async_group(self) -> aio.Group:
         """Async group"""
         return self._async_group
 
     @property
     def info(self) -> ConnectionInfo:
         """Connection info"""
         return self._info
 
     @property
-    def conn_req_user_data(self) -> Data:
+    def conn_req_user_data(self) -> util.Bytes:
         """Connect request's user data"""
         return self._conn_req_user_data
 
     @property
-    def conn_res_user_data(self) -> Data:
+    def conn_res_user_data(self) -> util.Bytes:
         """Connect response's user data"""
         return self._conn_res_user_data
 
-    def close(self, user_data: typing.Optional[Data] = None):
+    def close(self, user_data: util.Bytes | None = None):
         """Close connection"""
-        self._close_spdu = _Spdu(_SpduType.FN,
-                                 transport_disconnect=True,
-                                 user_data=user_data)
-        self._async_group.close()
+        self._close(common.Spdu(common.SpduType.FN,
+                                transport_disconnect=True,
+                                user_data=user_data))
 
-    async def async_close(self, user_data: typing.Optional[Data] = None):
+    async def async_close(self, user_data: util.Bytes | None = None):
         """Async close"""
         self.close(user_data)
         await self.wait_closed()
 
-    async def read(self) -> Data:
-        """Read data"""
-        return await self._read_queue.get()
-
-    def write(self, data: Data):
-        """Write data"""
-        buff = bytearray(_give_tokens_spdu_data)
-        buff.extend(_encode(_Spdu(type=_SpduType.DT,
-                                  data=data)))
-        self._cotp_conn.write(buff)
+    async def receive(self) -> util.Bytes:
+        """Receive data"""
+        try:
+            return await self._receive_queue.get()
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
+
+    async def send(self, data: util.Bytes):
+        """Send data"""
+        try:
+            await self._send_queue.put((data, None))
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
+
+    async def drain(self):
+        """Drain output buffer"""
+        try:
+            future = self._loop.create_future()
+            await self._send_queue.put((None, future))
+            await future
+
+        except aio.QueueClosedError:
+            raise ConnectionError()
 
-    async def _read_loop(self):
+    async def _on_close(self):
+        await _close_cotp(self._conn, self._close_spdu)
+
+    def _close(self, spdu):
+        if not self.is_open:
+            return
+
+        self._close_spdu = spdu
+        self._async_group.close()
+
+    async def _receive_loop(self):
         try:
             data = bytearray()
             while True:
-                spdu_data = await self._cotp_conn.read()
-                spdu = _decode(memoryview(spdu_data))
-                if spdu.type == _SpduType.DT:
+                spdu_bytes = await self._conn.receive()
+                spdu = encoder.decode(memoryview(spdu_bytes))
+
+                if spdu.type == common.SpduType.DT:
                     data.extend(spdu.data)
+
                     if spdu.end is None or spdu.end:
-                        await self._read_queue.put(data)
+                        await self._receive_queue.put(data)
                         data = bytearray()
-                elif spdu.type == _SpduType.FN:
-                    self._close_spdu = _dn_spdu
+
+                elif spdu.type == common.SpduType.FN:
+                    self._close(_dn_spdu)
                     break
-                elif spdu.type == _SpduType.AB:
-                    self._close_spdu = None
+
+                elif spdu.type == common.SpduType.AB:
+                    self._close(None)
                     break
+
                 else:
-                    self._close_spdu = _ab_spdu
+                    self._close(_ab_spdu)
                     break
+
+        except ConnectionError:
+            pass
+
+        except Exception as e:
+            mlog.error("receive loop error: %s", e, exc_info=e)
+
         finally:
-            self._async_group.close()
-            self._read_queue.close()
-            await aio.uncancellable(
-                _close_connection(self._cotp_conn, self._close_spdu))
-
-
-async def _create_outgoing_connection(cotp_conn, local_ssel, remote_ssel,
-                                      user_data):
-    cn_spdu = _Spdu(_SpduType.CN,
-                    extended_spdus=False,
-                    version_number=_params_version,
-                    requirements=_params_requirements,
-                    calling_ssel=local_ssel,
-                    called_ssel=remote_ssel,
-                    user_data=user_data)
-    cotp_conn.write(_encode(cn_spdu))
-    ac_spdu_data = await cotp_conn.read()
-    ac_spdu = _decode(memoryview(ac_spdu_data))
-    _validate_connect_response(cn_spdu, ac_spdu)
-    calling_ssel, called_ssel = _get_ssels(cn_spdu, ac_spdu)
-    return _create_connection(cotp_conn, cn_spdu, ac_spdu,
-                              calling_ssel, called_ssel)
-
-
-async def _create_incomming_connection(validate_cb, cotp_conn):
-    cn_spdu_data = await cotp_conn.read()
-    cn_spdu = _decode(memoryview(cn_spdu_data))
-    _validate_connect_request(cn_spdu)
-    res_user_data = await aio.call(validate_cb, cn_spdu.user_data)
-    ac_spdu = _Spdu(_SpduType.AC,
-                    extended_spdus=False,
-                    version_number=_params_version,
-                    requirements=_params_requirements,
-                    calling_ssel=cn_spdu.calling_ssel,
-                    called_ssel=cn_spdu.called_ssel,
-                    user_data=res_user_data)
-    cotp_conn.write(_encode(ac_spdu))
-    calling_ssel, called_ssel = _get_ssels(cn_spdu, ac_spdu)
-    return _create_connection(cotp_conn, cn_spdu, ac_spdu,
-                              called_ssel, calling_ssel)
-
-
-async def _close_connection(cotp_conn, spdu):
-    if spdu:
-        data = _encode(spdu)
-        with contextlib.suppress(Exception):
-            cotp_conn.write(data)
-    await cotp_conn.async_close()
+            self.close()
+            self._receive_queue.close()
+
+    async def _send_loop(self):
+        future = None
+        try:
+            while True:
+                data, future = await self._send_queue.get()
+
+                if data is None:
+                    await self._conn.drain()
+
+                else:
+                    spdu = common.Spdu(type=common.SpduType.DT,
+                                       data=data)
+                    spdu_bytes = encoder.encode(spdu)
+
+                    msg = bytes(itertools.chain(common.give_tokens_spdu_bytes,
+                                                spdu_bytes))
+
+                    await self._conn.send(msg)
+
+                if future and not future.done():
+                    future.set_result(None)
+
+        except ConnectionError:
+            pass
+
+        except Exception as e:
+            mlog.error("send loop error: %s", e, exc_info=e)
+
+        finally:
+            self.close()
+            self._send_queue.close()
+
+            while True:
+                if future and not future.done():
+                    future.set_result(None)
+                if self._send_queue.empty():
+                    break
+                _, future = self._send_queue.get_nowait()
+
+
+async def _close_cotp(cotp_conn, spdu):
+    try:
+        if not cotp_conn.is_open or not spdu:
+            return
+
+        spdu_bytes = encoder.encode(spdu)
+        await cotp_conn.send(spdu_bytes)
+        await cotp_conn.drain()
+
+    except Exception as e:
+        mlog.error('close cotp error: %s', e, exc_info=e)
+
+    finally:
+        await cotp_conn.async_close()
 
 
 def _get_ssels(cn_spdu, ac_spdu):
     calling_ssel = (cn_spdu.calling_ssel
                     if cn_spdu.calling_ssel is not None
                     else ac_spdu.calling_ssel)
+
     called_ssel = (cn_spdu.called_ssel
                    if cn_spdu.called_ssel is not None
                    else ac_spdu.called_ssel)
+
     return calling_ssel, called_ssel
 
 
 def _validate_connect_request(cn_spdu):
-    if cn_spdu.type != _SpduType.CN:
+    if cn_spdu.type != common.SpduType.CN:
         raise Exception("received message is not of type CN")
 
 
 def _validate_connect_response(cn_spdu, ac_spdu):
-    if ac_spdu.type != _SpduType.AC:
+    if ac_spdu.type != common.SpduType.AC:
         raise Exception("received message is not of type AC")
+
     if (cn_spdu.calling_ssel is not None and
             ac_spdu.calling_ssel is not None and
             cn_spdu.calling_ssel != ac_spdu.calling_ssel):
         raise Exception(f"received calling ssel  {ac_spdu.calling_ssel} "
                         f"(expecting {cn_spdu.calling_ssel})")
+
     if (cn_spdu.called_ssel is not None and
             ac_spdu.called_ssel is not None and
             cn_spdu.called_ssel != ac_spdu.called_ssel):
         raise Exception(f"received calling ssel {ac_spdu.called_ssel} "
                         f"(expecting {cn_spdu.called_ssel})")
-
-
-class _SpduType(enum.Enum):
-    CN = 13
-    AC = 14
-    RF = 12
-    FN = 9
-    DN = 10
-    NF = 8
-    AB = 25
-    DT = 1
-
-
-class _Spdu(typing.NamedTuple):
-    type: _SpduType
-    extended_spdus: typing.Optional[bool] = None
-    version_number: typing.Optional[int] = None
-    transport_disconnect: typing.Optional[bool] = None
-    requirements: typing.Optional[Data] = None
-    beginning: typing.Optional[bool] = None
-    end: typing.Optional[bool] = None
-    calling_ssel: typing.Optional[int] = None
-    called_ssel: typing.Optional[int] = None
-    user_data: typing.Optional[Data] = None
-    data: Data = b''
-
-
-def _encode(spdu):
-    params = bytearray()
-
-    conn_acc = bytearray()
-    if spdu.extended_spdus is not None:
-        _encode_param(conn_acc, 19, [1] if spdu.extended_spdus else [0])
-    if spdu.version_number is not None:
-        _encode_param(conn_acc, 22, [spdu.version_number])
-    if conn_acc:
-        _encode_param(params, 5, conn_acc)
-
-    if spdu.transport_disconnect is not None:
-        _encode_param(params, 17, [1 if spdu.transport_disconnect else 0])
-    if spdu.requirements is not None:
-        _encode_param(params, 20, spdu.requirements)
-    if spdu.beginning is not None and spdu.end is not None:
-        _encode_param(params, 25, [(1 if spdu.beginning else 0) |
-                                   (2 if spdu.end else 0)])
-    if spdu.calling_ssel is not None:
-        _encode_param(params, 51, spdu.calling_ssel.to_bytes(2, 'big'))
-    if spdu.called_ssel is not None:
-        _encode_param(params, 52, spdu.called_ssel.to_bytes(2, 'big'))
-    if spdu.user_data is not None:
-        _encode_param(params, 193, spdu.user_data)
-
-    buff = bytearray()
-    buff.append(spdu.type.value)
-    _encode_length(buff, params)
-    buff.extend(params)
-    buff.extend(spdu.data)
-    return buff
-
-
-def _decode(data):
-    if data[:len(_give_tokens_spdu_data)] == _give_tokens_spdu_data:
-        data = data[len(_give_tokens_spdu_data):]
-
-    spdu_type, data = _SpduType(data[0]), data[1:]
-    params_length, data = _decode_length(data)
-    params, data = data[:params_length], data[params_length:]
-
-    extended_spdus = None
-    version_number = None
-    transport_disconnect = None
-    requirements = None
-    beginning = None
-    end = None
-    calling_ssel = None
-    called_ssel = None
-    user_data = None
-    while params:
-        code, param, params = _decode_param(params)
-        if code == 5:
-            conn_acc = param
-            while conn_acc:
-                code, param, conn_acc = _decode_param(conn_acc)
-                if code == 19:
-                    extended_spdus = bool(param[0])
-                elif code == 22:
-                    version_number = param[0]
-        elif code == 17:
-            transport_disconnect = bool(param[0])
-        elif code == 20:
-            requirements = param
-        elif code == 25:
-            beginning = bool(param[0] & 1)
-            end = bool(param[0] & 2)
-        elif code == 51:
-            calling_ssel = int.from_bytes(param, 'big')
-        elif code == 52:
-            called_ssel = int.from_bytes(param, 'big')
-        elif code == 193:
-            user_data = param
-
-    return _Spdu(type=spdu_type,
-                 extended_spdus=extended_spdus,
-                 version_number=version_number,
-                 transport_disconnect=transport_disconnect,
-                 requirements=requirements,
-                 beginning=beginning,
-                 end=end,
-                 calling_ssel=calling_ssel,
-                 called_ssel=called_ssel,
-                 user_data=user_data,
-                 data=data)
-
-
-def _encode_param(buff, code, data):
-    buff.append(code)
-    _encode_length(buff, data)
-    buff.extend(data)
-
-
-def _decode_param(data):
-    code, data = data[0], data[1:]
-    length, data = _decode_length(data)
-    return code, data[:length], data[length:]
-
-
-def _encode_length(buff, data):
-    li = len(data)
-    if li < 0xFF:
-        buff.append(li)
-    else:
-        buff.extend([0xFF, li >> 8, li & 0xFF])
-
-
-def _decode_length(data):
-    if data[0] != 0xFF:
-        return data[0], data[1:]
-    return ((data[1] << 8) | data[2]), data[3:]
-
-
-_give_tokens_spdu_data = b'\x01\x00'
-_params_requirements = b'\x00\x02'
-_params_version = 2
-_ab_spdu = _Spdu(_SpduType.AB, transport_disconnect=True)
-_dn_spdu = _Spdu(_SpduType.DN)
```

## Comparing `hat_drivers-0.6.9.dist-info/LICENSE` & `hat_drivers-0.7.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `hat_drivers-0.6.9.dist-info/METADATA` & `hat_drivers-0.7.0.dist-info/METADATA`

 * *Files 16% similar despite different names*

```diff
@@ -1,61 +1,92 @@
 Metadata-Version: 2.1
 Name: hat-drivers
-Version: 0.6.9
+Version: 0.7.0
 Summary: Hat communication drivers
 Home-page: https://github.com/hat-open/hat-drivers
 License: Apache-2.0
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: Apache Software License
-Requires-Python: >=3.8
+Requires-Python: >=3.10
 Description-Content-Type: text/x-rst
 License-File: LICENSE
-Requires-Dist: aiohttp (~=3.8.3)
-Requires-Dist: cryptography (~=38.0.4)
-Requires-Dist: hat-aio (~=0.7.3)
-Requires-Dist: hat-asn1 (~=0.6.3)
-Requires-Dist: hat-json (~=0.5.13)
-Requires-Dist: hat-util (<0.7.0,>=0.5.8)
+Requires-Dist: aiohttp (~=3.8.4)
+Requires-Dist: cryptography (>=3.3.2)
+Requires-Dist: hat-aio (~=0.7.8)
+Requires-Dist: hat-asn1 (~=0.6.6)
+Requires-Dist: hat-json (~=0.5.19)
+Requires-Dist: hat-util (~=0.6.10)
 Requires-Dist: pyserial (~=3.5)
 
-hat-drivers - Communication drivers
-===================================
+.. _online documentation: https://hat-drivers.hat-open.com
+.. _git repository: https://github.com/hat-open/hat-drivers.git
+.. _PyPI project: https://pypi.org/project/hat-drivers
+.. _pydoit: https://pydoit.org
+.. _Hat Open: https://hat-open.com
+.. _Konar Digital: https://www.koncar.hr/en
 
-This library is part of Hat Open project - open-source framework of tools and
-libraries for developing applications used for remote monitoring, control and
-management of intelligent electronic devices such as IoT devices, PLCs,
-industrial automation or home automation systems.
 
-Development of Hat Open and associated repositories is sponsored by
-`Konar Digital <https://www.koncar.hr>`_.
+hat-drivers - Communication drivers
+===================================
 
 For more information see:
 
-    * hat-drivers documentation - `<https://hat-drivers.hat-open.com>`_
-    * hat-drivers git repository - `<https://github.com/hat-open/hat-drivers.git>`_
-    * Hat Open homepage - `<https://hat-open.com>`_
+* `online documentation`_
+* `git repository`_
 
-.. warning::
 
-    This project is currently in state of active development. Features,
-    functionality and API are unstable.
+Runtime requirements
+--------------------
+
+* python >=3.10
 
 
 Install
 -------
 
-::
+`hat-drivers` is available as `PyPI project`_::
 
     $ pip install hat-drivers
 
 
+Build
+-----
+
+Build tool used for `hat-drivers` is `pydoit`_. It can be installed together
+with other python dependencies by running::
+
+    $ pip install -r requirements.pip.dev.txt
+
+For listing available doit tasks, use::
+
+    $ doit list
+
+Default task::
+
+    $ doit
+
+creates wheel package inside `build` directory.
+
+
+Hat Open
+--------
+
+`hat-drivers` is part of `Hat Open`_ project - open-source framework of tools
+and libraries for developing applications used for remote monitoring, control
+and management of intelligent electronic devices such as IoT devices, PLCs,
+industrial automation or home automation systems.
+
+Development of Hat Open and associated repositories is sponsored by
+`Konar Digital`_.
+
+
 License
 -------
 
-Copyright 2020-2022 Hat Open AUTHORS
+Copyright 2020-2023 Hat Open AUTHORS
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 
     http://www.apache.org/licenses/LICENSE-2.0
```

## Comparing `hat_drivers-0.6.9.dist-info/RECORD` & `hat_drivers-0.7.0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,97 +1,110 @@
 hat/drivers/__init__.py,sha256=UO4PRHAujnvqYiMfPDy7x_nTW5KqOsqzFXyZseTTSzQ,28
-hat/drivers/cosp.py,sha256=bCc9VleWNrd7Ayk5gxuD_jHDy-Udfc5GytLl4iGW2_w,14501
-hat/drivers/cotp.py,sha256=7dZ8OIF5Px0TyA9sViFarJXDDQGvvMh3wutznlKztyA,14253
-hat/drivers/serial.py,sha256=jVLDWeBLLuYGxUglKCJXNFLO_-BZL9zHujgvHk8BSY8,6645
-hat/drivers/ssdp.py,sha256=3Y2qnz8D_5ZjebIP7315RSg-9OpjvHAiolqX4WtVRYw,2735
-hat/drivers/tcp.py,sha256=oi7qlmoGe2d3VapIewS75hfx-IsVrWpimlFHQZoZKGQ,10153
-hat/drivers/tpkt.py,sha256=6l6ddcwKPuwZowZ0SGisYLFfaeDTG3KLqFbKaEALSQQ,4036
-hat/drivers/udp.py,sha256=NUu6cQEOl04t91JNkz0PymBnO4vzR5F3TvXc5cs89A0,2756
-hat/drivers/acse/__init__.py,sha256=nSbXCFVbjHCG_lZNSFJ391JBaBqx2KEstlig4uR7gCI,15198
+hat/drivers/ssdp.py,sha256=B2kqGmBDFXCsI0-C7sv_Xntq2e3Z3Z4VX-b-CTegKwY,2691
+hat/drivers/tcp.py,sha256=dlhNRzCCfwOGCez_w4XO1CPWvHd-wP_1A1TNGzqKEpQ,12953
+hat/drivers/tpkt.py,sha256=Fux8OLuTrE-SSnHMDrCXJKlCYP3uZworOGqSnZcGfRo,4582
+hat/drivers/udp.py,sha256=HjzHCuNCkimDtK96Q9UQWDizn0oalBn0aDWOT1QrUtM,3139
+hat/drivers/acse/__init__.py,sha256=Bzhhn-DjM25xFi0mQ21BKtSrCaZMzuRZA7c7LPpoUX8,18002
 hat/drivers/acse/asn1_repo.json,sha256=Tffx-W5yNdiWjIh6pP83t4MN4TEbpeQnLZh7VPwVZNc,8498
 hat/drivers/cdt/__init__.py,sha256=wG0lASt8qE99KEytBExJDmbK_xHkzbyhBgYbUc5DB7c,1024
 hat/drivers/cdt/browser.py,sha256=v-HFpa2WDPJUqgTjTOsGSRj_PEoUSps42bm7CavMQno,286
-hat/drivers/cdt/connection.py,sha256=1H1X0qZ6HWCH7y8s1tfdIwci3iNselXFRt6Ra-BCjlo,3476
+hat/drivers/cdt/connection.py,sha256=AkRQ10rCRRb7GTq8vYmW4H3r1UiXmBH6Nn2_h8I970k,3466
 hat/drivers/cdt/page.py,sha256=jKaYGEPyVe57PE_VVtbtlE6eYKjXthaBXtQXs9kCdSE,596
-hat/drivers/cdt/runtime.py,sha256=GRtOEil-Xd9skpCl5KOx2b9_KYtDdsoTLy9eeBEr1ow,1297
-hat/drivers/cdt/target.py,sha256=-ZFTO7QBWYDmCLTpTjuh0bcE6yaJF8E0RPrL4lqg8Mw,2859
-hat/drivers/copp/__init__.py,sha256=DgsWroXdrXEPv24E5vpQwdo8LG_fePDaNyxMeL-5nQw,14325
+hat/drivers/cdt/runtime.py,sha256=Epcdh2bdwJSzI-AOM_BSf31L52b-jnO5uqu0KDXwZm8,1268
+hat/drivers/cdt/target.py,sha256=lzDwW9fc8nj_3F_oIi6-v1g3JsxTOaovlEvFuMWLEsw,2807
+hat/drivers/copp/__init__.py,sha256=iOWewUPPga2QEjw_-tT3Ke1Yd7cCam4Ep8cdCgGIOP0,17263
 hat/drivers/copp/asn1_repo.json,sha256=sDQRMgbqhoKVvhPDhuM0Llgp1LzKcSvPJODRpdlOdzg,12628
-hat/drivers/iec101/__init__.py,sha256=glY-xkDCiNuqBX4Wuku_vao8mlrmpy3BhhUXZ4y_5Qc,7994
-hat/drivers/iec101/common.py,sha256=7heZqbWY5pEN1qNszqLM7-Wv8Q5XGowS1rRdHvq9B0A,16692
-hat/drivers/iec101/connection.py,sha256=UTtOPxyysA-ap8fqYEhHMGWyRUTin8H38eNE6j-RbeQ,1025
-hat/drivers/iec101/encoder.py,sha256=cvvDf3igWMIykgyrZR3CHLrJ6IC_S5OpWWUx3LTbpLU,33150
-hat/drivers/iec103/__init__.py,sha256=PS7K4sxttTl10mIo4ch0tmAEubcF7h-YqqQ0RioXnGU,3592
-hat/drivers/iec103/common.py,sha256=INO8HVSFlepy0ZEwN80dAVwtw_QsGc8DDoJQnKOA05w,4230
-hat/drivers/iec103/master.py,sha256=TMDKcBmGx5BNfPtnpm7Pabz8zKK0kYZfxl4_uo0mpdE,17825
-hat/drivers/iec104/__init__.py,sha256=IyU1DYwdGz4G-jq4Z3Ir6lvB18x0pEGEnnCJXRq9tz4,8052
-hat/drivers/iec104/common.py,sha256=pVQNOYDpbJ7OQOSJ1GEr5LEkcvOntBevhwocM9e-8zE,5967
-hat/drivers/iec104/encoder.py,sha256=Eh-n6cUp3p3Wl3iKTiVNyEsg8atYkxYhoFdsqtoKn6k,30142
-hat/drivers/iec104/connection/__init__.py,sha256=PGyw9Z-wE5YJrkxhNBEDH7J6GuE7mNMLHuH1ZzrXJXA,3426
-hat/drivers/iec104/connection/regular.py,sha256=iBbSkhAsjLfo_oMhS57XJfZujbLhhaZT0KwbwJRCAWA,1060
-hat/drivers/iec104/connection/secure.py,sha256=r0TLTQAkwesA883RKjsJg-BAl9fP_VNx1sg12vRECcE,3533
+hat/drivers/cosp/__init__.py,sha256=LNMwl9imlYOgnS3Frxddk8sDxyeCAGl5bPgZQzxZgYs,582
+hat/drivers/cosp/common.py,sha256=ptZkWMM2fI7dK7-2YC1fIelaWEDm71x1Vbtc7zb4Ba4,670
+hat/drivers/cosp/connection.py,sha256=YMEdPzE1U-Dz8J7tyqo9uYMumG35yLXf2r7vx8uq5T0,13338
+hat/drivers/cosp/encoder.py,sha256=0kLDavhIriK6DACDURynBkFMwbyxJOlkvzXSho7dxUs,3895
+hat/drivers/cotp/__init__.py,sha256=VCE7xOygmmoWGUFM8-AHzKO7Nctj0OuHIP9d8i3TCjc,506
+hat/drivers/cotp/common.py,sha256=dP8fBswknTQ6M2JM2mXQtHuHcKbhDFb0MzvaBsPBIUQ,1747
+hat/drivers/cotp/connection.py,sha256=x5PiBjDPSV7WpZKGLDlS8L8SCLyY5E8NkizSGbSTS5c,10851
+hat/drivers/cotp/encoder.py,sha256=ZWcbWqf3MPDm1P13G8fH1ND9QPYz-GzGvQGnUnDG0N0,4807
+hat/drivers/iec101/__init__.py,sha256=XarPNvu9opiziYAuUB8V0oFb3v5NepaaxLO8dkRyUqo,7928
+hat/drivers/iec101/common.py,sha256=eJC9P6VjF7fkl9LGaYU-OPj7qckfhMTifgsxjiQI7Qw,17550
+hat/drivers/iec101/connection.py,sha256=D2aGwfrVsPj1CJivSMd4yOuGVWJauXpM3T7yjsAdqnQ,996
+hat/drivers/iec101/encoder.py,sha256=xadfFhxPjuWwplSen6eKxZbw1oVpHWMSAYeFOg08AFQ,33161
+hat/drivers/iec103/__init__.py,sha256=8BXko70YVZzAcCAhgqGaKLtCdBJm4ugPnFdMRnv3Gbc,3526
+hat/drivers/iec103/common.py,sha256=ZgKWA6eQN2kUXgbNEmeeCDhfoClvGPx-RvAR2P6E9G0,4734
+hat/drivers/iec103/master.py,sha256=dRtEnB3LBx7kKh98SB4cnPVVoNJ2zP-LY3hUjCgoDe0,17832
+hat/drivers/iec104/__init__.py,sha256=6IgwGCshxqJbkVKwNvDgvHPF7ny6X5QAqK0Odoq_S7k,7986
+hat/drivers/iec104/common.py,sha256=nVXHBovt5sAN9qndr-nw0fZeXPtO_rcYWeHru7Vsq5Q,7450
+hat/drivers/iec104/encoder.py,sha256=yr9vyAGdZ21e0A6YATYOMlJxcQc7M6yH6ih8VibJRKU,30153
+hat/drivers/iec104/connection/__init__.py,sha256=GMFeUtzijtM5p28GbdZxB3aZ6ZTJAeHX7pfq19gNwDA,3324
+hat/drivers/iec104/connection/regular.py,sha256=KBOvdIvaWPPDh3DA7eTnBaWtSMmg1b4K_keWGO1KumA,977
+hat/drivers/iec104/connection/secure.py,sha256=kr3a9HJmFhRLKDTLQ5sg2ESXoHCV-VaM1oCK74rbZLE,3340
 hat/drivers/iec60870/__init__.py,sha256=O_WDH0bbJgX8Mlhcr3P7MsS_kElBzs4moRKy5FnFlYQ,42
-hat/drivers/iec60870/apci/__init__.py,sha256=6AkjJ8x3UKebh70yT_n9MhxwMufmOp412RQtkFvZIGU,647
-hat/drivers/iec60870/apci/common.py,sha256=Jv-WXDs4V0NuehGIM2uboeRXMKpI9aI8AqiBTcQyBv4,571
-hat/drivers/iec60870/apci/connection.py,sha256=ZxrY8d3Qiax7KFOefQC_XQbU6imXWJORyfKk5IhwyDA,15414
-hat/drivers/iec60870/apci/encoder.py,sha256=-2x1sXr7bgI302OgHF6uvWxdlJmFLFRZfvGugEpdT58,2159
-hat/drivers/iec60870/link/__init__.py,sha256=1wJ_tR4nhYzAFDUPYTzw6DlX3TRGfeeIwLXVdSttm9U,725
-hat/drivers/iec60870/link/common.py,sha256=x5Va7JhGDfEaBMIpIQuAEljH_4XqZ457lsjQThzxWH4,1336
-hat/drivers/iec60870/link/connection.py,sha256=kwdtUQBHQOrumU46kC1vjQIrh9GLOSkvXjcdQVV4Ufk,335
-hat/drivers/iec60870/link/encoder.py,sha256=xDBkQpMIw3jDVgPpmjiYhWTdgqPXfnRhEPMRbq_RYyk,4822
-hat/drivers/iec60870/link/endpoint.py,sha256=guoXBH_HJ26zCbGU8dpeD35hbLofJONyQEQ8xaIdiE4,2348
+hat/drivers/iec60870/apci/__init__.py,sha256=V-HmbczJCFStFJYyBRFFfgjosyFlPKIH-i7ZR5FYpXw,572
+hat/drivers/iec60870/apci/common.py,sha256=--Wjw9zIROagmQtbOmHlXaXhiBgI_f0o81HpZ7ZWyTk,570
+hat/drivers/iec60870/apci/connection.py,sha256=1rRwqo05HIwIHikFsdveNrPTv00q6-UZ7T9wkHFQQ-c,16414
+hat/drivers/iec60870/apci/encoder.py,sha256=re9UHJDpDPVMyMA_fVhVwKTRwy4cmBfPC8ZflycCHnI,2175
+hat/drivers/iec60870/link/__init__.py,sha256=tTeWkWRtqpabkrqWW88myAZQqInCHxsjglRkFEcjgWg,652
+hat/drivers/iec60870/link/common.py,sha256=nbyQ7rx-C_zOeVlYqPi1RcAg3i-PmQpMbGbm85I8Ws8,1309
+hat/drivers/iec60870/link/connection.py,sha256=MZY327rfnVXSrrlcmukDaBVZ6hHHW1KjhU5MlDzvYmE,339
+hat/drivers/iec60870/link/encoder.py,sha256=Uk5ElGpNdSatCVMYVYA4KwJ_gTXXwDkrSsOlgQ1TXBk,4838
+hat/drivers/iec60870/link/endpoint.py,sha256=6xSQ327G0CcIZ4LjSYrvrfba2tyKbdBvJ0wq0a-LpRA,2349
 hat/drivers/iec60870/link/balanced/__init__.py,sha256=dbAnQ9uYvjkorbaThlLDoRXp58mV3PWhCLNZL-hq2_8,90
-hat/drivers/iec60870/link/balanced/connection.py,sha256=uW10SmMU2jfcXJFF3yym3WwcUOudGMJ0GPixO9KXSLo,1085
+hat/drivers/iec60870/link/balanced/connection.py,sha256=OoiKPD62MgGDlQPE8eXeHpJ60-DC3mHl1MzWz9iMAX8,1103
 hat/drivers/iec60870/link/unbalanced/__init__.py,sha256=BcaIvKGnULA6IhgqUo2hB8mKvZI3X_fVdBsWe99ywHw,368
-hat/drivers/iec60870/link/unbalanced/master.py,sha256=OoWIbd3xd-spzPfHf-7AcIEwZWpCkQC1kMmHc0A2gi4,12180
-hat/drivers/iec60870/link/unbalanced/slave.py,sha256=-nhPK_-O4mlStBsmj5PclcS6z6G3kUbeknbDcUAGG7A,8162
+hat/drivers/iec60870/link/unbalanced/master.py,sha256=4RtzItMKUxT_boYtz9gsZAKS2_ZK-duFjoF9oDAhe3M,12166
+hat/drivers/iec60870/link/unbalanced/slave.py,sha256=-q3Ou_61QJmS5uL1AakXw8XbKp3yg7JI5VWkjhdK6t0,8118
 hat/drivers/iec60870/msgs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-hat/drivers/iec60870/msgs/common.py,sha256=KtElPnEdjZKdJes2WGvmixl_mrQ8JBrsh3TkMxtVxQA,3110
-hat/drivers/iec60870/msgs/encoder.py,sha256=H_gqb_2D9duKrsbSL9EO-Qlqx_7SpPSGsGSOKnU0MgU,6488
+hat/drivers/iec60870/msgs/common.py,sha256=vUaR6q8WYicWVzSkRT_EcA-8v7LPNvEf74ikUykmC-Q,2956
+hat/drivers/iec60870/msgs/encoder.py,sha256=hzNs09D5ghrBh40YpWbL5NArierRNIpMRHfkD9JSwv8,6645
 hat/drivers/iec60870/msgs/iec101/__init__.py,sha256=LoNnYnworC0Syt6WFBRjDDksmFOGQ0tDUcl9o3-T2So,182
-hat/drivers/iec60870/msgs/iec101/common.py,sha256=DC1cSD9XbBUMYzakR9rJJzT18qxQSgM4c705V1Uj0BA,15262
-hat/drivers/iec60870/msgs/iec101/encoder.py,sha256=JgGYYM8-VTTco2J3HM1ji_kzpF07sFz_Ew6MhOIF0aM,48820
+hat/drivers/iec60870/msgs/iec101/common.py,sha256=I7cs_LLtMQvJYmAtVxUcVvuaIDyrUIi8huLwicowgFw,15741
+hat/drivers/iec60870/msgs/iec101/encoder.py,sha256=VofiV_mbPBJC8mUmJPIPh4E8PpfZNTxx5zxsUB30iX0,48353
 hat/drivers/iec60870/msgs/iec103/__init__.py,sha256=sKeQPNibv6jLIOESHFsZBDEecpAPGRQbZUTvp1C13Lw,182
-hat/drivers/iec60870/msgs/iec103/common.py,sha256=VwfamW_GNpvLXTWxFm8dxcwN-KsmGTQex88nV5O7Ess,13455
-hat/drivers/iec60870/msgs/iec103/encoder.py,sha256=AAshR_kHWSHhwLwGPVj81Fgp7Pko0waAqTYYeIXQxg0,35045
+hat/drivers/iec60870/msgs/iec103/common.py,sha256=4yvhJCGh7pq9FeomUlGiSTy8p5E9cSh8CLEJJM1fMR4,13182
+hat/drivers/iec60870/msgs/iec103/encoder.py,sha256=sH-p93ttXd44A1eDOeaYLhkk91Q7sOugpfyBQpwZp-k,35040
 hat/drivers/iec60870/msgs/iec104/__init__.py,sha256=fIulTXzp_BVP_fWtl6TD9RWuoSohs0yNKm6f_8Ukx9M,182
-hat/drivers/iec60870/msgs/iec104/common.py,sha256=0ETk2pvx3KDAzvpfCCZjjmdjMPtFaZtwybqeCIzhxEs,9677
-hat/drivers/iec60870/msgs/iec104/encoder.py,sha256=rSTk1RotZOW6KqGkOTGwCH8oVB2pGrN4yQlNbUUVy0s,10043
+hat/drivers/iec60870/msgs/iec104/common.py,sha256=DN2f0idKbcCSgEwnLFnDzsbnf2Fmdh-V7sEMwDfiM1Y,9902
+hat/drivers/iec60870/msgs/iec104/encoder.py,sha256=-26EOSzKjZV7qGyDbfmhIxhpjpDAPnkRU7zDXyGRitE,10037
 hat/drivers/iec60870/msgs/security/__init__.py,sha256=blaR1iTo1sapYSNd6FzVF6gmB30nbh-OjwS2Sw9avlY,203
-hat/drivers/iec60870/msgs/security/common.py,sha256=WPLbFZ8_fwU9kj8vV-49u9RFUJl-Op4b0DDAE4z9dbI,7219
-hat/drivers/iec60870/msgs/security/encoder.py,sha256=m28ivpZRGjgUcE0vKICl6RRkJ3sUPv4JRhr4uY9BN84,25326
-hat/drivers/mms/__init__.py,sha256=tJgjZad0VPvnGg0bcsAafF3XiBb-oPRhw5ZWJqLmpP8,4434
+hat/drivers/iec60870/msgs/security/common.py,sha256=X4kNDnEAXDdAaiimMdufLNeRQQ-iGKkqjeIn4us-w80,7369
+hat/drivers/iec60870/msgs/security/encoder.py,sha256=1ddd2yEW1M0lYULgMJWvvIeEI0ndcH4MRZ_rE7jLrEI,25259
+hat/drivers/mms/__init__.py,sha256=Z2QQ6YpGyMLLXZJr6Jsr2cI6OwQR6z8WO_QDcGKYtV8,4404
 hat/drivers/mms/asn1_repo.json,sha256=kgJs61OAUoruZ_8rTEQyKn4ZZoTNYiUS1t9h-vZZEuk,186717
-hat/drivers/mms/common.py,sha256=U7zZARJIQaYPPDchZtXNYXWlFFJ_cYUc6qK4vBWGSY0,10223
-hat/drivers/mms/connection.py,sha256=IjyfBOo2JFJrauT6dfnR-ERrPiARObNQ3NaWZS-RURk,13095
-hat/drivers/mms/encoder.py,sha256=-YUA_by7ejs1A5yo1hBv5v8dYu-SEw72gbVUBYu5CZI,26923
+hat/drivers/mms/common.py,sha256=IC6SXfRD-IS7-KWGxXivwAv37XN6AmBnDZIHnU6weiU,8238
+hat/drivers/mms/connection.py,sha256=GqJsvqMQfpu7n47IznhCh2Bm6ropT_xZZa6lVYHA1FE,13117
+hat/drivers/mms/encoder.py,sha256=HXUFWeGNJx1KN2wMqPLCiCCW2fyMgtF6i8B1hY84ao0,26924
 hat/drivers/modbus/__init__.py,sha256=0QHorC_OjrIKfxZeEY1FU7RIOY1vl2jJCwbg09WcomM,1112
 hat/drivers/modbus/common.py,sha256=i7ZdYxQ4S9XAg0VF6MZ-__OK2-xwIjfQrFC5NGTVNOo,532
-hat/drivers/modbus/master.py,sha256=LrjUaH_kayhJ_KuTXvAbyueQdao5ioBeLM-TcuBTtLs,12155
-hat/drivers/modbus/slave.py,sha256=Mqlibee44JCqFI3vQ3TV5vJI_pNYOEjj0tB4oYg9bLQ,15351
+hat/drivers/modbus/master.py,sha256=L9MhEdnwhw7x3zWShHfV1uaPrjelgS1SEK7fxE5bMFI,13153
+hat/drivers/modbus/slave.py,sha256=CgNMR9z0MWbLFV4V2JXK4vYs-4DxmAMzE4Uv8fS88yo,16491
 hat/drivers/modbus/transport/__init__.py,sha256=BaavJsOVBa_ruNub5XSd1mlrSVHQBvj5kexEVj9D14s,3526
-hat/drivers/modbus/transport/common.py,sha256=5bHGDrOR05H58Jo93piz_Du9DX_sSYPF-PJhEjdjGBs,5176
-hat/drivers/modbus/transport/connection.py,sha256=rfbqMo73FzBN09W7hZbc-nnaajWS16Iqj3nNxHGeq30,3907
-hat/drivers/modbus/transport/encoder.py,sha256=HsBePlLUf8hTukWz8YjTwerV74mbBo67EQQuRUWKajQ,19777
+hat/drivers/modbus/transport/_encoder.abi3.pyd,sha256=-dg8YyAFJPC4peIzaqGmcJaD1Zg_SxjlmJV1lSt2wkA,108045
+hat/drivers/modbus/transport/common.py,sha256=kKPc3Xzat1NH4Y9dhkS7YOZ9xa0_k6fdbS53mPDOjFE,4552
+hat/drivers/modbus/transport/connection.py,sha256=jn-WhItQM93dfU4MM9LLJenK0HUdJFfQsMZ-UmwoniU,4709
+hat/drivers/modbus/transport/encoder.py,sha256=-4agUbvdn24LUbC295BxnKN9sUYY2WsZKQ2WbSDSu_M,19933
 hat/drivers/pnetgateway/__init__.py,sha256=H6q9I-xn4rf0Z0YUoVgJgLao8ihOGaQPFWYo0YIGhmA,823
-hat/drivers/pnetgateway/client.py,sha256=NDfR9HNeKwzTPIQu0LQWOWgmGemRny-OZ_VmORbQJrI,6161
-hat/drivers/pnetgateway/common.py,sha256=T-bJlIUGJercTbtX1-_gHT-d1V08oelpNm6SqDEiAGM,1182
-hat/drivers/pnetgateway/encoder.py,sha256=p0KXXU13OwPYp_V6d2dhOkNXCBTMjO21F6bmP2FT0nY,1880
-hat/drivers/pnetgateway/transport.py,sha256=jW8Jqr5omcfoDXxXKW-DVBAy_eUUKpiRMWwYi0L4V78,791
-hat/drivers/snmp/__init__.py,sha256=9UoB06_3cXIa2QqLQG9xwabfmnKM_yH_sPrrV_NrxTM,2029
-hat/drivers/snmp/agent.py,sha256=KP4aQgUWDVaB_1-xnKUYzgwRgxIhQglomB7_1_Vd25Q,6184
-hat/drivers/snmp/common.py,sha256=N1-Q9godBTBFDI1mnxHAL3yhk_PtMf7AdTUuLaR-Tuw,4942
-hat/drivers/snmp/manager.py,sha256=fhu9ej0nH2AnjwVC38xkts73ea7c-C-h_s8mHuQispA,7545
-hat/drivers/snmp/trap.py,sha256=DPpK3azQ1r1uSFWehGNr2iWoc8FaOrUe7bQDIAZIBVk,12648
-hat/drivers/snmp/encoder/__init__.py,sha256=QP0qXyogN-3fuI-fPSeGQf5NmCnOD5jX4kV2UymXzzY,2511
+hat/drivers/pnetgateway/client.py,sha256=e4nbw53PpEnvNOOIl_p9jKeZ5-WXVM5i1nbSlM4F27c,6296
+hat/drivers/pnetgateway/common.py,sha256=XL73Ym1zABJckyIDtQy2TNj9170Y3dhaZdGQmqaoQcQ,1142
+hat/drivers/pnetgateway/encoder.py,sha256=rwey5rL4k8je30h0OoeorDFzqf_AgKSS_tP6k6BG8HQ,1881
+hat/drivers/pnetgateway/transport.py,sha256=2DdWFEtDPPq3HA9r1zO4DnodJh1opMZbkRH-GLECpS0,803
+hat/drivers/serial/__init__.py,sha256=A41ydYvdskql49bpUDKjx-aPBA2tuJaRWwf7PaFK39s,1965
+hat/drivers/serial/_native_serial.abi3.pyd,sha256=X88CIUGe_kckWB-csbeDkOk6iJbj2V91xmjssHKl3CQ,120682
+hat/drivers/serial/common.py,sha256=y-h9G2fhrAMk4y8mxntJ_JLA3lRFhWeXqXl9BQtR_WY,1103
+hat/drivers/serial/native_serial.py,sha256=DkrapIqZOjTATLuyBDrWARvQfbV9g3QhcuIB7y8ZXlA,5794
+hat/drivers/serial/py_serial.py,sha256=DashtcNGeIcadeS1waUfJjxzON19clDFyqXYXGfz_pg,4681
+hat/drivers/snmp/__init__.py,sha256=PaxY_z6W9f-hDZBB4YfuhJm6RzHgc2hJzEbe2pdxv2c,1879
+hat/drivers/snmp/agent.py,sha256=BczItjPQAR8u77I-19PYf43IWDBUL7jGSwYcB8fd6cU,6185
+hat/drivers/snmp/common.py,sha256=4ocgyPjjTQQMFhJQjwMnq6EWpmE5aIdNd_fr3vlJnY8,4871
+hat/drivers/snmp/manager.py,sha256=n1BRNp9WRdP948rUoxctfEuDlnW6CBmaPN1OtbsjDPw,7546
+hat/drivers/snmp/trap.py,sha256=Y7UlDoAeV0lNaOhzHZwEvKUIwMBZjHgcrA17CJ4m8VA,12554
+hat/drivers/snmp/encoder/__init__.py,sha256=vWsrue7-LVP1FCEY4-V9bWrkJ__Z84OO04oUB0oZ37Y,2598
 hat/drivers/snmp/encoder/asn1_repo.json,sha256=pW-zNotno2j-q-RPNtike2yzyMMPL3S9Ls-ctSFglMc,9211
-hat/drivers/snmp/encoder/v1.py,sha256=0y-FRLx4do2zVcZ2vi00w3ZUF9wB05eQya1f_EyZm0U,6259
-hat/drivers/snmp/encoder/v2c.py,sha256=GYa-vj74W7uqsqJkxCicBBpcfLjfNW4Cq3ERZvOp63M,7937
+hat/drivers/snmp/encoder/v1.py,sha256=1qSWdX4W4Z0Qe9QxXfT7LnM87O5iwpu3gOEKJIJtvyI,6241
+hat/drivers/snmp/encoder/v2c.py,sha256=HJMTeZu-hSdp1Ti5OKJPCwNx6DEAzO402jMW9PBadIM,7935
 hat/drivers/snmp/encoder/v3.py,sha256=bY5yBFvw-SdoaIo_5hr0e_7vUvHhPrSZen9eF9CqHlY,1943
+hat/drivers/ssl/__init__.py,sha256=91IGwrFBWEkq_NjbqF7PNQhXQSFZSIf64FKjSFygW4w,2082
+hat/drivers/ssl/_ssl.abi3.pyd,sha256=T5Lg5Hxbo7429FuQU8nKWYJu2THHYikMLid5fugAdN4,107412
 hat/drivers/upnp/__init__.py,sha256=DmKhdhUxEVXPtrJ1IY4xavSZvAimJJVP86ikJrMJ8Wk,34
-hat/drivers/upnp/description.py,sha256=cC1ywmOwjh24m9j6seUciQ7VcTaHMe2Iua2RcgTPVrc,3199
-hat_drivers-0.6.9.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
-hat_drivers-0.6.9.dist-info/METADATA,sha256=tQ6kFRACUSeLe1sRhqLsKbhEUeic6nXkzW3CmZfAaH8,2063
-hat_drivers-0.6.9.dist-info/WHEEL,sha256=CV8iyE3A7V2uhg9OaTlpshab_dzxBhIEuLDh8OHPmAw,132
-hat_drivers-0.6.9.dist-info/top_level.txt,sha256=3RuRoRsaXQZNKwr3T2RE9XepBRTk4YpnXUbMiH5nes8,4
-hat_drivers-0.6.9.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
-hat_drivers-0.6.9.dist-info/RECORD,,
+hat/drivers/upnp/description.py,sha256=xcBhslCKk6p50QYw7TfvRMrjrOPTj2FYqS_yuvdT2ww,3132
+hat_drivers-0.7.0.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
+hat_drivers-0.7.0.dist-info/METADATA,sha256=k1MVdR5Pue15iPdXfprhBwnOVhEEJq92gQX1c5kD_kA,2484
+hat_drivers-0.7.0.dist-info/WHEEL,sha256=EIDplvKX77HSdIuX_rx4QpXXtuIW5PK_-oQMxkWTHag,127
+hat_drivers-0.7.0.dist-info/top_level.txt,sha256=3RuRoRsaXQZNKwr3T2RE9XepBRTk4YpnXUbMiH5nes8,4
+hat_drivers-0.7.0.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+hat_drivers-0.7.0.dist-info/RECORD,,
```

