# Comparing `tmp/pyscf-2.2.1.tar.gz` & `tmp/pyscf-2.3.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pyscf-2.2.1.tar", last modified: Sat Apr  1 22:08:14 2023, max compression
+gzip compressed data, was "pyscf-2.3.0.tar", last modified: Sat Jul  8 07:46:59 2023, max compression
```

## Comparing `pyscf-2.2.1.tar` & `pyscf-2.3.0.tar`

### file list

```diff
@@ -1,1052 +1,1056 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.963098 pyscf-2.2.1/
--rw-r--r--   0 runner    (1001) docker     (123)    47699 2023-04-01 22:08:12.000000 pyscf-2.2.1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (123)    11357 2023-04-01 22:08:12.000000 pyscf-2.2.1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)      562 2023-04-01 22:08:12.000000 pyscf-2.2.1/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)     3243 2023-04-01 22:08:12.000000 pyscf-2.2.1/NOTICE
--rw-r--r--   0 runner    (1001) docker     (123)     1608 2023-04-01 22:08:14.963098 pyscf-2.2.1/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     2845 2023-04-01 22:08:12.000000 pyscf-2.2.1/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.827096 pyscf-2.2.1/pyscf/
--rw-r--r--   0 runner    (1001) docker     (123)      800 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/__all__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1161 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/__config__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4642 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.831096 pyscf-2.2.1/pyscf/adc/
--rw-r--r--   0 runner    (1001) docker     (123)     2831 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4128 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/dfadc.py
--rw-r--r--   0 runner    (1001) docker     (123)    14994 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/radc.py
--rw-r--r--   0 runner    (1001) docker     (123)    29869 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/radc_amplitudes.py
--rw-r--r--   0 runner    (1001) docker     (123)    11722 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/radc_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)    43312 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/radc_ea.py
--rw-r--r--   0 runner    (1001) docker     (123)    38351 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/radc_ip.py
--rw-r--r--   0 runner    (1001) docker     (123)    44625 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/radc_ip_cvs.py
--rw-r--r--   0 runner    (1001) docker     (123)    15275 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/uadc.py
--rw-r--r--   0 runner    (1001) docker     (123)    41215 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/uadc_amplitudes.py
--rw-r--r--   0 runner    (1001) docker     (123)    22683 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/uadc_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)    89083 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/uadc_ea.py
--rw-r--r--   0 runner    (1001) docker     (123)    81739 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/uadc_ip.py
--rw-r--r--   0 runner    (1001) docker     (123)   109911 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/adc/uadc_ip_cvs.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.831096 pyscf-2.2.1/pyscf/agf2/
--rw-r--r--   0 runner    (1001) docker     (123)     6029 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    18199 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/_agf2.py
--rw-r--r--   0 runner    (1001) docker     (123)    22826 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/aux_space.py
--rw-r--r--   0 runner    (1001) docker     (123)     5076 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/chempot.py
--rw-r--r--   0 runner    (1001) docker     (123)     5793 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/chkfile.py
--rw-r--r--   0 runner    (1001) docker     (123)    12982 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/dfragf2.py
--rw-r--r--   0 runner    (1001) docker     (123)    13721 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/dfuagf2.py
--rw-r--r--   0 runner    (1001) docker     (123)     4376 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/mpi_helper.py
--rw-r--r--   0 runner    (1001) docker     (123)    35992 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/ragf2.py
--rw-r--r--   0 runner    (1001) docker     (123)     8709 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/ragf2_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    36471 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/uagf2.py
--rw-r--r--   0 runner    (1001) docker     (123)    10460 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/agf2/uagf2_slow.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.831096 pyscf-2.2.1/pyscf/ao2mo/
--rw-r--r--   0 runner    (1001) docker     (123)    20570 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ao2mo/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    11221 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ao2mo/_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)     7717 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ao2mo/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)     9787 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ao2mo/incore.py
--rw-r--r--   0 runner    (1001) docker     (123)    15389 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ao2mo/nrr_outcore.py
--rw-r--r--   0 runner    (1001) docker     (123)    34086 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ao2mo/outcore.py
--rw-r--r--   0 runner    (1001) docker     (123)    12225 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ao2mo/r_outcore.py
--rw-r--r--   0 runner    (1001) docker     (123)    13156 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ao2mo/semi_incore.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.839096 pyscf-2.2.1/pyscf/cc/
--rw-r--r--   0 runner    (1001) docker     (123)     7697 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      949 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/_ccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)     6080 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)     9663 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/bccd.py
--rw-r--r--   0 runner    (1001) docker     (123)     2918 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccd.py
--rw-r--r--   0 runner    (1001) docker     (123)    67040 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    17685 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccsd_lambda.py
--rw-r--r--   0 runner    (1001) docker     (123)    21249 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccsd_rdm.py
--rw-r--r--   0 runner    (1001) docker     (123)     9115 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccsd_rdm_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    11032 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccsd_t.py
--rw-r--r--   0 runner    (1001) docker     (123)     4357 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccsd_t_lambda_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     6401 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccsd_t_rdm_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     6645 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/ccsd_t_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     9440 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/dfccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    25619 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/eom_gccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    80794 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/eom_rccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)   117716 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/eom_uccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    24131 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/gccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)     8214 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/gccsd_lambda.py
--rw-r--r--   0 runner    (1001) docker     (123)    10804 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/gccsd_rdm.py
--rw-r--r--   0 runner    (1001) docker     (123)     3327 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/gccsd_t.py
--rw-r--r--   0 runner    (1001) docker     (123)     5864 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/gccsd_t_lambda.py
--rw-r--r--   0 runner    (1001) docker     (123)     8779 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/gccsd_t_rdm.py
--rw-r--r--   0 runner    (1001) docker     (123)     2830 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/gccsd_t_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     9609 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/gintermediates.py
--rw-r--r--   0 runner    (1001) docker     (123)    28221 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/momgfccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    17632 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/qcisd.py
--rw-r--r--   0 runner    (1001) docker     (123)     7530 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/qcisd_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     5528 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/qcisd_t.py
--rw-r--r--   0 runner    (1001) docker     (123)     5395 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/qcisd_t_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    16362 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/rccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)     9749 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/rccsd_lambda.py
--rw-r--r--   0 runner    (1001) docker     (123)    44719 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/rccsd_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    12025 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/rintermediates.py
--rw-r--r--   0 runner    (1001) docker     (123)    58897 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    23359 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uccsd_lambda.py
--rw-r--r--   0 runner    (1001) docker     (123)    27641 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uccsd_rdm.py
--rw-r--r--   0 runner    (1001) docker     (123)    29032 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uccsd_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    18577 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uccsd_t.py
--rw-r--r--   0 runner    (1001) docker     (123)     9775 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uccsd_t_lambda.py
--rw-r--r--   0 runner    (1001) docker     (123)    16218 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uccsd_t_rdm.py
--rw-r--r--   0 runner    (1001) docker     (123)     9259 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uccsd_t_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    38860 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uintermediates.py
--rw-r--r--   0 runner    (1001) docker     (123)     7310 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/cc/uintermediates_slow.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.839096 pyscf-2.2.1/pyscf/ci/
--rw-r--r--   0 runner    (1001) docker     (123)     3754 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ci/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1313 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ci/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)    44497 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ci/cisd.py
--rw-r--r--   0 runner    (1001) docker     (123)    18109 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ci/gcisd.py
--rw-r--r--   0 runner    (1001) docker     (123)    42328 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/ci/ucisd.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.839096 pyscf-2.2.1/pyscf/data/
--rw-r--r--   0 runner    (1001) docker     (123)      661 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    38038 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/elements.py
--rw-r--r--   0 runner    (1001) docker     (123)      788 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/gyro.py
--rw-r--r--   0 runner    (1001) docker     (123)     5327 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/gyromagnetic_ratio.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2644 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/nist.py
--rw-r--r--   0 runner    (1001) docker     (123)    23505 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/nuclear_g_factor.dat
--rw-r--r--   0 runner    (1001) docker     (123)     8817 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/nucprop.py
--rw-r--r--   0 runner    (1001) docker     (123)    13797 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/radii.py
--rw-r--r--   0 runner    (1001) docker     (123)     1928 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/data/solvents.dat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.839096 pyscf-2.2.1/pyscf/df/
--rw-r--r--   0 runner    (1001) docker     (123)     1540 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10115 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)    13699 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/df.py
--rw-r--r--   0 runner    (1001) docker     (123)    21252 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/df_jk.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.839096 pyscf-2.2.1/pyscf/df/grad/
--rw-r--r--   0 runner    (1001) docker     (123)      114 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    26211 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/casdm2_util.py
--rw-r--r--   0 runner    (1001) docker     (123)     9316 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/casscf.py
--rw-r--r--   0 runner    (1001) docker     (123)    19991 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     4432 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)      201 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/rohf.py
--rw-r--r--   0 runner    (1001) docker     (123)      201 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/roks.py
--rw-r--r--   0 runner    (1001) docker     (123)    17299 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/sacasscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     1986 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     3947 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/grad/uks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.839096 pyscf-2.2.1/pyscf/df/hessian/
--rw-r--r--   0 runner    (1001) docker     (123)      106 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/hessian/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    22428 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/hessian/rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     5273 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/hessian/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)    25454 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/hessian/uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     5878 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/hessian/uks.py
--rw-r--r--   0 runner    (1001) docker     (123)    11027 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/incore.py
--rw-r--r--   0 runner    (1001) docker     (123)    11278 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/outcore.py
--rw-r--r--   0 runner    (1001) docker     (123)     3646 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/df/r_incore.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.847097 pyscf-2.2.1/pyscf/dft/
--rw-r--r--   0 runner    (1001) docker     (123)     3341 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4998 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/dks.py
--rw-r--r--   0 runner    (1001) docker     (123)    25070 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/gen_grid.py
--rw-r--r--   0 runner    (1001) docker     (123)     1386 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/gen_libxc_param.py
--rw-r--r--   0 runner    (1001) docker     (123)     5001 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/gen_xcfun_param.py
--rw-r--r--   0 runner    (1001) docker     (123)     6151 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/gks.py
--rw-r--r--   0 runner    (1001) docker     (123)     2563 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/gks_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)   117255 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/libxc.py
--rw-r--r--   0 runner    (1001) docker     (123)   119767 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/numint.py
--rw-r--r--   0 runner    (1001) docker     (123)    29705 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/numint2c.py
--rw-r--r--   0 runner    (1001) docker     (123)    30233 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/r_numint.py
--rw-r--r--   0 runner    (1001) docker     (123)     5182 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/radi.py
--rw-r--r--   0 runner    (1001) docker     (123)    19449 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)     2420 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/rks_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)     2523 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/roks.py
--rw-r--r--   0 runner    (1001) docker     (123)     4870 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/sap.py
--rw-r--r--   0 runner    (1001) docker     (123)  3933728 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/sap_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6599 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/uks.py
--rw-r--r--   0 runner    (1001) docker     (123)     1795 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/uks_symm.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.847097 pyscf-2.2.1/pyscf/dft/xc/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/xc/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1635 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/xc/utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    19090 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/xc_deriv.py
--rw-r--r--   0 runner    (1001) docker     (123)    37382 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/dft/xcfun.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.847097 pyscf-2.2.1/pyscf/eph/
--rw-r--r--   0 runner    (1001) docker     (123)      878 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/eph/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5910 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/eph/eph_fd.py
--rw-r--r--   0 runner    (1001) docker     (123)     8464 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/eph/rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     8107 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/eph/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)     6225 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/eph/uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    10834 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/eph/uks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.851097 pyscf-2.2.1/pyscf/fci/
--rw-r--r--   0 runner    (1001) docker     (123)     9053 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    31951 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)    18925 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/cistring.py
--rw-r--r--   0 runner    (1001) docker     (123)    15408 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/direct_ep.py
--rw-r--r--   0 runner    (1001) docker     (123)     9501 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/direct_nosym.py
--rw-r--r--   0 runner    (1001) docker     (123)    18351 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/direct_spin0.py
--rw-r--r--   0 runner    (1001) docker     (123)    13529 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/direct_spin0_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)    41187 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/direct_spin1.py
--rw-r--r--   0 runner    (1001) docker     (123)    10966 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/direct_spin1_cyl_sym.py
--rw-r--r--   0 runner    (1001) docker     (123)    28054 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/direct_spin1_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)    14577 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/direct_uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     9667 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/fci_dhf_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     9107 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/fci_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    15142 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/rdm.py
--rw-r--r--   0 runner    (1001) docker     (123)    42019 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/selected_ci.py
--rw-r--r--   0 runner    (1001) docker     (123)    16283 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/selected_ci_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     7597 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/selected_ci_spin0.py
--rw-r--r--   0 runner    (1001) docker     (123)     6392 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/selected_ci_spin0_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)    13369 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/selected_ci_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)    11601 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/fci/spin_op.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.851097 pyscf-2.2.1/pyscf/geomopt/
--rw-r--r--   0 runner    (1001) docker     (123)      977 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/geomopt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3018 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/geomopt/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)     9026 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/geomopt/berny_solver.py
--rw-r--r--   0 runner    (1001) docker     (123)     9560 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/geomopt/geometric_solver.py
--rw-r--r--   0 runner    (1001) docker     (123)      288 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/geomopt/log.ini
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.851097 pyscf-2.2.1/pyscf/grad/
--rw-r--r--   0 runner    (1001) docker     (123)     1761 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    13787 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/casci.py
--rw-r--r--   0 runner    (1001) docker     (123)     8436 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/casscf.py
--rw-r--r--   0 runner    (1001) docker     (123)    17826 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/ccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    13169 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/ccsd_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     5049 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/ccsd_t.py
--rw-r--r--   0 runner    (1001) docker     (123)     7135 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/cisd.py
--rw-r--r--   0 runner    (1001) docker     (123)    10755 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/dhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     8759 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/lagrange.py
--rw-r--r--   0 runner    (1001) docker     (123)    11913 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/mp2.py
--rw-r--r--   0 runner    (1001) docker     (123)    16224 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    23315 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)     2124 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/rohf.py
--rw-r--r--   0 runner    (1001) docker     (123)     1311 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/roks.py
--rw-r--r--   0 runner    (1001) docker     (123)    38900 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/sacasscf.py
--rw-r--r--   0 runner    (1001) docker     (123)    12028 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/tdrhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    15129 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/tdrks.py
--rw-r--r--   0 runner    (1001) docker     (123)    10692 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/tduhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    20550 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/tduks.py
--rw-r--r--   0 runner    (1001) docker     (123)    21754 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/uccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)     5040 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/uccsd_t.py
--rw-r--r--   0 runner    (1001) docker     (123)     2493 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/ucisd.py
--rw-r--r--   0 runner    (1001) docker     (123)     3788 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    11302 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/uks.py
--rw-r--r--   0 runner    (1001) docker     (123)    12638 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/grad/ump2.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.855097 pyscf-2.2.1/pyscf/gto/
--rw-r--r--   0 runner    (1001) docker     (123)     1004 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.899097 pyscf-2.2.1/pyscf/gto/basis/
--rw-r--r--   0 runner    (1001) docker     (123)   137396 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/Burkatzi-Filippi-Dolg-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)    47103 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/DgaussA1_dft_cfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    47104 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/DgaussA1_dft_xfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    22868 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/DgaussA2_dft_cfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    22870 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/DgaussA2_dft_xfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    26619 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)   141928 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/adzp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    83566 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ahlrichs_cfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)  1389925 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ano.dat
--rw-r--r--   0 runner    (1001) docker     (123)   127274 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aqzp.dat
--rw-r--r--   0 runner    (1001) docker     (123)   108802 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/atzp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1993 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pV5Z-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)   124241 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pV5Z_MP2FIT.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1435 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVDZ-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)   134863 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVQZ-DK3.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1807 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVQZ-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)   108901 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVQZ_MP2FIT.dat
--rw-r--r--   0 runner    (1001) docker     (123)   110807 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVTZ-DK3.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1621 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVTZ-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)   190050 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pv5z-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)    53483 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pv5z-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    97411 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pv5z-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   190020 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pv5z.dat
--rw-r--r--   0 runner    (1001) docker     (123)   117453 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdpdz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    98649 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdz-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)    41742 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdz-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    30634 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdz-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)    98569 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    40752 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdzp-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    29379 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdzp-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   290273 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvqz-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)    48952 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvqz-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    48083 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvqz-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   155183 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvqz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   314115 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvtz-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)    45670 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvtz-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    39435 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvtz-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   122314 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvtz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   346258 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVQZ-DK.dat
--rw-r--r--   0 runner    (1001) docker     (123)   183629 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVQZ-DK3.dat
--rw-r--r--   0 runner    (1001) docker     (123)   410566 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVTZ-DK.dat
--rw-r--r--   0 runner    (1001) docker     (123)   139736 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVTZ-DK3.dat
--rw-r--r--   0 runner    (1001) docker     (123)   124542 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVTZ_MP2FIT.dat
--rw-r--r--   0 runner    (1001) docker     (123)   182677 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcv5z-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)   363886 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcv5z.dat
--rw-r--r--   0 runner    (1001) docker     (123)    37069 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcvdz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   285250 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcvqz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   192834 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcvtz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    48451 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pc-0.dat
--rw-r--r--   0 runner    (1001) docker     (123)   112718 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pc-1.dat
--rw-r--r--   0 runner    (1001) docker     (123)   173735 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pc-2.dat
--rw-r--r--   0 runner    (1001) docker     (123)   267909 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pc-3.dat
--rw-r--r--   0 runner    (1001) docker     (123)   390219 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pc-4.dat
--rw-r--r--   0 runner    (1001) docker     (123)    87863 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-0.dat
--rw-r--r--   0 runner    (1001) docker     (123)   122797 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-1.dat
--rw-r--r--   0 runner    (1001) docker     (123)   194490 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-2.dat
--rw-r--r--   0 runner    (1001) docker     (123)   312944 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-3.dat
--rw-r--r--   0 runner    (1001) docker     (123)   437986 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-4.dat
--rw-r--r--   0 runner    (1001) docker     (123)    12151 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/bfd_pp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    46296 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/bfd_v5z.dat
--rw-r--r--   0 runner    (1001) docker     (123)    31518 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/bfd_vdz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    65568 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/bfd_vqz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    57266 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/bfd_vtz.dat
--rw-r--r--   0 runner    (1001) docker     (123)     4828 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/bse.py
--rw-r--r--   0 runner    (1001) docker     (123)   200095 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pCV5Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)    54500 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pCV6Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3460 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pCVDZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    13152 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pCVQZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)     7488 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pCVTZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)   103871 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pV5Z_MP2FIT.dat
--rw-r--r--   0 runner    (1001) docker     (123)     4712 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pVDZ-PP-NR.dat
--rw-r--r--   0 runner    (1001) docker     (123)   114741 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pVQZ-DK3.dat
--rw-r--r--   0 runner    (1001) docker     (123)    90211 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pVQZ_MP2FIT.dat
--rw-r--r--   0 runner    (1001) docker     (123)    93193 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pVTZ-DK3.dat
--rw-r--r--   0 runner    (1001) docker     (123)     7167 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pVTZ-PP-NR.dat
--rw-r--r--   0 runner    (1001) docker     (123)   189349 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pv5z-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)    45383 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pv5z-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)   222905 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pv5z-pp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    41961 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pv5z-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   194433 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pv5z.dat
--rw-r--r--   0 runner    (1001) docker     (123)   115228 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvdpdz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   377366 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvdz-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)    36718 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvdz-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    94731 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvdz-pp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    30544 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvdz-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)    94827 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvdz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    11311 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvdz_fit.dat
--rw-r--r--   0 runner    (1001) docker     (123)   850318 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvqz-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)    41794 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvqz-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)   177582 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvqz-pp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    48631 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvqz-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   149280 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvqz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   914722 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvtz-dk.dat
--rw-r--r--   0 runner    (1001) docker     (123)    39454 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvtz-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)   132320 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvtz-pp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    39711 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvtz-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   117771 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvtz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    14008 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pvtz_fit.dat
--rw-r--r--   0 runner    (1001) docker     (123)   106072 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCV5Z-DK.dat
--rw-r--r--   0 runner    (1001) docker     (123)    98164 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCV5Z-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)   232487 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCV5Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)    53340 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVDZ-DK.dat
--rw-r--r--   0 runner    (1001) docker     (123)    12089 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVDZ-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)    18284 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVDZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)   241499 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVQZ-DK.dat
--rw-r--r--   0 runner    (1001) docker     (123)   160567 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVQZ-DK3.dat
--rw-r--r--   0 runner    (1001) docker     (123)    32332 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVQZ-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)    84240 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVQZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)   240607 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ-DK.dat
--rw-r--r--   0 runner    (1001) docker     (123)   120526 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ-DK3.dat
--rw-r--r--   0 runner    (1001) docker     (123)    22290 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ-PP.dat
--rw-r--r--   0 runner    (1001) docker     (123)    99466 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)   104732 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ_MP2FIT.dat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.823096 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.903097 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/
--rw-r--r--   0 runner    (1001) docker     (123)     8306 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP.dat
--rw-r--r--   0 runner    (1001) docker     (123)    80494 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pV5Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)    36684 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pV6Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)    41351 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVDZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    66515 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVQZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    53428 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVTZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    75421 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pV5Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)    34550 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pV6Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)    38752 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVDZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    62219 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVQZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    49967 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVTZ.dat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.903097 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/
--rw-r--r--   0 runner    (1001) docker     (123)     1155 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP.dat
--rw-r--r--   0 runner    (1001) docker     (123)    13000 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pV5Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)       65 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pV6Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)     9436 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVDZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    11614 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVQZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    10426 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVTZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    11812 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pV5Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)       65 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pV6Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)     8842 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVDZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)    10624 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVQZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)     9634 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVTZ.dat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.903097 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/
--rw-r--r--   0 runner    (1001) docker     (123)      294 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3396 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pV5Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2208 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVDZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2934 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVQZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2538 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVTZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3000 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pV5Z.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2010 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVDZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2604 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVQZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2274 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVTZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)   262035 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/crenbl.dat
--rw-r--r--   0 runner    (1001) docker     (123)   129690 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/crenbs.dat
--rw-r--r--   0 runner    (1001) docker     (123)     7054 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/crystal-cc-pvdz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    37024 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-qzvp-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   180299 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-qzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)   185113 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-qzvpd.dat
--rw-r--r--   0 runner    (1001) docker     (123)    43496 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-qzvpp-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   184475 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-qzvpp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    45242 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-qzvppd-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   189343 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-qzvppd.dat
--rw-r--r--   0 runner    (1001) docker     (123)    57404 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-svp-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   110762 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-svp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    60367 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-svpd-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   117659 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-svpd.dat
--rw-r--r--   0 runner    (1001) docker     (123)    71708 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-tzvp-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   132134 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-tzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    74591 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-tzvpd-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   138427 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-tzvpd.dat
--rw-r--r--   0 runner    (1001) docker     (123)    59466 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-tzvpp-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   136623 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-tzvpp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    62380 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-tzvppd-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)   142965 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-tzvppd.dat
--rw-r--r--   0 runner    (1001) docker     (123)   130384 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-universal-jfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)   235329 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/def2-universal-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    47198 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/demon_cfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)     9397 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dyall_dz.py
--rw-r--r--   0 runner    (1001) docker     (123)     8871 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dyall_qz.py
--rw-r--r--   0 runner    (1001) docker     (123)    13052 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dyall_tz.py
--rw-r--r--   0 runner    (1001) docker     (123)    10886 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   131530 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dzp-dkh.dat
--rw-r--r--   0 runner    (1001) docker     (123)   132516 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dzp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     8909 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dzp_dunning.py
--rw-r--r--   0 runner    (1001) docker     (123)   178866 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    71969 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/dzvp2.dat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.907097 pyscf-2.2.1/pyscf/gto/basis/f12-basis/
--rw-r--r--   0 runner    (1001) docker     (123)    20014 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/aug-cc-pV5Z-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    15354 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/aug-cc-pVDZ-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    17248 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/aug-cc-pVQZ-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    15259 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/aug-cc-pVTZ-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    28721 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pCVDZ-F12-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    26437 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pCVQZ-F12-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    25757 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pCVTZ-F12-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    56899 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pV5Z-F12.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2205 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pV5Z-F12rev2.dat
--rw-r--r--   0 runner    (1001) docker     (123)    12587 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVDZ-F12-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    26302 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVDZ-F12-nZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)      639 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVDZ-F12rev2.dat
--rw-r--r--   0 runner    (1001) docker     (123)    13769 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVQZ-F12-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    48697 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVQZ-F12-nZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1480 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVQZ-F12rev2.dat
--rw-r--r--   0 runner    (1001) docker     (123)    13371 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVTZ-F12-OptRI.dat
--rw-r--r--   0 runner    (1001) docker     (123)    35324 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVTZ-F12-nZ.dat
--rw-r--r--   0 runner    (1001) docker     (123)      947 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVTZ-F12rev2.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2441 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/faegre_dz.py
--rw-r--r--   0 runner    (1001) docker     (123)    43856 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/heavy-aug-cc-pvdz-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    30481 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/heavy-aug-cc-pvdz-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)    47735 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/heavy-aug-cc-pvtz-jkfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)    39167 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/heavy-aug-cc-pvtz-ri.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1839 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/iglo3.py
--rw-r--r--   0 runner    (1001) docker     (123)    92388 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/lanl08.dat
--rw-r--r--   0 runner    (1001) docker     (123)   109544 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/lanl2dz.dat
--rw-r--r--   0 runner    (1001) docker     (123)    52603 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/lanl2tz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   117876 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/minao.py
--rw-r--r--   0 runner    (1001) docker     (123)     5495 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/parse_bfd_pp.py
--rw-r--r--   0 runner    (1001) docker     (123)     4103 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/parse_gaussian.py
--rw-r--r--   0 runner    (1001) docker     (123)     6551 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/parse_molpro.py
--rw-r--r--   0 runner    (1001) docker     (123)    13573 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/parse_nwchem.py
--rw-r--r--   0 runner    (1001) docker     (123)    35344 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pc-0.dat
--rw-r--r--   0 runner    (1001) docker     (123)    82701 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pc-1.dat
--rw-r--r--   0 runner    (1001) docker     (123)   132372 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pc-2.dat
--rw-r--r--   0 runner    (1001) docker     (123)   211146 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pc-3.dat
--rw-r--r--   0 runner    (1001) docker     (123)   315764 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pc-4.dat
--rw-r--r--   0 runner    (1001) docker     (123)    65047 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pcseg-0.dat
--rw-r--r--   0 runner    (1001) docker     (123)    91188 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pcseg-1.dat
--rw-r--r--   0 runner    (1001) docker     (123)   150241 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pcseg-2.dat
--rw-r--r--   0 runner    (1001) docker     (123)   250673 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pcseg-3.dat
--rw-r--r--   0 runner    (1001) docker     (123)   357977 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pcseg-4.dat
--rw-r--r--   0 runner    (1001) docker     (123)    35826 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pob-tzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     9411 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pob-tzvpp.dat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.911097 pyscf-2.2.1/pyscf/gto/basis/pople-basis/
--rw-r--r--   0 runner    (1001) docker     (123)    55204 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21++G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    55937 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21++Gs.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3082 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21G-diffuse.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1615 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21G-polarization.dat
--rw-r--r--   0 runner    (1001) docker     (123)    53526 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    54234 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21Gs.dat
--rw-r--r--   0 runner    (1001) docker     (123)     7526 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/4-31G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    36010 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31++G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    21162 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31++Gs.dat
--rw-r--r--   0 runner    (1001) docker     (123)    38362 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31++Gss.dat
--rw-r--r--   0 runner    (1001) docker     (123)    21734 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31+G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    20062 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31+Gs.dat
--rw-r--r--   0 runner    (1001) docker     (123)    22947 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31+Gss.dat
--rw-r--r--   0 runner    (1001) docker     (123)    20190 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311++G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    21836 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311++Gs.dat
--rw-r--r--   0 runner    (1001) docker     (123)    34756 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311++Gss.dat
--rw-r--r--   0 runner    (1001) docker     (123)    20634 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311+G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    22361 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311+Gs.dat
--rw-r--r--   0 runner    (1001) docker     (123)    22104 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311+Gss.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2698 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-diffuse.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2180 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-2d.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1250 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-2p.dat
--rw-r--r--   0 runner    (1001) docker     (123)     4515 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-3d.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1585 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-3p.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3472 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-d.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2477 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-f.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1144 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-p.dat
--rw-r--r--   0 runner    (1001) docker     (123)    31263 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    33384 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311Gs.dat
--rw-r--r--   0 runner    (1001) docker     (123)    33056 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311Gss.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2992 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-diffuse.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2928 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-2d.dat
--rw-r--r--   0 runner    (1001) docker     (123)      748 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-2p.dat
--rw-r--r--   0 runner    (1001) docker     (123)     4215 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-3d.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1285 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-3p.dat
--rw-r--r--   0 runner    (1001) docker     (123)     4078 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-d.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2055 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-f.dat
--rw-r--r--   0 runner    (1001) docker     (123)      177 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-p.dat
--rw-r--r--   0 runner    (1001) docker     (123)    34316 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G.dat
--rw-r--r--   0 runner    (1001) docker     (123)    44932 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31Gs.dat
--rw-r--r--   0 runner    (1001) docker     (123)    36668 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31Gss.dat
--rw-r--r--   0 runner    (1001) docker     (123)   117420 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/qzp-dkh.dat
--rw-r--r--   0 runner    (1001) docker     (123)   117314 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/qzp.dat
--rw-r--r--   0 runner    (1001) docker     (123)   139676 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/roos-dz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   169498 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/roos-tz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   142994 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/sarc-dkh2.dat
--rw-r--r--   0 runner    (1001) docker     (123)    72840 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/sbkjc.dat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.911097 pyscf-2.2.1/pyscf/gto/basis/soecp/
--rw-r--r--   0 runner    (1001) docker     (123)     6080 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS10MDFSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)    12273 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS28MDFSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)     5195 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS28MWBSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3769 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS46MDFSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)     5467 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS60MDFSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)     7973 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS60MWBSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3683 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS78MDFSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)    10959 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS92MDFBQSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)    10955 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS92MDFBSO.dat
--rw-r--r--   0 runner    (1001) docker     (123)    49513 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/sto-3g.dat
--rw-r--r--   0 runner    (1001) docker     (123)    50158 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/sto-6g.dat
--rw-r--r--   0 runner    (1001) docker     (123)    70653 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/stuttgart_dz.dat
--rw-r--r--   0 runner    (1001) docker     (123)   140417 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/stuttgart_rsc.dat
--rw-r--r--   0 runner    (1001) docker     (123)   100829 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/tzp-dkh.dat
--rw-r--r--   0 runner    (1001) docker     (123)   100810 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/tzp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    48273 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/tzv.dat
--rw-r--r--   0 runner    (1001) docker     (123)   130384 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/basis/weigend_cfit.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1829 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/cmd_args.py
--rw-r--r--   0 runner    (1001) docker     (123)     6334 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/ecp.py
--rw-r--r--   0 runner    (1001) docker     (123)     9041 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/eval_gto.py
--rw-r--r--   0 runner    (1001) docker     (123)     6357 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/ft_ao.py
--rw-r--r--   0 runner    (1001) docker     (123)   141332 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/mole.py
--rw-r--r--   0 runner    (1001) docker     (123)    37978 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/moleintor.py
--rw-r--r--   0 runner    (1001) docker     (123)     2675 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gto/pp_int.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.911097 pyscf-2.2.1/pyscf/gw/
--rw-r--r--   0 runner    (1001) docker     (123)     1734 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gw/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    15534 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gw/gw_ac.py
--rw-r--r--   0 runner    (1001) docker     (123)    12067 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gw/gw_cd.py
--rw-r--r--   0 runner    (1001) docker     (123)    14552 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gw/gw_exact.py
--rw-r--r--   0 runner    (1001) docker     (123)    11034 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gw/gw_slow.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     9105 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gw/rpa.py
--rw-r--r--   0 runner    (1001) docker     (123)    18653 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gw/ugw_ac.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     7563 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/gw/urpa.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.911097 pyscf-2.2.1/pyscf/hessian/
--rw-r--r--   0 runner    (1001) docker     (123)      961 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/hessian/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    25044 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/hessian/rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    24203 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/hessian/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)    14633 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/hessian/thermo.py
--rw-r--r--   0 runner    (1001) docker     (123)    20889 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/hessian/uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    35539 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/hessian/uks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.915097 pyscf-2.2.1/pyscf/lib/
--rw-r--r--   0 runner    (1001) docker     (123)     9537 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1155 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.915097 pyscf-2.2.1/pyscf/lib/agf2/
--rw-r--r--   0 runner    (1001) docker     (123)      847 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/agf2/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)    13242 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/agf2/ragf2.c
--rw-r--r--   0 runner    (1001) docker     (123)     1516 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/agf2/ragf2.h
--rw-r--r--   0 runner    (1001) docker     (123)    12519 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/agf2/uagf2.c
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.915097 pyscf-2.2.1/pyscf/lib/ao2mo/
--rw-r--r--   0 runner    (1001) docker     (123)      909 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)    45916 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/nr_ao2mo.c
--rw-r--r--   0 runner    (1001) docker     (123)     2582 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/nr_ao2mo.h
--rw-r--r--   0 runner    (1001) docker     (123)     3094 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/nr_incore.c
--rw-r--r--   0 runner    (1001) docker     (123)     1428 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/nr_incore.h
--rw-r--r--   0 runner    (1001) docker     (123)    10730 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/nrr_ao2mo.c
--rw-r--r--   0 runner    (1001) docker     (123)    33947 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/r_ao2mo.c
--rw-r--r--   0 runner    (1001) docker     (123)     1267 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/r_ao2mo.h
--rw-r--r--   0 runner    (1001) docker     (123)     3042 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ao2mo/restore_eri.c
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.915097 pyscf-2.2.1/pyscf/lib/cc/
--rw-r--r--   0 runner    (1001) docker     (123)      894 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/cc/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3782 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/cc/ccsd_grad.c
--rw-r--r--   0 runner    (1001) docker     (123)     6538 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/cc/ccsd_pack.c
--rw-r--r--   0 runner    (1001) docker     (123)    44310 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/cc/ccsd_t.c
--rw-r--r--   0 runner    (1001) docker     (123)    35659 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/cc/uccsd_t.c
--rw-r--r--   0 runner    (1001) docker     (123)     5820 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/chkfile.py
--rw-r--r--   0 runner    (1001) docker     (123)      137 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/config.h.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.919098 pyscf-2.2.1/pyscf/lib/dft/
--rw-r--r--   0 runner    (1001) docker     (123)     1416 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)   173239 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/CxLebedevGrid.c
--rw-r--r--   0 runner    (1001) docker     (123)     3974 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/grid_basis.c
--rw-r--r--   0 runner    (1001) docker     (123)     1094 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/grid_basis.h
--rw-r--r--   0 runner    (1001) docker     (123)    34160 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/libxc_itrf.c
--rw-r--r--   0 runner    (1001) docker     (123)    10682 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/nr_numint.c
--rw-r--r--   0 runner    (1001) docker     (123)    54367 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/nr_numint_sparse.c
--rw-r--r--   0 runner    (1001) docker     (123)   105128 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/numint_uniform_grid.c
--rw-r--r--   0 runner    (1001) docker     (123)     9100 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/r_numint.c
--rw-r--r--   0 runner    (1001) docker     (123)     1197 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/vxc.h
--rw-r--r--   0 runner    (1001) docker     (123)     6567 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/xc_deriv.c
--rw-r--r--   0 runner    (1001) docker     (123)     7236 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/dft/xcfun_itrf.c
--rw-r--r--   0 runner    (1001) docker     (123)    12054 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/diis.py
--rw-r--r--   0 runner    (1001) docker     (123)      762 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/exceptions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.919098 pyscf-2.2.1/pyscf/lib/gto/
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.919098 pyscf-2.2.1/pyscf/lib/gto/autocode/
--rw-r--r--   0 runner    (1001) docker     (123)    57483 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/autocode/auto_eval1.c
--rw-r--r--   0 runner    (1001) docker     (123)    26701 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/deriv1.c
--rw-r--r--   0 runner    (1001) docker     (123)    63100 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/deriv2.c
--rw-r--r--   0 runner    (1001) docker     (123)     3784 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/fastexp.c
--rw-r--r--   0 runner    (1001) docker     (123)     8515 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/fill_grids_int2c.c
--rw-r--r--   0 runner    (1001) docker     (123)     7798 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/fill_int2c.c
--rw-r--r--   0 runner    (1001) docker     (123)    24491 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/fill_int2e.c
--rw-r--r--   0 runner    (1001) docker     (123)     7986 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/fill_nr_3c.c
--rw-r--r--   0 runner    (1001) docker     (123)     7357 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/fill_r_3c.c
--rw-r--r--   0 runner    (1001) docker     (123)     3480 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/fill_r_4c.c
--rw-r--r--   0 runner    (1001) docker     (123)    46755 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/ft_ao.c
--rw-r--r--   0 runner    (1001) docker     (123)     3955 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/ft_ao.h
--rw-r--r--   0 runner    (1001) docker     (123)    12435 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/ft_ao_deriv.c
--rw-r--r--   0 runner    (1001) docker     (123)    20944 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/grid_ao_drv.c
--rw-r--r--   0 runner    (1001) docker     (123)     4097 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/grid_ao_drv.h
--rw-r--r--   0 runner    (1001) docker     (123)      845 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/gto.h
--rw-r--r--   0 runner    (1001) docker     (123)  1015998 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/nr_ecp.c
--rw-r--r--   0 runner    (1001) docker     (123)    46231 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/gto/nr_ecp_deriv.c
--rw-r--r--   0 runner    (1001) docker     (123)    61582 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/linalg_helper.py
--rw-r--r--   0 runner    (1001) docker     (123)     6296 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/logger.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.919098 pyscf-2.2.1/pyscf/lib/mcscf/
--rw-r--r--   0 runner    (1001) docker     (123)     1236 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2795 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/fci.h
--rw-r--r--   0 runner    (1001) docker     (123)    23910 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/fci_4pdm.c
--rw-r--r--   0 runner    (1001) docker     (123)    34630 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/fci_contract.c
--rw-r--r--   0 runner    (1001) docker     (123)     8680 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/fci_contract_nosym.c
--rw-r--r--   0 runner    (1001) docker     (123)    30335 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/fci_rdm.c
--rw-r--r--   0 runner    (1001) docker     (123)    14106 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/fci_string.c
--rw-r--r--   0 runner    (1001) docker     (123)     9579 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/nevpt_contract.c
--rw-r--r--   0 runner    (1001) docker     (123)    25231 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/mcscf/select_ci.c
--rw-r--r--   0 runner    (1001) docker     (123)    42415 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/misc.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.923097 pyscf-2.2.1/pyscf/lib/np_helper/
--rw-r--r--   0 runner    (1001) docker     (123)      882 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/np_helper/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3460 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/np_helper/condense.c
--rw-r--r--   0 runner    (1001) docker     (123)     1292 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/np_helper/np_helper.c
--rw-r--r--   0 runner    (1001) docker     (123)     2639 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/np_helper/np_helper.h
--rw-r--r--   0 runner    (1001) docker     (123)     8172 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/np_helper/npdot.c
--rw-r--r--   0 runner    (1001) docker     (123)     5047 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/np_helper/omp_reduce.c
--rw-r--r--   0 runner    (1001) docker     (123)     7709 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/np_helper/pack_tril.c
--rw-r--r--   0 runner    (1001) docker     (123)     4398 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/np_helper/transpose.c
--rw-r--r--   0 runner    (1001) docker     (123)    45200 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/numpy_helper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2752 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/parameters.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.923097 pyscf-2.2.1/pyscf/lib/pbc/
--rw-r--r--   0 runner    (1001) docker     (123)      979 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)    11794 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/cint2e.c
--rw-r--r--   0 runner    (1001) docker     (123)    10426 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/cint3c2e.c
--rw-r--r--   0 runner    (1001) docker     (123)    49423 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/fill_ints.c
--rw-r--r--   0 runner    (1001) docker     (123)    81485 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/fill_ints_sr.c
--rw-r--r--   0 runner    (1001) docker     (123)    35487 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/ft_ao.c
--rw-r--r--   0 runner    (1001) docker     (123)    30687 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/grid_ao.c
--rw-r--r--   0 runner    (1001) docker     (123)    20143 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/inner_dot.c
--rw-r--r--   0 runner    (1001) docker     (123)    26183 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/nr_direct.c
--rw-r--r--   0 runner    (1001) docker     (123)     2454 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/optimizer.c
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/optimizer.h
--rw-r--r--   0 runner    (1001) docker     (123)     1882 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/pbc.h
--rw-r--r--   0 runner    (1001) docker     (123)     2875 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/pbc/symmetry.c
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.923097 pyscf-2.2.1/pyscf/lib/ri/
--rw-r--r--   0 runner    (1001) docker     (123)      825 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ri/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     7098 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/ri/r_df_incore.c
--rw-r--r--   0 runner    (1001) docker     (123)     3607 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/scipy_helper.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.927098 pyscf-2.2.1/pyscf/lib/vhf/
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)      806 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/cvhf.h
--rw-r--r--   0 runner    (1001) docker     (123)     4132 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/fblas.h
--rw-r--r--   0 runner    (1001) docker     (123)     5153 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/fill_nr_s8.c
--rw-r--r--   0 runner    (1001) docker     (123)    13409 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/hessian_screen.c
--rw-r--r--   0 runner    (1001) docker     (123)    23682 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/nr_direct.c
--rw-r--r--   0 runner    (1001) docker     (123)     2876 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/nr_direct.h
--rw-r--r--   0 runner    (1001) docker     (123)   132053 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/nr_direct_dot.c
--rw-r--r--   0 runner    (1001) docker     (123)    29999 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/nr_incore.c
--rw-r--r--   0 runner    (1001) docker     (123)    20242 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/nr_sgx_direct.c
--rw-r--r--   0 runner    (1001) docker     (123)    17348 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/optimizer.c
--rw-r--r--   0 runner    (1001) docker     (123)     2969 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/optimizer.h
--rw-r--r--   0 runner    (1001) docker     (123)    24284 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/r_direct_dot.c
--rw-r--r--   0 runner    (1001) docker     (123)     5677 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/r_direct_dot.h
--rw-r--r--   0 runner    (1001) docker     (123)    12689 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/r_direct_o1.c
--rw-r--r--   0 runner    (1001) docker     (123)    14446 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/rah_direct_dot.c
--rw-r--r--   0 runner    (1001) docker     (123)    14412 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/rha_direct_dot.c
--rw-r--r--   0 runner    (1001) docker     (123)    13334 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/rkb_screen.c
--rw-r--r--   0 runner    (1001) docker     (123)    25499 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/time_rev.c
--rw-r--r--   0 runner    (1001) docker     (123)     3479 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lib/vhf/time_rev.h
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.927098 pyscf-2.2.1/pyscf/lo/
--rw-r--r--   0 runner    (1001) docker     (123)     1026 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    14852 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/boys.py
--rw-r--r--   0 runner    (1001) docker     (123)     3210 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/cholesky.py
--rw-r--r--   0 runner    (1001) docker     (123)     2686 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/edmiston.py
--rw-r--r--   0 runner    (1001) docker     (123)     6575 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/iao.py
--rw-r--r--   0 runner    (1001) docker     (123)    16582 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/ibo.py
--rw-r--r--   0 runner    (1001) docker     (123)     9457 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/nao.py
--rw-r--r--   0 runner    (1001) docker     (123)    13365 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/orth.py
--rw-r--r--   0 runner    (1001) docker     (123)    11992 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/pipek.py
--rw-r--r--   0 runner    (1001) docker     (123)     4718 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/lo/vvo.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.927098 pyscf-2.2.1/pyscf/mcscf/
--rw-r--r--   0 runner    (1001) docker     (123)    20802 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/PiOS.py
--rw-r--r--   0 runner    (1001) docker     (123)    11792 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    65700 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)    10113 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/avas.py
--rw-r--r--   0 runner    (1001) docker     (123)    50444 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/casci.py
--rw-r--r--   0 runner    (1001) docker     (123)     7945 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/casci_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)     2314 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/chkfile.py
--rw-r--r--   0 runner    (1001) docker     (123)    16616 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/df.py
--rw-r--r--   0 runner    (1001) docker     (123)     9729 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/dmet_cas.py
--rw-r--r--   0 runner    (1001) docker     (123)    59738 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/mc1step.py
--rw-r--r--   0 runner    (1001) docker     (123)     6513 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/mc1step_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)     7968 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/mc2step.py
--rw-r--r--   0 runner    (1001) docker     (123)    14918 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/mc_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)    39686 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/newton_casscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     4974 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/newton_casscf_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)    20357 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/ucasci.py
--rw-r--r--   0 runner    (1001) docker     (123)    38636 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/umc1step.py
--rw-r--r--   0 runner    (1001) docker     (123)     6015 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/umc2step.py
--rw-r--r--   0 runner    (1001) docker     (123)    15946 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mcscf/umc_ao2mo.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.927098 pyscf-2.2.1/pyscf/md/
--rw-r--r--   0 runner    (1001) docker     (123)     1458 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/md/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1682 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/md/distributions.py
--rw-r--r--   0 runner    (1001) docker     (123)    17044 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/md/integrators.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.931098 pyscf-2.2.1/pyscf/mp/
--rw-r--r--   0 runner    (1001) docker     (123)     2740 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6958 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/dfgmp2.py
--rw-r--r--   0 runner    (1001) docker     (123)     5741 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/dfmp2.py
--rw-r--r--   0 runner    (1001) docker     (123)    30558 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/dfmp2_native.py
--rw-r--r--   0 runner    (1001) docker     (123)    26258 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/dfump2_native.py
--rw-r--r--   0 runner    (1001) docker     (123)    14930 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/gmp2.py
--rw-r--r--   0 runner    (1001) docker     (123)    30595 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/mp2.py
--rw-r--r--   0 runner    (1001) docker     (123)     7278 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/mp2f12_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    30400 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mp/ump2.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.931098 pyscf-2.2.1/pyscf/mrpt/
--rw-r--r--   0 runner    (1001) docker     (123)      772 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mrpt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    42942 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/mrpt/nevpt2.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.931098 pyscf-2.2.1/pyscf/pbc/
--rw-r--r--   0 runner    (1001) docker     (123)      286 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/__all__.py
--rw-r--r--   0 runner    (1001) docker     (123)      943 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.931098 pyscf-2.2.1/pyscf/pbc/adc/
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/adc/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1954 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/adc/dfadc.py
--rw-r--r--   0 runner    (1001) docker     (123)    13136 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/adc/kadc_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)    11436 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/adc/kadc_rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    14131 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/adc/kadc_rhf_amplitudes.py
--rw-r--r--   0 runner    (1001) docker     (123)    62318 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/adc/kadc_rhf_ea.py
--rw-r--r--   0 runner    (1001) docker     (123)    46647 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/adc/kadc_rhf_ip.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.931098 pyscf-2.2.1/pyscf/pbc/ao2mo/
--rw-r--r--   0 runner    (1001) docker     (123)      632 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/ao2mo/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8682 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/ao2mo/eris.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.935098 pyscf-2.2.1/pyscf/pbc/cc/
--rw-r--r--   0 runner    (1001) docker     (123)     2136 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6728 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/ccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    82519 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_ghf.py
--rw-r--r--   0 runner    (1001) docker     (123)    68243 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     2448 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_rhf_ea.py
--rw-r--r--   0 runner    (1001) docker     (123)     2429 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_rhf_ip.py
--rw-r--r--   0 runner    (1001) docker     (123)    57971 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    35089 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    50402 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kccsd_rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    31998 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kccsd_rhf_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)    15664 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kccsd_t.py
--rw-r--r--   0 runner    (1001) docker     (123)    28804 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kccsd_t_rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    11709 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kccsd_t_rhf_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    59109 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kccsd_uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    22280 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kintermediates.py
--rw-r--r--   0 runner    (1001) docker     (123)    42214 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kintermediates_rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    10075 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kintermediates_rhf_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)    60669 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kintermediates_uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     7878 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/cc/kuccsd_rdm.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.935098 pyscf-2.2.1/pyscf/pbc/ci/
--rw-r--r--   0 runner    (1001) docker     (123)     1298 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/ci/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4715 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/ci/cisd.py
--rw-r--r--   0 runner    (1001) docker     (123)    26420 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/ci/kcis_rhf.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.935098 pyscf-2.2.1/pyscf/pbc/df/
--rw-r--r--   0 runner    (1001) docker     (123)      970 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    24024 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/aft.py
--rw-r--r--   0 runner    (1001) docker     (123)    17682 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/aft_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)    15896 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/aft_jk.py
--rw-r--r--   0 runner    (1001) docker     (123)    32100 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/df.py
--rw-r--r--   0 runner    (1001) docker     (123)    13852 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/df_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)    44538 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/df_jk.py
--rw-r--r--   0 runner    (1001) docker     (123)    14978 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/fft.py
--rw-r--r--   0 runner    (1001) docker     (123)    18458 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/fft_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)    19061 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/fft_jk.py
--rw-r--r--   0 runner    (1001) docker     (123)    28164 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/ft_ao.py
--rw-r--r--   0 runner    (1001) docker     (123)    27614 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/gdf_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)    29572 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/incore.py
--rw-r--r--   0 runner    (1001) docker     (123)    18202 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/mdf.py
--rw-r--r--   0 runner    (1001) docker     (123)     6818 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/mdf_ao2mo.py
--rw-r--r--   0 runner    (1001) docker     (123)     5261 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/mdf_jk.py
--rw-r--r--   0 runner    (1001) docker     (123)     9044 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/outcore.py
--rw-r--r--   0 runner    (1001) docker     (123)    27087 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/rsdf.py
--rw-r--r--   0 runner    (1001) docker     (123)    56627 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/rsdf_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)    52421 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/rsdf_helper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1739 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/df/rsdf_jk.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.939098 pyscf-2.2.1/pyscf/pbc/dft/
--rw-r--r--   0 runner    (1001) docker     (123)     3432 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4779 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/cdft.py
--rw-r--r--   0 runner    (1001) docker     (123)    10003 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/gen_grid.py
--rw-r--r--   0 runner    (1001) docker     (123)     5044 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/gks.py
--rw-r--r--   0 runner    (1001) docker     (123)     6181 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/kgks.py
--rw-r--r--   0 runner    (1001) docker     (123)     6849 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/krks.py
--rw-r--r--   0 runner    (1001) docker     (123)     6269 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/krks_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)    10848 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/krkspu.py
--rw-r--r--   0 runner    (1001) docker     (123)     2397 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/krkspu_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)     2824 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/kroks.py
--rw-r--r--   0 runner    (1001) docker     (123)     6269 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/kuks.py
--rw-r--r--   0 runner    (1001) docker     (123)     5780 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/kuks_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)     7375 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/kukspu.py
--rw-r--r--   0 runner    (1001) docker     (123)     2397 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/kukspu_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)    74676 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/multigrid.py
--rw-r--r--   0 runner    (1001) docker     (123)    49165 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/numint.py
--rw-r--r--   0 runner    (1001) docker     (123)     9830 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)     2824 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/roks.py
--rw-r--r--   0 runner    (1001) docker     (123)     5393 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/dft/uks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.939098 pyscf-2.2.1/pyscf/pbc/eph/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/eph/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6591 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/eph/eph_fd.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.939098 pyscf-2.2.1/pyscf/pbc/geomopt/
--rw-r--r--   0 runner    (1001) docker     (123)      871 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/geomopt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9237 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/geomopt/geometric_solver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.939098 pyscf-2.2.1/pyscf/pbc/grad/
--rw-r--r--   0 runner    (1001) docker     (123)     1083 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/grad/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    17115 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/grad/krhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     5831 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/grad/krks.py
--rw-r--r--   0 runner    (1001) docker     (123)     3969 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/grad/kuhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     5302 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/grad/kuks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.939098 pyscf-2.2.1/pyscf/pbc/gto/
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2371 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/_pbcintor.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.943098 pyscf-2.2.1/pyscf/pbc/gto/basis/
--rw-r--r--   0 runner    (1001) docker     (123)     4185 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4663 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-dzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     9723 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-qzv2p.dat
--rw-r--r--   0 runner    (1001) docker     (123)    10587 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-qzv3p.dat
--rw-r--r--   0 runner    (1001) docker     (123)     7314 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-tzv2p.dat
--rw-r--r--   0 runner    (1001) docker     (123)     6711 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-tzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     1609 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-cc-dzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3610 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-cc-qzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2430 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-cc-tzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     5774 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzv.dat
--rw-r--r--   0 runner    (1001) docker     (123)      859 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzvp-molopt-sr-q9.dat
--rw-r--r--   0 runner    (1001) docker     (123)    53413 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzvp-molopt-sr.dat
--rw-r--r--   0 runner    (1001) docker     (123)     6349 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzvp-molopt.dat
--rw-r--r--   0 runner    (1001) docker     (123)    10728 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    18881 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-qzv2p.dat
--rw-r--r--   0 runner    (1001) docker     (123)    20609 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-qzv3p.dat
--rw-r--r--   0 runner    (1001) docker     (123)      472 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szv-molopt-sr-q9.dat
--rw-r--r--   0 runner    (1001) docker     (123)    31790 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szv-molopt-sr.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3593 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szv-molopt.dat
--rw-r--r--   0 runner    (1001) docker     (123)     5859 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szv.dat
--rw-r--r--   0 runner    (1001) docker     (123)      671 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szvp-molopt-sr-q9.dat
--rw-r--r--   0 runner    (1001) docker     (123)     9087 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzv2p-molopt.dat
--rw-r--r--   0 runner    (1001) docker     (123)    13658 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzv2p.dat
--rw-r--r--   0 runner    (1001) docker     (123)    10067 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzv2px-molopt.dat
--rw-r--r--   0 runner    (1001) docker     (123)     8125 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzvp-molopt.dat
--rw-r--r--   0 runner    (1001) docker     (123)    12452 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzvp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3189 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/parse_cp2k.py
--rw-r--r--   0 runner    (1001) docker     (123)     1623 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/split_BASIS_MOLOPT.py
--rw-r--r--   0 runner    (1001) docker     (123)     1567 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/split_GTH_BASIS_SETS.py
--rw-r--r--   0 runner    (1001) docker     (123)     1626 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/basis/split_HFX_BASIS.py
--rw-r--r--   0 runner    (1001) docker     (123)    70087 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/cell.py
--rw-r--r--   0 runner    (1001) docker     (123)     2550 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/ecp.py
--rw-r--r--   0 runner    (1001) docker     (123)     7758 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/eval_gto.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.943098 pyscf-2.2.1/pyscf/pbc/gto/pseudo/
--rw-r--r--   0 runner    (1001) docker     (123)     3101 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    24006 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-blyp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    14867 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-bp.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3889 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-hcth120.dat
--rw-r--r--   0 runner    (1001) docker     (123)     3243 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-hcth407.dat
--rw-r--r--   0 runner    (1001) docker     (123)    90523 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-hf-rev.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2442 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-hf.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2820 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-olyp.dat
--rw-r--r--   0 runner    (1001) docker     (123)    54113 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-pade.dat
--rw-r--r--   0 runner    (1001) docker     (123)    42074 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-pbe.dat
--rw-r--r--   0 runner    (1001) docker     (123)     2789 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-pbesol.dat
--rw-r--r--   0 runner    (1001) docker     (123)     4013 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/parse_cp2k.py
--rw-r--r--   0 runner    (1001) docker     (123)     9662 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/pp.py
--rw-r--r--   0 runner    (1001) docker     (123)    11734 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/pp_int.py
--rw-r--r--   0 runner    (1001) docker     (123)     2215 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gto/pseudo/split_GTH_POTENTIALS.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.943098 pyscf-2.2.1/pyscf/pbc/gw/
--rw-r--r--   0 runner    (1001) docker     (123)       33 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gw/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      991 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gw/gw_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     5977 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gw/kgw_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     4215 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gw/kgw_slow_supercell.py
--rw-r--r--   0 runner    (1001) docker     (123)    25958 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gw/krgw_ac.py
--rw-r--r--   0 runner    (1001) docker     (123)    28680 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gw/krgw_cd.py
--rw-r--r--   0 runner    (1001) docker     (123)    31542 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/gw/kugw_ac.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.943098 pyscf-2.2.1/pyscf/pbc/lib/
--rw-r--r--   0 runner    (1001) docker     (123)      637 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/lib/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10549 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/lib/arnoldi.py
--rw-r--r--   0 runner    (1001) docker     (123)     1698 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/lib/chkfile.py
--rw-r--r--   0 runner    (1001) docker     (123)    41622 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/lib/kpts.py
--rw-r--r--   0 runner    (1001) docker     (123)    17829 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/lib/kpts_helper.py
--rw-r--r--   0 runner    (1001) docker     (123)    12221 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/lib/ktensor.py
--rw-r--r--   0 runner    (1001) docker     (123)    29322 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/lib/linalg_helper.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.947098 pyscf-2.2.1/pyscf/pbc/mp/
--rw-r--r--   0 runner    (1001) docker     (123)     1488 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mp/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    30958 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mp/kmp2.py
--rw-r--r--   0 runner    (1001) docker     (123)    10416 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mp/kmp2_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)    16730 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mp/kmp2_stagger.py
--rw-r--r--   0 runner    (1001) docker     (123)    17429 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mp/kump2.py
--rw-r--r--   0 runner    (1001) docker     (123)     3539 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mp/mp2.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.947098 pyscf-2.2.1/pyscf/pbc/mpicc/
--rw-r--r--   0 runner    (1001) docker     (123)      862 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpicc/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)   160425 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpicc/kccsd_rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    70288 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpicc/kintermediates_rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     4737 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpicc/mpi_kpoint_helper.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.947098 pyscf-2.2.1/pyscf/pbc/mpitools/
--rw-r--r--   0 runner    (1001) docker     (123)      611 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpitools/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10765 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpitools/mpi.py
--rw-r--r--   0 runner    (1001) docker     (123)     3277 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpitools/mpi_blksize.py
--rw-r--r--   0 runner    (1001) docker     (123)     3158 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpitools/mpi_helper.py
--rw-r--r--   0 runner    (1001) docker     (123)     6685 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpitools/mpi_load_balancer.py
--rw-r--r--   0 runner    (1001) docker     (123)     5691 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/mpitools/mpi_pool.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.951098 pyscf-2.2.1/pyscf/pbc/scf/
--rw-r--r--   0 runner    (1001) docker     (123)     3789 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    14976 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/_response_functions.py
--rw-r--r--   0 runner    (1001) docker     (123)    22994 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)      965 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/chkfile.py
--rw-r--r--   0 runner    (1001) docker     (123)     5923 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/cphf.py
--rw-r--r--   0 runner    (1001) docker     (123)     5197 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/ghf.py
--rw-r--r--   0 runner    (1001) docker     (123)    33205 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/hf.py
--rw-r--r--   0 runner    (1001) docker     (123)     8270 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/kghf.py
--rw-r--r--   0 runner    (1001) docker     (123)     7089 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/kghf_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)    33375 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/khf.py
--rw-r--r--   0 runner    (1001) docker     (123)    15645 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/khf_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)    18184 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/krohf.py
--rw-r--r--   0 runner    (1001) docker     (123)    24872 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/kuhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     9973 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/kuhf_ksymm.py
--rw-r--r--   0 runner    (1001) docker     (123)    11926 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/newton_ah.py
--rw-r--r--   0 runner    (1001) docker     (123)     5558 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/rohf.py
--rw-r--r--   0 runner    (1001) docker     (123)    43944 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/rsjk.py
--rw-r--r--   0 runner    (1001) docker     (123)     2298 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/scfint.py
--rw-r--r--   0 runner    (1001) docker     (123)    11808 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/stability.py
--rw-r--r--   0 runner    (1001) docker     (123)     8738 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/scf/uhf.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.951098 pyscf-2.2.1/pyscf/pbc/symm/
--rw-r--r--   0 runner    (1001) docker     (123)      696 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/symm/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5620 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/symm/basis.py
--rw-r--r--   0 runner    (1001) docker     (123)     7869 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/symm/geom.py
--rw-r--r--   0 runner    (1001) docker     (123)    14926 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/symm/group.py
--rw-r--r--   0 runner    (1001) docker     (123)     1968 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/symm/pyscf_spglib.py
--rw-r--r--   0 runner    (1001) docker     (123)    12555 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/symm/space_group.py
--rw-r--r--   0 runner    (1001) docker     (123)    11446 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/symm/symmetry.py
--rw-r--r--   0 runner    (1001) docker     (123)     3240 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/symm/tables.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.951098 pyscf-2.2.1/pyscf/pbc/tddft/
--rw-r--r--   0 runner    (1001) docker     (123)      746 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tddft/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.951098 pyscf-2.2.1/pyscf/pbc/tdscf/
--rw-r--r--   0 runner    (1001) docker     (123)     3100 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7401 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/kproxy.py
--rw-r--r--   0 runner    (1001) docker     (123)    26754 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/kproxy_supercell.py
--rw-r--r--   0 runner    (1001) docker     (123)    12730 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/krhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    13493 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/krhf_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     7798 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/krhf_slow_gamma.py
--rw-r--r--   0 runner    (1001) docker     (123)     9915 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/krhf_slow_supercell.py
--rw-r--r--   0 runner    (1001) docker     (123)     2314 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/krks.py
--rw-r--r--   0 runner    (1001) docker     (123)    12946 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/kuhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     2258 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/kuks.py
--rw-r--r--   0 runner    (1001) docker     (123)     1949 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/proxy.py
--rw-r--r--   0 runner    (1001) docker     (123)     3850 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     2039 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/rhf_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     1524 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)     1312 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     1525 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tdscf/uks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.955098 pyscf-2.2.1/pyscf/pbc/tools/
--rw-r--r--   0 runner    (1001) docker     (123)      688 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10744 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/k2gamma.py
--rw-r--r--   0 runner    (1001) docker     (123)     6640 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     4066 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/make_test_cell.py
--rw-r--r--   0 runner    (1001) docker     (123)    28614 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/pbc.py
--rw-r--r--   0 runner    (1001) docker     (123)     2296 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/print_funcs.py
--rw-r--r--   0 runner    (1001) docker     (123)     3536 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/pyscf_ase.py
--rw-r--r--   0 runner    (1001) docker     (123)    52868 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/pywannier90.py
--rw-r--r--   0 runner    (1001) docker     (123)     1990 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/tools/tril.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.955098 pyscf-2.2.1/pyscf/pbc/x2c/
--rw-r--r--   0 runner    (1001) docker     (123)      611 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/x2c/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    13005 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/x2c/sfx2c1e.py
--rw-r--r--   0 runner    (1001) docker     (123)    10659 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/pbc/x2c/x2c1e.py
--rw-r--r--   0 runner    (1001) docker     (123)      101 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/post_scf.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.955098 pyscf-2.2.1/pyscf/qmmm/
--rw-r--r--   0 runner    (1001) docker     (123)      791 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/qmmm/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    12221 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/qmmm/itrf.py
--rw-r--r--   0 runner    (1001) docker     (123)     2953 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/qmmm/mm_mole.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.955098 pyscf-2.2.1/pyscf/scf/
--rw-r--r--   0 runner    (1001) docker     (123)     6943 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    11920 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/_response_functions.py
--rw-r--r--   0 runner    (1001) docker     (123)    28425 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/_vhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    41522 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)     7048 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/atom_hf.py
--rw-r--r--   0 runner    (1001) docker     (123)     3623 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/atom_ks.py
--rw-r--r--   0 runner    (1001) docker     (123)     1457 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/chkfile.py
--rw-r--r--   0 runner    (1001) docker     (123)     5738 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/cphf.py
--rw-r--r--   0 runner    (1001) docker     (123)    35601 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/dhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     8551 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/diis.py
--rw-r--r--   0 runner    (1001) docker     (123)    21187 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/ghf.py
--rw-r--r--   0 runner    (1001) docker     (123)    12853 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/ghf_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)    77769 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/hf.py
--rw-r--r--   0 runner    (1001) docker     (123)    39080 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/hf_symm.py
--rw-r--r--   0 runner    (1001) docker     (123)    11428 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/jk.py
--rw-r--r--   0 runner    (1001) docker     (123)    17876 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/rohf.py
--rw-r--r--   0 runner    (1001) docker     (123)    24292 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/stability.py
--rw-r--r--   0 runner    (1001) docker     (123)     9365 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/stability_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     5854 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/ucphf.py
--rw-r--r--   0 runner    (1001) docker     (123)    40932 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)    23409 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/scf/uhf_symm.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.955098 pyscf-2.2.1/pyscf/sgx/
--rw-r--r--   0 runner    (1001) docker     (123)       30 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/sgx/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    14160 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/sgx/sgx.py
--rw-r--r--   0 runner    (1001) docker     (123)    14480 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/sgx/sgx_jk.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.959098 pyscf-2.2.1/pyscf/solvent/
--rw-r--r--   0 runner    (1001) docker     (123)     4385 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/solvent/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    24790 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/solvent/_attach_solvent.py
--rw-r--r--   0 runner    (1001) docker     (123)    57049 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/solvent/_ddcosmo_tdscf_grad.py
--rw-r--r--   0 runner    (1001) docker     (123)    36268 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/solvent/ddcosmo.py
--rw-r--r--   0 runner    (1001) docker     (123)    14634 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/solvent/ddcosmo_grad.py
--rw-r--r--   0 runner    (1001) docker     (123)    13469 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/solvent/ddpcm.py
--rw-r--r--   0 runner    (1001) docker     (123)    18327 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/solvent/pol_embed.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.959098 pyscf-2.2.1/pyscf/soscf/
--rw-r--r--   0 runner    (1001) docker     (123)      611 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/soscf/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    12279 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/soscf/ciah.py
--rw-r--r--   0 runner    (1001) docker     (123)    42099 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/soscf/newton_ah.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.959098 pyscf-2.2.1/pyscf/symm/
--rw-r--r--   0 runner    (1001) docker     (123)     6910 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/symm/Dmatrix.py
--rw-r--r--   0 runner    (1001) docker     (123)     1107 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/symm/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    13869 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/symm/addons.py
--rw-r--r--   0 runner    (1001) docker     (123)    24944 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/symm/basis.py
--rw-r--r--   0 runner    (1001) docker     (123)     1475 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/symm/cg.py
--rw-r--r--   0 runner    (1001) docker     (123)    34285 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/symm/geom.py
--rw-r--r--   0 runner    (1001) docker     (123)    11265 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/symm/param.py
--rw-r--r--   0 runner    (1001) docker     (123)     8240 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/symm/sph.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.959098 pyscf-2.2.1/pyscf/tddft/
--rw-r--r--   0 runner    (1001) docker     (123)      660 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tddft/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.959098 pyscf-2.2.1/pyscf/tdscf/
--rw-r--r--   0 runner    (1001) docker     (123)     2410 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    24041 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/common_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)    28247 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/dhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/dks.py
--rw-r--r--   0 runner    (1001) docker     (123)    25650 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/ghf.py
--rw-r--r--   0 runner    (1001) docker     (123)     6321 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/gks.py
--rw-r--r--   0 runner    (1001) docker     (123)     9541 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/proxy.py
--rw-r--r--   0 runner    (1001) docker     (123)    39279 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/rhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     7112 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/rhf_slow.py
--rw-r--r--   0 runner    (1001) docker     (123)     7871 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/rks.py
--rw-r--r--   0 runner    (1001) docker     (123)    34480 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/uhf.py
--rw-r--r--   0 runner    (1001) docker     (123)     8816 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tdscf/uks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.959098 pyscf-2.2.1/pyscf/tools/
--rw-r--r--   0 runner    (1001) docker     (123)      740 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3635 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/c60struct.py
--rw-r--r--   0 runner    (1001) docker     (123)     9580 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/chgcar.py
--rw-r--r--   0 runner    (1001) docker     (123)     2342 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/chkfile_util.py
--rw-r--r--   0 runner    (1001) docker     (123)    14660 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/cubegen.py
--rw-r--r--   0 runner    (1001) docker     (123)     8527 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/dump_mat.py
--rw-r--r--   0 runner    (1001) docker     (123)    13341 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/fcidump.py
--rw-r--r--   0 runner    (1001) docker     (123)     3857 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/mo_mapping.py
--rw-r--r--   0 runner    (1001) docker     (123)    19491 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/molden.py
--rw-r--r--   0 runner    (1001) docker     (123)      910 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/ring.py
--rw-r--r--   0 runner    (1001) docker     (123)     8282 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/tools/wfn_format.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.963098 pyscf-2.2.1/pyscf/x2c/
--rw-r--r--   0 runner    (1001) docker     (123)      720 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1158 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/_response_functions.py
--rw-r--r--   0 runner    (1001) docker     (123)     2102 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/dft.py
--rw-r--r--   0 runner    (1001) docker     (123)     2603 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/newton_ah.py
--rw-r--r--   0 runner    (1001) docker     (123)    10996 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/sfx2c1e.py
--rw-r--r--   0 runner    (1001) docker     (123)    10187 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/sfx2c1e_grad.py
--rw-r--r--   0 runner    (1001) docker     (123)    16870 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/sfx2c1e_hess.py
--rw-r--r--   0 runner    (1001) docker     (123)     1363 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/stability.py
--rw-r--r--   0 runner    (1001) docker     (123)    15430 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/tdscf.py
--rw-r--r--   0 runner    (1001) docker     (123)    36023 2023-04-01 22:08:12.000000 pyscf-2.2.1/pyscf/x2c/x2c.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 22:08:14.831096 pyscf-2.2.1/pyscf.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     1608 2023-04-01 22:08:14.000000 pyscf-2.2.1/pyscf.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    27754 2023-04-01 22:08:14.000000 pyscf-2.2.1/pyscf.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-01 22:08:14.000000 pyscf-2.2.1/pyscf.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)      600 2023-04-01 22:08:14.000000 pyscf-2.2.1/pyscf.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       28 2023-04-01 22:08:14.000000 pyscf-2.2.1/pyscf.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)      366 2023-04-01 22:08:14.963098 pyscf-2.2.1/setup.cfg
--rwxr-xr-x   0 runner    (1001) docker     (123)     6402 2023-04-01 22:08:12.000000 pyscf-2.2.1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.698976 pyscf-2.3.0/
+-rw-r--r--   0 runner    (1001) docker     (123)    48932 2023-07-08 07:46:57.000000 pyscf-2.3.0/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)    11357 2023-07-08 07:46:57.000000 pyscf-2.3.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      562 2023-07-08 07:46:57.000000 pyscf-2.3.0/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     3269 2023-07-08 07:46:57.000000 pyscf-2.3.0/NOTICE
+-rw-r--r--   0 runner    (1001) docker     (123)     1608 2023-07-08 07:46:59.698976 pyscf-2.3.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2845 2023-07-08 07:46:57.000000 pyscf-2.3.0/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.514972 pyscf-2.3.0/pyscf/
+-rw-r--r--   0 runner    (1001) docker     (123)      800 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/__all__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1213 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/__config__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4642 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.514972 pyscf-2.3.0/pyscf/adc/
+-rw-r--r--   0 runner    (1001) docker     (123)     2831 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4128 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/dfadc.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14994 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/radc.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29869 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/radc_amplitudes.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11722 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/radc_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    43312 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/radc_ea.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38351 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/radc_ip.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44625 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/radc_ip_cvs.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15275 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/uadc.py
+-rw-r--r--   0 runner    (1001) docker     (123)    41215 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/uadc_amplitudes.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22683 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/uadc_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    89083 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/uadc_ea.py
+-rw-r--r--   0 runner    (1001) docker     (123)    81739 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/uadc_ip.py
+-rw-r--r--   0 runner    (1001) docker     (123)   109911 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/adc/uadc_ip_cvs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.514972 pyscf-2.3.0/pyscf/agf2/
+-rw-r--r--   0 runner    (1001) docker     (123)     6029 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18199 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/_agf2.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22826 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/aux_space.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5076 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/chempot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5793 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/chkfile.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12982 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/dfragf2.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13721 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/dfuagf2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4376 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/mpi_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35992 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/ragf2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8709 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/ragf2_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    36471 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/uagf2.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10460 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/agf2/uagf2_slow.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.518972 pyscf-2.3.0/pyscf/ao2mo/
+-rw-r--r--   0 runner    (1001) docker     (123)    20570 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ao2mo/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11221 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ao2mo/_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7717 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ao2mo/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9787 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ao2mo/incore.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15389 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ao2mo/nrr_outcore.py
+-rw-r--r--   0 runner    (1001) docker     (123)    34086 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ao2mo/outcore.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12225 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ao2mo/r_outcore.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13156 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ao2mo/semi_incore.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.526972 pyscf-2.3.0/pyscf/cc/
+-rw-r--r--   0 runner    (1001) docker     (123)     7697 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      949 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/_ccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6080 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12059 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/bccd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2918 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    67040 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17685 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccsd_lambda.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21249 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccsd_rdm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9115 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccsd_rdm_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11032 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccsd_t.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4357 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccsd_t_lambda_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6401 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccsd_t_rdm_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6645 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/ccsd_t_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9440 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/dfccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25619 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/eom_gccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    81346 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/eom_rccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)   117956 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/eom_uccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24131 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/gccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8214 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/gccsd_lambda.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10804 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/gccsd_rdm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3327 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/gccsd_t.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5864 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/gccsd_t_lambda.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8779 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/gccsd_t_rdm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2830 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/gccsd_t_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9609 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/gintermediates.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28221 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/momgfccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17632 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/qcisd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7530 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/qcisd_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5528 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/qcisd_t.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5395 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/qcisd_t_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16362 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/rccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9749 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/rccsd_lambda.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44719 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/rccsd_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12025 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/rintermediates.py
+-rw-r--r--   0 runner    (1001) docker     (123)    58897 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23359 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uccsd_lambda.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27641 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uccsd_rdm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29032 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uccsd_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18577 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uccsd_t.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9775 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uccsd_t_lambda.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16218 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uccsd_t_rdm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9259 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uccsd_t_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38860 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uintermediates.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7310 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/cc/uintermediates_slow.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.530973 pyscf-2.3.0/pyscf/ci/
+-rw-r--r--   0 runner    (1001) docker     (123)     3754 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ci/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1313 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ci/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44497 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ci/cisd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18109 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ci/gcisd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42328 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/ci/ucisd.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.530973 pyscf-2.3.0/pyscf/data/
+-rw-r--r--   0 runner    (1001) docker     (123)      661 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38038 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/elements.py
+-rw-r--r--   0 runner    (1001) docker     (123)      788 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/gyro.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5327 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/gyromagnetic_ratio.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2644 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/nist.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23505 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/nuclear_g_factor.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     8817 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/nucprop.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13797 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/radii.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1928 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/data/solvents.dat
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.530973 pyscf-2.3.0/pyscf/df/
+-rw-r--r--   0 runner    (1001) docker     (123)     1540 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10115 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13759 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/df.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21889 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/df_jk.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.534973 pyscf-2.3.0/pyscf/df/grad/
+-rw-r--r--   0 runner    (1001) docker     (123)      114 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26211 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/casdm2_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9316 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/casscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19993 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4307 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)      201 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/rohf.py
+-rw-r--r--   0 runner    (1001) docker     (123)      201 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/roks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17299 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/sacasscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1986 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4373 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/grad/uks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.534973 pyscf-2.3.0/pyscf/df/hessian/
+-rw-r--r--   0 runner    (1001) docker     (123)      106 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/hessian/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22207 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/hessian/rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5327 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/hessian/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25233 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/hessian/uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5932 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/hessian/uks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11027 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/incore.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11278 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/outcore.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3646 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/df/r_incore.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.538973 pyscf-2.3.0/pyscf/dft/
+-rw-r--r--   0 runner    (1001) docker     (123)     3341 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5056 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/dks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24793 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/gen_grid.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1386 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/gen_libxc_param.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5001 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/gen_xcfun_param.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6336 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/gks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2563 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/gks_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)   117540 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/libxc.py
+-rw-r--r--   0 runner    (1001) docker     (123)   120580 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/numint.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30353 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/numint2c.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30251 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/r_numint.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5182 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/radi.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19835 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2420 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/rks_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2523 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/roks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4870 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/sap.py
+-rw-r--r--   0 runner    (1001) docker     (123)  3933728 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/sap_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6794 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/uks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1795 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/uks_symm.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.538973 pyscf-2.3.0/pyscf/dft/xc/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/xc/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1635 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/xc/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19090 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/xc_deriv.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37538 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/dft/xcfun.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.542973 pyscf-2.3.0/pyscf/eph/
+-rw-r--r--   0 runner    (1001) docker     (123)      878 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/eph/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5910 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/eph/eph_fd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8464 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/eph/rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8107 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/eph/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6225 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/eph/uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10834 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/eph/uks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.542973 pyscf-2.3.0/pyscf/fci/
+-rw-r--r--   0 runner    (1001) docker     (123)     9053 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27884 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19466 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/cistring.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15408 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/direct_ep.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9524 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/direct_nosym.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18097 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/direct_spin0.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8121 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/direct_spin0_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40745 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/direct_spin1.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24559 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/direct_spin1_cyl_sym.py
+-rw-r--r--   0 runner    (1001) docker     (123)    32489 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/direct_spin1_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12015 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/direct_uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9666 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/fci_dhf_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9233 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/fci_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15131 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/rdm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42130 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/selected_ci.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16283 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/selected_ci_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7532 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/selected_ci_spin0.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6311 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/selected_ci_spin0_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13362 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/selected_ci_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11590 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/fci/spin_op.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.542973 pyscf-2.3.0/pyscf/geomopt/
+-rw-r--r--   0 runner    (1001) docker     (123)      977 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/geomopt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3018 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/geomopt/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9026 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/geomopt/berny_solver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9566 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/geomopt/geometric_solver.py
+-rw-r--r--   0 runner    (1001) docker     (123)      288 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/geomopt/log.ini
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.546973 pyscf-2.3.0/pyscf/grad/
+-rw-r--r--   0 runner    (1001) docker     (123)     1761 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13788 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/casci.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8437 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/casscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17801 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/ccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13169 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/ccsd_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5049 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/ccsd_t.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7136 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/cisd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10755 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/dhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8759 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/lagrange.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11944 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/mp2.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16431 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24045 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2124 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/rohf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1311 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/roks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    41104 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/sacasscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12013 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/tdrhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14982 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/tdrks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10692 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/tduhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16963 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/tduks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21754 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/uccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5040 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/uccsd_t.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2493 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/ucisd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3788 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11095 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/uks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12638 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/grad/ump2.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.546973 pyscf-2.3.0/pyscf/gto/
+-rw-r--r--   0 runner    (1001) docker     (123)     1004 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.606974 pyscf-2.3.0/pyscf/gto/basis/
+-rw-r--r--   0 runner    (1001) docker     (123)   137396 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/Burkatzi-Filippi-Dolg-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    47103 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/DgaussA1_dft_cfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    47104 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/DgaussA1_dft_xfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    22868 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/DgaussA2_dft_cfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    22870 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/DgaussA2_dft_xfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    26619 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)   141928 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/adzp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    83566 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ahlrichs_cfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)  1389925 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ano.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   127274 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aqzp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   108802 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/atzp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1993 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pV5Z-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   124241 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pV5Z_MP2FIT.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1435 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVDZ-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   134863 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVQZ-DK3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1807 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVQZ-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   108901 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVQZ_MP2FIT.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   110807 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVTZ-DK3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1621 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVTZ-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   190050 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pv5z-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    53483 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pv5z-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    97411 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pv5z-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   190020 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pv5z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   117453 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdpdz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    98649 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdz-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    41742 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdz-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    30634 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdz-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    98569 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    40752 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdzp-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    29379 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdzp-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   290273 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvqz-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    48952 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvqz-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    48083 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvqz-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   155183 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvqz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   314115 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvtz-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    45670 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvtz-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    39435 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvtz-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   122314 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvtz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   346258 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVQZ-DK.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   183629 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVQZ-DK3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   410566 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVTZ-DK.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   139736 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVTZ-DK3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   124542 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVTZ_MP2FIT.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   182677 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcv5z-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   363886 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcv5z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    37069 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcvdz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   285250 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcvqz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   192834 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcvtz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    48451 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pc-0.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   112718 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pc-1.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   173735 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pc-2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   267909 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pc-3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   390219 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pc-4.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    87863 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-0.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   122797 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-1.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   194490 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   312944 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   437986 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-4.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    12151 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/bfd_pp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    46296 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/bfd_v5z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    31518 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/bfd_vdz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    65568 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/bfd_vqz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    57266 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/bfd_vtz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     4828 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/bse.py
+-rw-r--r--   0 runner    (1001) docker     (123)   200095 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pCV5Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    54500 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pCV6Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3460 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pCVDZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    13152 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pCVQZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     7488 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pCVTZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   103871 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pV5Z_MP2FIT.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     4712 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pVDZ-PP-NR.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   114741 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pVQZ-DK3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    90211 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pVQZ_MP2FIT.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    93193 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pVTZ-DK3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     7167 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pVTZ-PP-NR.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   189349 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pv5z-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    45383 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pv5z-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   222905 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pv5z-pp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    41961 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pv5z-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   194433 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pv5z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   115228 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvdpdz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   377366 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvdz-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    36718 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvdz-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    94731 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvdz-pp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    30544 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvdz-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    94827 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvdz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    11311 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvdz_fit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   850318 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvqz-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    41794 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvqz-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   177582 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvqz-pp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    48631 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvqz-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   149280 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvqz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   914722 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvtz-dk.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    39454 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvtz-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   132320 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvtz-pp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    39711 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvtz-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   117771 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvtz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    14008 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pvtz_fit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   106072 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCV5Z-DK.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    98164 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCV5Z-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   232487 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCV5Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    53340 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVDZ-DK.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    12089 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVDZ-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    18284 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVDZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   241499 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVQZ-DK.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   160567 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVQZ-DK3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    32332 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVQZ-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    84240 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVQZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   240607 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ-DK.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   120526 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ-DK3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    22290 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ-PP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    99466 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   104732 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ_MP2FIT.dat
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.506972 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.606974 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/
+-rw-r--r--   0 runner    (1001) docker     (123)     8306 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    80494 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pV5Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    36684 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pV6Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    41351 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVDZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    66515 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVQZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    53428 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVTZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    75421 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pV5Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    34550 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pV6Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    38752 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVDZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    62219 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVQZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    49967 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVTZ.dat
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.610974 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/
+-rw-r--r--   0 runner    (1001) docker     (123)     1155 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    13000 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pV5Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)       65 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pV6Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     9436 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVDZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    11614 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVQZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    10426 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVTZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    11812 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pV5Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)       65 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pV6Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     8842 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVDZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    10624 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVQZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     9634 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVTZ.dat
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.614974 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/
+-rw-r--r--   0 runner    (1001) docker     (123)      294 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3396 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pV5Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2208 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVDZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2934 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVQZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2538 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVTZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3000 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pV5Z.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2010 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVDZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2604 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVQZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2274 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVTZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   262035 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/crenbl.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   129690 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/crenbs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     7054 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/crystal-cc-pvdz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    37024 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-qzvp-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   180299 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-qzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   185113 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-qzvpd.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    43496 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-qzvpp-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   184475 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-qzvpp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    45242 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-qzvppd-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   189343 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-qzvppd.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    57404 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-svp-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   110762 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-svp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    60367 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-svpd-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   117659 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-svpd.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    71708 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-tzvp-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   132134 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-tzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    74591 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-tzvpd-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   138427 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-tzvpd.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    59466 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-tzvpp-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   136623 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-tzvpp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    62380 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-tzvppd-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   142965 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-tzvppd.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   130384 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-universal-jfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   235329 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/def2-universal-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    47198 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/demon_cfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     9397 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dyall_dz.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8871 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dyall_qz.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13052 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dyall_tz.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10886 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   131530 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dzp-dkh.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   132516 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dzp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     8909 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dzp_dunning.py
+-rw-r--r--   0 runner    (1001) docker     (123)   178866 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    71969 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/dzvp2.dat
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.622974 pyscf-2.3.0/pyscf/gto/basis/f12-basis/
+-rw-r--r--   0 runner    (1001) docker     (123)    20014 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/aug-cc-pV5Z-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    15354 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/aug-cc-pVDZ-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    17248 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/aug-cc-pVQZ-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    15259 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/aug-cc-pVTZ-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    28721 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pCVDZ-F12-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    26437 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pCVQZ-F12-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    25757 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pCVTZ-F12-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    56899 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pV5Z-F12.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2205 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pV5Z-F12rev2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    12587 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVDZ-F12-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    26302 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVDZ-F12-nZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)      639 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVDZ-F12rev2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    13769 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVQZ-F12-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    48697 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVQZ-F12-nZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1480 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVQZ-F12rev2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    13371 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVTZ-F12-OptRI.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    35324 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVTZ-F12-nZ.dat
+-rw-r--r--   0 runner    (1001) docker     (123)      947 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVTZ-F12rev2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2441 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/faegre_dz.py
+-rw-r--r--   0 runner    (1001) docker     (123)    43856 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/heavy-aug-cc-pvdz-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    30481 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/heavy-aug-cc-pvdz-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    47735 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/heavy-aug-cc-pvtz-jkfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    39167 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/heavy-aug-cc-pvtz-ri.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1839 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/iglo3.py
+-rw-r--r--   0 runner    (1001) docker     (123)    92388 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/lanl08.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   109544 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/lanl2dz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    52603 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/lanl2tz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   117876 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/minao.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5495 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/parse_bfd_pp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4103 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/parse_gaussian.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6551 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/parse_molpro.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13573 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/parse_nwchem.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35344 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pc-0.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    82701 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pc-1.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   132372 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pc-2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   211146 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pc-3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   315764 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pc-4.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    65047 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pcseg-0.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    91188 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pcseg-1.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   150241 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pcseg-2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   250673 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pcseg-3.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   357977 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pcseg-4.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    35826 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pob-tzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     9411 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pob-tzvpp.dat
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.630975 pyscf-2.3.0/pyscf/gto/basis/pople-basis/
+-rw-r--r--   0 runner    (1001) docker     (123)    55204 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21++G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    55937 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21++Gs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3082 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21G-diffuse.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1615 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21G-polarization.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    53526 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    54234 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21Gs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     7526 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/4-31G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    36010 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31++G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    21162 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31++Gs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    38362 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31++Gss.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    21734 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31+G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    20062 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31+Gs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    22947 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31+Gss.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    20190 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311++G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    21836 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311++Gs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    34756 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311++Gss.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    20634 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311+G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    22361 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311+Gs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    22104 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311+Gss.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2698 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-diffuse.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2180 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-2d.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1250 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-2p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     4515 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-3d.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1585 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-3p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3472 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-d.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2477 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-f.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1144 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    31263 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    33384 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311Gs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    33056 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311Gss.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2992 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-diffuse.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2928 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-2d.dat
+-rw-r--r--   0 runner    (1001) docker     (123)      748 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-2p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     4215 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-3d.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1285 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-3p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     4078 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-d.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2055 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-f.dat
+-rw-r--r--   0 runner    (1001) docker     (123)      177 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    34316 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    44932 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31Gs.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    36668 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31Gss.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   117420 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/qzp-dkh.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   117314 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/qzp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   139676 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/roos-dz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   169498 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/roos-tz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   142994 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/sarc-dkh2.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    72840 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/sbkjc.dat
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.630975 pyscf-2.3.0/pyscf/gto/basis/soecp/
+-rw-r--r--   0 runner    (1001) docker     (123)     6080 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS10MDFSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    12273 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS28MDFSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     5195 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS28MWBSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3769 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS46MDFSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     5467 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS60MDFSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     7973 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS60MWBSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3683 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS78MDFSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    10959 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS92MDFBQSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    10955 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS92MDFBSO.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    49513 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/sto-3g.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    50158 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/sto-6g.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    70653 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/stuttgart_dz.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   140417 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/stuttgart_rsc.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   100829 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/tzp-dkh.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   100810 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/tzp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    48273 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/tzv.dat
+-rw-r--r--   0 runner    (1001) docker     (123)   130384 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/basis/weigend_cfit.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1829 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/cmd_args.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6334 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/ecp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9041 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/eval_gto.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7337 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/ft_ao.py
+-rw-r--r--   0 runner    (1001) docker     (123)   141702 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/mole.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37978 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/moleintor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2675 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gto/pp_int.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.630975 pyscf-2.3.0/pyscf/gw/
+-rw-r--r--   0 runner    (1001) docker     (123)     1734 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gw/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15534 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gw/gw_ac.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12067 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gw/gw_cd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14552 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gw/gw_exact.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11034 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gw/gw_slow.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     9105 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gw/rpa.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18653 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gw/ugw_ac.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     7563 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/gw/urpa.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.630975 pyscf-2.3.0/pyscf/hessian/
+-rw-r--r--   0 runner    (1001) docker     (123)      961 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/hessian/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25044 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/hessian/rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24257 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/hessian/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14633 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/hessian/thermo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20889 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/hessian/uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35594 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/hessian/uks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.634975 pyscf-2.3.0/pyscf/lib/
+-rw-r--r--   0 runner    (1001) docker     (123)     9663 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1155 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.634975 pyscf-2.3.0/pyscf/lib/agf2/
+-rw-r--r--   0 runner    (1001) docker     (123)      847 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/agf2/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    13242 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/agf2/ragf2.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1516 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/agf2/ragf2.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12519 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/agf2/uagf2.c
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.634975 pyscf-2.3.0/pyscf/lib/ao2mo/
+-rw-r--r--   0 runner    (1001) docker     (123)      909 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    45916 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/nr_ao2mo.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2582 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/nr_ao2mo.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3094 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/nr_incore.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1428 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/nr_incore.h
+-rw-r--r--   0 runner    (1001) docker     (123)    10730 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/nrr_ao2mo.c
+-rw-r--r--   0 runner    (1001) docker     (123)    33947 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/r_ao2mo.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1267 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/r_ao2mo.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3042 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ao2mo/restore_eri.c
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.634975 pyscf-2.3.0/pyscf/lib/cc/
+-rw-r--r--   0 runner    (1001) docker     (123)      894 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/cc/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3782 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/cc/ccsd_grad.c
+-rw-r--r--   0 runner    (1001) docker     (123)     6538 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/cc/ccsd_pack.c
+-rw-r--r--   0 runner    (1001) docker     (123)    44310 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/cc/ccsd_t.c
+-rw-r--r--   0 runner    (1001) docker     (123)    35659 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/cc/uccsd_t.c
+-rw-r--r--   0 runner    (1001) docker     (123)     5820 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/chkfile.py
+-rw-r--r--   0 runner    (1001) docker     (123)      137 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/config.h.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.638975 pyscf-2.3.0/pyscf/lib/dft/
+-rw-r--r--   0 runner    (1001) docker     (123)     1416 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   173239 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/CxLebedevGrid.c
+-rw-r--r--   0 runner    (1001) docker     (123)     3974 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/grid_basis.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1094 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/grid_basis.h
+-rw-r--r--   0 runner    (1001) docker     (123)    34520 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/libxc_itrf.c
+-rw-r--r--   0 runner    (1001) docker     (123)    10682 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/nr_numint.c
+-rw-r--r--   0 runner    (1001) docker     (123)    54245 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/nr_numint_sparse.c
+-rw-r--r--   0 runner    (1001) docker     (123)   105128 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/numint_uniform_grid.c
+-rw-r--r--   0 runner    (1001) docker     (123)     9100 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/r_numint.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1197 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/vxc.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6567 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/xc_deriv.c
+-rw-r--r--   0 runner    (1001) docker     (123)     7236 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/dft/xcfun_itrf.c
+-rw-r--r--   0 runner    (1001) docker     (123)    12054 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/diis.py
+-rw-r--r--   0 runner    (1001) docker     (123)      762 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.638975 pyscf-2.3.0/pyscf/lib/gto/
+-rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.638975 pyscf-2.3.0/pyscf/lib/gto/autocode/
+-rw-r--r--   0 runner    (1001) docker     (123)    57483 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/autocode/auto_eval1.c
+-rw-r--r--   0 runner    (1001) docker     (123)    26701 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/deriv1.c
+-rw-r--r--   0 runner    (1001) docker     (123)    63100 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/deriv2.c
+-rw-r--r--   0 runner    (1001) docker     (123)     3784 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/fastexp.c
+-rw-r--r--   0 runner    (1001) docker     (123)     8515 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/fill_grids_int2c.c
+-rw-r--r--   0 runner    (1001) docker     (123)     7798 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/fill_int2c.c
+-rw-r--r--   0 runner    (1001) docker     (123)    24491 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/fill_int2e.c
+-rw-r--r--   0 runner    (1001) docker     (123)     7986 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/fill_nr_3c.c
+-rw-r--r--   0 runner    (1001) docker     (123)     7357 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/fill_r_3c.c
+-rw-r--r--   0 runner    (1001) docker     (123)     3480 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/fill_r_4c.c
+-rw-r--r--   0 runner    (1001) docker     (123)    51411 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/ft_ao.c
+-rw-r--r--   0 runner    (1001) docker     (123)     4288 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/ft_ao.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12441 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/ft_ao_deriv.c
+-rw-r--r--   0 runner    (1001) docker     (123)    20944 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/grid_ao_drv.c
+-rw-r--r--   0 runner    (1001) docker     (123)     4097 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/grid_ao_drv.h
+-rw-r--r--   0 runner    (1001) docker     (123)      845 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/gto.h
+-rw-r--r--   0 runner    (1001) docker     (123)  1014868 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/nr_ecp.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1512 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/nr_ecp.h
+-rw-r--r--   0 runner    (1001) docker     (123)    45488 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/gto/nr_ecp_deriv.c
+-rw-r--r--   0 runner    (1001) docker     (123)    61512 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/linalg_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6296 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/logger.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.642975 pyscf-2.3.0/pyscf/lib/mcscf/
+-rw-r--r--   0 runner    (1001) docker     (123)     1236 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2795 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/fci.h
+-rw-r--r--   0 runner    (1001) docker     (123)    23910 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/fci_4pdm.c
+-rw-r--r--   0 runner    (1001) docker     (123)    41632 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/fci_contract.c
+-rw-r--r--   0 runner    (1001) docker     (123)     8680 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/fci_contract_nosym.c
+-rw-r--r--   0 runner    (1001) docker     (123)    30335 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/fci_rdm.c
+-rw-r--r--   0 runner    (1001) docker     (123)    14106 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/fci_string.c
+-rw-r--r--   0 runner    (1001) docker     (123)     9579 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/nevpt_contract.c
+-rw-r--r--   0 runner    (1001) docker     (123)    25231 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/mcscf/select_ci.c
+-rw-r--r--   0 runner    (1001) docker     (123)    42814 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/misc.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.642975 pyscf-2.3.0/pyscf/lib/np_helper/
+-rw-r--r--   0 runner    (1001) docker     (123)      882 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/np_helper/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4980 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/np_helper/condense.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1292 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/np_helper/np_helper.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2639 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/np_helper/np_helper.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8172 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/np_helper/npdot.c
+-rw-r--r--   0 runner    (1001) docker     (123)     5047 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/np_helper/omp_reduce.c
+-rw-r--r--   0 runner    (1001) docker     (123)     7709 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/np_helper/pack_tril.c
+-rw-r--r--   0 runner    (1001) docker     (123)     4398 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/np_helper/transpose.c
+-rw-r--r--   0 runner    (1001) docker     (123)    45884 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/numpy_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2752 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/parameters.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.642975 pyscf-2.3.0/pyscf/lib/pbc/
+-rw-r--r--   0 runner    (1001) docker     (123)     1003 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    14263 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/cint2e.c
+-rw-r--r--   0 runner    (1001) docker     (123)    14385 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/cint3c2e.c
+-rw-r--r--   0 runner    (1001) docker     (123)    58339 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/fill_ints.c
+-rw-r--r--   0 runner    (1001) docker     (123)    80808 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/fill_ints_sr.c
+-rw-r--r--   0 runner    (1001) docker     (123)    36806 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/ft_ao.c
+-rw-r--r--   0 runner    (1001) docker     (123)    30687 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/grid_ao.c
+-rw-r--r--   0 runner    (1001) docker     (123)    31483 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/inner_dot.c
+-rw-r--r--   0 runner    (1001) docker     (123)    49956 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/nr_direct.c
+-rw-r--r--   0 runner    (1001) docker     (123)    10239 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/nr_ecp.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2454 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/optimizer.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/optimizer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2059 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/pbc.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2875 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/symmetry.c
+-rw-r--r--   0 runner    (1001) docker     (123)    14078 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/pbc/transform_mo.c
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.646975 pyscf-2.3.0/pyscf/lib/ri/
+-rw-r--r--   0 runner    (1001) docker     (123)      825 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ri/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     7098 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/ri/r_df_incore.c
+-rw-r--r--   0 runner    (1001) docker     (123)     3631 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/scipy_helper.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.646975 pyscf-2.3.0/pyscf/lib/vhf/
+-rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      806 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/cvhf.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4132 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/fblas.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5153 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/fill_nr_s8.c
+-rw-r--r--   0 runner    (1001) docker     (123)    13409 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/hessian_screen.c
+-rw-r--r--   0 runner    (1001) docker     (123)    23654 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/nr_direct.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2876 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/nr_direct.h
+-rw-r--r--   0 runner    (1001) docker     (123)   132053 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/nr_direct_dot.c
+-rw-r--r--   0 runner    (1001) docker     (123)    29999 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/nr_incore.c
+-rw-r--r--   0 runner    (1001) docker     (123)    20242 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/nr_sgx_direct.c
+-rw-r--r--   0 runner    (1001) docker     (123)    17348 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/optimizer.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2969 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/optimizer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    24284 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/r_direct_dot.c
+-rw-r--r--   0 runner    (1001) docker     (123)     5677 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/r_direct_dot.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12689 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/r_direct_o1.c
+-rw-r--r--   0 runner    (1001) docker     (123)    14446 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/rah_direct_dot.c
+-rw-r--r--   0 runner    (1001) docker     (123)    14412 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/rha_direct_dot.c
+-rw-r--r--   0 runner    (1001) docker     (123)    13334 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/rkb_screen.c
+-rw-r--r--   0 runner    (1001) docker     (123)    25499 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/time_rev.c
+-rw-r--r--   0 runner    (1001) docker     (123)     3479 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lib/vhf/time_rev.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.646975 pyscf-2.3.0/pyscf/lo/
+-rw-r--r--   0 runner    (1001) docker     (123)     1026 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14852 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/boys.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3210 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/cholesky.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2686 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/edmiston.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6575 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/iao.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16582 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/ibo.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9495 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/nao.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13405 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/orth.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11992 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/pipek.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4718 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/lo/vvo.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.650975 pyscf-2.3.0/pyscf/mcscf/
+-rw-r--r--   0 runner    (1001) docker     (123)    20802 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/PiOS.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11792 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    65838 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16646 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/apc.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10115 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/avas.py
+-rw-r--r--   0 runner    (1001) docker     (123)    50473 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/casci.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7981 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/casci_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2314 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/chkfile.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16616 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/df.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9729 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/dmet_cas.py
+-rw-r--r--   0 runner    (1001) docker     (123)    59975 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/mc1step.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6549 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/mc1step_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7968 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/mc2step.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14918 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/mc_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39686 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/newton_casscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4974 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/newton_casscf_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20383 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/ucasci.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38408 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/umc1step.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6015 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/umc2step.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15946 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mcscf/umc_ao2mo.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.650975 pyscf-2.3.0/pyscf/md/
+-rw-r--r--   0 runner    (1001) docker     (123)     1458 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/md/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1682 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/md/distributions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17044 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/md/integrators.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.650975 pyscf-2.3.0/pyscf/mp/
+-rw-r--r--   0 runner    (1001) docker     (123)     2740 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6958 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/dfgmp2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5741 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/dfmp2.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30558 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/dfmp2_native.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26258 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/dfump2_native.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14930 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/gmp2.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30595 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/mp2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7280 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/mp2f12_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30400 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mp/ump2.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.650975 pyscf-2.3.0/pyscf/mrpt/
+-rw-r--r--   0 runner    (1001) docker     (123)      772 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mrpt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42942 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/mrpt/nevpt2.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.650975 pyscf-2.3.0/pyscf/pbc/
+-rw-r--r--   0 runner    (1001) docker     (123)      286 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/__all__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      943 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.654975 pyscf-2.3.0/pyscf/pbc/adc/
+-rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/adc/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1954 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/adc/dfadc.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13136 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/adc/kadc_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11436 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/adc/kadc_rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14131 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/adc/kadc_rhf_amplitudes.py
+-rw-r--r--   0 runner    (1001) docker     (123)    62318 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/adc/kadc_rhf_ea.py
+-rw-r--r--   0 runner    (1001) docker     (123)    46647 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/adc/kadc_rhf_ip.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.654975 pyscf-2.3.0/pyscf/pbc/ao2mo/
+-rw-r--r--   0 runner    (1001) docker     (123)      632 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/ao2mo/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8682 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/ao2mo/eris.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.654975 pyscf-2.3.0/pyscf/pbc/cc/
+-rw-r--r--   0 runner    (1001) docker     (123)     2136 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6728 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/ccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    82519 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_ghf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    68243 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2448 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_rhf_ea.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2429 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_rhf_ip.py
+-rw-r--r--   0 runner    (1001) docker     (123)    57971 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35089 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    50402 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kccsd_rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31998 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kccsd_rhf_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15664 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kccsd_t.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28804 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kccsd_t_rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11709 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kccsd_t_rhf_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    59109 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kccsd_uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22280 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kintermediates.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42214 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kintermediates_rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10075 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kintermediates_rhf_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    60669 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kintermediates_uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7878 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/cc/kuccsd_rdm.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.654975 pyscf-2.3.0/pyscf/pbc/ci/
+-rw-r--r--   0 runner    (1001) docker     (123)     1298 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/ci/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4715 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/ci/cisd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26420 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/ci/kcis_rhf.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.658975 pyscf-2.3.0/pyscf/pbc/df/
+-rw-r--r--   0 runner    (1001) docker     (123)      970 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28877 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/aft.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17682 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/aft_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31911 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/aft_jk.py
+-rw-r--r--   0 runner    (1001) docker     (123)    33544 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/df.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13852 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/df_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44775 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/df_jk.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13844 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/fft.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18458 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/fft_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19016 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/fft_jk.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31884 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/ft_ao.py
+-rw-r--r--   0 runner    (1001) docker     (123)    45502 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/gdf_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18695 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/incore.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18202 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/mdf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6818 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/mdf_ao2mo.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5261 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/mdf_jk.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9044 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/outcore.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28630 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/rsdf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    68851 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/rsdf_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)    53138 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/rsdf_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1739 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/df/rsdf_jk.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.658975 pyscf-2.3.0/pyscf/pbc/dft/
+-rw-r--r--   0 runner    (1001) docker     (123)     3432 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4779 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/cdft.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9890 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/gen_grid.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5171 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/gks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6488 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/kgks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7104 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/krks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6500 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/krks_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10848 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/krkspu.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2397 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/krkspu_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2824 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/kroks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6524 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/kuks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6011 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/kuks_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7375 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/kukspu.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2397 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/kukspu_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    73723 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/multigrid.py
+-rw-r--r--   0 runner    (1001) docker     (123)    49299 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/numint.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10446 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2909 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/roks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5649 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/dft/uks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.658975 pyscf-2.3.0/pyscf/pbc/eph/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/eph/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6591 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/eph/eph_fd.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.662975 pyscf-2.3.0/pyscf/pbc/geomopt/
+-rw-r--r--   0 runner    (1001) docker     (123)      871 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/geomopt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9237 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/geomopt/geometric_solver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.662975 pyscf-2.3.0/pyscf/pbc/grad/
+-rw-r--r--   0 runner    (1001) docker     (123)     1083 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/grad/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17272 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/grad/krhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5831 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/grad/krks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3969 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/grad/kuhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5302 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/grad/kuks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.662975 pyscf-2.3.0/pyscf/pbc/gto/
+-rw-r--r--   0 runner    (1001) docker     (123)      997 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2371 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/_pbcintor.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.666975 pyscf-2.3.0/pyscf/pbc/gto/basis/
+-rw-r--r--   0 runner    (1001) docker     (123)     4185 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4663 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-dzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     9723 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-qzv2p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    10587 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-qzv3p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     7314 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-tzv2p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     6711 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-tzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     1609 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-cc-dzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3610 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-cc-qzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2430 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-cc-tzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     5774 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzv.dat
+-rw-r--r--   0 runner    (1001) docker     (123)      859 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzvp-molopt-sr-q9.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    53413 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzvp-molopt-sr.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     6349 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzvp-molopt.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    10728 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    18881 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-qzv2p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    20609 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-qzv3p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)      472 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szv-molopt-sr-q9.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    31790 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szv-molopt-sr.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3593 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szv-molopt.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     5859 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szv.dat
+-rw-r--r--   0 runner    (1001) docker     (123)      671 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szvp-molopt-sr-q9.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     9087 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzv2p-molopt.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    13658 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzv2p.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    10067 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzv2px-molopt.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     8125 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzvp-molopt.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    12452 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzvp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3189 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/parse_cp2k.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1623 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/split_BASIS_MOLOPT.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1567 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/split_GTH_BASIS_SETS.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1626 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/basis/split_HFX_BASIS.py
+-rw-r--r--   0 runner    (1001) docker     (123)    69700 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/cell.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2326 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/ecp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9503 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/eval_gto.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.666975 pyscf-2.3.0/pyscf/pbc/gto/pseudo/
+-rw-r--r--   0 runner    (1001) docker     (123)     3101 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24006 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-blyp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    14867 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-bp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3889 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-hcth120.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3243 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-hcth407.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    90523 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-hf-rev.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2442 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-hf.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2820 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-olyp.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    54113 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-pade.dat
+-rw-r--r--   0 runner    (1001) docker     (123)    42074 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-pbe.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     2789 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-pbesol.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     4013 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/parse_cp2k.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9662 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/pp.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11729 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/pp_int.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2215 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gto/pseudo/split_GTH_POTENTIALS.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.666975 pyscf-2.3.0/pyscf/pbc/gw/
+-rw-r--r--   0 runner    (1001) docker     (123)       33 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gw/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      991 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gw/gw_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5977 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gw/kgw_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4215 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gw/kgw_slow_supercell.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25958 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gw/krgw_ac.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28680 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gw/krgw_cd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31542 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/gw/kugw_ac.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.666975 pyscf-2.3.0/pyscf/pbc/lib/
+-rw-r--r--   0 runner    (1001) docker     (123)      637 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/lib/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10549 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/lib/arnoldi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1698 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/lib/chkfile.py
+-rw-r--r--   0 runner    (1001) docker     (123)    41676 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/lib/kpts.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21179 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/lib/kpts_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12221 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/lib/ktensor.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29322 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/lib/linalg_helper.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.666975 pyscf-2.3.0/pyscf/pbc/mp/
+-rw-r--r--   0 runner    (1001) docker     (123)     1488 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mp/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30958 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mp/kmp2.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10416 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mp/kmp2_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16730 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mp/kmp2_stagger.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17429 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mp/kump2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3539 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mp/mp2.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.670976 pyscf-2.3.0/pyscf/pbc/mpicc/
+-rw-r--r--   0 runner    (1001) docker     (123)      862 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpicc/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)   160425 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpicc/kccsd_rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    70288 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpicc/kintermediates_rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4737 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpicc/mpi_kpoint_helper.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.670976 pyscf-2.3.0/pyscf/pbc/mpitools/
+-rw-r--r--   0 runner    (1001) docker     (123)      611 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpitools/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10765 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpitools/mpi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3277 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpitools/mpi_blksize.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3158 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpitools/mpi_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6685 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpitools/mpi_load_balancer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5691 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/mpitools/mpi_pool.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.670976 pyscf-2.3.0/pyscf/pbc/scf/
+-rw-r--r--   0 runner    (1001) docker     (123)     3789 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14759 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/_response_functions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23923 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)      965 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/chkfile.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5923 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/cphf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5518 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/ghf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    33045 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/hf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8977 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/kghf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7259 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/kghf_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    32806 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/khf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14999 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/khf_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16767 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/krohf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23340 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/kuhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9120 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/kuhf_ksymm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11926 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/newton_ah.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4936 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/rohf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    60699 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/rsjk.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2298 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/scfint.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11808 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/stability.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8285 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/scf/uhf.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.670976 pyscf-2.3.0/pyscf/pbc/symm/
+-rw-r--r--   0 runner    (1001) docker     (123)      696 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/symm/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5620 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/symm/basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7869 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/symm/geom.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14926 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/symm/group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1968 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/symm/pyscf_spglib.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12555 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/symm/space_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11446 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/symm/symmetry.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3240 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/symm/tables.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.670976 pyscf-2.3.0/pyscf/pbc/tddft/
+-rw-r--r--   0 runner    (1001) docker     (123)      746 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tddft/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.674975 pyscf-2.3.0/pyscf/pbc/tdscf/
+-rw-r--r--   0 runner    (1001) docker     (123)     3100 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7401 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/kproxy.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26754 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/kproxy_supercell.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12730 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/krhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13493 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/krhf_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7798 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/krhf_slow_gamma.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9915 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/krhf_slow_supercell.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2314 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/krks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12946 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/kuhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2258 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/kuks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1949 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/proxy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3850 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2039 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/rhf_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1524 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1312 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1525 2023-07-08 07:46:57.000000 pyscf-2.3.0/pyscf/pbc/tdscf/uks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.674975 pyscf-2.3.0/pyscf/pbc/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)      688 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11646 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/k2gamma.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6640 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4066 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/make_test_cell.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27089 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/pbc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2296 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/print_funcs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3536 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/pyscf_ase.py
+-rw-r--r--   0 runner    (1001) docker     (123)    52868 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/pywannier90.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1990 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/tools/tril.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.678976 pyscf-2.3.0/pyscf/pbc/x2c/
+-rw-r--r--   0 runner    (1001) docker     (123)      611 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/x2c/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13062 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/x2c/sfx2c1e.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10296 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/pbc/x2c/x2c1e.py
+-rw-r--r--   0 runner    (1001) docker     (123)      101 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/post_scf.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.678976 pyscf-2.3.0/pyscf/qmmm/
+-rw-r--r--   0 runner    (1001) docker     (123)      791 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/qmmm/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16569 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/qmmm/itrf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4297 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/qmmm/mm_mole.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.682976 pyscf-2.3.0/pyscf/scf/
+-rw-r--r--   0 runner    (1001) docker     (123)     6943 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11926 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/_response_functions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28425 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/_vhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    41846 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7143 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/atom_hf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3623 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/atom_ks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1457 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/chkfile.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5738 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/cphf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35427 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/dhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8543 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/diis.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20445 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/ghf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12841 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/ghf_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    77661 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/hf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39092 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/hf_symm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11428 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/jk.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18287 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/rohf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24292 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/stability.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9365 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/stability_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5854 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/ucphf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    41353 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23385 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/scf/uhf_symm.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.686976 pyscf-2.3.0/pyscf/sgx/
+-rw-r--r--   0 runner    (1001) docker     (123)       30 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/sgx/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14160 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/sgx/sgx.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14480 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/sgx/sgx_jk.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.686976 pyscf-2.3.0/pyscf/solvent/
+-rw-r--r--   0 runner    (1001) docker     (123)     4385 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/solvent/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24790 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/solvent/_attach_solvent.py
+-rw-r--r--   0 runner    (1001) docker     (123)    57049 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/solvent/_ddcosmo_tdscf_grad.py
+-rw-r--r--   0 runner    (1001) docker     (123)    36196 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/solvent/ddcosmo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14603 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/solvent/ddcosmo_grad.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13436 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/solvent/ddpcm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18327 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/solvent/pol_embed.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.686976 pyscf-2.3.0/pyscf/soscf/
+-rw-r--r--   0 runner    (1001) docker     (123)      611 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/soscf/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12279 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/soscf/ciah.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42099 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/soscf/newton_ah.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.690976 pyscf-2.3.0/pyscf/symm/
+-rw-r--r--   0 runner    (1001) docker     (123)     6910 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/symm/Dmatrix.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1107 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/symm/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13869 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/symm/addons.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25049 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/symm/basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1475 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/symm/cg.py
+-rw-r--r--   0 runner    (1001) docker     (123)    34285 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/symm/geom.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11265 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/symm/param.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8240 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/symm/sph.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.690976 pyscf-2.3.0/pyscf/tddft/
+-rw-r--r--   0 runner    (1001) docker     (123)      660 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tddft/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.694976 pyscf-2.3.0/pyscf/tdscf/
+-rw-r--r--   0 runner    (1001) docker     (123)     2410 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24041 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/common_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28284 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/dhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/dks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25682 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/ghf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6321 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/gks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9541 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/proxy.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39283 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/rhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7112 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/rhf_slow.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7871 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/rks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    34484 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/uhf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8816 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tdscf/uks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.694976 pyscf-2.3.0/pyscf/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)      740 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3635 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/c60struct.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9580 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/chgcar.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2342 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/chkfile_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14660 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/cubegen.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8527 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/dump_mat.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13341 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/fcidump.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3857 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/mo_mapping.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19491 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/molden.py
+-rw-r--r--   0 runner    (1001) docker     (123)      910 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/ring.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8282 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/tools/wfn_format.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.698976 pyscf-2.3.0/pyscf/x2c/
+-rw-r--r--   0 runner    (1001) docker     (123)      720 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1158 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/_response_functions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2102 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/dft.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2603 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/newton_ah.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10996 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/sfx2c1e.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10187 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/sfx2c1e_grad.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16870 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/sfx2c1e_hess.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1363 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/stability.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15467 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/tdscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35808 2023-07-08 07:46:58.000000 pyscf-2.3.0/pyscf/x2c/x2c.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-08 07:46:59.514972 pyscf-2.3.0/pyscf.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     1608 2023-07-08 07:46:59.000000 pyscf-2.3.0/pyscf.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    27848 2023-07-08 07:46:59.000000 pyscf-2.3.0/pyscf.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-07-08 07:46:59.000000 pyscf-2.3.0/pyscf.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      600 2023-07-08 07:46:59.000000 pyscf-2.3.0/pyscf.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       28 2023-07-08 07:46:59.000000 pyscf-2.3.0/pyscf.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      366 2023-07-08 07:46:59.698976 pyscf-2.3.0/setup.cfg
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6402 2023-07-08 07:46:58.000000 pyscf-2.3.0/setup.py
```

### Comparing `pyscf-2.2.1/CHANGELOG` & `pyscf-2.3.0/CHANGELOG`

 * *Files 0% similar despite different names*

```diff
@@ -1,7 +1,38 @@
+PySCF 2.3.0 (2023-07-04)
+------------------------
+* Added
+  - Gaussian MM charges
+  - Stepsize scheduler for UCASSCF
+  - APC active space selection
+  - f-in-core ECPs and core configurations
+  - TDDFT gradients for triplet states
+  - Support complex-valued h1e in fci_slow.absorb_h1e
+* Improved
+  - Update B3LYP functional to make it behave the same to ORCA
+  - Disable CLI parser by default
+  - Accuracy and performance of RSDF, GDF and RSJK methods
+  - get_lattice_Ls, and energy cutoff estimation
+  - Performance of PBC-AFTDF get_k method
+  - BCCD with semi-canonicalized orbitals
+  - Smearing in the molecular ROHF method
+  - Refactors FCI cylindrical symmetry implementation and improves its stability and performance
+  - Update interface of geomeTRIC library to support initial hessian
+  - NLC parser and NLC integral code
+* Fixes
+  - Update ddCOSMO functional to make it behave the same to Gaussian
+  - Deprecated keywords when calling scipy.linalg.solve
+  - The numerical issue in df hessian when the overlap matrix is ill-conditioned
+  - PBC-DFT eval_rho2 method
+  - xc parser for hybrid LDA functional
+  - SACASSCF grad fcasscf right track nelecas
+  - density fitting for GHF objects
+  - Fix bug in MP2 gradients scanner
+
+
 PySCF 2.2.1 (2023-03-29)
 ------------------------
 * Added
   - Density fitting gradients and hessian for RSH functionals
   - SCS-MP2 and SCS-KMP2
   - Configurations of f-in-core ECPs
   - ao2mo integral transformation for GHF orbitals with scalar ERIs
```

### Comparing `pyscf-2.2.1/LICENSE` & `pyscf-2.3.0/LICENSE`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/MANIFEST.in` & `pyscf-2.3.0/MANIFEST.in`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/NOTICE` & `pyscf-2.3.0/NOTICE`

 * *Files 0% similar despite different names*

```diff
@@ -77,15 +77,15 @@
 Zhenyu Zhu
 Shirong Wang
 Xubo Wang
 Kyle Bystrom
 Minye Zhang
 Yusuke Kimura
 Unathi Koketso Skosana
-Matthew Hennefarth
+Matthew R Hennefarth (University of Chicago)
 Will Wheeler
 Basil Ibrahim
 Junjie Yang
 Pablo del Mazo Sevillano
 Allan Chain
 Xin Xing
 Seunghoon Lee
```

### Comparing `pyscf-2.2.1/PKG-INFO` & `pyscf-2.3.0/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyscf
-Version: 2.2.1
+Version: 2.3.0
 Summary: PySCF: Python-based Simulations of Chemistry Framework
 Home-page: http://www.pyscf.org
 Author: Qiming Sun
 Author-email: osirpt.sun@gmail.com
 License: Apache License 2.0
 Download-URL: http://github.com/pyscf/pyscf
 Platform: Linux
```

### Comparing `pyscf-2.2.1/README.md` & `pyscf-2.3.0/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -3,17 +3,17 @@
 </div>
 
 Python-based Simulations of Chemistry Framework
 ===============================================
 [![Build Status](https://github.com/pyscf/pyscf/workflows/CI/badge.svg)](https://github.com/pyscf/pyscf/actions?query=workflow%3ACI)
 [![codecov](https://codecov.io/gh/pyscf/pyscf/branch/master/graph/badge.svg)](https://codecov.io/gh/pyscf/pyscf)
 
-2023-03-29
+2023-07-04
 
-* [Stable release 2.2.1](https://github.com/pyscf/pyscf/releases/tag/v2.2.1)
+* [Stable release 2.3.0](https://github.com/pyscf/pyscf/releases/tag/v2.3.0)
 * [Changelog](../master/CHANGELOG)
 * [Documentation](http://www.pyscf.org)
 * [Installation](#installation)
 * [Features](../master/FEATURES)
 
 
 Installation
```

### Comparing `pyscf-2.2.1/pyscf/__all__.py` & `pyscf-2.3.0/pyscf/__all__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/__config__.py` & `pyscf-2.3.0/pyscf/__config__.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 #
 
 DEBUG = False
 
 MAX_MEMORY = int(os.environ.get('PYSCF_MAX_MEMORY', 4000)) # MB
 TMPDIR = os.environ.get('TMPDIR', '.')
 TMPDIR = os.environ.get('PYSCF_TMPDIR', TMPDIR)
+ARGPARSE = bool(os.getenv('PYSCF_ARGPARSE', False))
 
 VERBOSE = 3  # default logger level (logger.NOTE)
 UNIT = 'angstrom'
 
 #
 # Loading pyscf_conf.py and overwriting above parameters
 #
```

### Comparing `pyscf-2.2.1/pyscf/__init__.py` & `pyscf-2.3.0/pyscf/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -31,15 +31,15 @@
     >>> mol = pyscf.M(atom='H 0 0 0; H 0 0 1.2', basis='cc-pvdz')
     >>> mol.RHF().run()
     converged SCF energy = -1.06111199785749
     -1.06111199786
 
 '''
 
-__version__ = '2.2.1'
+__version__ = '2.3.0'
 
 import os
 import sys
 
 # Load modules which are developed as plugins of the namespace package
 PYSCF_EXT_PATH = os.getenv('PYSCF_EXT_PATH')
 if PYSCF_EXT_PATH:
```

### Comparing `pyscf-2.2.1/pyscf/adc/__init__.py` & `pyscf-2.3.0/pyscf/adc/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/dfadc.py` & `pyscf-2.3.0/pyscf/adc/dfadc.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/radc.py` & `pyscf-2.3.0/pyscf/adc/radc.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/radc_amplitudes.py` & `pyscf-2.3.0/pyscf/adc/radc_amplitudes.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/radc_ao2mo.py` & `pyscf-2.3.0/pyscf/adc/radc_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/radc_ea.py` & `pyscf-2.3.0/pyscf/adc/radc_ea.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/radc_ip.py` & `pyscf-2.3.0/pyscf/adc/radc_ip.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/radc_ip_cvs.py` & `pyscf-2.3.0/pyscf/adc/radc_ip_cvs.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/uadc.py` & `pyscf-2.3.0/pyscf/adc/uadc.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/uadc_amplitudes.py` & `pyscf-2.3.0/pyscf/adc/uadc_amplitudes.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/uadc_ao2mo.py` & `pyscf-2.3.0/pyscf/adc/uadc_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/uadc_ea.py` & `pyscf-2.3.0/pyscf/adc/uadc_ea.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/uadc_ip.py` & `pyscf-2.3.0/pyscf/adc/uadc_ip.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/adc/uadc_ip_cvs.py` & `pyscf-2.3.0/pyscf/adc/uadc_ip_cvs.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/__init__.py` & `pyscf-2.3.0/pyscf/agf2/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/_agf2.py` & `pyscf-2.3.0/pyscf/agf2/_agf2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/aux_space.py` & `pyscf-2.3.0/pyscf/agf2/aux_space.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/chempot.py` & `pyscf-2.3.0/pyscf/agf2/chempot.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/chkfile.py` & `pyscf-2.3.0/pyscf/agf2/chkfile.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/dfragf2.py` & `pyscf-2.3.0/pyscf/agf2/dfragf2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/dfuagf2.py` & `pyscf-2.3.0/pyscf/agf2/dfuagf2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/mpi_helper.py` & `pyscf-2.3.0/pyscf/agf2/mpi_helper.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/ragf2.py` & `pyscf-2.3.0/pyscf/agf2/ragf2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/ragf2_slow.py` & `pyscf-2.3.0/pyscf/agf2/ragf2_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/uagf2.py` & `pyscf-2.3.0/pyscf/agf2/uagf2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/agf2/uagf2_slow.py` & `pyscf-2.3.0/pyscf/agf2/uagf2_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ao2mo/__init__.py` & `pyscf-2.3.0/pyscf/ao2mo/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ao2mo/_ao2mo.py` & `pyscf-2.3.0/pyscf/ao2mo/_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ao2mo/addons.py` & `pyscf-2.3.0/pyscf/ao2mo/addons.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ao2mo/incore.py` & `pyscf-2.3.0/pyscf/ao2mo/incore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ao2mo/nrr_outcore.py` & `pyscf-2.3.0/pyscf/ao2mo/nrr_outcore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ao2mo/outcore.py` & `pyscf-2.3.0/pyscf/ao2mo/outcore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ao2mo/r_outcore.py` & `pyscf-2.3.0/pyscf/ao2mo/r_outcore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ao2mo/semi_incore.py` & `pyscf-2.3.0/pyscf/ao2mo/semi_incore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/__init__.py` & `pyscf-2.3.0/pyscf/cc/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/_ccsd.py` & `pyscf-2.3.0/pyscf/cc/_ccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/addons.py` & `pyscf-2.3.0/pyscf/cc/addons.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/bccd.py` & `pyscf-2.3.0/pyscf/cc/bccd.py`

 * *Files 18% similar despite different names*

```diff
@@ -74,14 +74,16 @@
         nocc_a, nocc_b, nvir_a, nvir_b = t2.shape
         umat_occ_a = umat_a[:nocc_a, :nocc_a]
         umat_occ_b = umat_b[:nocc_b, :nocc_b]
         umat_vir_a = umat_a[nocc_a:, nocc_a:]
         umat_vir_b = umat_b[nocc_b:, nocc_b:]
         t2_bo = np.einsum("ijab, iI, jJ, aA, bB -> IJAB", t2, umat_occ_a,
                           umat_occ_b, umat_vir_a, umat_vir_b, optimize=True)
+        # (T) need a continuous array
+        t2_bo = np.asarray(t2_bo, order='C')
     else: # UHF
         t2_bo = [None, None, None]
         t2_bo[0] = transform_t2_to_bo(t2[0], umat[0])
         t2_bo[1] = transform_t2_to_bo(t2[1], umat[0], umat_b=umat[1])
         t2_bo[2] = transform_t2_to_bo(t2[2], umat[1])
     return t2_bo
 
@@ -124,28 +126,30 @@
             xsin = (rd[i, i + 1] - rd[i + 1, i]) * 0.5
             theta = np.arctan2(xsin, xcos)
             ld[i, i + 1] = theta
             ld[i + 1, i] = -theta
         return rv @ ld @ rv.T
 
 def bccd_kernel_(mycc, u=None, conv_tol_normu=1e-5, max_cycle=20, diis=True,
-                 verbose=4):
+                 canonicalization=True, verbose=4):
     """
     Brueckner coupled-cluster wrapper, using an outer-loop algorithm.
 
     Args:
         mycc: a converged CCSD object.
         u: initial transformation matrix.
         conv_tol_normu: convergence tolerance for u matrix.
         max_cycle: Maximum number of BCC cycles.
         diis: whether perform DIIS.
+        canonicalization: whether to semi-canonicalize the Brueckner orbitals.
         verbose: verbose for CCSD inner iterations.
 
     Returns:
         mycc: a modified CC object with t1 vanished.
+              mycc._scf and mycc will be modified.
     """
     log = lib.logger.new_logger(mycc, verbose)
     log.info("BCCD loop starts.")
 
     def trans_mo(mo_coeff, u):
         mo_coeff = np.asarray(mo_coeff)
         if mo_coeff.ndim == 2:
@@ -252,14 +256,66 @@
             log.info("BCC iter: %4d  E: %20.12f  dE: %12.3e  |t1|: %12.3e",
                      i, mycc.e_tot, dE, t1_norm)
             if t1_norm < conv_tol_normu:
                 break
             u = get_umat_from_t1(mycc.t1)
         else:
             log.warn("BCC: not converged, max_cycle reached.")
+
+    # semi-canonicalization
+    if canonicalization:
+        dm = mf.make_rdm1(mycc.mo_coeff, mycc.mo_occ)
+        vhf = mf.get_veff(mycc.mol, dm)
+        fockao = mf.get_fock(vhf=vhf, dm=dm)
+        e_corr = mycc.e_corr
+
+        if u.ndim == 2:
+            fock = mycc.mo_coeff.conj().T @ fockao @ mycc.mo_coeff
+            fock_xcore = fock[np.ix_(frozen_mask, frozen_mask)]
+            foo = fock_xcore[:mycc.nocc, :mycc.nocc]
+            fvv = fock_xcore[mycc.nocc:, mycc.nocc:]
+            ew_o, ev_o = la.eigh(foo)
+            ew_v, ev_v = la.eigh(fvv)
+            umat_xcore = la.block_diag(ev_o, ev_v)
+            umat = np.eye(mycc.mo_coeff.shape[-1])
+            umat[np.ix_(frozen_mask, frozen_mask)] = umat_xcore
+            mf.mo_coeff = mf.mo_coeff @ umat
+            mycc.mo_coeff = mf.mo_coeff
+        else:
+            umat = []
+            umat_xcore = []
+            for s in range(2):
+                fock = mycc.mo_coeff[s].conj().T @ fockao[s] @ mycc.mo_coeff[s]
+                fock_xcore = fock[np.ix_(frozen_mask[s], frozen_mask[s])]
+                foo = fock_xcore[:mycc.nocc[s], :mycc.nocc[s]]
+                fvv = fock_xcore[mycc.nocc[s]:, mycc.nocc[s]:]
+                ew_o, ev_o = la.eigh(foo)
+                ew_v, ev_v = la.eigh(fvv)
+                umat_xcore.append(la.block_diag(ev_o, ev_v))
+                umat_s = np.eye(mycc.mo_coeff[s].shape[-1])
+                umat_s[np.ix_(frozen_mask[s], frozen_mask[s])] = umat_xcore[-1]
+                umat.append(umat_s)
+
+            umat = np.asarray(umat)
+            mf.mo_coeff = np.einsum('spm, smn -> spn', mf.mo_coeff, umat)
+            mycc.mo_coeff = mf.mo_coeff
+
+        t1 = transform_t1_to_bo(mycc.t1, umat_xcore)
+        t2 = transform_t2_to_bo(mycc.t2, umat_xcore)
+
+        mf.e_tot = mf.energy_tot()
+        mycc.__init__(mf)
+        mycc.e_hf = mycc.get_e_hf()
+        mycc.e_corr = e_corr
+        mycc.frozen = frozen
+        mycc.level_shift = level_shift
+        mycc.verbose = verbose
+        mycc.t1 = t1
+        mycc.t2 = t2
+
     return mycc
 
 if __name__ == "__main__":
     import pyscf
     from pyscf import cc
 
     np.set_printoptions(3, linewidth=1000, suppress=True)
@@ -272,19 +328,23 @@
 
     myhf = mol.HF()
     myhf.kernel()
     E_ref = myhf.e_tot
     rdm1_mf = myhf.make_rdm1()
 
     mycc = cc.CCSD(myhf, frozen=None)
+    #mycc.frozen = [0]
     mycc.kernel()
     mycc.conv_tol = 1e-3
 
     mycc = bccd_kernel_(mycc, diis=True, verbose=4)
     e_r = mycc.e_tot
+    e_ccsd_t = mycc.ccsd_t()
+    # PSI4 reference
+    assert abs(e_ccsd_t - -0.002625521337000) < 1e-5
 
     print (la.norm(mycc.t1))
     assert la.norm(mycc.t1) < 1e-5
 
     myhf = mol.UHF()
     myhf.kernel()
     myucc = cc.CCSD(myhf, frozen=None)
```

### Comparing `pyscf-2.2.1/pyscf/cc/ccd.py` & `pyscf-2.3.0/pyscf/cc/ccd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/ccsd.py` & `pyscf-2.3.0/pyscf/cc/ccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/ccsd_lambda.py` & `pyscf-2.3.0/pyscf/cc/ccsd_lambda.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/ccsd_rdm.py` & `pyscf-2.3.0/pyscf/cc/ccsd_rdm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/ccsd_rdm_slow.py` & `pyscf-2.3.0/pyscf/cc/ccsd_rdm_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/ccsd_t.py` & `pyscf-2.3.0/pyscf/cc/ccsd_t.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/ccsd_t_lambda_slow.py` & `pyscf-2.3.0/pyscf/cc/ccsd_t_lambda_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/ccsd_t_rdm_slow.py` & `pyscf-2.3.0/pyscf/cc/ccsd_t_rdm_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/ccsd_t_slow.py` & `pyscf-2.3.0/pyscf/cc/ccsd_t_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/dfccsd.py` & `pyscf-2.3.0/pyscf/cc/dfccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/eom_gccsd.py` & `pyscf-2.3.0/pyscf/cc/eom_gccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/eom_rccsd.py` & `pyscf-2.3.0/pyscf/cc/eom_rccsd.py`

 * *Files 0% similar despite different names*

```diff
@@ -524,23 +524,26 @@
         e.append(eval_+deltaE)
     t2 = restore_t2_inplace(t2T)
     return e
 
 class EOMIP(EOM):
     def get_init_guess(self, nroots=1, koopmans=True, diag=None):
         size = self.vector_size()
-        dtype = getattr(diag, 'dtype', np.double)
         nroots = min(nroots, size)
         guess = []
         if koopmans:
+            dtype = getattr(diag, 'dtype', np.double)
             for n in range(nroots):
                 g = np.zeros(int(size), dtype)
                 g[self.nocc-n-1] = 1.0
                 guess.append(g)
         else:
+            if diag is None:
+                diag = self.get_diag()
+            dtype = getattr(diag, 'dtype', np.double)
             idx = diag.argsort()[:nroots]
             for i in idx:
                 g = np.zeros(int(size), dtype)
                 g[i] = 1.0
                 guess.append(g)
         return guess
 
@@ -890,23 +893,26 @@
         e.append(eval_+deltaE)
     return e
 
 
 class EOMEA(EOM):
     def get_init_guess(self, nroots=1, koopmans=True, diag=None):
         size = self.vector_size()
-        dtype = getattr(diag, 'dtype', np.double)
         nroots = min(nroots, size)
         guess = []
         if koopmans:
+            dtype = getattr(diag, 'dtype', np.double)
             for n in range(nroots):
                 g = np.zeros(size, dtype)
                 g[n] = 1.0
                 guess.append(g)
         else:
+            if diag is None:
+                diag = self.get_diag()
+            dtype = getattr(diag, 'dtype', np.double)
             idx = diag.argsort()[:nroots]
             for i in idx:
                 g = np.zeros(size, dtype)
                 g[i] = 1.0
                 guess.append(g)
         return guess
 
@@ -1653,14 +1659,16 @@
     vec_eeT = amplitudes_to_vector_triplet(Hr1aa, (Hr2aa,Hr2ab))
     vec_sf = amplitudes_to_vector_eomsf(Hr1ab, (Hr2baaa,Hr2aaba))
     return vec_eeS, vec_eeT, vec_sf
 
 
 class EOMEE(EOM):
     def get_init_guess(self, nroots=1, koopmans=True, diag=None):
+        if diag is None:
+            diag = self.get_diag()
         if koopmans:
             nocc = self.nocc
             nvir = self.nmo - nocc
             idx = diag[:nocc*nvir].argsort()
         else:
             idx = diag.argsort()
 
@@ -1695,17 +1703,20 @@
 
 
 class EOMEESinglet(EOMEE):
     kernel = eomee_ccsd_singlet
     eomee_ccsd_singlet = eomee_ccsd_singlet
     matvec = eeccsd_matvec_singlet
 
+    def get_diag(self, imds=None):
+        return eeccsd_diag(self, imds=None)[0]
+
     def gen_matvec(self, imds=None, diag=None, **kwargs):
         if imds is None: imds = self.make_imds()
-        if diag is None: diag = self.get_diag(imds)[0]
+        if diag is None: diag = self.get_diag(imds)
         matvec = lambda xs: [self.matvec(x, imds) for x in xs]
         return matvec, diag
 
     amplitudes_to_vector = staticmethod(amplitudes_to_vector_singlet)
     vector_to_amplitudes = module_method(vector_to_amplitudes_singlet,
                                          absences=['nmo', 'nocc'])
     spatial2spin = staticmethod(spatial2spin_singlet)
@@ -1718,17 +1729,20 @@
 
 
 class EOMEETriplet(EOMEE):
     kernel = eomee_ccsd_triplet
     eomee_ccsd_triplet = eomee_ccsd_triplet
     matvec = eeccsd_matvec_triplet
 
+    def get_diag(self, imds=None):
+        return eeccsd_diag(self, imds=None)[1]
+
     def gen_matvec(self, imds=None, diag=None, **kwargs):
         if imds is None: imds = self.make_imds()
-        if diag is None: diag = self.get_diag(imds)[1]
+        if diag is None: diag = self.get_diag(imds)
         matvec = lambda xs: [self.matvec(x, imds) for x in xs]
         return matvec, diag
 
     amplitudes_to_vector = staticmethod(amplitudes_to_vector_triplet)
     vector_to_amplitudes = module_method(vector_to_amplitudes_triplet,
                                          absences=['nmo', 'nocc'])
     spatial2spin = staticmethod(spatial2spin_triplet)
@@ -1741,17 +1755,20 @@
 
 
 class EOMEESpinFlip(EOMEE):
     kernel = eomsf_ccsd
     eomsf_ccsd = eomsf_ccsd
     matvec = eeccsd_matvec_sf
 
+    def get_diag(self, imds=None):
+        return eeccsd_diag(self, imds=None)[2]
+
     def gen_matvec(self, imds=None, diag=None, **kwargs):
         if imds is None: imds = self.make_imds()
-        if diag is None: diag = self.get_diag(imds)[2]
+        if diag is None: diag = self.get_diag(imds)
         matvec = lambda xs: [self.matvec(x, imds) for x in xs]
         return matvec, diag
 
     amplitudes_to_vector = staticmethod(amplitudes_to_vector_eomsf)
     vector_to_amplitudes = module_method(vector_to_amplitudes_eomsf,
                                          absences=['nmo', 'nocc'])
     spatial2spin = staticmethod(spatial2spin_eomsf)
```

### Comparing `pyscf-2.2.1/pyscf/cc/eom_uccsd.py` & `pyscf-2.3.0/pyscf/cc/eom_uccsd.py`

 * *Files 0% similar despite different names*

```diff
@@ -324,14 +324,16 @@
 
     def __init__(self, cc):
         eom_rccsd.EOMIP.__init__(self, cc)
         self.nocc = cc.get_nocc()
         self.nmo = cc.get_nmo()
 
     def get_init_guess(self, nroots=1, koopmans=True, diag=None):
+        if diag is None:
+            diag = self.get_diag()
         if koopmans:
             nocca, noccb = self.nocc
             idx = diag[:nocca+noccb].argsort()
         else:
             idx = diag.argsort()
 
         size = self.vector_size()
@@ -849,14 +851,16 @@
 
     def __init__(self, cc):
         eom_rccsd.EOMEA.__init__(self, cc)
         self.nocc = cc.get_nocc()
         self.nmo = cc.get_nmo()
 
     def get_init_guess(self, nroots=1, koopmans=True, diag=None):
+        if diag is None:
+            diag = self.get_diag()
         if koopmans:
             nocca, noccb = self.nocc
             nmoa, nmob = self.nmo
             nvira, nvirb = nmoa-nocca, nmob-noccb
             idx = diag[:nvira+nvirb].argsort()
         else:
             idx = diag.argsort()
@@ -1846,14 +1850,16 @@
 class EOMEESpinKeep(EOMEE):
     kernel = eomee_ccsd
     eomee_ccsd = eomee_ccsd
     matvec = eomee_ccsd_matvec
     get_diag = eeccsd_diag
 
     def get_init_guess(self, nroots=1, koopmans=True, diag=None):
+        if diag is None:
+            diag = self.get_diag()
         if koopmans:
             nocca, noccb = self.nocc
             nmoa, nmob = self.nmo
             nvira, nvirb = nmoa-nocca, nmob-noccb
 # amplitudes are compressed by the function amplitudes_to_vector_ee. sizea is
 # the offset in the compressed vector that points to the amplitudes R1_beta
 # The addresses of R1_alpha and R1_beta are not contiguous in the compressed
@@ -1900,14 +1906,16 @@
 
 class EOMEESpinFlip(EOMEE):
     kernel = eomsf_ccsd
     eomsf_ccsd = eomsf_ccsd
     matvec = eomsf_ccsd_matvec
 
     def get_init_guess(self, nroots=1, koopmans=True, diag=None):
+        if diag is None:
+            diag = self.get_diag()
         if koopmans:
             nocca, noccb = self.nocc
             nmoa, nmob = self.nmo
             nvira, nvirb = nmoa-nocca, nmob-noccb
             idx = diag[:nocca*nvirb+noccb*nvira].argsort()
         else:
             idx = diag.argsort()
```

### Comparing `pyscf-2.2.1/pyscf/cc/gccsd.py` & `pyscf-2.3.0/pyscf/cc/gccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/gccsd_lambda.py` & `pyscf-2.3.0/pyscf/cc/gccsd_lambda.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/gccsd_rdm.py` & `pyscf-2.3.0/pyscf/cc/gccsd_rdm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/gccsd_t.py` & `pyscf-2.3.0/pyscf/cc/gccsd_t.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/gccsd_t_lambda.py` & `pyscf-2.3.0/pyscf/cc/gccsd_t_lambda.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/gccsd_t_rdm.py` & `pyscf-2.3.0/pyscf/cc/gccsd_t_rdm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/gccsd_t_slow.py` & `pyscf-2.3.0/pyscf/cc/gccsd_t_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/gintermediates.py` & `pyscf-2.3.0/pyscf/cc/gintermediates.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/momgfccsd.py` & `pyscf-2.3.0/pyscf/cc/momgfccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/qcisd.py` & `pyscf-2.3.0/pyscf/cc/qcisd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/qcisd_slow.py` & `pyscf-2.3.0/pyscf/cc/qcisd_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/qcisd_t.py` & `pyscf-2.3.0/pyscf/cc/qcisd_t.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/qcisd_t_slow.py` & `pyscf-2.3.0/pyscf/cc/qcisd_t_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/rccsd.py` & `pyscf-2.3.0/pyscf/cc/rccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/rccsd_lambda.py` & `pyscf-2.3.0/pyscf/cc/rccsd_lambda.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/rccsd_slow.py` & `pyscf-2.3.0/pyscf/cc/rccsd_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/rintermediates.py` & `pyscf-2.3.0/pyscf/cc/rintermediates.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uccsd.py` & `pyscf-2.3.0/pyscf/cc/uccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uccsd_lambda.py` & `pyscf-2.3.0/pyscf/cc/uccsd_lambda.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uccsd_rdm.py` & `pyscf-2.3.0/pyscf/cc/uccsd_rdm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uccsd_slow.py` & `pyscf-2.3.0/pyscf/cc/uccsd_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uccsd_t.py` & `pyscf-2.3.0/pyscf/cc/uccsd_t.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uccsd_t_lambda.py` & `pyscf-2.3.0/pyscf/cc/uccsd_t_lambda.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uccsd_t_rdm.py` & `pyscf-2.3.0/pyscf/cc/uccsd_t_rdm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uccsd_t_slow.py` & `pyscf-2.3.0/pyscf/cc/uccsd_t_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uintermediates.py` & `pyscf-2.3.0/pyscf/cc/uintermediates.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/cc/uintermediates_slow.py` & `pyscf-2.3.0/pyscf/cc/uintermediates_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ci/__init__.py` & `pyscf-2.3.0/pyscf/ci/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ci/addons.py` & `pyscf-2.3.0/pyscf/ci/addons.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ci/cisd.py` & `pyscf-2.3.0/pyscf/ci/cisd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ci/gcisd.py` & `pyscf-2.3.0/pyscf/ci/gcisd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/ci/ucisd.py` & `pyscf-2.3.0/pyscf/ci/ucisd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/__init__.py` & `pyscf-2.3.0/pyscf/data/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/elements.py` & `pyscf-2.3.0/pyscf/data/elements.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/gyro.py` & `pyscf-2.3.0/pyscf/data/gyro.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/gyromagnetic_ratio.dat` & `pyscf-2.3.0/pyscf/data/gyromagnetic_ratio.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/nist.py` & `pyscf-2.3.0/pyscf/data/nist.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/nuclear_g_factor.dat` & `pyscf-2.3.0/pyscf/data/nuclear_g_factor.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/nucprop.py` & `pyscf-2.3.0/pyscf/data/nucprop.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/radii.py` & `pyscf-2.3.0/pyscf/data/radii.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/data/solvents.dat` & `pyscf-2.3.0/pyscf/data/solvents.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/__init__.py` & `pyscf-2.3.0/pyscf/df/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/addons.py` & `pyscf-2.3.0/pyscf/df/addons.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/df.py` & `pyscf-2.3.0/pyscf/df/df.py`

 * *Files 0% similar despite different names*

```diff
@@ -273,15 +273,16 @@
         In this context, only LR or SR integrals for mol and auxmol are computed.
         '''
         key = '%.6f' % omega
         if key in self._rsh_df:
             rsh_df = self._rsh_df[key]
         else:
             rsh_df = self._rsh_df[key] = copy.copy(self).reset()
-            rsh_df._dataname = f'j3c/lr/{key}'
+            if hasattr(self, '_dataname'):
+                rsh_df._dataname = f'{self._dataname}/lr/{key}'
             logger.info(self, 'Create RSH-DF object %s for omega=%s', rsh_df, omega)
 
         mol = self.mol
         auxmol = self.auxmol
 
         mol_omega = mol.omega
         mol.omega = omega
```

### Comparing `pyscf-2.2.1/pyscf/df/df_jk.py` & `pyscf-2.3.0/pyscf/df/df_jk.py`

 * *Files 2% similar despite different names*

```diff
@@ -114,26 +114,37 @@
         def reset(self, mol=None):
             self.with_df.reset(mol)
             return mf_class.reset(self, mol)
 
         def get_jk(self, mol=None, dm=None, hermi=1, with_j=True, with_k=True,
                    omega=None):
             if dm is None: dm = self.make_rdm1()
-            if self.with_df and self.only_dfj:
-                vj = vk = None
-                if with_j:
-                    vj, vk = self.with_df.get_jk(dm, hermi, True, False,
+            if not self.with_df:
+                return mf_class.get_jk(self, mol, dm, hermi, with_j, with_k, omega)
+
+            with_dfk = with_k and not self.only_dfj
+            if isinstance(self, scf.ghf.GHF):
+                def jkbuild(mol, dm, hermi, with_j, with_k, omega=None):
+                    vj, vk = self.with_df.get_jk(dm.real, hermi, with_j, with_k,
                                                  self.direct_scf_tol, omega)
-                if with_k:
-                    vk = mf_class.get_jk(self, mol, dm, hermi, False, True, omega)[1]
-            elif self.with_df:
-                vj, vk = self.with_df.get_jk(dm, hermi, with_j, with_k,
-                                             self.direct_scf_tol, omega)
+                    if dm.dtype == numpy.complex128:
+                        vjI, vkI = self.with_df.get_jk(dm.imag, hermi, with_j, with_k,
+                                                       self.direct_scf_tol, omega)
+                        if with_j:
+                            vj = vj + vjI * 1j
+                        if with_k:
+                            vk = vk + vkI * 1j
+                    return vj, vk
+                vj, vk = scf.ghf.get_jk(mol, dm, hermi, with_j, with_dfk,
+                                        jkbuild, omega)
             else:
-                vj, vk = mf_class.get_jk(self, mol, dm, hermi, with_j, with_k, omega)
+                vj, vk = self.with_df.get_jk(dm, hermi, with_j, with_dfk,
+                                             self.direct_scf_tol, omega)
+            if with_k and not with_dfk:
+                vk = mf_class.get_jk(self, mol, dm, hermi, False, True, omega)[1]
             return vj, vk
 
         # for pyscf 1.0, 1.1 compatibility
         @property
         def _cderi(self):
             naux = self.with_df.get_naoaux()
             return next(self.with_df.loop(blksize=naux))
```

### Comparing `pyscf-2.2.1/pyscf/df/grad/casdm2_util.py` & `pyscf-2.3.0/pyscf/df/grad/casdm2_util.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/grad/casscf.py` & `pyscf-2.3.0/pyscf/df/grad/casscf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/grad/rhf.py` & `pyscf-2.3.0/pyscf/df/grad/rhf.py`

 * *Files 0% similar despite different names*

```diff
@@ -240,15 +240,15 @@
         int3c = get_int3c_s2((0, nbas, 0, nbas, shl0, shl1))  # (i,j|P)
         p0, p1 = aux_loc[shl0], aux_loc[shl1]
         rhoj[:,p0:p1] = lib.einsum('wp,nw->np', int3c, dm_tril)
         int3c = None
 
     # (P|Q)
     int2c = auxmol.intor('int2c2e', aosym='s1')
-    rhoj = scipy.linalg.solve(int2c, rhoj.T, sym_pos=True).T
+    rhoj = scipy.linalg.solve(int2c, rhoj.T, assume_a='pos').T
     int2c = None
 
     # (d/dX i,j|P)
     vj = numpy.zeros((nset,3,nao,nao))
     for shl0, shl1, nL in ao_ranges:
         int3c = get_int3c_ip1((0, nbas, 0, nbas, shl0, shl1))  # (i,j|P)
         p0, p1 = aux_loc[shl0], aux_loc[shl1]
```

### Comparing `pyscf-2.2.1/pyscf/df/grad/rks.py` & `pyscf-2.3.0/pyscf/df/grad/rks.py`

 * *Files 10% similar despite different names*

```diff
@@ -33,62 +33,56 @@
     '''Coulomb + XC functional
     '''
     if mol is None: mol = ks_grad.mol
     if dm is None: dm = ks_grad.base.make_rdm1()
     t0 = (logger.process_clock(), logger.perf_counter())
 
     mf = ks_grad.base
-    if ks_grad.grids is not None:
-        grids = ks_grad.grids
-    else:
-        grids = mf.grids
-    if mf.nlc != '':
-        assert 'VV10' in mf.nlc.upper()
-        if ks_grad.nlcgrids is not None:
-            nlcgrids = ks_grad.nlcgrids
-        else:
-            nlcgrids = mf.nlcgrids
-        if nlcgrids.coords is None:
-            nlcgrids.build(with_non0tab=True)
-    if grids.coords is None:
-        grids.build(with_non0tab=True)
-
     ni = mf._numint
-    omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, spin=mol.spin)
+    grids, nlcgrids = rks_grad._initialize_grids(ks_grad)
 
     mem_now = lib.current_memory()[0]
     max_memory = max(2000, ks_grad.max_memory*.9-mem_now)
     if ks_grad.grid_response:
         exc, vxc = rks_grad.get_vxc_full_response(
             ni, mol, grids, mf.xc, dm,
             max_memory=max_memory, verbose=ks_grad.verbose)
-        if mf.nlc:
-            enlc, vnlc = rks_grad.get_vxc_full_response(
-                ni, mol, nlcgrids, mf.xc+'__'+mf.nlc, dm,
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            if ni.libxc.is_nlc(mf.xc):
+                xc = mf.xc
+            else:
+                xc = mf.nlc
+            enlc, vnlc = rks_grad.get_nlc_vxc_full_response(
+                ni, mol, nlcgrids, xc, dm,
                 max_memory=max_memory, verbose=ks_grad.verbose)
             exc += enlc
             vxc += vnlc
         logger.debug1(ks_grad, 'sum(grids response) %s', exc.sum(axis=0))
     else:
         exc, vxc = rks_grad.get_vxc(
             ni, mol, grids, mf.xc, dm,
             max_memory=max_memory, verbose=ks_grad.verbose)
-        if mf.nlc:
-            enlc, vnlc = rks_grad.get_vxc(
-                ni, mol, nlcgrids, mf.xc+'__'+mf.nlc, dm,
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            if ni.libxc.is_nlc(mf.xc):
+                xc = mf.xc
+            else:
+                xc = mf.nlc
+            enlc, vnlc = rks_grad.get_nlc_vxc(
+                ni, mol, nlcgrids, xc, dm,
                 max_memory=max_memory, verbose=ks_grad.verbose)
             vxc += vnlc
     t0 = logger.timer(ks_grad, 'vxc', *t0)
 
     if not ni.libxc.is_hybrid_xc(mf.xc):
         vj = ks_grad.get_j(mol, dm)
         vxc += vj
         if ks_grad.auxbasis_response:
             e1_aux = vj.aux.sum ((0,1))
     else:
+        omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, spin=mol.spin)
         vj, vk = ks_grad.get_jk(mol, dm)
         if ks_grad.auxbasis_response:
             vk.aux *= hyb
         vk[:] *= hyb # Don't erase the .aux tags!
         if omega != 0:  # For range separated Coulomb operator
             # TODO: replaced with vk_sr which is numerically more stable for
             # inv(int2c2e)
```

### Comparing `pyscf-2.2.1/pyscf/df/grad/sacasscf.py` & `pyscf-2.3.0/pyscf/df/grad/sacasscf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/grad/uhf.py` & `pyscf-2.3.0/pyscf/df/grad/uhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/grad/uks.py` & `pyscf-2.3.0/pyscf/df/grad/uks.py`

 * *Files 21% similar despite different names*

```diff
@@ -22,62 +22,69 @@
 # Author: Qiming Sun <osirpt.sun@gmail.com>
 #
 
 
 import numpy
 from pyscf import lib
 from pyscf.lib import logger
+from pyscf.grad import rks as rks_grad
 from pyscf.grad import uks as uks_grad
 from pyscf.df.grad import rhf as df_rhf_grad
 
 
 def get_veff(ks_grad, mol=None, dm=None):
     '''Coulomb + XC functional
     '''
     if mol is None: mol = ks_grad.mol
     if dm is None: dm = ks_grad.base.make_rdm1()
     t0 = (logger.process_clock(), logger.perf_counter())
 
     mf = ks_grad.base
-    if ks_grad.grids is not None:
-        grids = ks_grad.grids
-    else:
-        grids = mf.grids
-    if mf.nlc != '':
-        if ks_grad.nlcgrids is not None:
-            nlcgrids = ks_grad.nlcgrids
-        else:
-            nlcgrids = mf.nlcgrids
-        if nlcgrids.coords is None:
-            nlcgrids.build(with_non0tab=True)
-    if grids.coords is None:
-        grids.build(with_non0tab=True)
-
     ni = mf._numint
-    omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, spin=mol.spin)
+    grids, nlcgrids = rks_grad._initialize_grids(ks_grad)
 
     mem_now = lib.current_memory()[0]
     max_memory = max(2000, ks_grad.max_memory*.9-mem_now)
     if ks_grad.grid_response:
         exc, vxc = uks_grad.get_vxc_full_response(
                 ni, mol, grids, mf.xc, dm,
                 max_memory=max_memory, verbose=ks_grad.verbose)
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            if ni.libxc.is_nlc(mf.xc):
+                xc = mf.xc
+            else:
+                xc = mf.nlc
+            enlc, vnlc = rks_grad.get_nlc_vxc_full_response(
+                ni, mol, nlcgrids, xc, dm[0]+dm[1],
+                max_memory=max_memory, verbose=ks_grad.verbose)
+            exc += enlc
+            vxc += vnlc
         logger.debug1(ks_grad, 'sum(grids response) %s', exc.sum(axis=0))
     else:
         exc, vxc = uks_grad.get_vxc(
                 ni, mol, grids, mf.xc, dm,
                 max_memory=max_memory, verbose=ks_grad.verbose)
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            if ni.libxc.is_nlc(mf.xc):
+                xc = mf.xc
+            else:
+                xc = mf.nlc
+            enlc, vnlc = rks_grad.get_nlc_vxc(
+                ni, mol, nlcgrids, xc, dm[0]+dm[1],
+                max_memory=max_memory, verbose=ks_grad.verbose)
+            vxc += vnlc
     t0 = logger.timer(ks_grad, 'vxc', *t0)
 
     if not ni.libxc.is_hybrid_xc(mf.xc):
         vj = ks_grad.get_j(mol, dm)
         vxc += vj[0] + vj[1]
         if ks_grad.auxbasis_response:
             e1_aux = vj.aux.sum ((0,1))
     else:
+        omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, spin=mol.spin)
         vj, vk = ks_grad.get_jk(mol, dm)
         if ks_grad.auxbasis_response:
             vk.aux = vk.aux * hyb
         vk[:] *= hyb # inplace * for vk[:] to keep the .aux tag
         if omega != 0:  # For range separated Coulomb operator
             vk_lr = ks_grad.get_k(mol, dm, omega=omega)
             vk[:] += vk_lr * (alpha - hyb)
```

### Comparing `pyscf-2.2.1/pyscf/df/hessian/rhf.py` & `pyscf-2.3.0/pyscf/df/hessian/rhf.py`

 * *Files 0% similar despite different names*

```diff
@@ -170,23 +170,15 @@
                 wk_ip2_P__[p0:p1] = lib.einsum('xuvp,ui,vj->pxij', int3c_ip2, mocc_2, mocc_2)
         int3c_ip2 = None
 
     if hessobj.auxbasis_response > 1:
         get_int3c_ipip2 = _int3c_wrapper(mol, auxmol, 'int3c2e_ipip2', 's1')
         rhok0_P__ = lib.einsum('plj,li->pij', rhok0_Pl_, mocc_2)
         rho2c_0 = lib.einsum('pij,qji->pq', rhok0_P__, rhok0_P__)
-
-        try:
-            int2c_inv = np.linalg.inv(int2c)
-        except scipy.linalg.LinAlgError:
-            w, v = scipy.linalg.eigh(int2c)
-            mask = w > LINEAR_DEP_THRESHOLD
-            v1 = v[:,mask]
-            int2c_inv = lib.dot(v1/w[mask], v1.conj().T)
-            v1 = None
+        int2c_inv = numpy.linalg.pinv(int2c, rcond=LINEAR_DEP_THRESHOLD)
         int2c_ipip1 = auxmol.intor('int2c2e_ipip1', aosym='s1')
         int2c_ip_ip  = lib.einsum('xpq,qr,ysr->xyps', int2c_ip1, int2c_inv, int2c_ip1)
         int2c_ip_ip -= auxmol.intor('int2c2e_ip1ip2', aosym='s1').reshape(3,3,naux,naux)
     int2c = solve_j2c = None
 
     get_int3c_ipvip1 = _int3c_wrapper(mol, auxmol, 'int3c2e_ipvip1', 's1')
     get_int3c_ip1ip2 = _int3c_wrapper(mol, auxmol, 'int3c2e_ip1ip2', 's1')
```

### Comparing `pyscf-2.2.1/pyscf/df/hessian/rks.py` & `pyscf-2.3.0/pyscf/df/hessian/rks.py`

 * *Files 3% similar despite different names*

```diff
@@ -37,27 +37,27 @@
 def partial_hess_elec(hessobj, mo_energy=None, mo_coeff=None, mo_occ=None,
                       atmlst=None, max_memory=4000, verbose=None):
     log = logger.new_logger(hessobj, verbose)
     time0 = t1 = (logger.process_clock(), logger.perf_counter())
 
     mol = hessobj.mol
     mf = hessobj.base
+    ni = mf._numint
+    if mf.nlc or ni.libxc.is_nlc(mf.xc):
+        raise NotImplementedError('RKS Hessian for NLC functional')
+
     if mo_energy is None: mo_energy = mf.mo_energy
     if mo_occ is None:    mo_occ = mf.mo_occ
     if mo_coeff is None:  mo_coeff = mf.mo_coeff
     if atmlst is None: atmlst = range(mol.natm)
 
     nao, nmo = mo_coeff.shape
     mocc = mo_coeff[:,mo_occ>0]
     dm0 = numpy.dot(mocc, mocc.T) * 2
 
-    if mf.nlc != '':
-        raise NotImplementedError
-
-    ni = mf._numint
     omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, spin=mol.spin)
     hybrid = ni.libxc.is_hybrid_xc(mf.xc)
     de2, ej, ek = df_rhf_hess._partial_hess_ejk(hessobj, mo_energy, mo_coeff, mo_occ,
                                                 atmlst, max_memory, verbose,
                                                 with_k=hybrid)
     de2 += ej - hyb * ek  # (A,B,dR_A,dR_B)
     if hybrid and omega != 0:
```

### Comparing `pyscf-2.2.1/pyscf/df/hessian/uhf.py` & `pyscf-2.3.0/pyscf/df/hessian/uhf.py`

 * *Files 1% similar despite different names*

```diff
@@ -193,23 +193,15 @@
 
     if hessobj.auxbasis_response > 1:
         get_int3c_ipip2 = _int3c_wrapper(mol, auxmol, 'int3c2e_ipip2', 's1')
         rhok0a_P__ = lib.einsum('plj,li->pij', rhok0a_Pl_, mocca)
         rhok0b_P__ = lib.einsum('plj,li->pij', rhok0b_Pl_, moccb)
         rho2c_0  = lib.einsum('pij,qij->pq', rhok0a_P__, rhok0a_P__)
         rho2c_0 += lib.einsum('pij,qij->pq', rhok0b_P__, rhok0b_P__)
-
-        try:
-            int2c_inv = np.linalg.inv(int2c)
-        except scipy.linalg.LinAlgError:
-            w, v = scipy.linalg.eigh(int2c)
-            mask = w > LINEAR_DEP_THRESHOLD
-            v1 = v[:,mask]
-            int2c_inv = lib.dot(v1/w[mask], v1.conj().T)
-            v1 = None
+        int2c_inv = numpy.linalg.pinv(int2c, rcond=LINEAR_DEP_THRESHOLD)
         int2c_ipip1 = auxmol.intor('int2c2e_ipip1', aosym='s1')
         int2c_ip_ip  = lib.einsum('xpq,qr,ysr->xyps', int2c_ip1, int2c_inv, int2c_ip1)
         int2c_ip_ip -= auxmol.intor('int2c2e_ip1ip2', aosym='s1').reshape(3,3,naux,naux)
     int2c = solve_j2c = None
 
     get_int3c_ipvip1 = _int3c_wrapper(mol, auxmol, 'int3c2e_ipvip1', 's1')
     get_int3c_ip1ip2 = _int3c_wrapper(mol, auxmol, 'int3c2e_ip1ip2', 's1')
```

### Comparing `pyscf-2.2.1/pyscf/df/hessian/uks.py` & `pyscf-2.3.0/pyscf/df/hessian/uks.py`

 * *Files 5% similar despite different names*

```diff
@@ -37,29 +37,29 @@
 def partial_hess_elec(hessobj, mo_energy=None, mo_coeff=None, mo_occ=None,
                       atmlst=None, max_memory=4000, verbose=None):
     log = logger.new_logger(hessobj, verbose)
     time0 = t1 = (logger.process_clock(), logger.perf_counter())
 
     mol = hessobj.mol
     mf = hessobj.base
+    ni = mf._numint
+    if mf.nlc or ni.libxc.is_nlc(mf.xc):
+        raise NotImplementedError('RKS Hessian for NLC functional')
+
     if mo_energy is None: mo_energy = mf.mo_energy
     if mo_occ is None:    mo_occ = mf.mo_occ
     if mo_coeff is None:  mo_coeff = mf.mo_coeff
     if atmlst is None: atmlst = range(mol.natm)
 
     nao, nmo = mo_coeff[0].shape
     mocca = mo_coeff[0][:,mo_occ[0]>0]
     moccb = mo_coeff[1][:,mo_occ[1]>0]
     dm0a = numpy.dot(mocca, mocca.T)
     dm0b = numpy.dot(moccb, moccb.T)
 
-    if mf.nlc != '':
-        raise NotImplementedError
-
-    ni = mf._numint
     omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, spin=mol.spin)
     hybrid = ni.libxc.is_hybrid_xc(mf.xc)
     de2, ej, ek = df_uhf_hess._partial_hess_ejk(hessobj, mo_energy, mo_coeff, mo_occ,
                                                 atmlst, max_memory, verbose,
                                                 with_k=hybrid)
     de2 += ej - hyb * ek  # (A,B,dR_A,dR_B)
     if hybrid and omega != 0:
```

### Comparing `pyscf-2.2.1/pyscf/df/incore.py` & `pyscf-2.3.0/pyscf/df/incore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/outcore.py` & `pyscf-2.3.0/pyscf/df/outcore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/df/r_incore.py` & `pyscf-2.3.0/pyscf/df/r_incore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/__init__.py` & `pyscf-2.3.0/pyscf/dft/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/dks.py` & `pyscf-2.3.0/pyscf/dft/dks.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,16 +29,16 @@
 from pyscf.dft import rks
 from pyscf.dft import gks
 from pyscf.dft import r_numint
 
 
 @lib.with_doc(gks.get_veff.__doc__)
 def get_veff(ks, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
-    if ks.nlc != '':
-        raise NotImplementedError(ks.nlc)
+    if ks.nlc or ks._numint.libxc.is_nlc(ks.xc):
+        raise NotImplementedError(f'NLC functional {ks.xc} + {ks.nlc}')
     return gks.get_veff(ks, mol, dm, dm_last, vhf_last, hermi)
 
 
 def energy_elec(ks, dm=None, h1e=None, vhf=None):
     r'''Electronic part of DKS energy.
 
     Note this function has side effects which cause mf.scf_summary updated.
```

### Comparing `pyscf-2.2.1/pyscf/dft/gen_grid.py` & `pyscf-2.3.0/pyscf/dft/gen_grid.py`

 * *Files 1% similar despite different names*

```diff
@@ -257,21 +257,14 @@
             if callable(prune):
                 angs = prune(chg, rad, n_ang)
             else:
                 angs = [n_ang] * n_rad
             logger.debug(mol, 'atom %s rad-grids = %d, ang-grids = %s',
                          symb, n_rad, angs)
 
-            ang_grids = {}
-            for n in sorted(set(angs)):
-                grid = numpy.empty((n,4))
-                libdft.MakeAngularGrid(grid.ctypes.data_as(ctypes.c_void_p),
-                                       ctypes.c_int(n))
-                ang_grids[n] = grid
-
             angs = numpy.array(angs)
             coords = []
             vol = []
             for n in sorted(set(angs)):
                 grid = numpy.empty((n,4))
                 libdft.MakeAngularGrid(grid.ctypes.data_as(ctypes.c_void_p),
                                        ctypes.c_int(n))
@@ -561,15 +554,15 @@
             self.weights = self.weights[idx]
 
         if self.alignment > 1:
             padding = _padding_size(self.size, self.alignment)
             logger.debug(self, 'Padding %d grids', padding)
             if padding > 0:
                 self.coords = numpy.vstack(
-                    [self.coords, numpy.repeat([[1e4]*3], padding, axis=0)])
+                    [self.coords, numpy.repeat([[1e-4]*3], padding, axis=0)])
                 self.weights = numpy.hstack([self.weights, numpy.zeros(padding)])
 
         if with_non0tab:
             self.non0tab = self.make_mask(mol, self.coords)
             self.screen_index = self.non0tab
         else:
             self.screen_index = self.non0tab = None
@@ -621,15 +614,15 @@
             self.coords  = numpy.asarray(self.coords [idx], order='C')
             self.weights = numpy.asarray(self.weights[idx], order='C')
             if self.alignment > 1:
                 padding = _padding_size(self.size, self.alignment)
                 logger.debug(self, 'prune_by_density_: %d padding grids', padding)
                 if padding > 0:
                     self.coords = numpy.vstack(
-                        [self.coords, numpy.repeat([[1e4]*3], padding, axis=0)])
+                        [self.coords, numpy.repeat([[1e-4]*3], padding, axis=0)])
                     self.weights = numpy.hstack([self.weights, numpy.zeros(padding)])
             self.non0tab = self.make_mask(mol, self.coords)
             self.screen_index = self.non0tab
         return self
 
 
 def _default_rad(nuc, level=3):
```

### Comparing `pyscf-2.2.1/pyscf/dft/gen_libxc_param.py` & `pyscf-2.3.0/pyscf/dft/gen_libxc_param.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/gen_xcfun_param.py` & `pyscf-2.3.0/pyscf/dft/gen_xcfun_param.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/gks.py` & `pyscf-2.3.0/pyscf/dft/gks.py`

 * *Files 4% similar despite different names*

```diff
@@ -71,21 +71,26 @@
     if hermi == 2:  # because rho = 0
         n, exc, vxc = 0, 0, 0
     else:
         max_memory = ks.max_memory - lib.current_memory()[0]
         ni = ks._numint
         n, exc, vxc = ni.get_vxc(mol, ks.grids, ks.xc, dm,
                                  hermi=hermi, max_memory=max_memory)
-        if ks.nlc != '':
-            assert ('VV10' in ks.nlc.upper())
-            _, enlc, vnlc = ni.get_vxc(mol, ks.nlcgrids, ks.xc+'__'+ks.nlc, dm,
-                                       hermi=hermi, max_memory=max_memory)
+        logger.debug(ks, 'nelec by numeric integration = %s', n)
+        if ks.nlc or ni.libxc.is_nlc(ks.xc):
+            if ni.libxc.is_nlc(ks.xc):
+                xc = ks.xc
+            else:
+                assert ni.libxc.is_nlc(ks.nlc)
+                xc = ks.nlc
+            n, enlc, vnlc = ni.nr_nlc_vxc(mol, ks.nlcgrids, xc, dm,
+                                          hermi=hermi, max_memory=max_memory)
             exc += enlc
             vxc += vnlc
-        logger.debug(ks, 'nelec by numeric integration = %s', n)
+            logger.debug(ks, 'nelec with nlc grids = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
 
     if not ni.libxc.is_hybrid_xc(ks.xc):
         vk = None
         if (ks._eri is None and ks.direct_scf and
             getattr(vhf_last, 'vj', None) is not None):
             ddm = numpy.asarray(dm) - numpy.asarray(dm_last)
```

### Comparing `pyscf-2.2.1/pyscf/dft/gks_symm.py` & `pyscf-2.3.0/pyscf/dft/gks_symm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/libxc.py` & `pyscf-2.3.0/pyscf/dft/libxc.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,14 +36,15 @@
 _itrf = lib.load_library('libxc_itrf')
 _itrf.LIBXC_is_lda.restype = ctypes.c_int
 _itrf.LIBXC_is_gga.restype = ctypes.c_int
 _itrf.LIBXC_is_meta_gga.restype = ctypes.c_int
 _itrf.LIBXC_needs_laplacian.restype = ctypes.c_int
 _itrf.LIBXC_needs_laplacian.argtypes = [ctypes.c_int]
 _itrf.LIBXC_is_hybrid.restype = ctypes.c_int
+_itrf.LIBXC_is_nlc.restype = ctypes.c_int
 _itrf.LIBXC_is_cam_rsh.restype = ctypes.c_int
 _itrf.LIBXC_max_deriv_order.restype = ctypes.c_int
 _itrf.LIBXC_number_of_functionals.restype = ctypes.c_int
 _itrf.LIBXC_functional_numbers.argtypes = (numpy.ctypeslib.ndpointer(dtype=numpy.intc, ndim=1, flags=("W", "C", "A")), )
 _itrf.LIBXC_functional_name.argtypes = [ctypes.c_int]
 _itrf.LIBXC_functional_name.restype = ctypes.c_char_p
 _itrf.LIBXC_hybrid_coeff.argtypes = [ctypes.c_int]
@@ -52,14 +53,17 @@
 _itrf.LIBXC_rsh_coeff.argtypes = [ctypes.c_int,ctypes.POINTER(ctypes.c_double)]
 
 _itrf.LIBXC_version.restype = ctypes.c_char_p
 _itrf.LIBXC_reference.restype = ctypes.c_char_p
 _itrf.LIBXC_reference_doi.restype = ctypes.c_char_p
 _itrf.LIBXC_xc_reference.argtypes = [ctypes.c_int, (ctypes.c_char_p * 8)]
 
+_itrf.xc_functional_get_number.argtypes = (ctypes.c_char_p, )
+_itrf.xc_functional_get_number.restype = ctypes.c_int
+
 def libxc_version():
     '''Returns the version of libxc'''
     return _itrf.LIBXC_version().decode("UTF-8")
 
 def libxc_reference():
     '''Returns the reference to libxc'''
     return _itrf.LIBXC_reference().decode("UTF-8")
@@ -424,14 +428,15 @@
         'HYB_GGA_XC_APF'               : 409, # A. Austin, G. A. Petersson, M. J. Frisch, F. J. Dobek, G. Scalmani, and K. Throssell, J. Chem. Theory Comput. 8, 4989 (2012)
         'HYB_GGA_XC_B1LYP'             : 416, # C. Adamo and V. Barone, Chem. Phys. Lett. 274, 242 (1997)
         'HYB_GGA_XC_B1PW91'            : 417, # C. Adamo and V. Barone, Chem. Phys. Lett. 274, 242 (1997)
         'HYB_GGA_XC_B1WC'              : 412, # D. I. Bilc, R. Orlando, R. Shaltaf, G.-M. Rignanese, J. Iniguez, and P. Ghosez, Phys. Rev. B 77, 165107 (2008)
         #'HYB_GGA_XC_B2PLYP'            : 713, # S. Grimme, J. Chem. Phys. 124, 034108 (2006)
         'HYB_GGA_XC_B3LYP'             : 402, # P. J. Stephens, F. J. Devlin, C. F. Chabalowski, and M. J. Frisch, J. Phys. Chem. 98, 11623 (1994)
         'HYB_GGA_XC_B3LYP5'            : 475, # P. J. Stephens, F. J. Devlin, C. F. Chabalowski, and M. J. Frisch, J. Phys. Chem. 98, 11623 (1994)
+        'HYB_GGA_XC_B3LYP3'            : 394,
         'HYB_GGA_XC_B3LYP_MCM1'        : 461, # M. T. Caldeira and R. Custodio, J. Mol. Model. 25, 62 (2019)
         'HYB_GGA_XC_B3LYP_MCM2'        : 462, # M. T. Caldeira and R. Custodio, J. Mol. Model. 25, 62 (2019)
         'HYB_GGA_XC_B3LYPS'            : 459, # M. Reiher, O. Salomon, and B. A. Hess, Theor. Chem. Acc. 107, 48 (2001)
         'HYB_GGA_XC_B3P86'             : 403, # Defined through Gaussian implementation
         #'HYB_GGA_XC_B3P86_NWCHEM'      : 315, # Defined through NWChem implementation
         'HYB_GGA_XC_B3PW91'            : 401, # A. D. Becke, J. Chem. Phys. 98, 5648 (1993)
         'HYB_GGA_XC_B5050LYP'          : 572, # Y. Shao, M. Head-Gordon, and A. I. Krylov, J. Chem. Phys. 118, 4807 (2003)
@@ -725,53 +730,58 @@
     'VWN3'          : 8,
     'VWNRPA'        : 8,
     'VWN5'          : 7,
     'B88'           : 106,
     'PBE0'          : 406,
     'PBE1PBE'       : 406,
     'OPTXCORR'      : '0.7344536875999693*SLATER - 0.6984752285760186*OPTX,',
-    'B3LYP'         : 'B3LYP5',  # VWN5 version
-    'B3LYP5'        : '.2*HF + .08*SLATER + .72*B88, .81*LYP + .19*VWN',
-    'B3LYPG'        : 402,  # VWN3, used by Gaussian
-    'B3P86'         : 'B3P865',  # VWN5 version
-    'B3P865'        : '.2*HF + .08*SLATER + .72*B88, .81*P86 + .19*VWN',
-    # FIXME: Check if Gaussian takes a different form for B3P86
-    #'B3P86G'        : 403,  # VWN3, used by Gaussian
-    'B3P86G'        : '.2*HF + .08*SLATER + .72*B88, .81*P86 + .19*VWN3',
-    'B3PW91'        : 'B3PW915',
-    'B3PW915'       : '.2*HF + .08*SLATER + .72*B88, .81*PW91 + .19*VWN',
-    #'B3PW91G'       : '.2*HF + .08*SLATER + .72*B88, .81*PW91 + .19*VWN3',
-    'B3PW91G'       : 401,
+    'B3LYP'         : 402,
+    'B3LYPG'        : 402,  # used by Gaussian
+    'B3LYP5'        : '.2*HF + .08*SLATER + .72*B88, .81*LYP + .19*VWN', # VWN5 version
+    'B3P86'         : 403,
+    'B3P86G'        : 403,  # used by Gaussian
+    'B3P86V5'       : '.2*HF + .08*SLATER + .72*B88, .81*P86 + .19*VWN', # VWN5 version
     #'O3LYP5'        : '.1161*HF + .9262*SLATER + .8133*OPTXCORR, .81*LYP + .19*VWN5',
-    #'O3LYPG'        : '.1161*HF + .9262*SLATER + .8133*OPTXCORR, .81*LYP + .19*VWN3',
+    #'O3LYPG'        : '.1161*HF + .9262*SLATER + .8133*OPTXCORR, .81*LYP + .19*VWNRPA',
     'O3LYP'         : 404, # in libxc == '.1161*HF + 0.071006917*SLATER + .8133*OPTX, .81*LYP + .19*VWN5', may be erroreous
     'MPW3PW'        : 'MPW3PW5',  # VWN5 version
     'MPW3PW5'       : '.2*HF + .08*SLATER + .72*MPW91, .81*PW91 + .19*VWN',
-    'MPW3PWG'       : 415,  # VWN3, used by Gaussian
+    'MPW3PWG'       : 415,  # used by Gaussian
     'MPW3LYP'       : 'MPW3LYP5',  # VWN5 version
     'MPW3LYP5'      : '.218*HF + .073*SLATER + .709*MPW91, .871*LYP + .129*VWN',
-    'MPW3LYPG'      : 419,  # VWN3, used by Gaussian
+    'MPW3LYPG'      : 419,  # used by Gaussian
     'REVB3LYP'      : 'REVB3LYP5',  # VWN5 version
     'REVB3LYP5'     : '.2*HF + .13*SLATER + .67*B88, .84*LYP + .16*VWN',
-    'REVB3LYPG'     : 454,  # VWN3, used by Gaussian
-    'X3LYP'         : 'X3LYP5',  # VWN5 version
+    'REVB3LYPG'     : 454,  # used by Gaussian
+    'X3LYP'         : 411,
+    'X3LYPG'        : 411,  # used by Gaussian
     'X3LYP5'        : '.218*HF + .073*SLATER + .542385*B88 + .166615*PW91, .871*LYP + .129*VWN',
-    'X3LYPG'        : 411,  # VWN3, used by Gaussian
     'CAMB3LYP'      : 'HYB_GGA_XC_CAM_B3LYP',
     'CAMYBLYP'      : 'HYB_GGA_XC_CAMY_BLYP',
     'CAMYB3LYP'     : 'HYB_GGA_XC_CAMY_B3LYP',
     'B5050LYP'      : '.5*HF + .08*SLATER + .42*B88, .81*LYP + .19*VWN',
     'MPW1LYP'       : '.25*HF + .75*MPW91, LYP',
     'MPW1PBE'       : '.25*HF + .75*MPW91, PBE',
     'PBE50'         : '.5*HF + .5*PBE, PBE',
     'REVPBE0'       : '.25*HF + .75*PBE_R, PBE',
     'B1B95'         : 440,
     'TPSS0'         : '.25*HF + .75*TPSS, TPSS',
 })  # noqa: E501
 
+# Issue 1480
+if not hasattr(__config__, 'B3LYP_WITH_VWN5'):
+    warnings.warn('Since PySCF-2.3, B3LYP (and B3P86) are changed to the VWN-RPA variant, '
+                  'the same to the B3LYP functional in Gaussian and ORCA (issue 1480). '
+                  'To restore the VWN5 definition, you can put the setting '
+                  '"B3LYP_WITH_VWN5 = True" in pyscf_conf.py')
+elif getattr(__config__, 'B3LYP_WITH_VWN5', False):
+    XC_CODES['B3P86' ] = 'B3P86V5'
+    XC_CODES['B3LYP' ] = 'B3LYP5'
+    XC_CODES['X3LYP' ] = 'X3LYP5'
+
 XC_KEYS = set(XC_CODES.keys())
 
 # Some XC functionals have conventional name, like M06-L means M06-L for X
 # functional and M06-L for C functional, PBE mean PBE-X plus PBE-C. If the
 # conventional name was placed in the XC_CODES, it may lead to recursive
 # reference when parsing the xc description.  These names (as exceptions of
 # XC_CODES) are listed in XC_ALIAS below and they should be treated as a
@@ -848,19 +858,14 @@
     'MN12SX'            : 'MN12_SX',
     'M052X'             : 'M05_2X',
     'M062X'             : 'M06_2X',
 }  # noqa: E122
 XC_ALIAS.update([(key.replace('-',''), XC_ALIAS[key])
                  for key in XC_ALIAS if '-' in key])
 
-VV10_XC = set(('B97M_V', 'WB97M_V', 'WB97X_V', 'VV10', 'LC_VV10',
-               'REVSCAN_VV10',
-               'SCAN_VV10', 'SCAN_RVV10', 'SCANL_VV10', 'SCANL_RVV10'))
-VV10_XC = VV10_XC.union(set([x.replace('_', '') for x in VV10_XC]))
-
 def xc_reference(xc_code):
     '''Returns the reference to the individual XC functional'''
     hyb, fn_facs = parse_xc(xc_code)
     refs = []
     c_refs = (ctypes.c_char_p * 8)()
     for xid, fac in fn_facs:
         _itrf.LIBXC_xc_reference(xid, c_refs)
@@ -870,19 +875,21 @@
     return refs
 
 @lru_cache(100)
 def xc_type(xc_code):
     if xc_code is None:
         return None
     elif isinstance(xc_code, str):
-        if is_nlc(xc_code):
-            return 'NLC'
+        if '__VV10' in xc_code:
+            raise RuntimeError('Deprecated notation for NLC functional.')
         hyb, fn_facs = parse_xc(xc_code)
     else:
+        assert isinstance(xc_code, int)
         fn_facs = [(xc_code, 1)]  # mimic fn_facs
+
     if not fn_facs:
         return 'HF'
     elif all(_itrf.LIBXC_is_lda(ctypes.c_int(xid)) for xid, fac in fn_facs):
         return 'LDA'
     elif any(_itrf.LIBXC_is_meta_gga(ctypes.c_int(xid)) for xid, fac in fn_facs):
         return 'MGGA'
     else:
@@ -915,20 +922,30 @@
 
 def is_meta_gga(xc_code):
     return xc_type(xc_code) == 'MGGA'
 
 def is_gga(xc_code):
     return xc_type(xc_code) == 'GGA'
 
+@lru_cache(100)
+def is_nlc(xc_code):
+    if isinstance(xc_code, str):
+        if xc_code.isdigit():
+            return _itrf.LIBXC_is_nlc(ctypes.c_int(int(xc_code)))
+        else:
+            fn_facs = parse_xc(xc_code)[1]
+            return any(_itrf.LIBXC_is_nlc(ctypes.c_int(xid)) for xid, fac in fn_facs)
+    elif isinstance(xc_code, int):
+        return _itrf.LIBXC_is_nlc(ctypes.c_int(xc_code))
+    else:
+        return any((is_nlc(x) for x in xc_code))
+
 def needs_laplacian(xc_code):
     return _itrf.LIBXC_needs_laplacian(xc_code) != 0
 
-def is_nlc(xc_code):
-    return '__VV10' in xc_code.upper()
-
 def max_deriv_order(xc_code):
     hyb, fn_facs = parse_xc(xc_code)
     if fn_facs:
         return min(_itrf.LIBXC_max_deriv_order(ctypes.c_int(xid)) for xid, fac in fn_facs)
     else:
         return 3
 
@@ -962,36 +979,21 @@
     hybs = [fac * _itrf.LIBXC_hybrid_coeff(ctypes.c_int(xid)) for xid, fac in fn_facs]
     return hyb[0] + sum(hybs)
 
 @lru_cache(100)
 def nlc_coeff(xc_code):
     '''Get NLC coefficients
     '''
-    nlc_code = None
-    if isinstance(xc_code, str) and '__VV10' in xc_code.upper():
-        xc_code, nlc_code = xc_code.upper().split('__', 1)
-
     hyb, fn_facs = parse_xc(xc_code)
-    nlc_pars = [0, 0]
+    nlc_pars = []
     nlc_tmp = (ctypes.c_double*2)()
     for xid, fac in fn_facs:
-        _itrf.LIBXC_nlc_coeff(xid, nlc_tmp)
-        nlc_pars[0] += nlc_tmp[0]
-        nlc_pars[1] += nlc_tmp[1]
-
-    if nlc_pars[0] == 0 and nlc_pars[1] == 0:
-        if nlc_code is not None:
-            # Use VV10 NLC parameters by default for the general case
-            _itrf.LIBXC_nlc_coeff(XC_CODES['GGA_XC_' + nlc_code], nlc_tmp)
-            nlc_pars[0] += nlc_tmp[0]
-            nlc_pars[1] += nlc_tmp[1]
-        else:
-            raise NotImplementedError(
-                '%s does not have NLC part. Available functionals are %s' %
-                (xc_code, ', '.join(VV10_XC.keys())))
+        if _itrf.LIBXC_is_nlc(ctypes.c_int(xid)):
+            _itrf.LIBXC_nlc_coeff(xid, nlc_tmp)
+            nlc_pars.append((tuple(nlc_tmp), fac))
     return tuple(nlc_pars)
 
 @lru_cache(100)
 def rsh_coeff(xc_code):
     '''Range-separated parameter and HF exchange components: omega, alpha, beta
 
     Exc_RSH = c_LR * LR_HFX + c_SR * SR_HFX + (1-c_SR) * Ex_SR + (1-c_LR) * Ex_LR + Ec
@@ -1169,15 +1171,19 @@
                                              'specific functional (e.g. X_%s, '
                                              'HYB_MGGA_X_%s)\n'
                                              % (key, key, key))
                         else:
                             x_id = possible_xc.pop()
                         x_id = XC_CODES[x_id]
                     else:
-                        raise KeyError('Unknown %s functional  %s' % (ftype, key))
+                        # Some libxc functionals may not be listed in the
+                        # XC_CODES table. Query libxc directly
+                        func_id = _itrf.xc_functional_get_number(ctypes.c_char_p(key.encode()))
+                        if func_id == -1:
+                            raise KeyError(f"LibXCFunctional: name '{key}' not found.")
                 if isinstance(x_id, str):
                     hyb1, fn_facs1 = parse_xc(x_id)
                     # Recursively scale the composed functional, to support e.g. '0.5*b3lyp'
                     if hyb1[0] != 0 or hyb1[1] != 0:
                         assign_omega(hyb1[2], hyb1[0]*fac, hyb1[1]*fac)
                     fn_facs.extend([(xid, c*fac) for xid, c in fn_facs1])
                 elif x_id is None:
@@ -1186,15 +1192,15 @@
                     fn_facs.append((x_id, fac))
     def possible_x_for(key):
         return set((key,
                     'LDA_X_'+key, 'GGA_X_'+key, 'MGGA_X_'+key,
                     'HYB_GGA_X_'+key, 'HYB_MGGA_X_'+key))
     def possible_xc_for(key):
         return set((key, 'LDA_XC_'+key, 'GGA_XC_'+key, 'MGGA_XC_'+key,
-                    'HYB_GGA_XC_'+key, 'HYB_MGGA_XC_'+key))
+                    'HYB_LDA_XC_'+key, 'HYB_GGA_XC_'+key, 'HYB_MGGA_XC_'+key))
     def possible_k_for(key):
         return set((key,
                     'LDA_K_'+key, 'GGA_K_'+key,))
     def possible_x_k_for(key):
         return possible_x_for(key).union(possible_k_for(key))
     def possible_c_for(key):
         return set((key,
```

### Comparing `pyscf-2.2.1/pyscf/dft/numint.py` & `pyscf-2.3.0/pyscf/dft/numint.py`

 * *Files 2% similar despite different names*

```diff
@@ -153,18 +153,15 @@
     >>> coords = numpy.random.random((100,3))  # 100 random points
     >>> ao_value = eval_ao(mol, coords, deriv=0)
     >>> dm = numpy.random.random((mol.nao_nr(),mol.nao_nr()))
     >>> dm = dm + dm.T
     >>> rho, dx_rho, dy_rho, dz_rho = eval_rho(mol, ao, dm, xctype='LDA')
     '''
     xctype = xctype.upper()
-    if xctype == 'LDA' or xctype == 'HF':
-        ngrids, nao = ao.shape
-    else:
-        ngrids, nao = ao[0].shape
+    ngrids, nao = ao.shape[-2:]
 
     shls_slice = (0, mol.nbas)
     ao_loc = mol.ao_loc_nr()
     if xctype == 'LDA' or xctype == 'HF':
         c0 = _dot_ao_dm(mol, ao, dm, non0tab, shls_slice, ao_loc)
         #:rho = numpy.einsum('pi,pi->p', ao, c0)
         rho = _contract_rho(ao, c0)
@@ -269,18 +266,15 @@
     '''
     if not (dm.dtype == ao.dtype == numpy.double):
         lib.logger.warn(mol, 'eval_rho1 does not support complex density, '
                         'eval_rho is called instead')
         return eval_rho(mol, ao, dm, screen_index, xctype, hermi, with_lapl, verbose)
 
     xctype = xctype.upper()
-    if xctype == 'LDA' or xctype == 'HF':
-        ngrids = ao.shape[0]
-    else:
-        ngrids = ao.shape[1]
+    ngrids = ao.shape[-2]
 
     if cutoff is None:
         cutoff = CUTOFF
     cutoff = min(cutoff, .1)
     nbins = NBINS * 2 - int(NBINS * numpy.log(cutoff) / numpy.log(ao_cutoff))
 
     if pair_mask is None:
@@ -365,18 +359,15 @@
         1D array of size N to store electron density if xctype = LDA;  2D array
         of (4,N) to store density and "density derivatives" for x,y,z components
         if xctype = GGA; For meta-GGA, returns can be a (6,N) (with_lapl=True)
         array where last two rows are \nabla^2 rho and tau = 1/2(\nabla f)^2
         or (5,N) (with_lapl=False) where the last row is tau = 1/2(\nabla f)^2
     '''
     xctype = xctype.upper()
-    if xctype == 'LDA' or xctype == 'HF':
-        ngrids, nao = ao.shape
-    else:
-        ngrids, nao = ao[0].shape
+    ngrids, nao = ao.shape[-2:]
 
     shls_slice = (0, mol.nbas)
     ao_loc = mol.ao_loc_nr()
     pos = mo_occ > OCCDROP
     if numpy.any(pos):
         cpos = numpy.einsum('ij,j->ij', mo_coeff[:,pos], numpy.sqrt(mo_occ[pos]))
         if xctype == 'LDA' or xctype == 'HF':
@@ -604,18 +595,15 @@
             is computed with the spin non-degenerated UKS formula.
 
     Returns:
         XC potential matrix in 2D array of shape (nao,nao) where nao is the
         number of AO functions.
     '''
     xctype = xctype.upper()
-    if xctype == 'LDA' or xctype == 'HF':
-        ngrids, nao = ao.shape
-    else:
-        ngrids, nao = ao[0].shape
+    ngrids, nao = ao.shape[-2:]
 
     if non0tab is None:
         non0tab = numpy.ones(((ngrids+BLKSIZE-1)//BLKSIZE,mol.nbas),
                              dtype=numpy.uint8)
     shls_slice = (0, mol.nbas)
     ao_loc = mol.ao_loc_nr()
     transpose_for_uks = False
@@ -1076,15 +1064,15 @@
 
     for ao, mask, weight, coords in ni.block_loop(mol, grids, nao, ao_deriv,
                                                   max_memory=max_memory):
         vxc = numpy.zeros(weight.size)
         # Form potential
         for ia, z in enumerate(atom_charges):
             rnuc = numpy.linalg.norm(atom_coords[ia] - coords, axis=1)
-            Zeff = sap_effective_charge(atom_charges[ia], rnuc)
+            Zeff = sap_effective_charge(z, rnuc)
             vxc -= Zeff/rnuc
 
         aow = _scale_ao(ao, weight*vxc, out=aow)
         vmat += _dot_ao_ao(mol, ao, aow, mask, shls_slice, ao_loc)
         vxc = None
 
     return vmat
@@ -1170,44 +1158,14 @@
         for i, ao, mask, wv in block_loop(ao_deriv):
             wv[0] *= .5  # *.5 because vmat + vmat.T at the end
             aow = _scale_ao_sparse(ao[:4], wv[:4], mask, ao_loc, out=aow)
             _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
                               hermi=0, out=vmat[i])
         vmat = lib.hermi_sum(vmat, axes=(0,2,1))
 
-    elif xctype == 'NLC':
-        nlc_pars = ni.nlc_coeff(xc_code)
-        ao_deriv = 1
-        vvrho = []
-        for ao, mask, weight, coords \
-                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory=max_memory):
-            vvrho.append([make_rho(idm, ao, mask, 'GGA') for idm in range(nset)])
-
-        vv_vxc = []
-        for i in range(nset):
-            rho = numpy.hstack([r[i] for r in vvrho])
-            exc, vxc = _vv10nlc(rho, grids.coords, rho, grids.weights,
-                                grids.coords, nlc_pars)
-            den = rho[0] * grids.weights
-            nelec[i] = den.sum()
-            excsum[i] = numpy.dot(den, exc)
-            vv_vxc.append(xc_deriv.transform_vxc(rho, vxc, 'GGA', spin=0))
-
-        p1 = 0
-        for ao, mask, weight, coords \
-                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory=max_memory):
-            p0, p1 = p1, p1 + weight.size
-            for i in range(nset):
-                wv = vv_vxc[i][:,p0:p1] * weight
-                wv[0] *= .5  # *.5 because vmat + vmat.T at the end
-                aow = _scale_ao_sparse(ao[:4], wv[:4], mask, ao_loc, out=aow)
-                _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
-                                  hermi=0, out=vmat[i])
-        vmat = lib.hermi_sum(vmat, axes=(0,2,1))
-
     elif xctype == 'MGGA':
         if (any(x in xc_code.upper() for x in ('CC06', 'CS', 'BR89', 'MK00'))):
             raise NotImplementedError('laplacian in meta-GGA method')
         ao_deriv = 1
         v1 = numpy.zeros_like(vmat)
         for i, ao, mask, wv in block_loop(ao_deriv):
             wv[0] *= .5  # *.5 for v+v.conj().T
@@ -1275,20 +1233,14 @@
     >>> grids.weights = numpy.random.random(100)
     >>> nao = mol.nao_nr()
     >>> dm = numpy.random.random((2,nao,nao))
     >>> ni = dft.numint.NumInt()
     >>> nelec, exc, vxc = ni.nr_uks(mol, grids, 'lda,vwn', dm)
     '''
     xctype = ni._xc_type(xc_code)
-    if xctype == 'NLC':
-        dms_sf = dms[0] + dms[1]
-        nelec, excsum, vmat = nr_rks(ni, mol, grids, xc_code, dms_sf, relativity, hermi,
-                                     max_memory, verbose)
-        return [nelec,nelec], excsum, numpy.asarray([vmat,vmat])
-
     ao_loc = mol.ao_loc_nr()
     cutoff = grids.cutoff * 1e2
     nbins = NBINS * 2 - int(NBINS * numpy.log(cutoff) / numpy.log(grids.cutoff))
 
     dma, dmb = _format_uks_dm(dms)
     nao = dma.shape[-1]
     make_rhoa, nset = ni._gen_rho_evaluator(mol, dma, hermi, False, grids)[:2]
@@ -1394,14 +1346,85 @@
             dma = lib.tag_array(dma, mo_coeff=mo_coeff[0], mo_occ=mo_occ[0])
             dmb = lib.tag_array(dmb, mo_coeff=mo_coeff[1], mo_occ=mo_occ[1])
     return dma, dmb
 
 nr_rks_vxc = nr_rks
 nr_uks_vxc = nr_uks
 
+def nr_nlc_vxc(ni, mol, grids, xc_code, dm, relativity=0, hermi=1,
+               max_memory=2000, verbose=None):
+    '''Calculate NLC functional and potential matrix on given grids
+
+    Args:
+        ni : an instance of :class:`NumInt`
+
+        mol : an instance of :class:`Mole`
+
+        grids : an instance of :class:`Grids`
+            grids.coords and grids.weights are needed for coordinates and weights of meshgrids.
+        xc_code : str
+            XC functional description.
+            See :func:`parse_xc` of pyscf/dft/libxc.py for more details.
+        dm : 2D array
+            Density matrix or multiple density matrices
+
+    Kwargs:
+        hermi : int
+            Input density matrices symmetric or not. It also indicates whether
+            the potential matrices in return are symmetric or not.
+        max_memory : int or float
+            The maximum size of cache to use (in MB).
+
+    Returns:
+        nelec, excsum, vmat.
+        nelec is the number of electrons generated by numerical integration.
+        excsum is the XC functional value.  vmat is the XC potential matrix in
+        2D array of shape (nao,nao) where nao is the number of AO functions.
+    '''
+    make_rho, nset, nao = ni._gen_rho_evaluator(mol, dm, hermi, False, grids)
+    assert nset == 1
+    ao_loc = mol.ao_loc_nr()
+    cutoff = grids.cutoff * 1e2
+    nbins = NBINS * 2 - int(NBINS * numpy.log(cutoff) / numpy.log(grids.cutoff))
+
+    ao_deriv = 1
+    vvrho = []
+    for ao, mask, weight, coords \
+            in ni.block_loop(mol, grids, nao, ao_deriv, max_memory=max_memory):
+        vvrho.append(make_rho(0, ao, mask, 'GGA'))
+    rho = numpy.hstack(vvrho)
+
+    exc = 0
+    vxc = 0
+    nlc_coefs = ni.nlc_coeff(xc_code)
+    for nlc_pars, fac in nlc_coefs:
+        e, v = _vv10nlc(rho, grids.coords, rho, grids.weights,
+                        grids.coords, nlc_pars)
+        exc += e * fac
+        vxc += v * fac
+    den = rho[0] * grids.weights
+    nelec = den.sum()
+    excsum = numpy.dot(den, exc)
+    vv_vxc = xc_deriv.transform_vxc(rho, vxc, 'GGA', spin=0)
+
+    pair_mask = mol.get_overlap_cond() < -numpy.log(ni.cutoff)
+    aow = None
+    vmat = numpy.zeros((nao,nao))
+    p1 = 0
+    for ao, mask, weight, coords \
+            in ni.block_loop(mol, grids, nao, ao_deriv, max_memory=max_memory):
+        p0, p1 = p1, p1 + weight.size
+        wv = vv_vxc[:,p0:p1] * weight
+        wv[0] *= .5
+        aow = _scale_ao_sparse(ao[:4], wv[:4], mask, ao_loc, out=aow)
+        _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
+                          hermi=0, out=vmat)
+    vmat = vmat + vmat.T
+    return nelec, excsum, vmat
+
 def nr_rks_fxc(ni, mol, grids, xc_code, dm0, dms, relativity=0, hermi=0,
                rho0=None, vxc=None, fxc=None, max_memory=2000, verbose=None):
     '''Contract RKS XC (singlet hessian) kernel matrix with given density matrices
 
     Args:
         ni : an instance of :class:`NumInt`
 
@@ -1473,15 +1496,15 @@
                 _fxc = fxc[:,:,p0:p1]
 
             for i in range(nset):
                 rho1 = make_rho1(i, ao, mask, xctype)
                 if xctype == 'LDA':
                     wv = weight * rho1 * _fxc[0]
                 else:
-                    wv = numpy.einsum('xg,xyg,g->yg', rho1, _fxc, weight)
+                    wv = numpy.einsum('yg,xyg,g->xg', rho1, _fxc, weight)
                 yield i, ao, mask, wv
 
     ao_loc = mol.ao_loc_nr()
     cutoff = grids.cutoff * 1e2
     nbins = NBINS * 2 - int(NBINS * numpy.log(cutoff) / numpy.log(grids.cutoff))
     pair_mask = mol.get_overlap_cond() < -numpy.log(ni.cutoff)
     vmat = numpy.zeros((nset,nao,nao))
@@ -1500,17 +1523,14 @@
             _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
                               hermi=0, out=vmat[i])
 
         # For real orbitals, K_{ia,bj} = K_{ia,jb}. It simplifies real fxc_jb
         # [(\nabla mu) nu + mu (\nabla nu)] * fxc_jb = ((\nabla mu) nu f_jb) + h.c.
         vmat = lib.hermi_sum(vmat, axes=(0,2,1))
 
-    elif xctype == 'NLC':
-        raise NotImplementedError('NLC')
-
     elif xctype == 'MGGA':
         assert not MGGA_DENSITY_LAPL
         ao_deriv = 2 if MGGA_DENSITY_LAPL else 1
         v1 = numpy.zeros_like(vmat)
         for i, ao, mask, wv in block_loop(ao_deriv):
             wv[0] *= .5  # *.5 for v+v.conj().T
             wv[4] *= .5  # *.5 for 1/2 in tau
@@ -1533,16 +1553,14 @@
     Note the difference to nr_rks_fxc, dms_alpha is the response density
     matrices of alpha spin, alpha+/-beta DM is applied due to singlet/triplet
     coupling
 
     Ref. CPL, 256, 454
     '''
     if fxc is None:
-        if dm0.ndim == 2:
-            dm0 = [dm0*.5] * 2
         fxc = ni.cache_xc_kernel1(mol, grids, xc_code, dm0, spin=1,
                                   max_memory=max_memory)[2]
     if singlet:
         fxc = fxc[0,:,0] + fxc[0,:,1]
     else:
         fxc = fxc[0,:,0] - fxc[0,:,1]
     return ni.nr_rks_fxc(mol, grids, xc_code, dm0, dms_alpha, hermi=0, fxc=fxc,
@@ -1804,17 +1822,14 @@
             _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
                               hermi=0, out=vmat[1,i])
 
         # For real orbitals, K_{ia,bj} = K_{ia,jb}. It simplifies real fxc_jb
         # [(\nabla mu) nu + mu (\nabla nu)] * fxc_jb = ((\nabla mu) nu f_jb) + h.c.
         vmat = lib.hermi_sum(vmat.reshape(-1,nao,nao), axes=(0,2,1)).reshape(2,nset,nao,nao)
 
-    elif xctype == 'NLC':
-        raise NotImplementedError('NLC')
-
     elif xctype == 'MGGA':
         assert not MGGA_DENSITY_LAPL
         ao_deriv = 1
         v1 = numpy.zeros_like(vmat)
         for i, ao, mask, wv in block_loop(ao_deriv):
             wv[:,0] *= .5
             wv[:,4] *= .5
@@ -2561,27 +2576,30 @@
     DFT hessian module etc.
     '''
     xctype = ni._xc_type(xc_code)
     if xctype == 'GGA':
         ao_deriv = 1
     elif xctype == 'MGGA':
         ao_deriv = 2 if MGGA_DENSITY_LAPL else 1
-    elif xctype == 'NLC':
-        raise NotImplementedError('NLC')
     else:
         ao_deriv = 0
 
-    if spin == 0:
+    if mo_coeff[0].ndim == 1:  # RKS
         nao = mo_coeff.shape[0]
         rho = []
         for ao, mask, weight, coords \
                 in ni.block_loop(mol, grids, nao, ao_deriv, max_memory=max_memory):
             rho.append(ni.eval_rho2(mol, ao, mo_coeff, mo_occ, mask, xctype))
         rho = numpy.hstack(rho)
-    else:
+        if spin == 1:  # RKS with nr_rks_fxc_st
+            rho *= .5
+            rho = numpy.repeat(rho[numpy.newaxis], 2, axis=0)
+    else:  # UKS
+        assert mo_coeff[0].ndim == 2
+        assert spin == 1
         nao = mo_coeff[0].shape[0]
         rhoa = []
         rhob = []
         for ao, mask, weight, coords \
                 in ni.block_loop(mol, grids, nao, ao_deriv, max_memory=max_memory):
             rhoa.append(ni.eval_rho2(mol, ao, mo_coeff[0], mo_occ[0], mask, xctype))
             rhob.append(ni.eval_rho2(mol, ao, mo_coeff[1], mo_occ[1], mask, xctype))
@@ -2594,27 +2612,30 @@
     DFT hessian module etc.
     '''
     xctype = ni._xc_type(xc_code)
     if xctype == 'GGA':
         ao_deriv = 1
     elif xctype == 'MGGA':
         ao_deriv = 2 if MGGA_DENSITY_LAPL else 1
-    elif xctype == 'NLC':
-        raise NotImplementedError('NLC')
     else:
         ao_deriv = 0
 
     make_rho, nset, nao = ni._gen_rho_evaluator(mol, dm, hermi=1)
-    if spin == 0:
+    if dm[0].ndim == 1:  # RKS
         rho = []
         for ao, mask, weight, coords \
                 in ni.block_loop(mol, grids, nao, ao_deriv, max_memory=max_memory):
             rho.append(make_rho(0, ao, mask, xctype))
         rho = numpy.hstack(rho)
-    else:
+        if spin == 1:  # RKS with nr_rks_fxc_st
+            rho *= .5
+            rho = numpy.repeat(rho[numpy.newaxis], 2, axis=0)
+    else:  # UKS
+        assert dm[0].ndim == 2
+        assert spin == 1
         rhoa = []
         rhob = []
         for ao, mask, weight, coords \
                 in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
             rhoa.append(make_rho(0, ao, mask, xctype))
             rhob.append(make_rho(1, ao, mask, xctype))
         rho = (numpy.hstack(rhoa), numpy.hstack(rhob))
@@ -2819,14 +2840,15 @@
         else:
             return self.nr_uks_fxc(mol, grids, xc_code, dm0, dms, relativity,
                                    hermi, rho0, vxc, fxc, max_memory, verbose)
     get_fxc = nr_fxc
 
     nr_rks = nr_rks
     nr_uks = nr_uks
+    nr_nlc_vxc = nr_nlc_vxc
     nr_sap = nr_sap_vxc = nr_sap_vxc
     nr_rks_fxc = nr_rks_fxc
     nr_uks_fxc = nr_uks_fxc
     nr_rks_fxc_st = nr_rks_fxc_st
     cache_xc_kernel  = cache_xc_kernel
     cache_xc_kernel1 = cache_xc_kernel1
```

### Comparing `pyscf-2.2.1/pyscf/dft/numint2c.py` & `pyscf-2.3.0/pyscf/dft/numint2c.py`

 * *Files 2% similar despite different names*

```diff
@@ -649,14 +649,30 @@
                                   hermi, max_memory, verbose)
             vmat = np.zeros_like(dms)
             vmat[...,:nao,:nao] = v[0]
             vmat[...,nao:,nao:] = v[1]
         return n, exc, vmat
     get_vxc = nr_gks_vxc = nr_vxc
 
+    @lib.with_doc(numint.nr_nlc_vxc.__doc__)
+    def nr_nlc_vxc(self, mol, grids, xc_code, dm, spin=0, relativity=0, hermi=1,
+                   max_memory=2000, verbose=None):
+        assert dm.ndim == 2
+        nao = dm.shape[-1] // 2
+        # ground state density is always real
+        dm_a = dm[:nao,:nao].real
+        dm_b = dm[nao:,nao:].real
+        ni = self._to_numint1c()
+        n, exc, v = ni.nr_nlc_vxc(mol, grids, xc_code, dm_a+dm_b, relativity,
+                                  hermi, max_memory, verbose)
+        vmat = np.zeros_like(dm)
+        vmat[:nao,:nao] = v[0]
+        vmat[nao:,nao:] = v[1]
+        return n, exc, vmat
+
     @lib.with_doc(numint.nr_rks_fxc.__doc__)
     def nr_fxc(self, mol, grids, xc_code, dm0, dms, spin=0, relativity=0, hermi=0,
                rho0=None, vxc=None, fxc=None, max_memory=2000, verbose=None):
         if self.collinear[0] not in ('c', 'm'):  # col or mcol
             raise NotImplementedError('non-collinear fxc')
 
         if self.collinear[0] == 'm':  # mcol
```

### Comparing `pyscf-2.2.1/pyscf/dft/r_numint.py` & `pyscf-2.3.0/pyscf/dft/r_numint.py`

 * *Files 1% similar despite different names*

```diff
@@ -112,15 +112,15 @@
 
     if non0tab is None:
         non0tab = numpy.ones(((ngrids+BLKSIZE-1)//BLKSIZE,mol.nbas),
                              dtype=numpy.uint8)
     shls_slice = (0, mol.nbas)
     ao_loc = mol.ao_loc_2c()
 
-    if xctype == 'LDA':
+    if xctype == 'LDA' or xctype == 'HF':
         c0 = _dot_spinor_dm(mol, ao, dm, non0tab, shls_slice, ao_loc)
         rho_m = _contract_rho_m(ao, c0, hermi, True)
     elif xctype == 'GGA':
         # first 4 ~ (rho, m), second 4 ~ (0th order, dx, dy, dz)
         if hermi:
             rho_m = numpy.empty((4, 4, ngrids))
         else:
```

### Comparing `pyscf-2.2.1/pyscf/dft/radi.py` & `pyscf-2.3.0/pyscf/dft/radi.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/rks.py` & `pyscf-2.3.0/pyscf/dft/rks.py`

 * *Files 2% similar despite different names*

```diff
@@ -74,21 +74,26 @@
 
     ni = ks._numint
     if hermi == 2:  # because rho = 0
         n, exc, vxc = 0, 0, 0
     else:
         max_memory = ks.max_memory - lib.current_memory()[0]
         n, exc, vxc = ni.nr_rks(mol, ks.grids, ks.xc, dm, max_memory=max_memory)
-        if ks.nlc:
-            assert 'VV10' in ks.nlc.upper()
-            _, enlc, vnlc = ni.nr_rks(mol, ks.nlcgrids, ks.xc+'__'+ks.nlc, dm,
-                                      max_memory=max_memory)
+        logger.debug(ks, 'nelec by numeric integration = %s', n)
+        if ks.nlc or ni.libxc.is_nlc(ks.xc):
+            if ni.libxc.is_nlc(ks.xc):
+                xc = ks.xc
+            else:
+                assert ni.libxc.is_nlc(ks.nlc)
+                xc = ks.nlc
+            n, enlc, vnlc = ni.nr_nlc_vxc(mol, ks.nlcgrids, xc, dm,
+                                          max_memory=max_memory)
             exc += enlc
             vxc += vnlc
-        logger.debug(ks, 'nelec by numeric integration = %s', n)
+            logger.debug(ks, 'nelec with nlc grids = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
 
     if not ni.libxc.is_hybrid_xc(ks.xc):
         vk = None
         if (ks._eri is None and ks.direct_scf and
             getattr(vhf_last, 'vj', None) is not None):
             ddm = numpy.asarray(dm) - numpy.asarray(dm_last)
@@ -252,29 +257,15 @@
 def define_xc_(ks, description, xctype='LDA', hyb=0, rsh=(0,0,0)):
     libxc = ks._numint.libxc
     ks._numint = libxc.define_xc_(ks._numint, description, xctype, hyb, rsh)
     return ks
 
 
 def _dft_common_init_(mf, xc='LDA,VWN'):
-    mf.xc = xc
-    mf.nlc = ''
-    mf.grids = gen_grid.Grids(mf.mol)
-    mf.grids.level = getattr(__config__, 'dft_rks_RKS_grids_level',
-                             mf.grids.level)
-    mf.nlcgrids = gen_grid.Grids(mf.mol)
-    mf.nlcgrids.level = getattr(__config__, 'dft_rks_RKS_nlcgrids_level',
-                                mf.nlcgrids.level)
-    # Use rho to filter grids
-    mf.small_rho_cutoff = getattr(__config__, 'dft_rks_RKS_small_rho_cutoff', 1e-7)
-##################################################
-# don't modify the following attributes, they are not input options
-    mf._numint = numint.NumInt()
-    mf._keys = mf._keys.union(['xc', 'nlc', 'omega', 'grids', 'nlcgrids',
-                               'small_rho_cutoff'])
+    raise DeprecationWarning
 
 class KohnShamDFT(object):
     '''
     Attributes for Kohn-Sham DFT:
         xc : str
             'X_name,C_name' for the XC functional.  Default is 'lda,vwn'
         nlc : str
@@ -325,15 +316,31 @@
     >>> mol = gto.M(atom='O 0 0 0; H 0 0 1; H 0 1 0', basis='ccpvdz', verbose=0)
     >>> mf = dft.RKS(mol)
     >>> mf.xc = 'b3lyp'
     >>> mf.kernel()
     -76.415443079840458
     '''
 
-    __init__ = _dft_common_init_
+    def __init__(self, xc='LDA,VWN'):
+        self.xc = xc
+        self.nlc = ''
+        self.grids = gen_grid.Grids(self.mol)
+        self.grids.level = getattr(
+            __config__, 'dft_rks_RKS_grids_level', self.grids.level)
+        self.nlcgrids = gen_grid.Grids(self.mol)
+        self.nlcgrids.level = getattr(
+            __config__, 'dft_rks_RKS_nlcgrids_level', self.nlcgrids.level)
+        # Use rho to filter grids
+        self.small_rho_cutoff = getattr(
+            __config__, 'dft_rks_RKS_small_rho_cutoff', 1e-7)
+##################################################
+# don't modify the following attributes, they are not input options
+        self._numint = numint.NumInt()
+        self._keys = self._keys.union([
+            'xc', 'nlc', 'omega', 'grids', 'nlcgrids', 'small_rho_cutoff'])
 
     @property
     def omega(self):
         return self._numint.omega
     @omega.setter
     def omega(self, v):
         self._numint.omega = float(v)
@@ -346,20 +353,22 @@
                  self._numint.libxc.__reference__)
 
         if log.verbose >= logger.INFO:
             log.info('XC functionals = %s', self.xc)
             if hasattr(self._numint.libxc, 'xc_reference'):
                 log.info(textwrap.indent('\n'.join(self._numint.libxc.xc_reference(self.xc)), '    '))
 
-        if self.nlc!='':
-            log.info('NLC functional = %s', self.nlc)
-
         self.grids.dump_flags(verbose)
-        if self.nlc!='':
-            log.info('** Following is NLC Grids **')
+
+        if self.nlc or self._numint.libxc.is_nlc(self.xc):
+            log.info('** Following is NLC and NLC Grids **')
+            if self.nlc:
+                log.info('NLC functional = %s', self.nlc)
+            else:
+                log.info('NLC functional = %s', self.xc)
             self.nlcgrids.dump_flags(verbose)
 
         log.info('small_rho_cutoff = %g', self.small_rho_cutoff)
         return self
 
     define_xc_ = define_xc_
 
@@ -474,25 +483,25 @@
                 # dm.ndim == 2 indicates ground state
                 isinstance(dm, numpy.ndarray) and dm.ndim == 2):
                 # Filter grids the first time setup grids
                 self.grids = prune_small_rho_grids_(self, self.mol, dm,
                                                     self.grids)
             t0 = logger.timer(self, 'setting up grids', *t0)
 
-        if self.nlc != '':
-            if self.nlcgrids.coords is None:
-                t0 = (logger.process_clock(), logger.perf_counter())
-                self.nlcgrids.build(with_non0tab=True)
-                if (self.small_rho_cutoff > 1e-20 and
-                    # dm.ndim == 2 indicates ground state
-                    isinstance(dm, numpy.ndarray) and dm.ndim == 2):
-                    # Filter grids the first time setup grids
-                    self.nlcgrids = prune_small_rho_grids_(self, self.mol, dm,
-                                                           self.nlcgrids)
-                t0 = logger.timer(self, 'setting up nlc grids', *t0)
+        is_nlc = self.nlc or self._numint.libxc.is_nlc(self.xc)
+        if is_nlc and self.nlcgrids.coords is None:
+            t0 = (logger.process_clock(), logger.perf_counter())
+            self.nlcgrids.build(with_non0tab=True)
+            if (self.small_rho_cutoff > 1e-20 and
+                # dm.ndim == 2 indicates ground state
+                isinstance(dm, numpy.ndarray) and dm.ndim == 2):
+                # Filter grids the first time setup grids
+                self.nlcgrids = prune_small_rho_grids_(self, self.mol, dm,
+                                                       self.nlcgrids)
+            t0 = logger.timer(self, 'setting up nlc grids', *t0)
         return self
 
 # Update the KohnShamDFT label in scf.hf module
 hf.KohnShamDFT = KohnShamDFT
 
 def _update_keys_(mf, src):
     src_keys = src.__dict__
```

### Comparing `pyscf-2.2.1/pyscf/dft/rks_symm.py` & `pyscf-2.3.0/pyscf/dft/rks_symm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/roks.py` & `pyscf-2.3.0/pyscf/dft/roks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/sap.py` & `pyscf-2.3.0/pyscf/dft/sap.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/sap_data.py` & `pyscf-2.3.0/pyscf/dft/sap_data.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/uks.py` & `pyscf-2.3.0/pyscf/dft/uks.py`

 * *Files 3% similar despite different names*

```diff
@@ -45,21 +45,26 @@
 
     ni = ks._numint
     if hermi == 2:  # because rho = 0
         n, exc, vxc = (0,0), 0, 0
     else:
         max_memory = ks.max_memory - lib.current_memory()[0]
         n, exc, vxc = ni.nr_uks(mol, ks.grids, ks.xc, dm, max_memory=max_memory)
-        if ks.nlc:
-            assert 'VV10' in ks.nlc.upper()
-            _, enlc, vnlc = ni.nr_rks(mol, ks.nlcgrids, ks.xc+'__'+ks.nlc, dm[0]+dm[1],
-                                      max_memory=max_memory)
+        logger.debug(ks, 'nelec by numeric integration = %s', n)
+        if ks.nlc or ni.libxc.is_nlc(ks.xc):
+            if ni.libxc.is_nlc(ks.xc):
+                xc = ks.xc
+            else:
+                assert ni.libxc.is_nlc(ks.nlc)
+                xc = ks.nlc
+            n, enlc, vnlc = ni.nr_nlc_vxc(mol, ks.nlcgrids, xc, dm[0]+dm[1],
+                                          max_memory=max_memory)
             exc += enlc
             vxc += vnlc
-        logger.debug(ks, 'nelec by numeric integration = %s', n)
+            logger.debug(ks, 'nelec with nlc grids = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
 
     if not ni.libxc.is_hybrid_xc(ks.xc):
         vk = None
         if (ks._eri is None and ks.direct_scf and
             getattr(vhf_last, 'vj', None) is not None):
             ddm = numpy.asarray(dm) - numpy.asarray(dm_last)
```

### Comparing `pyscf-2.2.1/pyscf/dft/uks_symm.py` & `pyscf-2.3.0/pyscf/dft/uks_symm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/xc/utils.py` & `pyscf-2.3.0/pyscf/dft/xc/utils.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/xc_deriv.py` & `pyscf-2.3.0/pyscf/dft/xc_deriv.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/dft/xcfun.py` & `pyscf-2.3.0/pyscf/dft/xcfun.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,14 +25,15 @@
 import copy
 import ctypes
 from functools import lru_cache
 import math
 import numpy
 from pyscf import lib
 from pyscf.dft.xc.utils import remove_dup, format_xc_code
+from pyscf import __config__
 
 _itrf = lib.load_library('libxcfun_itrf')
 
 _itrf.xcfun_splash.restype = ctypes.c_char_p
 _itrf.xcfun_version.restype = ctypes.c_char_p
 
 __version__ = _itrf.xcfun_version().decode("UTF-8")
@@ -141,42 +142,47 @@
 'KT1X'           : 'SLATERX - 0.006*KTX',  # Keal-Tozer 1, JCP, 119, 3015
 'KT2XC'         : '1.07173*SLATER - .006*KTX + 0.576727*VWN5',  # Keal-Tozer 2, JCP, 119, 3015
 'KT3XC'         : 'SLATERX*1.092 + KTX*-0.004 + OPTXCORR*-0.925452 + LYPC*0.864409',  # Keal-Tozer 3, JCP, 121, 5654
 # == '2.021452*SLATER - .004*KTX - .925452*OPTX + .864409*LYP',
 'PBE0'          : '.25*HF + .75*PBEX + PBEC',  # Perdew-Burke-Ernzerhof, JCP, 110, 6158
 'PBE1PBE'       : 'PBE0',
 'PBEH'          : 'PBE0',
-'B3P86'         : '.2*HF + .08*SLATER + .72*B88 + .81*P86C + .19*VWN5C',
+'B3P86'         : 'B3P86G',
 'B3P86G'        : '.2*HF + .08*SLATER + .72*B88 + .81*P86C + .19*VWN3C',
-'B3PW91'        : '.2*HF + .08*SLATER + .72*B88 + .81*PW91C + .19*VWN5C',
-'B3PW91G'       : '.2*HF + .08*SLATER + .72*B88 + .81*PW91C + .19*VWN3C',
-# Note, use VWN5 for B3LYP. It is different to the libxc default B3LYP
-'B3LYP'         : 'B3LYP5',
+'B3P86V5'       : '.2*HF + .08*SLATER + .72*B88 + .81*P86C + .19*VWN5C',
+'B3PW91'        : '.2*HF + .08*SLATER + .72*B88 + .81*PW91C + .19*PW92C',
+# Note, B3LYP uses VWN3 https://doi.org/10.1016/S0009-2614(97)00207-8.
+'B3LYP'         : 'B3LYPG',
 'B3LYP5'        : '.2*HF + .08*SLATER + .72*B88 + .81*LYP + .19*VWN5C',
 'B3LYPG'        : '.2*HF + .08*SLATER + .72*B88 + .81*LYP + .19*VWN3C', # B3LYP-VWN3 used by Gaussian and libxc
 #'O3LYP'         : '.1161*HF + .9262*SLATER + .8133*OPTXCORR + .81*LYP + .19*VWN5C',  # Mol. Phys. 99 607
 #'O3LYPG'        : '.1161*HF + .9262*SLATER + .8133*OPTXCORR + .81*LYP + .19*VWN3C',
 # libxc implementation as below, see also discussion in https://gitlab.com/libxc/libxc/issues/47
 #'O3LYP'         : '.1161*HF + .9262*SLATER + 1.164393477*OPTXCORR + .81*LYP + .19*VWN5C', #1.164393477 = .8133*1.43169
 #'O3LYPG'        : '.1161*HF + .9262*SLATER + 1.164393477*OPTXCORR + .81*LYP + .19*VWN3C',
 'O3LYP'         : '.1161*HF + 0.071006917*SLATER + .8133*OPTX, .81*LYP + .19*VWN5',  # libxc implementation
-'X3LYP'         : '.218*HF + .073*SLATER + 0.542385*B88 + .166615*PW91X + .871*LYP + .129*VWN5C',  # Xu, PNAS, 101, 2673
+'X3LYP'         : 'X3LYPG',
 'X3LYPG'        : '.218*HF + .073*SLATER + 0.542385*B88 + .166615*PW91X + .871*LYP + .129*VWN3C',
+'X3LYP5'        : '.218*HF + .073*SLATER + 0.542385*B88 + .166615*PW91X + .871*LYP + .129*VWN5C',  # Xu, PNAS, 101, 2673
 # Range-separated-hybrid functional: (alpha+beta)*SR_HF(0.33) + alpha*LR_HF(0.33)
 # Note default mu of xcfun is 0.4. It can cause discrepancy for CAMB3LYP
 'CAMB3LYP'      : '0.19*SR_HF(0.33) + 0.65*LR_HF(0.33) + 0.46*BECKESRX + 0.35*B88 + VWN5C*0.19 + LYPC*0.81',
 'CAM_B3LYP'     : 'CAMB3LYP',
 'LDAERF'        : 'LDAERFX + LDAERFC',  # Short-range exchange and correlation LDA functional
 'B97XC'         : 'B97X + B97C + HF*0.1943',
 'B97_1XC'       : 'B97_1X + B97_1C + HF*0.21',
 'B97_2XC'       : 'B97_2X + B97_2C + HF*0.21',
 'TPSSH'         : '0.1*HF + 0.9*TPSSX + TPSSC',
 'TF'            : 'TFK',
 }
 
+if getattr(__config__, 'B3LYP_WITH_VWN5', False):
+    XC_CODES['B3P86'] = 'B3P86V5'
+    XC_CODES['B3LYP'] = 'B3LYP5'
+
 # Some XC functionals have conventional name, like M06-L means M06-L for X
 # functional and M06-L for C functional, PBE mean PBE-X plus PBE-C. If the
 # conventional name was placed in the XC_CODES, it may lead to recursive
 # reference when parsing the xc description.  These names (as exceptions of
 # XC_CODES) are listed in XC_ALIAS below and they should be treated as a
 # shortcut for XC functional.
 XC_ALIAS = {
@@ -262,28 +268,27 @@
 VV10_XC.update([(key.replace('_', ''), val) for key, val in VV10_XC.items()])
 
 @lru_cache(100)
 def xc_type(xc_code):
     if xc_code is None:
         return None
     elif isinstance(xc_code, str):
-        if is_nlc(xc_code):
-            return 'NLC'
         hyb, fn_facs = parse_xc(xc_code)
     else:
         fn_facs = [(xc_code, 1)]  # mimic fn_facs
+
     if not fn_facs:
         return 'HF'
     elif all(_itrf.XCFUN_xc_type(ctypes.c_int(xid)) == 0 for xid, val in fn_facs):
         return 'LDA'
     elif any(_itrf.XCFUN_xc_type(ctypes.c_int(xid)) == 2 for xid, val in fn_facs):
         return 'MGGA'
     else:
         # all((xid in GGA_IDS or xid in LDA_IDS for xid, val in fn_fns)):
-        # include hybrid_xc
+        # include hybrid_xc and NLC
         return 'GGA'
 
 def is_lda(xc_code):
     return xc_type(xc_code) == 'LDA'
 
 def is_hybrid_xc(xc_code):
     if isinstance(xc_code, str):
@@ -297,35 +302,36 @@
 
 def is_meta_gga(xc_code):
     return xc_type(xc_code) == 'MGGA'
 
 def is_gga(xc_code):
     return xc_type(xc_code) == 'GGA'
 
+# Assign a temporary Id to VV10 functionals. parse_xc function needs them to
+# parse NLC functionals
+XC_CODES.update([(key, 5000+i) for i, key in enumerate(VV10_XC)])
+VV10_XC.update([(5000+i, VV10_XC[key]) for i, key in enumerate(VV10_XC)])
+
 def is_nlc(xc_code):
-    return '__VV10' in xc_code.upper()
+    fn_facs = parse_xc(xc_code)[1]
+    return any(xid >= 5000 for xid, c in fn_facs)
 
 def nlc_coeff(xc_code):
     '''Get NLC coefficients
     '''
     xc_code = xc_code.upper()
-
-    nlc_part = None
     if '__VV10' in xc_code:
-        xc_code, nlc_part = xc_code.split('__', 1)
+        raise RuntimeError('Deprecated notation for NLC functional.')
 
-    if xc_code in VV10_XC:
-        return VV10_XC[xc_code]
-    elif nlc_part is not None:
-        # Use VV10 NLC parameters by default for the general case
-        return VV10_XC[nlc_part]
-    else:
-        raise NotImplementedError(
-            '%s does not have NLC part. Available functionals are %s' %
-            (xc_code, ', '.join(VV10_XC.keys())))
+    fn_facs = parse_xc(xc_code)[1]
+    nlc_pars = []
+    for xid, fac in fn_facs:
+        if xid >= 5000:
+            nlc_pars.append((VV10_XC[xid], fac))
+    return tuple(nlc_pars)
 
 def rsh_coeff(xc_code):
     '''Get Range-separated-hybrid coefficients
     '''
     hyb, fn_facs = parse_xc(xc_code)
     hyb, alpha, omega = hyb
     beta = hyb - alpha
@@ -338,16 +344,14 @@
     support = deriv <= max_deriv_order(xc_code)
     if not support and raise_error:
         raise NotImplementedError('xcfun library does not support derivative '
                                   'order %d for  %s' % (deriv, xc_code))
     return support
 
 def hybrid_coeff(xc_code, spin=0):
-    if is_nlc(xc_code):
-        return 0
     hyb, fn_facs = parse_xc(xc_code)
     return hyb[0]
 
 def parse_xc_name(xc_name):
     fn_facs = parse_xc(xc_name)[1]
     return fn_facs[0][0], fn_facs[1][0]
```

### Comparing `pyscf-2.2.1/pyscf/eph/__init__.py` & `pyscf-2.3.0/pyscf/eph/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/eph/eph_fd.py` & `pyscf-2.3.0/pyscf/eph/eph_fd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/eph/rhf.py` & `pyscf-2.3.0/pyscf/eph/rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/eph/rks.py` & `pyscf-2.3.0/pyscf/eph/rks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/eph/uhf.py` & `pyscf-2.3.0/pyscf/eph/uhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/eph/uks.py` & `pyscf-2.3.0/pyscf/eph/uks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/fci/__init__.py` & `pyscf-2.3.0/pyscf/fci/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/fci/addons.py` & `pyscf-2.3.0/pyscf/fci/addons.py`

 * *Files 14% similar despite different names*

```diff
@@ -29,15 +29,16 @@
 
 def large_ci(ci, norb, nelec, tol=LARGE_CI_TOL, return_strs=RETURN_STRS):
     '''Search for the largest CI coefficients
     '''
     neleca, nelecb = _unpack_nelec(nelec)
     na = cistring.num_strings(norb, neleca)
     nb = cistring.num_strings(norb, nelecb)
-    assert (ci.shape == (na, nb))
+    assert ci.size == na * nb
+    ci = ci.reshape(na, nb)
     addra, addrb = numpy.where(abs(ci) > tol)
     if addra.size == 0:
         # No large CI coefficient > tol, search for the largest coefficient
         addra, addrb = numpy.unravel_index(numpy.argmax(abs(ci)), ci.shape)
         addra = numpy.asarray([addra])
         addrb = numpy.asarray([addrb])
     strsa = cistring.addrs2str(norb, neleca, addra)
@@ -79,124 +80,15 @@
             The irrep ID of target symmetry
         irrep_nelec : dict
             Freeze occupancy for certain irreps
 
     Returns:
         CI coefficients 2D array which has the target symmetry.
     '''
-    neleca, nelecb = _unpack_nelec(nelec)
-    orbsym = numpy.asarray(orbsym)
-    if not isinstance(orbsym[0], numpy.number):
-        raise RuntimeError('TODO: convert irrep symbol to irrep id')
-
-    na = cistring.num_strings(norb, neleca)
-    nb = cistring.num_strings(norb, nelecb)
-    ci1 = numpy.zeros((na,nb))
-
-########################
-# pass 1: The fixed occs
-    orbleft = numpy.ones(norb, dtype=bool)
-    stra = numpy.zeros(norb, dtype=bool)
-    strb = numpy.zeros(norb, dtype=bool)
-    if irrep_nelec is not None:
-        for k,n in irrep_nelec.items():
-            orbleft[orbsym==k] = False
-            if isinstance(n, (int, numpy.number)):
-                idx = numpy.where(orbsym==k)[0][:n//2]
-                stra[idx] = True
-                strb[idx] = True
-            else:
-                na, nb = n
-                stra[numpy.where(orbsym==k)[0][:na]] = True
-                strb[numpy.where(orbsym==k)[0][:nb]] = True
-                if (na-nb)%2:
-                    wfnsym ^= k
-
-    orbleft = numpy.where(orbleft)[0]
-    neleca_left = neleca - stra.sum()
-    nelecb_left = nelecb - strb.sum()
-    spin = neleca_left - nelecb_left
-    assert (neleca_left >= 0)
-    assert (nelecb_left >= 0)
-    assert (spin >= 0)
-
-########################
-# pass 2: search pattern
-    def gen_str_iter(orb_list, nelec):
-        if nelec == 1:
-            for i in orb_list:
-                yield [i]
-        elif nelec >= len(orb_list):
-            yield orb_list
-        else:
-            restorb = orb_list[1:]
-            #yield from gen_str_iter(restorb, nelec)
-            for x in gen_str_iter(restorb, nelec):
-                yield x
-            for x in gen_str_iter(restorb, nelec-1):
-                yield [orb_list[0]] + x
-
-    # search for alpha and beta pattern which match to the required symmetry
-    def query(target, nelec_atmost, spin, orbsym):
-        norb = len(orbsym)
-        for excite_level in range(1, nelec_atmost+1):
-            for beta_only in gen_str_iter(list(range(norb)), excite_level):
-                alpha_allow = [i for i in range(norb) if i not in beta_only]
-                alpha_orbsym = orbsym[alpha_allow]
-                alpha_target = target
-                for i in beta_only:
-                    alpha_target ^= orbsym[i]
-                alpha_only = symm.route(alpha_target, spin+excite_level, alpha_orbsym)
-                if alpha_only:
-                    alpha_only = [alpha_allow[i] for i in alpha_only]
-                    return alpha_only, beta_only
-        raise RuntimeError('No pattern found for wfn irrep %s over orbsym %s'
-                           % (target, orbsym))
-
-    if spin == 0:
-        aonly = bonly = []
-        if wfnsym != 0:
-            aonly, bonly = query(wfnsym, neleca_left, spin, orbsym[orbleft])
-    else:
-        # 1. assume "nelecb_left" doubly occupied orbitals
-        # search for alpha pattern which match to the required symmetry
-        aonly, bonly = orbleft[symm.route(wfnsym, spin, orbsym[orbleft])], []
-        # dcompose doubly occupied orbitals, search for alpha and beta pattern
-        if len(aonly) != spin:
-            aonly, bonly = query(wfnsym, neleca_left, spin, orbsym[orbleft])
-
-    ndocc = neleca_left - len(aonly) # == nelecb_left - len(bonly)
-    docc_allow = numpy.ones(len(orbleft), dtype=bool)
-    docc_allow[aonly] = False
-    docc_allow[bonly] = False
-    docclst = orbleft[numpy.where(docc_allow)[0]][:ndocc]
-    stra[docclst] = True
-    strb[docclst] = True
-
-    def find_addr_(stra, aonly, nelec):
-        stra[orbleft[aonly]] = True
-        return cistring.str2addr(norb, nelec, ('%i'*norb)%tuple(stra)[::-1])
-    if bonly:
-        if spin > 0:
-            aonly, socc_only = aonly[:-spin], aonly[-spin:]
-            stra[orbleft[socc_only]] = True
-        stra1 = stra.copy()
-        strb1 = strb.copy()
-
-        addra = find_addr_(stra, aonly, neleca)
-        addrb = find_addr_(strb, bonly, nelecb)
-        addra1 = find_addr_(stra1, bonly, neleca)
-        addrb1 = find_addr_(strb1, aonly, nelecb)
-        ci1[addra,addrb] = ci1[addra1,addrb1] = numpy.sqrt(.5)
-    else:
-        addra = find_addr_(stra, aonly, neleca)
-        addrb = find_addr_(strb, bonly, nelecb)
-        ci1[addra,addrb] = 1
-
-    return ci1
+    raise DeprecationWarning
 
 
 def cylindrical_init_guess(mol, norb, nelec, orbsym, wfnsym=0, singlet=True,
                            nroots=1):
     '''
     FCI initial guess for system of cylindrical symmetry.
     (In testing)
@@ -242,17 +134,17 @@
         orb_lz = irrep_id2lz(orbsym)
         wfn_lz = irrep_id2lz(wfnsym)
         d2h_wfnsym_id = wfnsym % 10
     else:
         raise NotImplementedError
         orb_lz = wfn_lz = d2h_wfnsym_id = None
 
-    occslsta = occslstb = cistring._gen_occslst(range(norb), neleca)
+    occslsta = occslstb = cistring.gen_occslst(range(norb), neleca)
     if neleca != nelecb:
-        occslstb = cistring._gen_occslst(range(norb), nelecb)
+        occslstb = cistring.gen_occslst(range(norb), nelecb)
     na = len(occslsta)
     nb = len(occslsta)
 
     gx_mask = orbsym == 2
     gy_mask = orbsym == 3
     ux_mask = orbsym == 7
     uy_mask = orbsym == 6
@@ -643,14 +535,17 @@
         ss : number
             S^2 expection value == s*(s+1)
 
     Returns
             A modified FCI object based on fciobj.
     '''
     import types
+    from pyscf.fci import direct_uhf
+    if isinstance(fciobj, direct_uhf.FCISolver):
+        raise NotImplementedError
 
     if 'ss_value' in kwargs:
         sys.stderr.write('fix_spin_: kwarg "ss_value" will be removed in future release. '
                          'It was replaced by "ss"\n')
         ss_value = kwargs['ss_value']
     else:
         ss_value = ss
```

### Comparing `pyscf-2.2.1/pyscf/fci/cistring.py` & `pyscf-2.3.0/pyscf/fci/cistring.py`

 * *Files 2% similar despite different names*

```diff
@@ -37,15 +37,15 @@
     >>> [bin(x) for x in make_strings((0,1,2,3),2)]
     [0b11, 0b101, 0b110, 0b1001, 0b1010, 0b1100]
     >>> [bin(x) for x in make_strings((3,1,0,2),2)]
     [0b1010, 0b1001, 0b11, 0b1100, 0b110, 0b101]
     '''
     orb_list = list(orb_list)
     if len(orb_list) > 63:
-        return _gen_occslst(orb_list, nelec)
+        return gen_occslst(orb_list, nelec)
 
     assert (nelec >= 0)
     if nelec == 0:
         return numpy.asarray([0], dtype=numpy.int64)
     elif nelec > len(orb_list):
         return numpy.asarray([], dtype=numpy.int64)
     def gen_str_iter(orb_list, nelec):
@@ -64,16 +64,32 @@
                 res.append(n | thisorb)
         return res
     strings = gen_str_iter(orb_list, nelec)
     assert (strings.__len__() == num_strings(len(orb_list),nelec))
     return numpy.asarray(strings, dtype=numpy.int64)
 gen_strings4orblist = make_strings
 
-def _gen_occslst(orb_list, nelec):
+def gen_occslst(orb_list, nelec):
     '''Generate occupied orbital list for each string.
+
+    Returns:
+        List of lists of int32. Each inner list has length equal to the number of
+        electrons, and contains the occupied orbitals in the corresponding string.
+
+    Example:
+
+        >>> [bin(x) for x in make_strings((0, 1, 2, 3), 2)]
+        ['0b11', '0b101', '0b110', '0b1001', '0b1010', '0b1100']
+        >>> gen_occslst((0, 1, 2, 3), 2)
+        OIndexList([[0, 1],
+                    [0, 2],
+                    [1, 2],
+                    [0, 3],
+                    [1, 3],
+                    [2, 3]], dtype=int32)
     '''
     orb_list = list(orb_list)
     assert (nelec >= 0)
     if nelec == 0:
         return numpy.zeros((1,nelec), dtype=numpy.int32)
     elif nelec > len(orb_list):
         return numpy.zeros((0,nelec), dtype=numpy.int32)
@@ -113,15 +129,15 @@
     else:
         return math.factorial(n) // (math.factorial(n-m)*math.factorial(m))
 
 def gen_linkstr_index_o0(orb_list, nelec, strs=None):
     if strs is None:
         strs = make_strings(orb_list, nelec)
     strdic = dict(zip(strs,range(strs.__len__())))
-    def propgate1e(str0):
+    def propagate1e(str0):
         occ = []
         vir = []
         for i in orb_list:
             if str0 & (1 << i):
                 occ.append(i)
             else:
                 vir.append(i)
@@ -131,23 +147,23 @@
         for i in occ:
             for a in vir:
                 str1 = str0 ^ (1 << i) | (1 << a)
                 # [cre, des, target_address, parity]
                 linktab.append((a, i, strdic[str1], cre_des_sign(a, i, str0)))
         return linktab
 
-    t = [propgate1e(s) for s in strs.astype(numpy.int64)]
+    t = [propagate1e(s) for s in strs.astype(numpy.int64)]
     return numpy.array(t, dtype=numpy.int32)
 
 def gen_linkstr_index_o1(orb_list, nelec, strs=None, tril=False):
     if nelec == 0:
         return numpy.zeros((0,0,4), dtype=numpy.int32)
 
     if strs is None:
-        strs = _gen_occslst(orb_list, nelec)
+        strs = gen_occslst(orb_list, nelec)
     occslst = strs
 
     orb_list = numpy.asarray(orb_list)
     norb = len(orb_list)
     assert (numpy.all(numpy.arange(norb) == orb_list))
 
     strdic = dict((tuple(s), i) for i,s in enumerate(occslst))
```

### Comparing `pyscf-2.2.1/pyscf/fci/direct_ep.py` & `pyscf-2.3.0/pyscf/fci/direct_ep.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/fci/direct_nosym.py` & `pyscf-2.3.0/pyscf/fci/direct_nosym.py`

 * *Files 0% similar despite different names*

```diff
@@ -36,15 +36,15 @@
 import numpy
 import scipy.linalg
 from pyscf import lib
 from pyscf import ao2mo
 from pyscf.fci import cistring
 from pyscf.fci import direct_spin1
 
-libfci = lib.load_library('libfci')
+libfci = direct_spin1.libfci
 
 def contract_1e(h1e, fcivec, norb, nelec, link_index=None):
     h1e = numpy.asarray(h1e, order='C')
     fcivec = numpy.asarray(fcivec, order='C')
     link_indexa, link_indexb = _unpack(norb, nelec, link_index)
 
     na, nlinka = link_indexa.shape[:2]
@@ -114,15 +114,15 @@
     return ci1.view(direct_spin1.FCIvector)
 
 def absorb_h1e(h1e, eri, norb, nelec, fac=1):
     '''Modify 2e Hamiltonian to include 1e Hamiltonian contribution.
     '''
     if not isinstance(nelec, (int, numpy.number)):
         nelec = sum(nelec)
-    h2e = ao2mo.restore(1, eri.copy(), norb)
+    h2e = ao2mo.restore(1, eri.copy(), norb).astype(h1e.dtype, copy=False)
     f1e = h1e - numpy.einsum('jiik->jk', h2e) * .5
     f1e = f1e * (1./(nelec+1e-100))
     for k in range(norb):
         h2e[k,k,:,:] += f1e
         h2e[:,:,k,k] += f1e
     return h2e * fac
```

### Comparing `pyscf-2.2.1/pyscf/fci/direct_spin0.py` & `pyscf-2.3.0/pyscf/fci/direct_spin0.py`

 * *Files 4% similar despite different names*

```diff
@@ -45,20 +45,23 @@
 from pyscf import ao2mo
 from pyscf.lib import logger
 from pyscf.fci import cistring
 from pyscf.fci import rdm
 from pyscf.fci import direct_spin1
 from pyscf.fci.spin_op import contract_ss
 
-libfci = lib.load_library('libfci')
+libfci = direct_spin1.libfci
 
 @lib.with_doc(direct_spin1.contract_1e.__doc__)
 def contract_1e(f1e, fcivec, norb, nelec, link_index=None):
     fcivec = numpy.asarray(fcivec, order='C')
-    link_index = _unpack(norb, nelec, link_index)
+    link_index = direct_spin1._unpack(norb, nelec, link_index)
+    if not isinstance(link_index, numpy.ndarray):
+        # Handle computability. link_index should be (nparray, nparray)
+        link_index = link_index[0]
     na, nlink = link_index.shape[:2]
     assert (fcivec.size == na**2)
     ci1 = numpy.empty_like(fcivec)
     f1e_tril = lib.pack_tril(f1e)
     libfci.FCIcontract_1e_spin0(f1e_tril.ctypes.data_as(ctypes.c_void_p),
                                 fcivec.ctypes.data_as(ctypes.c_void_p),
                                 ci1.ctypes.data_as(ctypes.c_void_p),
@@ -80,15 +83,18 @@
 # the input fcivec should be symmetrized
 @lib.with_doc(direct_spin1.contract_2e.__doc__)
 def contract_2e(eri, fcivec, norb, nelec, link_index=None):
     fcivec = numpy.asarray(fcivec, order='C')
     eri = ao2mo.restore(4, eri, norb)
     lib.transpose_sum(eri, inplace=True)
     eri *= .5
-    link_index = _unpack(norb, nelec, link_index)
+    link_index = direct_spin1._unpack(norb, nelec, link_index)
+    if not isinstance(link_index, numpy.ndarray):
+        # Handle computability. link_index should be (nparray, nparray)
+        link_index = link_index[0]
     na, nlink = link_index.shape[:2]
     assert (fcivec.size == na**2)
     ci1 = numpy.empty((na,na))
 
     libfci.FCIcontract_2e_spin0(eri.ctypes.data_as(ctypes.c_void_p),
                                 fcivec.ctypes.data_as(ctypes.c_void_p),
                                 ci1.ctypes.data_as(ctypes.c_void_p),
@@ -98,15 +104,15 @@
 # no *.5 because FCIcontract_2e_spin0 only compute half of the contraction
     ci1 = lib.transpose_sum(ci1, inplace=True).reshape(fcivec.shape)
     return ci1.view(direct_spin1.FCIvector)
 
 absorb_h1e = direct_spin1.absorb_h1e
 
 @lib.with_doc(direct_spin1.make_hdiag.__doc__)
-def make_hdiag(h1e, eri, norb, nelec):
+def make_hdiag(h1e, eri, norb, nelec, compress=False):
     hdiag = direct_spin1.make_hdiag(h1e, eri, norb, nelec)
     na = int(numpy.sqrt(hdiag.size))
 # symmetrize hdiag to reduce numerical error
     hdiag = lib.transpose_sum(hdiag.reshape(na,na), inplace=True) * .5
     return hdiag.ravel()
 
 pspace = direct_spin1.pspace
@@ -230,153 +236,159 @@
     if nroots is None: nroots = fci.nroots
     if davidson_only is None: davidson_only = fci.davidson_only
     if pspace_size is None: pspace_size = fci.pspace_size
     if max_memory is None:
         max_memory = fci.max_memory - lib.current_memory()[0]
     log = logger.new_logger(fci, verbose)
 
-    assert (fci.spin is None or fci.spin == 0)
-    assert (0 <= numpy.sum(nelec) <= norb*2)
+    nelec = direct_spin1._unpack_nelec(nelec, fci.spin)
+    assert (0 <= nelec[0] <= norb and 0 <= nelec[1] <= norb)
 
-    link_index = _unpack(norb, nelec, link_index)
-    h1e = numpy.ascontiguousarray(h1e)
-    eri = numpy.ascontiguousarray(eri)
-    na = link_index.shape[0]
+    hdiag = fci.make_hdiag(h1e, eri, norb, nelec, compress=True)
+    if getattr(fci, 'sym_allowed_idx', None):
+        # Remove symmetry forbidden elements
+        sym_idx = numpy.hstack(fci.sym_allowed_idx)
+        civec_size = sym_idx.size
+    else:
+        sym_idx = None
+        civec_size = hdiag.size
 
-    if max_memory < na**2*6*8e-6:
+    if max_memory < hdiag.size*6*8e-6:
         log.warn('Not enough memory for FCI solver. '
-                 'The minimal requirement is %.0f MB', na**2*60e-6)
+                 'The minimal requirement is %.0f MB', hdiag.size*60e-6)
 
-    hdiag = fci.make_hdiag(h1e, eri, norb, nelec)
+    pspace_size = min(hdiag.size, pspace_size)
     nroots = min(hdiag.size, nroots)
-
-    try:
-        addr, h0 = fci.pspace(h1e, eri, norb, nelec, hdiag, max(pspace_size,nroots))
-        if pspace_size > 0:
-            pw, pv = fci.eig(h0)
+    na = cistring.num_strings(norb, nelec[0])
+    addr = [0]
+    pw = pv = None
+    if pspace_size > 0:
+        try:
+            addr, h0 = fci.pspace(h1e, eri, norb, nelec, hdiag, pspace_size)
+        except NotImplementedError:
+            pass
+        pw, pv = fci.eig(h0)
+
+    if pspace_size >= civec_size and ci0 is None and not davidson_only:
+        e = []
+        civec = []
+        for i in range(pspace_size):
+            c = numpy.empty(civec_size)
+            c[addr] = pv[:,i]
+            try:
+                civec.append(_check_(c.reshape(na,na)))
+            except ValueError:
+                continue
+            e.append(pw[i])
+            if len(civec) >= nroots:
+                break
+        if nroots == 1:
+            return e[0]+ecore, civec[0]
         else:
-            pw = pv = None
-
-        if pspace_size >= na*na and ci0 is None and not davidson_only:
-            # The degenerated wfn can break symmetry.  The davidson iteration with proper
-            # initial guess doesn't have this issue
-            if na*na == 1:
-                return pw[0]+ecore, pv[:,0].reshape(1,1).view(direct_spin1.FCIvector)
-            elif nroots > 1:
-                civec = numpy.empty((nroots,na*na))
-                civec[:,addr] = pv[:,:nroots].T
-                civec = civec.reshape(nroots,na,na)
-                try:
-                    return (pw[:nroots]+ecore,
-                            [_check_(ci).view(direct_spin1.FCIvector) for ci in civec])
-                except ValueError:
-                    pass
-            elif abs(pw[0]-pw[1]) > 1e-12:
-                civec = numpy.empty((na*na))
-                civec[addr] = pv[:,0]
-                civec = civec.reshape(na,na)
-                civec = lib.transpose_sum(civec) * .5
-                # direct diagonalization may lead to triplet ground state
-
-                #TODO: optimize initial guess.  Using pspace vector as initial guess may have
-                # spin problems.  The 'ground state' of psapce vector may have different spin
-                # state to the true ground state.
-                try:
-                    return (pw[0]+ecore,
-                            _check_(civec.reshape(na,na)).view(direct_spin1.FCIvector))
-                except ValueError:
-                    pass
-    except NotImplementedError:
-        addr = [0]
+            return numpy.array(e)+ecore, civec
     pw = pv = h0 = None
 
-    precond = fci.make_precond(hdiag)
+    if hdiag.size == civec_size:
+        precond = fci.make_precond(hdiag)
+    else:
+        precond = fci.make_precond(hdiag[sym_idx])
 
     h2e = fci.absorb_h1e(h1e, eri, norb, nelec, .5)
     if hop is None:
+        cpu0 = [logger.process_clock(), logger.perf_counter()]
         def hop(c):
             hc = fci.contract_2e(h2e, c.reshape(na,na), norb, nelec, link_index)
+            cpu0[:] = log.timer_debug1('contract_2e', *cpu0)
             return hc.ravel()
 
-#TODO: check spin of initial guess
-    if ci0 is None:
+    def init_guess():
         if callable(getattr(fci, 'get_init_guess', None)):
-            ci0 = lambda: fci.get_init_guess(norb, nelec, nroots, hdiag)
+            return fci.get_init_guess(norb, nelec, nroots, hdiag)
         else:
-            def ci0():
-                x0 = []
-                for i in range(nroots):
-                    x = numpy.zeros((na,na))
-                    addra = addr[i] // na
-                    addrb = addr[i] % na
-                    if addra == addrb:
-                        x[addra,addrb] = 1
-                    else:
-                        x[addra,addrb] = x[addrb,addra] = numpy.sqrt(.5)
-                    x0.append(x.ravel())
-                return x0
+            x0 = []
+            for i in range(nroots):
+                x = numpy.zeros((na,na))
+                addra = addr[i] // na
+                addrb = addr[i] % na
+                if addra == addrb:
+                    x[addra,addrb] = 1
+                else:
+                    x[addra,addrb] = x[addrb,addra] = numpy.sqrt(.5)
+                x0.append(x.ravel())
+            return x0
+
+    if ci0 is None:
+        ci0 = init_guess  # lazy initialization to reduce memory footprint
     elif not callable(ci0):
-        if isinstance(ci0, numpy.ndarray) and ci0.size == na*na:
+        if isinstance(ci0, numpy.ndarray):
             ci0 = [ci0.ravel()]
         else:
             ci0 = [x.ravel() for x in ci0]
+        if sym_idx is not None and ci0[0].size != civec_size:
+            ci0 = [x[sym_idx] for x in ci0]
+        if len(ci0) < nroots:
+            ci0.extend(init_guess()[len(ci0):])
 
     if tol is None: tol = fci.conv_tol
     if lindep is None: lindep = fci.lindep
     if max_cycle is None: max_cycle = fci.max_cycle
     if max_space is None: max_space = fci.max_space
     tol_residual = getattr(fci, 'conv_tol_residual', None)
 
     with lib.with_omp_threads(fci.threads):
-        #e, c = lib.davidson(hop, ci0, precond, tol=fci.conv_tol, lindep=fci.lindep)
         e, c = fci.eig(hop, ci0, precond, tol=tol, lindep=lindep,
                        max_cycle=max_cycle, max_space=max_space, nroots=nroots,
                        max_memory=max_memory, verbose=log, follow_state=True,
                        tol_residual=tol_residual, **kwargs)
-    if nroots > 1:
-        return (e+ecore,
-                [_check_(ci.reshape(na,na)).view(direct_spin1.FCIvector) for ci in c])
-    else:
-        return e+ecore, _check_(c.reshape(na,na)).view(direct_spin1.FCIvector)
+    return e+ecore, c
 
 def _check_(c):
     c = lib.transpose_sum(c, inplace=True)
     c *= .5
     norm = numpy.linalg.norm(c)
     if abs(norm-1) > 1e-6:
         raise ValueError('State not singlet %g' % (norm - 1))
     return c/norm
 
 
 class FCISolver(direct_spin1.FCISolver):
 
-    def make_hdiag(self, h1e, eri, norb, nelec):
-        return make_hdiag(h1e, eri, norb, nelec)
+    make_hdiag = staticmethod(make_hdiag)
 
     def contract_1e(self, f1e, fcivec, norb, nelec, link_index=None, **kwargs):
         return contract_1e(f1e, fcivec, norb, nelec, link_index, **kwargs)
 
     def contract_2e(self, eri, fcivec, norb, nelec, link_index=None, **kwargs):
         return contract_2e(eri, fcivec, norb, nelec, link_index, **kwargs)
 
     def get_init_guess(self, norb, nelec, nroots, hdiag):
         return get_init_guess(norb, nelec, nroots, hdiag)
 
     def kernel(self, h1e, eri, norb, nelec, ci0=None,
                tol=None, lindep=None, max_cycle=None, max_space=None,
                nroots=None, davidson_only=None, pspace_size=None,
                orbsym=None, wfnsym=None, ecore=0, **kwargs):
+        if nroots is None: nroots = self.nroots
         if self.verbose >= logger.WARN:
             self.check_sanity()
+        assert self.spin is None or self.spin == 0
         self.norb = norb
         self.nelec = nelec
-        self.eci, self.ci = \
-                kernel_ms0(self, h1e, eri, norb, nelec, ci0, None,
-                           tol, lindep, max_cycle, max_space, nroots,
-                           davidson_only, pspace_size, ecore=ecore, **kwargs)
+        link_index = direct_spin1._unpack(norb, nelec, None)
+        e, c = kernel_ms0(self, h1e, eri, norb, nelec, ci0, link_index,
+                          tol, lindep, max_cycle, max_space, nroots,
+                          davidson_only, pspace_size, ecore=ecore, **kwargs)
+        self.eci = e
+
+        na = link_index[0].shape[0]
+        if nroots > 1:
+            self.ci = [
+                _check_(x.reshape(na,na)).view(direct_spin1.FCIvector) for x in c]
+        else:
+            self.ci = _check_(c.reshape(na,na)).view(direct_spin1.FCIvector)
         return self.eci, self.ci
 
     def energy(self, h1e, eri, fcivec, norb, nelec, link_index=None):
         h2e = self.absorb_h1e(h1e, eri, norb, nelec, .5)
         ci1 = self.contract_2e(h2e, fcivec, norb, nelec, link_index)
         return numpy.dot(fcivec.reshape(-1), ci1.reshape(-1))
 
@@ -412,26 +424,14 @@
         else:
             link_index = cistring.gen_linkstr_index(range(norb), neleca)
         return link_index
 
 FCI = FCISolver
 
 
-def _unpack(norb, nelec, link_index):
-    if link_index is None:
-        if isinstance(nelec, (int, numpy.number)):
-            neleca = nelec//2
-        else:
-            neleca, nelecb = nelec
-            assert (neleca == nelecb)
-        return cistring.gen_linkstr_index_trilidx(range(norb), neleca)
-    else:
-        return link_index
-
-
 if __name__ == '__main__':
     from functools import reduce
     from pyscf import gto
     from pyscf import scf
 
     mol = gto.Mole()
     mol.verbose = 0
```

### Comparing `pyscf-2.2.1/pyscf/fci/direct_spin0_symm.py` & `pyscf-2.3.0/pyscf/fci/selected_ci_symm.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 #!/usr/bin/env python
-# Copyright 2014-2019 The PySCF Developers. All Rights Reserved.
+# Copyright 2014-2021 The PySCF Developers. All Rights Reserved.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
@@ -12,318 +12,282 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
 # Author: Qiming Sun <osirpt.sun@gmail.com>
 #
 
-'''
-Different FCI solvers are implemented to support different type of symmetry.
-                    Symmetry
-File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
-direct_spin0_symm   Yes           Yes            Yes                Yes
-direct_spin1_symm   Yes           No             Yes                Yes
-direct_spin0        No            Yes            Yes                Yes
-direct_spin1        No            No             Yes                Yes
-direct_uhf          No            No             Yes                No
-direct_nosym        No            No             No**               Yes
-
-*  Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)
-** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...
-'''
-
-import sys
 import ctypes
+import warnings
 import numpy
 from pyscf import lib
-from pyscf import ao2mo
 from pyscf.lib import logger
-from pyscf import symm
-from pyscf.scf.hf_symm import map_degeneracy
-from pyscf.fci import cistring
-from pyscf.fci import direct_spin0
+from pyscf import ao2mo
 from pyscf.fci import direct_spin1
 from pyscf.fci import direct_spin1_symm
+from pyscf.fci import selected_ci
 from pyscf.fci import addons
-from pyscf.fci.spin_op import contract_ss
-from pyscf import __config__
 
-libfci = lib.load_library('libfci')
+libfci = direct_spin1.libfci
 
-TOTIRREPS = 8
-
-def contract_1e(f1e, fcivec, norb, nelec, link_index=None, orbsym=None):
-    return direct_spin0.contract_1e(f1e, fcivec, norb, nelec, link_index)
-
-# Note eri is NOT the 2e hamiltonian matrix, the 2e hamiltonian is
-# h2e = eri_{pq,rs} p^+ q r^+ s
-#     = (pq|rs) p^+ r^+ s q - (pq|rs) \delta_{qr} p^+ s
-# so eri is defined as
-#       eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)
-# to restore the symmetry between pq and rs,
-#       eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]
-# Please refer to the treatment in direct_spin1.absorb_h1e
-# the input fcivec should be symmetrized
-def contract_2e(eri, fcivec, norb, nelec, link_index=None, orbsym=None, wfnsym=0):
+def reorder4irrep(eri, norb, link_index, orbsym, offdiag=0):
     if orbsym is None:
-        return direct_spin0.contract_2e(eri, fcivec, norb, nelec, link_index)
-
-    eri = ao2mo.restore(4, eri, norb)
-    neleca, nelecb = direct_spin1._unpack_nelec(nelec)
-    assert (neleca == nelecb)
-    link_indexa = direct_spin0._unpack(norb, nelec, link_index)
-    na, nlinka = link_indexa.shape[:2]
-    eri_irs, rank_eri, irrep_eri = direct_spin1_symm.reorder_eri(eri, norb, orbsym)
-
-    strsa = numpy.asarray(cistring.gen_strings4orblist(range(norb), neleca))
-    aidx, link_indexa = direct_spin1_symm.gen_str_irrep(strsa, orbsym, link_indexa,
-                                                        rank_eri, irrep_eri)
-
-    Tirrep = ctypes.c_void_p*TOTIRREPS
-    linka_ptr = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in link_indexa])
-    eri_ptrs = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in eri_irs])
-    dimirrep = (ctypes.c_int*TOTIRREPS)(*[x.shape[0] for x in eri_irs])
-    fcivec_shape = fcivec.shape
-    fcivec = fcivec.reshape((na,na), order='C')
-    ci1new = numpy.zeros_like(fcivec)
-    nas = (ctypes.c_int*TOTIRREPS)(*[x.size for x in aidx])
-
-    ci0 = []
-    ci1 = []
-    wfnsym_in_d2h = wfnsym % 10
-    for ir in range(TOTIRREPS):
-        ma, mb = aidx[ir].size, aidx[wfnsym_in_d2h ^ ir].size
-        ci0.append(numpy.zeros((ma,mb)))
-        ci1.append(numpy.zeros((ma,mb)))
-        if ma > 0 and mb > 0:
-            lib.take_2d(fcivec, aidx[ir], aidx[wfnsym_in_d2h ^ ir], out=ci0[ir])
-    ci0_ptrs = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in ci0])
-    ci1_ptrs = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in ci1])
-    libfci.FCIcontract_2e_symm1(eri_ptrs, ci0_ptrs, ci1_ptrs,
-                                ctypes.c_int(norb), nas, nas,
-                                ctypes.c_int(nlinka), ctypes.c_int(nlinka),
-                                linka_ptr, linka_ptr, dimirrep,
-                                ctypes.c_int(wfnsym_in_d2h))
-    for ir in range(TOTIRREPS):
-        if ci0[ir].size > 0:
-            lib.takebak_2d(ci1new, ci1[ir], aidx[ir], aidx[wfnsym_in_d2h ^ ir])
-    ci1 = lib.transpose_sum(ci1new, inplace=True).reshape(fcivec_shape)
-    return ci1.view(direct_spin1.FCIvector)
+        return eri, link_index, numpy.array(norb, dtype=numpy.int32)
+    orbsym = numpy.asarray(orbsym)
+    # map irrep IDs of Dooh or Coov to D2h, C2v
+    # see symm.basis.linearmole_symm_descent
+    orbsym = orbsym % 10
+    # irrep of (ij| pair
+    trilirrep = (orbsym[:,None] ^ orbsym)[numpy.tril_indices(norb, offdiag)]
+    # and the number of occurence for each irrep
+    dimirrep = numpy.array(numpy.bincount(trilirrep), dtype=numpy.int32)
+    # we sort the irreps of (ij| pair, to group the pairs which have same irreps
+    # "order" is irrep-id-sorted index. The (ij| paired is ordered that the
+    # pair-id given by order[0] comes first in the sorted pair
+    # "rank" is a sorted "order". Given nth (ij| pair, it returns the place(rank)
+    # of the sorted pair
+    order = numpy.asarray(trilirrep.argsort(), dtype=numpy.int32)
+    rank = numpy.asarray(order.argsort(), dtype=numpy.int32)
+    eri = lib.take_2d(eri, order, order)
+    link_index_irrep = link_index.copy()
+    link_index_irrep[:,:,0] = rank[link_index[:,:,0]]
+    return numpy.asarray(eri, order='C'), link_index_irrep, dimirrep
+
+def contract_2e(eri, civec_strs, norb, nelec, link_index=None, orbsym=None):
+    ci_coeff, nelec, ci_strs = selected_ci._unpack(civec_strs, nelec)
+    if link_index is None:
+        link_index = selected_ci._all_linkstr_index(ci_strs, norb, nelec)
+    cd_indexa, dd_indexa, cd_indexb, dd_indexb = link_index
+    na, nlinka = cd_indexa.shape[:2]
+    nb, nlinkb = cd_indexb.shape[:2]
+
+    eri = ao2mo.restore(1, eri, norb)
+    eri1 = eri.transpose(0,2,1,3) - eri.transpose(0,2,3,1)
+    idx,idy = numpy.tril_indices(norb, -1)
+    idx = idx * norb + idy
+    eri1 = lib.take_2d(eri1.reshape(norb**2,-1), idx, idx) * 2
+    eri1, dd_indexa, dimirrep = reorder4irrep(eri1, norb, dd_indexa, orbsym, -1)
+    dd_indexb = reorder4irrep(eri1, norb, dd_indexb, orbsym, -1)[1]
+    fcivec = ci_coeff.reshape(na,nb)
+    # (bb|bb)
+    if nelec[1] > 1:
+        mb, mlinkb = dd_indexb.shape[:2]
+        fcivecT = lib.transpose(fcivec)
+        ci1T = numpy.zeros((nb,na))
+        libfci.SCIcontract_2e_aaaa_symm(eri1.ctypes.data_as(ctypes.c_void_p),
+                                        fcivecT.ctypes.data_as(ctypes.c_void_p),
+                                        ci1T.ctypes.data_as(ctypes.c_void_p),
+                                        ctypes.c_int(norb),
+                                        ctypes.c_int(nb), ctypes.c_int(na),
+                                        ctypes.c_int(mb), ctypes.c_int(mlinkb),
+                                        dd_indexb.ctypes.data_as(ctypes.c_void_p),
+                                        dimirrep.ctypes.data_as(ctypes.c_void_p),
+                                        ctypes.c_int(len(dimirrep)))
+        ci1 = lib.transpose(ci1T, out=fcivecT)
+    else:
+        ci1 = numpy.zeros_like(fcivec)
+    # (aa|aa)
+    if nelec[0] > 1:
+        ma, mlinka = dd_indexa.shape[:2]
+        libfci.SCIcontract_2e_aaaa_symm(eri1.ctypes.data_as(ctypes.c_void_p),
+                                        fcivec.ctypes.data_as(ctypes.c_void_p),
+                                        ci1.ctypes.data_as(ctypes.c_void_p),
+                                        ctypes.c_int(norb),
+                                        ctypes.c_int(na), ctypes.c_int(nb),
+                                        ctypes.c_int(ma), ctypes.c_int(mlinka),
+                                        dd_indexa.ctypes.data_as(ctypes.c_void_p),
+                                        dimirrep.ctypes.data_as(ctypes.c_void_p),
+                                        ctypes.c_int(len(dimirrep)))
+
+    h_ps = numpy.einsum('pqqs->ps', eri)
+    eri1 = eri * 2
+    for k in range(norb):
+        eri1[:,:,k,k] += h_ps/nelec[0]
+        eri1[k,k,:,:] += h_ps/nelec[1]
+    eri1 = ao2mo.restore(4, eri1, norb)
+    eri1, cd_indexa, dimirrep = reorder4irrep(eri1, norb, cd_indexa, orbsym)
+    cd_indexb = reorder4irrep(eri1, norb, cd_indexb, orbsym)[1]
+    # (bb|aa)
+    libfci.SCIcontract_2e_bbaa_symm(eri1.ctypes.data_as(ctypes.c_void_p),
+                                    fcivec.ctypes.data_as(ctypes.c_void_p),
+                                    ci1.ctypes.data_as(ctypes.c_void_p),
+                                    ctypes.c_int(norb),
+                                    ctypes.c_int(na), ctypes.c_int(nb),
+                                    ctypes.c_int(nlinka), ctypes.c_int(nlinkb),
+                                    cd_indexa.ctypes.data_as(ctypes.c_void_p),
+                                    cd_indexb.ctypes.data_as(ctypes.c_void_p),
+                                    dimirrep.ctypes.data_as(ctypes.c_void_p),
+                                    ctypes.c_int(len(dimirrep)))
 
+    return selected_ci._as_SCIvector(ci1.reshape(ci_coeff.shape), ci_strs)
 
 def kernel(h1e, eri, norb, nelec, ci0=None, level_shift=1e-3, tol=1e-10,
            lindep=1e-14, max_cycle=50, max_space=12, nroots=1,
            davidson_only=False, pspace_size=400, orbsym=None, wfnsym=None,
-           ecore=0, **kwargs):
-    assert (len(orbsym) == norb)
-    cis = FCISolver(None)
-    cis.level_shift = level_shift
-    cis.conv_tol = tol
-    cis.lindep = lindep
-    cis.max_cycle = max_cycle
-    cis.max_space = max_space
-    cis.nroots = nroots
-    cis.davidson_only = davidson_only
-    cis.pspace_size = pspace_size
-    cis.orbsym = orbsym
-    cis.wfnsym = wfnsym
-
-    unknown = {}
-    for k, v in kwargs.items():
-        if not hasattr(cis, k):
-            unknown[k] = v
-        setattr(cis, k, v)
-    if unknown:
-        sys.stderr.write('Unknown keys %s for FCI kernel %s\n' %
-                         (str(unknown.keys()), __name__))
-
-    wfnsym = direct_spin1_symm._id_wfnsym(cis, norb, nelec, cis.orbsym,
-                                          cis.wfnsym)
-    if cis.wfnsym is not None and ci0 is None:
-        ci0 = addons.symm_initguess(norb, nelec, orbsym, wfnsym)
-
-    e, c = cis.kernel(h1e, eri, norb, nelec, ci0, ecore=ecore, **unknown)
-    return e, c
-
-make_rdm1 = direct_spin0.make_rdm1
-make_rdm1s = direct_spin0.make_rdm1s
-make_rdm12 = direct_spin0.make_rdm12
-
-trans_rdm1s = direct_spin0.trans_rdm1s
-trans_rdm1 = direct_spin0.trans_rdm1
-trans_rdm12 = direct_spin0.trans_rdm12
-
-def energy(h1e, eri, fcivec, norb, nelec, link_index=None, orbsym=None, wfnsym=0):
-    h2e = direct_spin1.absorb_h1e(h1e, eri, norb, nelec) * .5
-    ci1 = contract_2e(h2e, fcivec, norb, nelec, link_index, orbsym, wfnsym)
-    return numpy.dot(fcivec.ravel(), ci1.ravel())
-
-def get_init_guess(norb, nelec, nroots, hdiag, orbsym, wfnsym=0):
-    neleca, nelecb = direct_spin1._unpack_nelec(nelec)
-    assert (neleca == nelecb)
-    strsa = cistring.gen_strings4orblist(range(norb), neleca)
-    airreps = direct_spin1_symm._gen_strs_irrep(strsa, orbsym)
-    na = nb = len(airreps)
-    hdiag = hdiag.reshape(na,nb)
-
-    ci0 = []
-    iroot = 0
-    sym_allowed = (airreps[:,None] ^ airreps) == wfnsym
-    idx = numpy.arange(na)
-    sym_allowed[idx[:,None] < idx] = False
-    idx_a, idx_b = numpy.where(sym_allowed)
-    for k in hdiag[idx_a,idx_b].argsort():
-        addra, addrb = idx_a[k], idx_b[k]
-        x = numpy.zeros((na, nb))
-        if addra == addrb:
-            x[addra,addrb] = 1
-        else:
-            x[addra,addrb] = x[addrb,addra] = numpy.sqrt(.5)
-        ci0.append(x.ravel().view(direct_spin1.FCIvector))
-        iroot += 1
-        if iroot >= nroots:
-            break
-
-    if len(ci0) == 0:
-        raise RuntimeError(f'Initial guess for symmetry {wfnsym} not found')
-    return ci0
-
-def get_init_guess_cyl_sym(norb, nelec, nroots, hdiag, orbsym, wfnsym=0):
-    neleca, nelecb = direct_spin1._unpack_nelec(nelec)
-    strsa = cistring.gen_strings4orblist(range(norb), neleca)
-    airreps_d2h = direct_spin1_symm._gen_strs_irrep(strsa, orbsym)
-    a_ls = direct_spin1_symm._strs_angular_momentum(strsa, orbsym)
-
-    wfnsym_in_d2h = wfnsym % 10
-    wfn_momentum = symm.basis.linearmole_irrep2momentum(wfnsym)
-    na = nb = len(strsa)
-    hdiag = hdiag.reshape(na,nb)
-    degen = orbsym.degen_mapping
-    ci0 = []
-    iroot = 0
-    wfn_ungerade = wfnsym_in_d2h >= 4
-    a_ungerade = airreps_d2h >= 4
-    sym_allowed = a_ungerade[:,None] == a_ungerade ^ wfn_ungerade
-    # total angular momentum == wfn_momentum
-    sym_allowed &= a_ls[:,None] == wfn_momentum - a_ls
-    idx = numpy.arange(na)
-    sym_allowed[idx[:,None] < idx] = False
-
-    idx_a, idx_b = numpy.where(sym_allowed)
-    for k in hdiag[idx_a,idx_b].argsort():
-        addra, addrb = idx_a[k], idx_b[k]
-        ca = direct_spin1_symm._cyl_sym_csf2civec(strsa, addra, orbsym, degen)
-        cb = direct_spin1_symm._cyl_sym_csf2civec(strsa, addrb, orbsym, degen)
-        if wfn_momentum > 0 or wfnsym in (0, 5):
-            x = ca.real[:,None] * cb.real
-            x-= ca.imag[:,None] * cb.imag
+           select_cutoff=1e-3, ci_coeff_cutoff=1e-3, ecore=0, **kwargs):
+    return direct_spin1._kfactory(SelectedCI, h1e, eri, norb, nelec, ci0,
+                                  level_shift, tol, lindep, max_cycle,
+                                  max_space, nroots, davidson_only,
+                                  pspace_size, select_cutoff=select_cutoff,
+                                  ci_coeff_cutoff=ci_coeff_cutoff, ecore=ecore,
+                                  **kwargs)
+
+make_rdm1s = selected_ci.make_rdm1s
+make_rdm2s = selected_ci.make_rdm2s
+make_rdm1 = selected_ci.make_rdm1
+make_rdm2 = selected_ci.make_rdm2
+
+trans_rdm1s = selected_ci.trans_rdm1s
+trans_rdm1 = selected_ci.trans_rdm1
+
+
+class SelectedCI(selected_ci.SelectedCI):
+    def contract_2e(self, eri, civec_strs, norb, nelec, link_index=None,
+                    orbsym=None, **kwargs):
+        if orbsym is None:
+            orbsym = self.orbsym
+        if getattr(civec_strs, '_strs', None) is not None:
+            self._strs = civec_strs._strs
         else:
-            x = ca.imag[:,None] * cb.real
-            x+= ca.real[:,None] * cb.imag
-        if addra == addrb:
-            norm = numpy.linalg.norm(x)
-        else:
-            x = x + x.T
-            norm = numpy.linalg.norm(x)
-            if norm < 1e-7:
-                continue
-        x *= 1./norm
-        ci0.append(x.ravel().view(direct_spin1.FCIvector))
-        iroot += 1
-        if iroot >= nroots:
-            break
-
-    if len(ci0) == 0:
-        raise RuntimeError(f'Initial guess for symmetry {wfnsym} not found')
-    return ci0
-
-
-class FCISolver(direct_spin0.FCISolver):
-
-    davidson_only = getattr(__config__, 'fci_direct_spin1_symm_FCI_davidson_only', True)
-
-    # pspace may break point group symmetry
-    pspace_size = getattr(__config__, 'fci_direct_spin1_symm_FCI_pspace_size', 0)
-
-    def __init__(self, mol=None, **kwargs):
-        direct_spin0.FCISolver.__init__(self, mol, **kwargs)
-        # wfnsym will be guessed based on initial guess if it is None
-        self.wfnsym = None
-
-    def dump_flags(self, verbose=None):
-        direct_spin0.FCISolver.dump_flags(self, verbose)
-        log = logger.new_logger(self, verbose)
-        if isinstance(self.wfnsym, str):
-            log.info('specified CI wfn symmetry = %s', self.wfnsym)
-        elif isinstance(self.wfnsym, (int, numpy.number)):
-            groupname = getattr(self.mol, 'groupname', None)
-            log.info('specified CI wfn symmetry = %s',
-                     symm.irrep_id2name(groupname, self.wfnsym))
-
-    def absorb_h1e(self, h1e, eri, norb, nelec, fac=1):
-        return direct_spin1.absorb_h1e(h1e, eri, norb, nelec, fac)
-
-    def make_hdiag(self, h1e, eri, norb, nelec):
-        return direct_spin0.make_hdiag(h1e, eri, norb, nelec)
-
-    def pspace(self, h1e, eri, norb, nelec, hdiag, np=400):
-        return direct_spin0.pspace(h1e, eri, norb, nelec, hdiag, np)
-
-    def contract_1e(self, f1e, fcivec, norb, nelec, link_index=None, **kwargs):
-        return contract_1e(f1e, fcivec, norb, nelec, link_index, **kwargs)
-
-    def contract_2e(self, eri, fcivec, norb, nelec, link_index=None,
-                    orbsym=None, wfnsym=None, **kwargs):
-        if orbsym is None: orbsym = self.orbsym
-        if wfnsym is None: wfnsym = self.wfnsym
-        wfnsym = direct_spin1_symm._id_wfnsym(self, norb, nelec, orbsym,
-                                              wfnsym)
-        return contract_2e(eri, fcivec, norb, nelec, link_index, orbsym, wfnsym, **kwargs)
-
-    def get_init_guess(self, norb, nelec, nroots, hdiag):
+            assert (civec_strs.size == len(self._strs[0])*len(self._strs[1]))
+            civec_strs = selected_ci._as_SCIvector(civec_strs, self._strs)
+        return contract_2e(eri, civec_strs, norb, nelec, link_index, orbsym)
+
+    def get_init_guess(self, ci_strs, norb, nelec, nroots, hdiag):
+        '''Initial guess is the single Slater determinant
+        '''
         wfnsym = direct_spin1_symm._id_wfnsym(self, norb, nelec, self.orbsym,
                                               self.wfnsym)
-        if getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov'):
-            return get_init_guess_cyl_sym(
-                norb, nelec, nroots, hdiag, self.orbsym, wfnsym)
+        airreps = direct_spin1_symm._gen_strs_irrep(ci_strs[0], self.orbsym)
+        birreps = direct_spin1_symm._gen_strs_irrep(ci_strs[1], self.orbsym)
+        ci0 = direct_spin1_symm._get_init_guess(
+            airreps, birreps, nroots, hdiag, nelec, self.orbsym, wfnsym)
+        return [selected_ci._as_SCIvector(x, ci_strs) for x in ci0]
+
+    def guess_wfnsym(self, norb, nelec, fcivec=None, orbsym=None, wfnsym=None,
+                     **kwargs):
+        if orbsym is None:
+            orbsym = self.orbsym
+        if fcivec is None:
+            wfnsym = direct_spin1_symm._id_wfnsym(self, norb, nelec, orbsym, wfnsym)
+
+        elif wfnsym is None:
+            strsa, strsb = getattr(fcivec, '_strs', self._strs)
+            if isinstance(fcivec, numpy.ndarray) and fcivec.ndim <= 2:
+                wfnsym = addons._guess_wfnsym(fcivec, strsa, strsb, orbsym)
+            else:
+                wfnsym = [addons._guess_wfnsym(c, strsa, strsb, orbsym)
+                          for c in fcivec]
+                if any(wfnsym[0] != x for x in wfnsym):
+                    warnings.warn('Different wfnsym %s found in different CI vecotrs' % wfnsym)
+                wfnsym = wfnsym[0]
+
         else:
-            return get_init_guess(norb, nelec, nroots, hdiag, self.orbsym, wfnsym)
+            strsa, strsb = getattr(fcivec, '_strs', self._strs)
+            na, nb = strsa.size, strsb.size
+
+            orbsym_in_d2h = numpy.asarray(orbsym) % 10  # convert to D2h irreps
+            airreps = numpy.zeros(na, dtype=numpy.int32)
+            birreps = numpy.zeros(nb, dtype=numpy.int32)
+            for i, ir in enumerate(orbsym_in_d2h):
+                airreps[numpy.bitwise_and(strsa, 1 << i) > 0] ^= ir
+                birreps[numpy.bitwise_and(strsb, 1 << i) > 0] ^= ir
+
+            wfnsym = direct_spin1_symm._id_wfnsym(self, norb, nelec, orbsym, wfnsym)
+            mask = (airreps.reshape(-1,1) ^ birreps) == wfnsym
+
+            if isinstance(fcivec, numpy.ndarray) and fcivec.ndim <= 2:
+                fcivec = [fcivec]
+            if all(abs(c.reshape(na, nb)[mask]).max() < 1e-5 for c in fcivec):
+                raise RuntimeError('Input wfnsym is not consistent with fcivec coefficients')
 
-    guess_wfnsym = direct_spin1_symm.guess_wfnsym
+        verbose = kwargs.get('verbose', None)
+        log = logger.new_logger(self, verbose)
+        log.debug('Guessing CI wfn symmetry = %s', wfnsym)
+        return wfnsym
 
     def kernel(self, h1e, eri, norb, nelec, ci0=None,
                tol=None, lindep=None, max_cycle=None, max_space=None,
                nroots=None, davidson_only=None, pspace_size=None,
                orbsym=None, wfnsym=None, ecore=0, **kwargs):
         if nroots is None: nroots = self.nroots
         if orbsym is None: orbsym = self.orbsym
         if wfnsym is None: wfnsym = self.wfnsym
         if self.verbose >= logger.WARN:
             self.check_sanity()
-        self.norb = norb
-        self.nelec = nelec
 
-        if (not hasattr(orbsym, 'degen_mapping') and
-            getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov')):
-            degen_mapping = map_degeneracy(h1e.diagonal(), orbsym)
-            orbsym = lib.tag_array(orbsym, degen_mapping=degen_mapping)
-
-        wfnsym = self.guess_wfnsym(norb, nelec, ci0, orbsym, wfnsym, **kwargs)
-
-        if wfnsym > 7:
-            # Symmetry broken for Dooh and Coov groups is often observed.
-            # A larger max_space is helpful to reduce the error. Also it is
-            # hard to converge to high precision.
-            if max_space is None and self.max_space == FCISolver.max_space:
-                max_space = 20 + 7 * nroots
-            if tol is None and self.conv_tol == FCISolver.conv_tol:
-                tol = 1e-7
+        if getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov'):
+            raise NotImplementedError
 
         with lib.temporary_env(self, orbsym=orbsym, wfnsym=wfnsym):
-            e, c = direct_spin0.kernel_ms0(self, h1e, eri, norb, nelec, ci0, None,
-                                           tol, lindep, max_cycle, max_space,
-                                           nroots, davidson_only, pspace_size,
-                                           ecore=ecore, **kwargs)
+            e, c = selected_ci.kernel_float_space(self, h1e, eri, norb, nelec, ci0,
+                                                  tol, lindep, max_cycle, max_space,
+                                                  nroots, davidson_only, ecore=ecore,
+                                                  **kwargs)
+            if wfnsym is not None:
+                wfnsym0 = self.guess_wfnsym(norb, nelec, ci0, orbsym, wfnsym, **kwargs)
+                strsa, strsb = c._strs
+                if nroots > 1:
+                    for i, ci in enumerate(c):
+                        ci = addons._symmetrize_wfn(ci, strsa, strsb, self.orbsym, wfnsym0)
+                        c[i] = selected_ci._as_SCIvector(ci, c._strs)
+                else:
+                    ci = addons._symmetrize_wfn(c, strsa, strsb, self.orbsym, wfnsym0)
+                    c = selected_ci._as_SCIvector(ci, c._strs)
+
         self.eci, self.ci = e, c
         return e, c
 
-FCI = FCISolver
+SCI = SelectedCI
+
+
+if __name__ == '__main__':
+    from functools import reduce
+    from pyscf import gto
+    from pyscf import scf
+    from pyscf import symm
+    from pyscf.fci import cistring
+
+    norb, nelec = 7, (4,4)
+    strs = cistring.gen_strings4orblist(range(norb), nelec[0])
+    numpy.random.seed(11)
+    mask = numpy.random.random(len(strs)) > .3
+    strsa = strs[mask]
+    mask = numpy.random.random(len(strs)) > .2
+    strsb = strs[mask]
+    ci_strs = (strsa, strsb)
+    civec_strs = selected_ci._as_SCIvector(numpy.random.random((len(strsa),len(strsb))), ci_strs)
+    orbsym = (numpy.random.random(norb) * 4).astype(int)
+    nn = norb*(norb+1)//2
+    eri = (numpy.random.random(nn*(nn+1)//2)-.2)**3
+
+    ci0 = selected_ci.to_fci(civec_strs, norb, nelec)
+    ci0 = addons.symmetrize_wfn(ci0, norb, nelec, orbsym)
+    civec_strs = selected_ci.from_fci(ci0, civec_strs._strs, norb, nelec)
+    e1 = numpy.dot(civec_strs.ravel(), contract_2e(eri, civec_strs, norb, nelec, orbsym=orbsym).ravel())
+    e2 = numpy.dot(ci0.ravel(), direct_spin1_symm.contract_2e(eri, ci0, norb, nelec, orbsym=orbsym).ravel())
+    print(e1-e2)
+
+    mol = gto.Mole()
+    mol.verbose = 0
+    mol.output = None
+    mol.atom = [
+        ['O', ( 0., 0.    , 0.   )],
+        ['H', ( 0., -0.757, 0.587)],
+        ['H', ( 0., 0.757 , 0.587)],]
+    mol.basis = 'sto-3g'
+    mol.symmetry = 1
+    mol.build()
+    m = scf.RHF(mol).run()
+
+    norb = m.mo_coeff.shape[1]
+    nelec = mol.nelectron - 2
+    h1e = reduce(numpy.dot, (m.mo_coeff.T, scf.hf.get_hcore(mol), m.mo_coeff))
+    eri = ao2mo.incore.full(m._eri, m.mo_coeff)
+    orbsym = symm.label_orb_symm(mol, mol.irrep_id, mol.symm_orb, m.mo_coeff)
+
+    myci = SelectedCI().set(orbsym=orbsym)
+    e1, c1 = myci.kernel(h1e, eri, norb, nelec)
+    myci = direct_spin1_symm.FCISolver().set(orbsym=orbsym)
+    e2, c2 = myci.kernel(h1e, eri, norb, nelec)
+    print(e1 - e2)
+
```

### Comparing `pyscf-2.2.1/pyscf/fci/direct_spin1.py` & `pyscf-2.3.0/pyscf/fci/direct_spin1.py`

 * *Files 3% similar despite different names*

```diff
@@ -49,15 +49,15 @@
 from pyscf.fci import rdm
 from pyscf.fci import spin_op
 from pyscf.fci import addons
 from pyscf.fci.spin_op import contract_ss
 from pyscf.fci.addons import _unpack_nelec
 from pyscf import __config__
 
-libfci = lib.load_library('libfci')
+libfci = cistring.libfci
 
 def contract_1e(f1e, fcivec, norb, nelec, link_index=None):
     '''Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
     vector.
     '''
     fcivec = numpy.asarray(fcivec, order='C')
     link_indexa, link_indexb = _unpack(norb, nelec, link_index)
@@ -136,26 +136,29 @@
                                 ctypes.c_int(norb),
                                 ctypes.c_int(na), ctypes.c_int(nb),
                                 ctypes.c_int(nlinka), ctypes.c_int(nlinkb),
                                 link_indexa.ctypes.data_as(ctypes.c_void_p),
                                 link_indexb.ctypes.data_as(ctypes.c_void_p))
     return ci1.view(FCIvector)
 
-def make_hdiag(h1e, eri, norb, nelec):
+def make_hdiag(h1e, eri, norb, nelec, compress=False):
     '''Diagonal Hamiltonian for Davidson preconditioner
+
+    Kwargs:
+        compress (bool) : whether to remove symmetry forbidden elements
     '''
     if h1e.dtype == numpy.complex128 or eri.dtype == numpy.complex128:
         raise NotImplementedError('Complex Hamiltonian')
 
     neleca, nelecb = _unpack_nelec(nelec)
     h1e = numpy.asarray(h1e, order='C')
     eri = ao2mo.restore(1, eri, norb)
-    occslsta = occslstb = cistring._gen_occslst(range(norb), neleca)
+    occslsta = occslstb = cistring.gen_occslst(range(norb), neleca)
     if neleca != nelecb:
-        occslstb = cistring._gen_occslst(range(norb), nelecb)
+        occslstb = cistring.gen_occslst(range(norb), nelecb)
     na = len(occslsta)
     nb = len(occslstb)
 
     hdiag = numpy.empty(na*nb)
     jdiag = numpy.asarray(numpy.einsum('iijj->ij',eri), order='C')
     kdiag = numpy.asarray(numpy.einsum('ijji->ij',eri), order='C')
     c_h1e = h1e.ctypes.data_as(ctypes.c_void_p)
@@ -194,17 +197,19 @@
 
     if h1e.dtype == numpy.complex128 or eri.dtype == numpy.complex128:
         raise NotImplementedError('Complex Hamiltonian')
 
     neleca, nelecb = _unpack_nelec(nelec)
     h1e = numpy.ascontiguousarray(h1e)
     eri = ao2mo.restore(1, eri, norb)
+    na = cistring.num_strings(norb, neleca)
     nb = cistring.num_strings(norb, nelecb)
     if hdiag is None:
-        hdiag = make_hdiag(h1e, eri, norb, nelec)
+        hdiag = make_hdiag(h1e, eri, norb, nelec, compress=False)
+    assert hdiag.size == na * nb
     if hdiag.size <= np:
         addr = numpy.arange(hdiag.size)
     else:
         try:
             addr = numpy.argpartition(hdiag, np-1)[:np].copy()
         except AttributeError:
             addr = numpy.argsort(hdiag)[:np].copy()
@@ -430,16 +435,15 @@
 
 def _get_init_guess(na, nb, nroots, hdiag, nelec):
     # The "nroots" lowest determinats based on energy expectation value.
     ci0 = []
     neleca, nelecb = _unpack_nelec(nelec)
     if neleca == nelecb and na == nb:
         hdiag = hdiag.reshape(na, na)
-        idx = numpy.arange(na)
-        addrs = numpy.argpartition(hdiag[idx[:,None]>=idx], nroots-1)[:nroots]
+        addrs = numpy.argpartition(lib.pack_tril(hdiag), nroots-1)[:nroots]
         for addr in addrs:
             addra = (int)((2*addr+.25)**.5 - .5 + 1e-7)
             addrb = addr - addra*(addra+1)//2
             x = numpy.zeros((na, na))
             x[addra,addrb] = 1
             ci0.append(x.ravel().view(FCIvector))
     else:
@@ -515,99 +519,105 @@
     if pspace_size is None: pspace_size = fci.pspace_size
     if max_memory is None:
         max_memory = fci.max_memory - lib.current_memory()[0]
     log = logger.new_logger(fci, verbose)
 
     nelec = _unpack_nelec(nelec, fci.spin)
     assert (0 <= nelec[0] <= norb and 0 <= nelec[1] <= norb)
-    link_indexa, link_indexb = _unpack(norb, nelec, link_index)
-    na = link_indexa.shape[0]
-    nb = link_indexb.shape[0]
-
-    if max_memory < na*nb*6*8e-6:
-        log.warn('Not enough memory for FCI solver. '
-                 'The minimal requirement is %.0f MB', na*nb*60e-6)
 
-    hdiag = fci.make_hdiag(h1e, eri, norb, nelec)
-    nroots = min(hdiag.size, nroots)
+    hdiag = fci.make_hdiag(h1e, eri, norb, nelec, compress=False).ravel()
+    if getattr(fci, 'sym_allowed_idx', None):
+        # Remove symmetry forbidden elements
+        sym_idx = numpy.hstack(fci.sym_allowed_idx)
+        civec_size = sym_idx.size
+    else:
+        sym_idx = None
+        civec_size = hdiag.size
 
-    try:
-        addr, h0 = fci.pspace(h1e, eri, norb, nelec, hdiag, max(pspace_size,nroots))
-        if pspace_size > 0:
-            pw, pv = fci.eig(h0)
-        else:
-            pw = pv = None
+    if max_memory < civec_size*6*8e-6:
+        log.warn('Not enough memory for FCI solver. '
+                 'The minimal requirement is %.0f MB', civec_size*60e-6)
 
-        if pspace_size >= na*nb and ci0 is None and not davidson_only:
-            # The degenerated wfn can break symmetry.  The davidson iteration with proper
-            # initial guess doesn't have this issue
-            if na*nb == 1:
-                return pw[0]+ecore, pv[:,0].reshape(1,1).view(FCIvector)
-            elif nroots > 1:
-                civec = numpy.empty((nroots,na*nb))
-                civec[:,addr] = pv[:,:nroots].T
-                return pw[:nroots]+ecore, [c.reshape(na,nb).view(FCIvector) for c in civec]
-            elif abs(pw[0]-pw[1]) > 1e-12:
-                civec = numpy.empty((na*nb))
-                civec[addr] = pv[:,0]
-                return pw[0]+ecore, civec.reshape(na,nb).view(FCIvector)
-    except NotImplementedError:
-        addr = [0]
+    pspace_size = min(hdiag.size, pspace_size)
+    addr = [0]
+    pw = pv = None
+    if pspace_size > 0:
+        try:
+            addr, h0 = fci.pspace(h1e, eri, norb, nelec, hdiag, pspace_size)
+            pspace_size = len(addr)
+        except NotImplementedError:
+            pass
+        pw, pv = fci.eig(h0)
+
+    if pspace_size >= civec_size and ci0 is None and not davidson_only:
+        if nroots > 1:
+            nroots = min(civec_size, nroots)
+            civec = numpy.empty((nroots,civec_size))
+            civec[:,addr] = pv[:,:nroots].T
+            return pw[:nroots]+ecore, civec
+        elif pspace_size == 1 or abs(pw[0]-pw[1]) > 1e-12:
+            # Check degeneracy. Degenerated wfn may break point group symmetry.
+            # Davidson iteration with a proper initial guess can avoid this problem.
+            civec = numpy.empty(civec_size)
+            civec[addr] = pv[:,0]
+            return pw[0]+ecore, civec
     pw = pv = h0 = None
 
-    precond = fci.make_precond(hdiag)
+    if hdiag.size == civec_size:
+        precond = fci.make_precond(hdiag)
+    else:
+        precond = fci.make_precond(hdiag[sym_idx])
 
     h2e = fci.absorb_h1e(h1e, eri, norb, nelec, .5)
     if hop is None:
+        cpu0 = [logger.process_clock(), logger.perf_counter()]
         def hop(c):
-            hc = fci.contract_2e(h2e, c, norb, nelec, (link_indexa,link_indexb))
+            hc = fci.contract_2e(h2e, c, norb, nelec, link_index)
+            cpu0[:] = log.timer_debug1('contract_2e', *cpu0)
             return hc.ravel()
 
-    if ci0 is None:
+    def init_guess():
         if callable(getattr(fci, 'get_init_guess', None)):
-            ci0 = lambda: fci.get_init_guess(norb, nelec, nroots, hdiag)
+            return fci.get_init_guess(norb, nelec, nroots, hdiag)
         else:
-            def ci0():  # lazy initialization to reduce memory footprint
-                x0 = []
-                for i in range(nroots):
-                    x = numpy.zeros(na*nb)
-                    x[addr[i]] = 1
-                    x0.append(x)
-                return x0
+            x0 = []
+            for i in range(min(len(addr), nroots)):
+                x = numpy.zeros(civec_size)
+                x[addr[i]] = 1
+                x0.append(x)
+            return x0
+
+    if ci0 is None:
+        ci0 = init_guess  # lazy initialization to reduce memory footprint
     elif not callable(ci0):
-        if isinstance(ci0, numpy.ndarray) and ci0.size == na*nb:
+        if isinstance(ci0, numpy.ndarray):
             ci0 = [ci0.ravel()]
         else:
             ci0 = [x.ravel() for x in ci0]
-        # Add vectors if not enough initial guess is given
+        if sym_idx is not None and ci0[0].size != civec_size:
+            ci0 = [x[sym_idx] for x in ci0]
+        # If provided initial guess ci0 are accidentally the eigenvectors of the
+        # system, Davidson solver may be failed to find enough roots as it is
+        # unable to generate more subspace basis from ci0. Adding vectors so
+        # initial guess to help Davidson solver generate enough basis.
         if len(ci0) < nroots:
-            if callable(getattr(fci, 'get_init_guess', None)):
-                ci0.extend(fci.get_init_guess(norb, nelec, nroots, hdiag)[len(ci0):])
-            else:
-                for i in range(len(ci0), nroots):
-                    x = numpy.zeros(na*nb)
-                    x[addr[i]] = 1
-                    ci0.append(x)
+            ci0.extend(init_guess()[len(ci0):])
 
     if tol is None: tol = fci.conv_tol
     if lindep is None: lindep = fci.lindep
     if max_cycle is None: max_cycle = fci.max_cycle
     if max_space is None: max_space = fci.max_space
     tol_residual = getattr(fci, 'conv_tol_residual', None)
 
     with lib.with_omp_threads(fci.threads):
-        #e, c = lib.davidson(hop, ci0, precond, tol=fci.conv_tol, lindep=fci.lindep)
         e, c = fci.eig(hop, ci0, precond, tol=tol, lindep=lindep,
                        max_cycle=max_cycle, max_space=max_space, nroots=nroots,
                        max_memory=max_memory, verbose=log, follow_state=True,
                        tol_residual=tol_residual, **kwargs)
-    if nroots > 1:
-        return e+ecore, [ci.reshape(na,nb).view(FCIvector) for ci in c]
-    else:
-        return e+ecore, c.reshape(na,nb).view(FCIvector)
+    return e+ecore, c
 
 def make_pspace_precond(hdiag, pspaceig, pspaceci, addr, level_shift=0):
     # precondition with pspace Hamiltonian, CPL, 169, 463
     def precond(r, e0, x0, *args):
         #h0e0 = h0 - numpy.eye(len(addr))*(e0-level_shift)
         h0e0inv = numpy.dot(pspaceci/(pspaceig-(e0-level_shift)), pspaceci.T)
         hdiaginv = 1/(hdiag - (e0-level_shift))
@@ -766,17 +776,17 @@
 
     @lib.with_doc(absorb_h1e.__doc__)
     def absorb_h1e(self, h1e, eri, norb, nelec, fac=1):
         nelec = _unpack_nelec(nelec, self.spin)
         return absorb_h1e(h1e, eri, norb, nelec, fac)
 
     @lib.with_doc(make_hdiag.__doc__)
-    def make_hdiag(self, h1e, eri, norb, nelec):
+    def make_hdiag(self, h1e, eri, norb, nelec, compress=False):
         nelec = _unpack_nelec(nelec, self.spin)
-        return make_hdiag(h1e, eri, norb, nelec)
+        return make_hdiag(h1e, eri, norb, nelec, compress)
 
     @lib.with_doc(pspace.__doc__)
     def pspace(self, h1e, eri, norb, nelec, hdiag=None, np=400):
         nelec = _unpack_nelec(nelec, self.spin)
         return pspace(h1e, eri, norb, nelec, hdiag, np)
 
     @lib.with_doc(contract_1e.__doc__)
@@ -817,22 +827,31 @@
         return get_init_guess(norb, nelec, nroots, hdiag)
 
     @lib.with_doc(kernel_ms1.__doc__)
     def kernel(self, h1e, eri, norb, nelec, ci0=None,
                tol=None, lindep=None, max_cycle=None, max_space=None,
                nroots=None, davidson_only=None, pspace_size=None,
                orbsym=None, wfnsym=None, ecore=0, **kwargs):
+        if nroots is None: nroots = self.nroots
         if self.verbose >= logger.WARN:
             self.check_sanity()
         self.norb = norb
-        self.nelec = nelec
-        self.eci, self.ci = \
-                kernel_ms1(self, h1e, eri, norb, nelec, ci0, None,
-                           tol, lindep, max_cycle, max_space, nroots,
-                           davidson_only, pspace_size, ecore=ecore, **kwargs)
+        self.nelec = nelec = _unpack_nelec(nelec, self.spin)
+        link_index = _unpack(norb, nelec, None)
+        e, c = kernel_ms1(self, h1e, eri, norb, nelec, ci0, link_index,
+                          tol, lindep, max_cycle, max_space, nroots,
+                          davidson_only, pspace_size, ecore=ecore, **kwargs)
+        self.eci = e
+
+        na = link_index[0].shape[0]
+        nb = link_index[1].shape[0]
+        if nroots > 1:
+            self.ci = [x.reshape(na,nb).view(FCIvector) for x in c]
+        else:
+            self.ci = c.reshape(na,nb).view(FCIvector)
         return self.eci, self.ci
 
     @lib.with_doc(energy.__doc__)
     def energy(self, h1e, eri, fcivec, norb, nelec, link_index=None):
         nelec = _unpack_nelec(nelec, self.spin)
         h2e = self.absorb_h1e(h1e, eri, norb, nelec, .5)
         ci1 = self.contract_2e(h2e, fcivec, norb, nelec, link_index)
@@ -897,17 +916,16 @@
     def large_ci(self, fcivec, norb, nelec,
                  tol=getattr(__config__, 'fci_addons_large_ci_tol', .1),
                  return_strs=getattr(__config__, 'fci_addons_large_ci_return_strs', True)):
         nelec = _unpack_nelec(nelec, self.spin)
         return addons.large_ci(fcivec, norb, nelec, tol, return_strs)
 
     def contract_ss(self, fcivec, norb, nelec):  # noqa: F811
-        from pyscf.fci import spin_op
         nelec = _unpack_nelec(nelec, self.spin)
-        return spin_op.contract_ss(fcivec, norb, nelec)
+        return contract_ss(fcivec, norb, nelec)
 
     def gen_linkstr(self, norb, nelec, tril=True, spin=None):
         if spin is None:
             spin = self.spin
         neleca, nelecb = _unpack_nelec(nelec, spin)
         if tril:
             link_indexa = cistring.gen_linkstr_index_trilidx(range(norb), neleca)
@@ -944,47 +962,7 @@
         neleca, nelecb = _unpack_nelec(nelec, spin)
         link_indexa = link_indexb = cistring.gen_linkstr_index_trilidx(range(norb), neleca)
         if neleca != nelecb:
             link_indexb = cistring.gen_linkstr_index_trilidx(range(norb), nelecb)
         return link_indexa, link_indexb
     else:
         return link_index
-
-
-if __name__ == '__main__':
-    from functools import reduce
-    from pyscf import gto
-    from pyscf import scf
-
-    mol = gto.Mole()
-    mol.verbose = 0
-    mol.output = None#"out_h2o"
-    mol.atom = [
-        ['H', ( 1.,-1.    , 0.   )],
-        ['H', ( 0.,-1.    ,-1.   )],
-        ['H', ( 1.,-0.5   ,-1.   )],
-        #['H', ( 0.,-0.5   ,-1.   )],
-        #['H', ( 0.,-0.5   ,-0.   )],
-        ['H', ( 0.,-0.    ,-1.   )],
-        ['H', ( 1.,-0.5   , 0.   )],
-        ['H', ( 0., 1.    , 1.   )],
-    ]
-
-    mol.basis = {'H': 'sto-3g'}
-    mol.build()
-
-    m = scf.RHF(mol)
-    ehf = m.scf()
-
-    cis = FCISolver(mol)
-    norb = m.mo_coeff.shape[1]
-    nelec = mol.nelectron - 2
-    h1e = reduce(numpy.dot, (m.mo_coeff.T, m.get_hcore(), m.mo_coeff))
-    eri = ao2mo.incore.general(m._eri, (m.mo_coeff,)*4, compact=False)
-    eri = eri.reshape(norb,norb,norb,norb)
-    nea = nelec//2 + 1
-    neb = nelec//2 - 1
-    nelec = (nea, neb)
-
-    e1 = cis.kernel(h1e, eri, norb, nelec, davidson_only=True)[0]
-    print(e1, e1 - -7.7466756526056004)
-
```

### Comparing `pyscf-2.2.1/pyscf/fci/direct_spin1_cyl_sym.py` & `pyscf-2.3.0/pyscf/fci/direct_spin0_symm.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 #!/usr/bin/env python
-# Copyright 2014-2021 The PySCF Developers. All Rights Reserved.
+# Copyright 2014-2019 The PySCF Developers. All Rights Reserved.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
@@ -13,265 +13,197 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
 # Author: Qiming Sun <osirpt.sun@gmail.com>
 #
 
 '''
-Cylindrical symmetry
+Different FCI solvers are implemented to support different type of symmetry.
+                    Symmetry
+File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
+direct_spin0_symm   Yes           Yes            Yes                Yes
+direct_spin1_symm   Yes           No             Yes                Yes
+direct_spin0        No            Yes            Yes                Yes
+direct_spin1        No            No             Yes                Yes
+direct_uhf          No            No             Yes                No
+direct_nosym        No            No             No**               Yes
 
-This module is much slower than direct_spin1_symm.
-
-In this implementation, complex orbitals is used to construct the Hamiltonian.
-FCI wavefunction (called complex wavefunction here) is solved using the complex
-Hamiltonian. For 2D irreps, the real part and the imaginary part of the complex
-FCI wavefunction are identical to the Ex and Ey wavefunction obtained from
-direct_spin1_symm module. However, any observables from the complex FCI
-wavefunction should have an indentical one from either Ex or Ey wavefunction
-of direct_spin1_symm.
+*  Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)
+** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...
 '''
 
+import sys
+import ctypes
 import numpy
 from pyscf import lib
 from pyscf import ao2mo
 from pyscf.lib import logger
 from pyscf import symm
 from pyscf.scf.hf_symm import map_degeneracy
 from pyscf.fci import cistring
+from pyscf.fci import direct_spin0
 from pyscf.fci import direct_spin1
 from pyscf.fci import direct_spin1_symm
-from pyscf.fci.direct_spin1_symm import (_sv_associated_det,
-                                         _strs_angular_momentum,
-                                         _cyl_sym_orbital_rotation)
-from pyscf.fci import direct_nosym
 from pyscf.fci import addons
 from pyscf import __config__
 
+libfci = direct_spin1.libfci
+
+def contract_2e(eri, fcivec, norb, nelec, link_index=None, orbsym=None, wfnsym=0):
+    link_index = direct_spin1._unpack(norb, nelec, link_index)
+    if isinstance(link_index, numpy.ndarray):
+        # For backward compatibility
+        link_index = (link_index, link_index)
+    return direct_spin1_symm.contract_2e(eri, fcivec, norb, nelec, link_index,
+                                         orbsym, wfnsym)
+
+energy = direct_spin1_symm.energy
+kernel = direct_spin1_symm.kernel
+
+make_rdm1 = direct_spin0.make_rdm1
+make_rdm1s = direct_spin0.make_rdm1s
+make_rdm12 = direct_spin0.make_rdm12
+
+trans_rdm1s = direct_spin0.trans_rdm1s
+trans_rdm1 = direct_spin0.trans_rdm1
+trans_rdm12 = direct_spin0.trans_rdm12
+
 def get_init_guess(norb, nelec, nroots, hdiag, orbsym, wfnsym=0):
     neleca, nelecb = direct_spin1._unpack_nelec(nelec)
-    strsa = strsb = cistring.gen_strings4orblist(range(norb), neleca)
-    airreps_d2h = birreps_d2h = direct_spin1_symm._gen_strs_irrep(strsa, orbsym)
-    a_ls = b_ls = _strs_angular_momentum(strsa, orbsym)
-    if neleca != nelecb:
-        strsb = cistring.gen_strings4orblist(range(norb), nelecb)
-        birreps_d2h = direct_spin1_symm._gen_strs_irrep(strsb, orbsym)
-        b_ls = _strs_angular_momentum(strsb, orbsym)
+    assert (neleca == nelecb)
+
+    strsa = cistring.gen_strings4orblist(range(norb), neleca)
+    na = len(strsa)
+    airreps = direct_spin1_symm._gen_strs_irrep(strsa, orbsym)
+    hdiag = hdiag.reshape(na,na)
+
+    sym_allowed = (airreps[:,None] ^ airreps) == wfnsym
+    idx = numpy.arange(na)
+    sym_allowed[idx[:,None] < idx] = False
+    idx_a, idx_b = numpy.where(sym_allowed)
+
+    ci0 = []
+    for k in numpy.argpartition(hdiag[idx_a,idx_b], nroots-1)[:nroots]:
+        addra, addrb = idx_a[k], idx_b[k]
+        x = numpy.zeros((na, na))
+        if addra == addrb:
+            x[addra,addrb] = 1
+        else:
+            x[addra,addrb] = x[addrb,addra] = numpy.sqrt(.5)
+        ci0.append(x.ravel().view(direct_spin1.FCIvector))
+
+    if len(ci0) == 0:
+        raise RuntimeError(f'Initial guess for symmetry {wfnsym} not found')
+    return ci0
+
+def get_init_guess_cyl_sym(norb, nelec, nroots, hdiag, orbsym, wfnsym=0):
+    neleca, nelecb = direct_spin1._unpack_nelec(nelec)
+    strsa = cistring.gen_strings4orblist(range(norb), neleca)
+    airreps_d2h = direct_spin1_symm._gen_strs_irrep(strsa, orbsym)
+    a_ls = direct_spin1_symm._strs_angular_momentum(strsa, orbsym)
 
     wfnsym_in_d2h = wfnsym % 10
     wfn_momentum = symm.basis.linearmole_irrep2momentum(wfnsym)
     na = len(strsa)
-    nb = len(strsb)
-    hdiag = hdiag.reshape(na,nb)
+    hdiag = hdiag.reshape(na,na)
     degen = orbsym.degen_mapping
     ci0 = []
     iroot = 0
     wfn_ungerade = wfnsym_in_d2h >= 4
     a_ungerade = airreps_d2h >= 4
-    b_ungerade = birreps_d2h >= 4
-    sym_allowed = a_ungerade[:,None] == b_ungerade ^ wfn_ungerade
+    sym_allowed = a_ungerade[:,None] == a_ungerade ^ wfn_ungerade
     # total angular momentum == wfn_momentum
-    sym_allowed &= a_ls[:,None] == wfn_momentum - b_ls
-    if neleca == nelecb and na == nb:
-        idx = numpy.arange(na)
-        sym_allowed[idx[:,None] < idx] = False
-    idx_a, idx_b = numpy.where(sym_allowed)
+    sym_allowed &= a_ls[:,None] == wfn_momentum - a_ls
+    idx = numpy.arange(na)
+    sym_allowed[idx[:,None] < idx] = False
 
+    idx_a, idx_b = numpy.where(sym_allowed)
     for k in hdiag[idx_a,idx_b].argsort():
         addra, addrb = idx_a[k], idx_b[k]
-        x = numpy.zeros((na, nb))
-        x[addra, addrb] = 1.
-        if wfnsym in (0, 1, 4, 5):
-            addra1, sign_a = _sv_associated_det(strsa[addra], degen)
-            addrb1, sign_b = _sv_associated_det(strsb[addrb], degen)
-            # If (E+) and (E-) are associated determinants
-            # (E+)(E-') + (E-)(E+') => A1
-            # (E+)(E-') - (E-)(E+') => A2
-            if wfnsym in (0, 5):  # A1g, A1u
-                # ensure <|sigma_v|> = 1
-                x[addra1,addrb1] += sign_a * sign_b
-            elif wfnsym in (1, 4):  # A2g, A2u
-                # ensure <|sigma_v|> = -1
-                x[addra1,addrb1] -= sign_a * sign_b
-
-        norm = numpy.linalg.norm(x)
-        if norm < 1e-3:
-            continue
+        ca = direct_spin1_symm._cyl_sym_csf2civec(strsa, addra, orbsym, degen)
+        cb = direct_spin1_symm._cyl_sym_csf2civec(strsa, addrb, orbsym, degen)
+        if wfn_momentum > 0 or wfnsym in (0, 5):
+            x = ca.real[:,None] * cb.real
+            x-= ca.imag[:,None] * cb.imag
+        else:
+            x = ca.imag[:,None] * cb.real
+            x+= ca.real[:,None] * cb.imag
+        if addra == addrb:
+            norm = numpy.linalg.norm(x)
+        else:
+            x = x + x.T
+            norm = numpy.linalg.norm(x)
+            if norm < 1e-3:
+                continue
         x *= 1./norm
         ci0.append(x.ravel().view(direct_spin1.FCIvector))
         iroot += 1
         if iroot >= nroots:
             break
 
     if len(ci0) == 0:
         raise RuntimeError(f'Initial guess for symmetry {wfnsym} not found')
     return ci0
 
 
-def _guess_wfnsym(civec, strsa, strsb, orbsym):
-    degen_mapping = orbsym.degen_mapping
-    idx = abs(civec).argmax()
-    na = strsa.size
-    nb = strsb.size
-    civec = civec.reshape(na,nb)
-    addra = idx // nb
-    addrb = idx % nb
-    addra1, sign_a = _sv_associated_det(strsa[addra], degen_mapping)
-    addrb1, sign_b = _sv_associated_det(strsb[addrb], degen_mapping)
-
-    airreps_d2h = direct_spin1_symm._gen_strs_irrep(strsa[[addra]], orbsym)
-    birreps_d2h = direct_spin1_symm._gen_strs_irrep(strsb[[addrb]], orbsym)
-    a_ls = _strs_angular_momentum(strsa[[addra]], orbsym)
-    b_ls = _strs_angular_momentum(strsb[[addrb]], orbsym)
-    a_ungerade = airreps_d2h >= 4
-    b_ungerade = birreps_d2h >= 4
-    wfn_ungerade = a_ungerade[0] ^ b_ungerade[0]
-    wfn_momentum = a_ls[0] + b_ls[0]
-
-    if wfn_momentum == 0:
-        # For A1g and A1u, CI coefficient and its sigma_v associated one have
-        # the same sign
-        if sign_a*sign_b * civec[addra,addrb] * civec[addra1,addrb1] > 1e-6: # A1
-            if wfn_ungerade:
-                wfnsym = 5
-            else:
-                wfnsym = 0
-        else:
-            # For A2g and A2u, CI coefficient and its sigma_v associated one
-            # have opposite signs
-            if wfn_ungerade:
-                wfnsym = 4
-            else:
-                wfnsym = 1
-
-    elif wfn_momentum % 2 == 1:
-        if wfn_momentum > 0:  # Ex
-            if wfn_ungerade:
-                wfnsym = 7
-            else:
-                wfnsym = 2
-        else:  # Ey
-            if wfn_ungerade:
-                wfnsym = 6
-            else:
-                wfnsym = 3
-    else:
-        if wfn_momentum > 0:  # Ex
-            if wfn_ungerade:
-                wfnsym = 5
-            else:
-                wfnsym = 0
-        else:  # Ey
-            if wfn_ungerade:
-                wfnsym = 4
-            else:
-                wfnsym = 1
-
-    wfnsym += (abs(wfn_momentum) // 2) * 10
-    return wfnsym
-
-def guess_wfnsym(solver, norb, nelec, fcivec=None, orbsym=None, wfnsym=None, **kwargs):
-    '''
-    Guess point group symmetry of the FCI wavefunction.  If fcivec is
-    given, the symmetry of fcivec is used.  Otherwise the symmetry is
-    same to the HF determinant.
-    '''
-    if orbsym is None:
-        orbsym = solver.orbsym
-
-    verbose = kwargs.get('verbose', None)
-    log = logger.new_logger(solver, verbose)
-
-    neleca, nelecb = nelec = direct_spin1._unpack_nelec(nelec, solver.spin)
-    if fcivec is None or not hasattr(orbsym, 'degen_mapping'):
-        # guess wfnsym if initial guess is not given
-        wfnsym = direct_spin1_symm._id_wfnsym(solver, norb, nelec, orbsym, wfnsym)
-        log.debug('Guessing CI wfn symmetry = %s', wfnsym)
-
-    else:
-        strsa = strsb = cistring.gen_strings4orblist(range(norb), neleca)
-        if neleca != nelecb:
-            strsb = cistring.gen_strings4orblist(range(norb), nelecb)
-
-        if not isinstance(fcivec, numpy.ndarray) or fcivec.ndim > 2:
-            fcivec = fcivec[0]
-        wfnsym1 = _guess_wfnsym(fcivec, strsa, strsb, orbsym)
-
-        if (wfnsym is not None and
-            wfnsym1 != direct_spin1_symm._id_wfnsym(solver, norb, nelec, orbsym, wfnsym)):
-            raise RuntimeError(f'Input wfnsym {wfnsym} is not consistent with '
-                               f'fcivec symmetry {wfnsym1}')
-        wfnsym = wfnsym1
-    return wfnsym
-
+class FCISolver(direct_spin0.FCISolver):
 
-class FCISolver(direct_spin1_symm.FCISolver):
+    davidson_only = getattr(__config__, 'fci_direct_spin1_symm_FCI_davidson_only', True)
+    pspace_size = getattr(__config__, 'fci_direct_spin1_symm_FCI_pspace_size', 400)
 
-    def contract_1e(self, f1e, fcivec, norb, nelec, link_index=None, **kwargs):
-        return direct_nosym.contract_1e(f1e, fcivec, norb, nelec, link_index)
+    def __init__(self, mol=None, **kwargs):
+        # wfnsym will be guessed based on initial guess if it is None
+        self.wfnsym = None
+        self.sym_allowed_idx = None
+        direct_spin0.FCISolver.__init__(self, mol, **kwargs)
+
+    absorb_h1e = direct_spin1.FCISolver.absorb_h1e
+
+    dump_flags = direct_spin1_symm.FCISolver.dump_flags
+    make_hdiag = direct_spin1_symm.FCISolver.make_hdiag
+    pspace = direct_spin1_symm.FCISolver.pspace
+    contract_1e = direct_spin1_symm.FCISolver.contract_1e
+    contract_ss = direct_spin1_symm.FCISolver.contract_ss
+    guess_wfnsym = direct_spin1_symm.guess_wfnsym
+    kernel = direct_spin1_symm.FCISolver.kernel
 
     def contract_2e(self, eri, fcivec, norb, nelec, link_index=None,
                     orbsym=None, wfnsym=None, **kwargs):
-        return direct_nosym.contract_2e(eri, fcivec, norb, nelec, link_index)
-
-    def get_init_guess(self, norb, nelec, nroots, hdiag):
-        wfnsym = direct_spin1_symm._id_wfnsym(self, norb, nelec, self.orbsym, self.wfnsym)
-        return get_init_guess(norb, nelec, nroots, hdiag, self.orbsym, wfnsym)
-
-    absorb_h1e = direct_nosym.FCISolver.absorb_h1e
-    make_hdiag = direct_nosym.FCISolver.make_hdiag
-    pspace = direct_spin1.FCISolver.pspace
-    guess_wfnsym = guess_wfnsym
-
-    def make_rdm12(self, fcivec, norb, nelec, link_index=None, reorder=True):
-        nelec = direct_spin1._unpack_nelec(nelec, self.spin)
-        dm1, dm2 = direct_spin1.make_rdm12(fcivec, norb, nelec, link_index, reorder)
-        orbsym = self.orbsym
-        degen_mapping = self.orbsym.degen_mapping
-        u = _cyl_sym_orbital_rotation(orbsym, degen_mapping)
-        dm1 = u.conj().T.dot(dm1).dot(u)
-        dm2 = lib.einsum('pqrs,pi,qj,rk,sl->ijkl', dm2, u.conj(), u, u.conj(), u)
-        return dm1.real.copy(), dm2.real.copy()
-
-    def kernel(self, h1e, eri, norb, nelec, ci0=None,
-               tol=None, lindep=None, max_cycle=None, max_space=None,
-               nroots=None, davidson_only=None, pspace_size=None,
-               orbsym=None, wfnsym=None, ecore=0, **kwargs):
-        if nroots is None: nroots = self.nroots
         if orbsym is None: orbsym = self.orbsym
         if wfnsym is None: wfnsym = self.wfnsym
-        if self.verbose >= logger.WARN:
-            self.check_sanity()
-        self.norb = norb
-        self.nelec = nelec
-
-        if not hasattr(orbsym, 'degen_mapping'):
-            degen_mapping = map_degeneracy(h1e.diagonal(), orbsym)
-            orbsym = lib.tag_array(orbsym, degen_mapping=degen_mapping)
-        self.orbsym = orbsym
-        u = _cyl_sym_orbital_rotation(orbsym, orbsym.degen_mapping)
-        wfnsym = self.guess_wfnsym(norb, nelec, ci0, orbsym, wfnsym, **kwargs)
-
-        h1e = u.dot(h1e).dot(u.conj().T)
-        eri = ao2mo.restore(1, eri, norb)
-        eri = lib.einsum('pqrs,ip,jq,kr,ls->ijkl', eri, u, u.conj(), u, u.conj())
-        assert abs(h1e.imag).max() < 1e-12, 'Cylindrical symmetry broken'
-        assert abs(eri.imag).max() < 1e-12, 'Cylindrical symmetry broken'
-        h1e = h1e.real.copy()
-        # Note: although eri is real, it does not have the permutation relation
-        # (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)
-        # The nosym version fci contraction is required
-        eri = eri.real.copy()
-
-        neleca, nelecb = direct_spin1._unpack_nelec(nelec)
-        link_indexa = cistring.gen_linkstr_index(range(norb), neleca)
-        link_indexb = cistring.gen_linkstr_index(range(norb), nelecb)
-        with lib.temporary_env(self, orbsym=orbsym, wfnsym=wfnsym):
-            e, c = direct_spin1.kernel_ms1(self, h1e, eri, norb, nelec, ci0,
-                                           (link_indexa,link_indexb),
-                                           tol, lindep, max_cycle, max_space,
-                                           nroots, davidson_only, pspace_size,
-                                           ecore=ecore, **kwargs)
+        wfnsym = direct_spin1_symm._id_wfnsym(self, norb, nelec, orbsym, wfnsym)
+        nelec = direct_spin1._unpack_nelec(nelec, self.spin)
+        civec = contract_2e(eri, fcivec, norb, nelec, link_index, orbsym, wfnsym)
+        na = cistring.num_strings(norb, nelec[0])
+        if civec.size != na**2:
+            s_idx = numpy.hstack(self.sym_allowed_idx)
+            x, y = divmod(s_idx, na)
+            ci1 = numpy.empty(na**2)
+            ci1[y*na+x] = civec
+            civec += ci1[s_idx]
+            civec *= .5
+        else:
+            civec = lib.transpose_sum(civec.reshape(na,na), inplace=True)
+            civec *= .5
+        return civec
 
-        self.eci, self.ci = e, c
-        return e, c
+    def get_init_guess(self, norb, nelec, nroots, hdiag, orbsym=None, wfnsym=None):
+        if orbsym is None: orbsym = self.orbsym
+        if wfnsym is None:
+            wfnsym = direct_spin1_symm._id_wfnsym(
+                self, norb, nelec, orbsym, self.wfnsym)
+        s_idx = numpy.hstack(self.sym_allowed_idx)
+        if getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov'):
+            ci0 = get_init_guess_cyl_sym(
+                norb, nelec, nroots, hdiag, orbsym, wfnsym)
+        else:
+            nelec = direct_spin1._unpack_nelec(nelec, self.spin)
+            na = cistring.num_strings(norb, nelec[0])
+            if hdiag.size != na * na:
+                hdiag, hdiag0 = numpy.empty(na*na), hdiag
+                hdiag[:] = 1e9
+                hdiag[numpy.hstack(self.sym_allowed_idx)] = hdiag0
+            ci0 = get_init_guess(norb, nelec, nroots, hdiag.ravel(),
+                                 orbsym, wfnsym)
+        return [x[s_idx] for x in ci0]
 
 FCI = FCISolver
```

### Comparing `pyscf-2.2.1/pyscf/fci/direct_spin1_symm.py` & `pyscf-2.3.0/pyscf/fci/direct_spin1_symm.py`

 * *Files 18% similar despite different names*

```diff
@@ -30,33 +30,31 @@
 *  Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)
 ** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...
 '''
 
 import sys
 import ctypes
 import numpy
+import numpy as np
 from pyscf import ao2mo
 from pyscf import lib
 from pyscf.lib import logger
 from pyscf import symm
 from pyscf.scf.hf_symm import map_degeneracy
 from pyscf.fci import cistring
 from pyscf.fci import direct_spin1
 from pyscf.fci import addons
 from pyscf.fci.spin_op import contract_ss
 from pyscf.fci.addons import _unpack_nelec
 from pyscf import __config__
 
-libfci = lib.load_library('libfci')
+libfci = direct_spin1.libfci
 
 TOTIRREPS = 8
 
-def contract_1e(f1e, fcivec, norb, nelec, link_index=None, orbsym=None):
-    return direct_spin1.contract_1e(f1e, fcivec, norb, nelec, link_index)
-
 # Note eri is NOT the 2e hamiltonian matrix, the 2e hamiltonian is
 # h2e = eri_{pq,rs} p^+ q r^+ s
 #     = (pq|rs) p^+ r^+ s q - (pq|rs) \delta_{qr} p^+ s
 # so eri is defined as
 #       eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)
 # to restore the symmetry between pq and rs,
 #       eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]
@@ -66,77 +64,85 @@
         return direct_spin1.contract_2e(eri, fcivec, norb, nelec, link_index)
 
     eri = ao2mo.restore(4, eri, norb)
     neleca, nelecb = _unpack_nelec(nelec)
     link_indexa, link_indexb = direct_spin1._unpack(norb, nelec, link_index)
     na, nlinka = link_indexa.shape[:2]
     nb, nlinkb = link_indexb.shape[:2]
-    eri_irs, rank_eri, irrep_eri = reorder_eri(eri, norb, orbsym)
 
+    eri_irs, rank_eri, irrep_eri = reorder_eri(eri, norb, orbsym)
     strsa = cistring.gen_strings4orblist(range(norb), neleca)
     aidx, link_indexa = gen_str_irrep(strsa, orbsym, link_indexa, rank_eri, irrep_eri)
+    nas = np.array([x.size for x in aidx], dtype=np.int32)
     if neleca == nelecb:
         bidx, link_indexb = aidx, link_indexa
+        nbs = nas
     else:
         strsb = cistring.gen_strings4orblist(range(norb), nelecb)
         bidx, link_indexb = gen_str_irrep(strsb, orbsym, link_indexb, rank_eri, irrep_eri)
+        nbs = np.array([x.size for x in bidx], dtype=np.int32)
 
-    Tirrep = ctypes.c_void_p*TOTIRREPS
-    linka_ptr = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in link_indexa])
-    linkb_ptr = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in link_indexb])
-    eri_ptrs = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in eri_irs])
-    dimirrep = (ctypes.c_int*TOTIRREPS)(*[x.shape[0] for x in eri_irs])
-    fcivec_shape = fcivec.shape
-    fcivec = fcivec.reshape((na,nb), order='C')
-    ci1new = numpy.zeros_like(fcivec)
-    nas = (ctypes.c_int*TOTIRREPS)(*[x.size for x in aidx])
-    nbs = (ctypes.c_int*TOTIRREPS)(*[x.size for x in bidx])
+    eri_ir_dims = np.array([x.shape[0] for x in eri_irs], dtype=np.int32)
+    eri_irs = np.hstack([x.ravel() for x in eri_irs])
 
-    # aa, ab
-    ci0 = []
-    ci1 = []
     wfnsym_in_d2h = wfnsym % 10
-    for ir in range(TOTIRREPS):
-        ma, mb = aidx[ir].size, bidx[wfnsym_in_d2h ^ ir].size
-        ci0.append(numpy.zeros((ma,mb)))
-        ci1.append(numpy.zeros((ma,mb)))
-        if ma > 0 and mb > 0:
-            lib.take_2d(fcivec, aidx[ir], bidx[wfnsym_in_d2h ^ ir], out=ci0[ir])
-    ci0_ptrs = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in ci0])
-    ci1_ptrs = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in ci1])
-    libfci.FCIcontract_2e_symm1(eri_ptrs, ci0_ptrs, ci1_ptrs,
-                                ctypes.c_int(norb), nas, nbs,
-                                ctypes.c_int(nlinka), ctypes.c_int(nlinkb),
-                                linka_ptr, linkb_ptr, dimirrep,
-                                ctypes.c_int(wfnsym_in_d2h))
-    for ir in range(TOTIRREPS):
-        if ci0[ir].size > 0:
-            lib.takebak_2d(ci1new, ci1[ir], aidx[ir], bidx[wfnsym_in_d2h ^ ir])
+    orbsym_in_d2h = np.asarray(orbsym) % 10
+    max_ir = orbsym_in_d2h.max()
+    if max_ir >= 4:
+        nirreps = 8
+    elif max_ir >= 2:
+        nirreps = 4
+    elif max_ir >= 1:
+        nirreps = 2
+    else:
+        nirreps = 1
 
-    # bb, ba
-    ci0T = []
-    for ir in range(TOTIRREPS):
-        mb, ma = bidx[ir].size, aidx[wfnsym_in_d2h ^ ir].size
-        ci0T.append(numpy.zeros((mb,ma)))
-        if ma > 0 and mb > 0:
-            lib.transpose(ci0[wfnsym_in_d2h ^ ir], out=ci0T[ir])
-    ci0, ci0T = ci0T, None
-    ci1 = [numpy.zeros_like(x) for x in ci0]
-    ci0_ptrs = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in ci0])
-    ci1_ptrs = Tirrep(*[x.ctypes.data_as(ctypes.c_void_p) for x in ci1])
-    libfci.FCIcontract_2e_symm1(eri_ptrs, ci0_ptrs, ci1_ptrs,
-                                ctypes.c_int(norb), nbs, nas,
-                                ctypes.c_int(nlinkb), ctypes.c_int(nlinka),
-                                linkb_ptr, linka_ptr, dimirrep,
-                                ctypes.c_int(wfnsym_in_d2h))
-    for ir in range(TOTIRREPS):
-        if ci0[ir].size > 0:
-            lib.takebak_2d(ci1new, lib.transpose(ci1[ir]),
-                           aidx[wfnsym_in_d2h ^ ir], bidx[ir])
-    return ci1new.reshape(fcivec_shape).view(direct_spin1.FCIvector)
+    if fcivec.size == na * nb:
+        fcivec_shape = fcivec.shape
+        fcivec = fcivec.reshape((na,nb), order='C')
+        ci0 = []
+        for ir in range(nirreps):
+            ma, mb = aidx[ir].size, bidx[wfnsym_in_d2h ^ ir].size
+            ci0.append(np.zeros((ma, mb)))
+            if ma * mb > 0:
+                lib.take_2d(fcivec, aidx[ir], bidx[wfnsym_in_d2h ^ ir], out=ci0[ir])
+        ci_size = np.array([x.size for x in ci0], dtype=np.int32)
+        ci0 = np.hstack([x.ravel() for x in ci0])
+    else:
+        ci_size = []
+        for ir in range(nirreps):
+            ma, mb = aidx[ir].size, bidx[wfnsym_in_d2h ^ ir].size
+            ci_size.append(ma * mb)
+        ci_size = np.array(ci_size, dtype=np.int32)
+        ci0 = fcivec
+    ci1 = np.zeros_like(ci0)
+
+    libfci.FCIcontract_2e_symm1(
+        eri_irs.ctypes.data_as(ctypes.c_void_p),
+        ci0.ctypes.data_as(ctypes.c_void_p),
+        ci1.ctypes.data_as(ctypes.c_void_p),
+        eri_ir_dims.ctypes.data_as(ctypes.c_void_p),
+        ci_size.ctypes.data_as(ctypes.c_void_p),
+        nas.ctypes.data_as(ctypes.c_void_p),
+        nbs.ctypes.data_as(ctypes.c_void_p),
+        link_indexa.ctypes.data_as(ctypes.c_void_p),
+        link_indexb.ctypes.data_as(ctypes.c_void_p),
+        ctypes.c_int(norb), ctypes.c_int(nlinka), ctypes.c_int(nlinkb),
+        ctypes.c_int(nirreps), ctypes.c_int(wfnsym_in_d2h))
+
+    if fcivec.size == na * nb:
+        ci_loc = np.append(0, np.cumsum(ci_size))
+        ci1new = np.zeros_like(fcivec)
+        for ir in range(nirreps):
+            if ci_size[ir] > 0:
+                ma, mb = aidx[ir].size, bidx[wfnsym_in_d2h ^ ir].size
+                buf = ci1[ci_loc[ir]:ci_loc[ir+1]].reshape(ma, mb)
+                lib.takebak_2d(ci1new, buf, aidx[ir], bidx[wfnsym_in_d2h ^ ir])
+        ci1 = ci1new.reshape(fcivec_shape)
+    return ci1.view(direct_spin1.FCIvector)
 
 
 def kernel(h1e, eri, norb, nelec, ci0=None, level_shift=1e-3, tol=1e-10,
            lindep=1e-14, max_cycle=50, max_space=12, nroots=1,
            davidson_only=False, pspace_size=400, orbsym=None, wfnsym=None,
            ecore=0, **kwargs):
     assert (len(orbsym) == norb)
@@ -171,15 +177,15 @@
 trans_rdm1s = direct_spin1.trans_rdm1s
 trans_rdm1 = direct_spin1.trans_rdm1
 trans_rdm12 = direct_spin1.trans_rdm12
 
 def energy(h1e, eri, fcivec, norb, nelec, link_index=None, orbsym=None, wfnsym=0):
     h2e = direct_spin1.absorb_h1e(h1e, eri, norb, nelec) * .5
     ci1 = contract_2e(h2e, fcivec, norb, nelec, link_index, orbsym, wfnsym)
-    return numpy.dot(fcivec.ravel(), ci1.ravel())
+    return np.dot(fcivec.ravel(), ci1.ravel())
 
 def _id_wfnsym(cisolver, norb, nelec, orbsym, wfnsym):
     '''Guess wfnsym or convert wfnsym to symmetry ID if it's a symmetry label'''
     gpname = getattr(cisolver.mol, 'groupname', None)
     if wfnsym is None:
         neleca, nelecb = _unpack_nelec(nelec)
         wfnsym = 0  # Ag, A1 or A
@@ -192,58 +198,68 @@
             wfnsym += (l//2) * 10
     elif isinstance(wfnsym, str):
         wfnsym = symm.irrep_name2id(gpname, wfnsym)
     return wfnsym
 
 def _gen_strs_irrep(strs, orbsym):
     # % 10 to convert irrep_ids to irrep of D2h
-    orbsym_in_d2h = numpy.asarray(orbsym) % 10
-    irreps = numpy.zeros(len(strs), dtype=numpy.int32)
+    orbsym_in_d2h = np.asarray(orbsym) % 10
+    irreps = np.zeros(len(strs), dtype=np.int32)
     if isinstance(strs, cistring.OIndexList):
         nocc = strs.shape[1]
         for i in range(nocc):
             irreps ^= orbsym_in_d2h[strs[:,i]]
     else:
         for i, ir in enumerate(orbsym_in_d2h):
-            irreps[numpy.bitwise_and(strs, 1 << i) > 0] ^= ir
+            irreps[np.bitwise_and(strs, 1 << i) > 0] ^= ir
     return irreps
 
 def _get_init_guess(airreps, birreps, nroots, hdiag, nelec, orbsym, wfnsym=0):
     neleca, nelecb = _unpack_nelec(nelec)
     na = len(airreps)
     nb = len(birreps)
     hdiag = hdiag.reshape(na,nb)
-    ci0 = []
-    iroot = 0
     sym_allowed = airreps[:,None] == wfnsym ^ birreps
     if neleca == nelecb and na == nb:
-        idx = numpy.arange(na)
+        idx = np.arange(na)
         sym_allowed[idx[:,None] < idx] = False
-    idx_a, idx_b = numpy.where(sym_allowed)
-    for k in hdiag[idx_a,idx_b].argsort():
+    idx_a, idx_b = np.where(sym_allowed)
+
+    ci0 = []
+    for k in np.argpartition(hdiag[idx_a,idx_b], nroots-1)[:nroots]:
         addra, addrb = idx_a[k], idx_b[k]
-        x = numpy.zeros((na, nb))
+        x = np.zeros((na, nb))
         x[addra,addrb] = 1
         ci0.append(x.ravel().view(direct_spin1.FCIvector))
-        iroot += 1
-        if iroot >= nroots:
-            break
 
     if len(ci0) == 0:
         raise RuntimeError(f'Initial guess for symmetry {wfnsym} not found')
     return ci0
 
 def get_init_guess(norb, nelec, nroots, hdiag, orbsym, wfnsym=0):
     neleca, nelecb = _unpack_nelec(nelec)
-    strsa = cistring.gen_strings4orblist(range(norb), neleca)
-    airreps = birreps = _gen_strs_irrep(strsa, orbsym)
-    if neleca != nelecb:
-        strsb = cistring.gen_strings4orblist(range(norb), nelecb)
-        birreps = _gen_strs_irrep(strsb, orbsym)
-    return _get_init_guess(airreps, birreps, nroots, hdiag, nelec, orbsym, wfnsym)
+    na = cistring.num_strings(norb, neleca)
+    nb = cistring.num_strings(norb, nelecb)
+    if hdiag.size == na * nb:
+        strsa = cistring.gen_strings4orblist(range(norb), neleca)
+        airreps = birreps = _gen_strs_irrep(strsa, orbsym)
+        if neleca != nelecb:
+            strsb = cistring.gen_strings4orblist(range(norb), nelecb)
+            birreps = _gen_strs_irrep(strsb, orbsym)
+        return _get_init_guess(airreps, birreps, nroots, hdiag, nelec, orbsym, wfnsym)
+
+    ci0 = []
+    for k in np.argpartition(hdiag, nroots-1)[:nroots]:
+        x = np.zeros_like(hdiag)
+        x[k] = 1.
+        ci0.append(x.ravel().view(direct_spin1.FCIvector))
+
+    if len(ci0) == 0:
+        raise RuntimeError(f'Initial guess for symmetry {wfnsym} not found')
+    return ci0
 
 def get_init_guess_cyl_sym(norb, nelec, nroots, hdiag, orbsym, wfnsym=0):
     neleca, nelecb = _unpack_nelec(nelec)
     strsa = strsb = cistring.gen_strings4orblist(range(norb), neleca)
     airreps_d2h = birreps_d2h = _gen_strs_irrep(strsa, orbsym)
     a_ls = b_ls = _strs_angular_momentum(strsa, orbsym)
     if neleca != nelecb:
@@ -262,17 +278,17 @@
     wfn_ungerade = wfnsym_in_d2h >= 4
     a_ungerade = airreps_d2h >= 4
     b_ungerade = birreps_d2h >= 4
     sym_allowed = a_ungerade[:,None] == b_ungerade ^ wfn_ungerade
     # total angular momentum == wfn_momentum
     sym_allowed &= a_ls[:,None] == wfn_momentum - b_ls
     if neleca == nelecb and na == nb:
-        idx = numpy.arange(na)
+        idx = np.arange(na)
         sym_allowed[idx[:,None] < idx] = False
-    idx_a, idx_b = numpy.where(sym_allowed)
+    idx_a, idx_b = np.where(sym_allowed)
 
     for k in hdiag[idx_a,idx_b].argsort():
         addra, addrb = idx_a[k], idx_b[k]
         ca = _cyl_sym_csf2civec(strsa, addra, orbsym, degen_mapping)
         cb = _cyl_sym_csf2civec(strsb, addrb, orbsym, degen_mapping)
         if wfnsym in (0, 1, 4, 5):
             addra1, sign_a = _sv_associated_det(strsa[addra], degen_mapping)
@@ -290,27 +306,27 @@
                 cb = _cyl_sym_csf2civec(strsb, addrb1, orbsym, degen_mapping)
             if wfnsym in (0, 5):  # A1g, A1u
                 x += sign_a * sign_b * ca[:,None] * cb
                 #assert (sign_a*sign_b==1 and x.imag==0) or (sign_a*sign_b==-1 and x.real==0)
             elif wfnsym in (1, 4):  # A2g, A2u
                 x -= sign_a * sign_b * ca[:,None] * cb
                 #assert (sign_a*sign_b==1 and x.real==0) or (sign_a*sign_b==-1 and x.imag==0)
-            if numpy.linalg.norm(x.real) > 1e-6:
+            if np.linalg.norm(x.real) > 1e-6:
                 x = x.real.copy()
             else:
                 x = x.imag.copy()
 
         elif wfn_momentum > 0:
             x = ca.real[:,None] * cb.real
             x-= ca.imag[:,None] * cb.imag
         else:
             x = ca.imag[:,None] * cb.real
             x+= ca.real[:,None] * cb.imag
 
-        norm = numpy.linalg.norm(x)
+        norm = np.linalg.norm(x)
         if norm < 1e-3:
             continue
         x *= 1./norm
         ci0.append(x.ravel().view(direct_spin1.FCIvector))
         iroot += 1
         if iroot >= nroots:
             break
@@ -320,31 +336,31 @@
     return ci0
 
 def _cyl_sym_csf2civec(strs, addr, orbsym, degen_mapping):
     '''For orbital basis rotation from E(+/-) basis to Ex/Ey basis, mimic the CI
     transformation  addons.transform_ci(civec, (0, nelec), u)
     '''
     norb = orbsym.size
-    one_particle_strs = numpy.asarray([1 << i for i in range(norb)])
+    one_particle_strs = np.asarray([1 << i for i in range(norb)])
     occ_masks = (strs[:,None] & one_particle_strs) != 0
     na = strs.size
-    occ_idx_all_strs = numpy.where(occ_masks)[1].reshape(na,-1)
+    occ_idx_all_strs = np.where(occ_masks)[1].reshape(na,-1)
 
     u = _cyl_sym_orbital_rotation(orbsym, degen_mapping)
     ui = u[occ_masks[addr]].T.copy()
     minors = ui[occ_idx_all_strs]
-    civec = numpy.linalg.det(minors)
+    civec = np.linalg.det(minors)
     return civec
 
 def _cyl_sym_orbital_rotation(orbsym, degen_mapping):
     '''Rotation to transform (E+)/(E-) basis to Ex/Ey basis
     |Ex/Ey> = |E(+/-)> * u
     '''
     norb = orbsym.size
-    u = numpy.zeros((norb, norb), dtype=numpy.complex128)
+    u = np.zeros((norb, norb), dtype=np.complex128)
     sqrth = .5**.5
     sqrthi = sqrth * 1j
     for i, j in enumerate(degen_mapping):
         if i == j:  # 1d irrep
             if orbsym[i] in (1, 4):  # A2g, A2u
                 u[i,i] = 1j
             else:
@@ -367,77 +383,81 @@
                 # Ex, Ey orbitals swapped
                 sign = -sign
             ci_str1 |= 1 << j
             nelec += 1
     return cistring.str2addr(degen_mapping.size, nelec, ci_str1), sign
 
 def _strs_angular_momentum(strs, orbsym):
-    # angular momentum for each orbitals
+    # angular momentum for each orbital
     orb_l = (orbsym // 10) * 2
-    e1_mask = numpy.isin(orbsym % 10, (2, 3, 6, 7))
+    e1_mask = np.isin(orbsym % 10, (2, 3, 6, 7))
     orb_l[e1_mask] += 1
-    ey_mask = numpy.isin(orbsym % 10, (1, 3, 4, 6))
+    ey_mask = np.isin(orbsym % 10, (1, 3, 4, 6))
     orb_l[ey_mask] *= -1
 
     # total angular for each determinant (CSF)
-    ls = numpy.zeros(len(strs), dtype=int)
+    ls = np.zeros(len(strs), dtype=int)
     if isinstance(strs, cistring.OIndexList):
         nocc = strs.shape[1]
         for i in range(nocc):
             ls += orb_l[strs[:,i]]
     else:
         for i, l in enumerate(orb_l):
-            ls[numpy.bitwise_and(strs, 1 << i) > 0] += l
+            ls[np.bitwise_and(strs, 1 << i) > 0] += l
     return ls
 
 def reorder_eri(eri, norb, orbsym):
     if orbsym is None:
-        return [eri], numpy.arange(norb), numpy.zeros(norb,dtype=numpy.int32)
+        return [eri], np.arange(norb), np.zeros(norb,dtype=np.int32)
 
     # % 10 to map irrep IDs of Dooh or Coov, etc. to irreps of D2h, C2v
-    orbsym = numpy.asarray(orbsym) % 10
+    orbsym = np.asarray(orbsym) % 10
 
     # irrep of (ij| pair
-    trilirrep = (orbsym[:,None] ^ orbsym)[numpy.tril_indices(norb)]
+    trilirrep = (orbsym[:,None] ^ orbsym)[np.tril_indices(norb)]
     # and the number of occurence for each irrep
-    dimirrep = numpy.asarray(numpy.bincount(trilirrep), dtype=numpy.int32)
+    dimirrep = np.asarray(np.bincount(trilirrep), dtype=np.int32)
     # we sort the irreps of (ij| pair, to group the pairs which have same irreps
     # "order" is irrep-id-sorted index. The (ij| paired is ordered that the
     # pair-id given by order[0] comes first in the sorted pair
     # "rank" is a sorted "order". Given nth (ij| pair, it returns the place(rank)
     # of the sorted pair
-    old_eri_irrep = numpy.asarray(trilirrep, dtype=numpy.int32)
-    rank_in_irrep = numpy.empty_like(old_eri_irrep)
-    p0 = 0
-    eri_irs = [numpy.zeros((0,0))] * TOTIRREPS
+    old_eri_irrep = np.asarray(trilirrep, dtype=np.int32)
+    rank_in_irrep = np.empty_like(old_eri_irrep)
+    eri_irs = [np.zeros((0,0))] * TOTIRREPS
     for ir, nnorb in enumerate(dimirrep):
-        idx = numpy.asarray(numpy.where(trilirrep == ir)[0], dtype=numpy.int32)
-        rank_in_irrep[idx] = numpy.arange(nnorb, dtype=numpy.int32)
+        idx = np.asarray(np.where(trilirrep == ir)[0], dtype=np.int32)
+        rank_in_irrep[idx] = np.arange(nnorb, dtype=np.int32)
         eri_ir = lib.take_2d(eri, idx, idx)
         # Drop small integrals which may break symmetry?
         #eri_ir[abs(eri_ir) < 1e-13] = 0
         eri_irs[ir] = eri_ir
-        p0 += nnorb
     return eri_irs, rank_in_irrep, old_eri_irrep
 
-def gen_str_irrep(strs, orbsym, link_index, rank_eri, irrep_eri):
+def argsort_strs_by_irrep(strs, orbsym):
     airreps = _gen_strs_irrep(strs, orbsym)
-    na = len(airreps)
-    rank = numpy.zeros(na, dtype=numpy.int32)
-    aidx = [numpy.zeros(0,dtype=numpy.int32)] * TOTIRREPS
+    aidx = [np.zeros(0,dtype=np.int32)] * TOTIRREPS
     for ir in range(TOTIRREPS):
-        aidx[ir] = numpy.where(airreps == ir)[0]
-        ma = len(aidx[ir])
-        if ma > 0:
-            rank[aidx[ir]] = numpy.arange(ma, dtype=numpy.int32)
+        aidx[ir] = np.where(airreps == ir)[0]
+    return aidx
+
+def gen_str_irrep(strs, orbsym, link_index, rank_eri, irrep_eri):
+    aidx = argsort_strs_by_irrep(strs, orbsym)
+    na = len(strs)
+    rank = np.zeros(na, dtype=np.int32)
+    for idx in aidx:
+        if idx.size > 0:
+            rank[idx] = np.arange(idx.size, dtype=np.int32)
+
     link_index = link_index.copy()
+    link_index[:,:,2] = rank[link_index[:,:,2]]
     link_index[:,:,1] = irrep_eri[link_index[:,:,0]]
     link_index[:,:,0] = rank_eri[link_index[:,:,0]]
-    link_index[:,:,2] = rank[link_index[:,:,2]]
-    link_index = [link_index.take(aidx[ir], axis=0) for ir in range(TOTIRREPS)]
+
+    link_index = link_index.take(np.hstack(aidx), axis=0)
     return aidx, link_index
 
 def _guess_wfnsym_cyl_sym(civec, strsa, strsb, orbsym):
     degen_mapping = orbsym.degen_mapping
     idx = abs(civec).argmax()
     na = strsa.size
     nb = strsb.size
@@ -449,16 +469,16 @@
     addrb, addrb1 = min(addrb,addrb1), max(addrb,addrb1)
     ca = ca1 = _cyl_sym_csf2civec(strsa, addra, orbsym, degen_mapping)
     cb = cb1 = _cyl_sym_csf2civec(strsb, addrb, orbsym, degen_mapping)
     if addra != addra1:
         ca1 = _cyl_sym_csf2civec(strsa, addra1, orbsym, degen_mapping)
     if addrb != addrb1:
         cb1 = _cyl_sym_csf2civec(strsb, addrb1, orbsym, degen_mapping)
-    ua = numpy.stack([ca, ca1])
-    ub = numpy.stack([cb, cb1])
+    ua = np.stack([ca, ca1])
+    ub = np.stack([cb, cb1])
     # civec is in the Ex/Ey basis. Transform the largest coefficient to
     # (E+)/(E-) basis.
     c_max = ua.conj().dot(civec.reshape(na,nb)).dot(ub.conj().T)
 
     airreps_d2h = _gen_strs_irrep(strsa[[addra,addra1]], orbsym)
     birreps_d2h = _gen_strs_irrep(strsb[[addrb,addrb1]], orbsym)
     a_ls = _strs_angular_momentum(strsa[[addra,addra1]], orbsym)
@@ -533,152 +553,250 @@
         log.debug('Guessing CI wfn symmetry = %s', wfnsym)
 
     elif wfnsym is None:
         if groupname in ('Dooh', 'Coov'):
             strsa = strsb = cistring.gen_strings4orblist(range(norb), neleca)
             if neleca != nelecb:
                 strsb = cistring.gen_strings4orblist(range(norb), nelecb)
-            if not isinstance(fcivec, numpy.ndarray) or fcivec.ndim > 2:
+            if not isinstance(fcivec, np.ndarray) or fcivec.ndim > 2:
                 fcivec = fcivec[0]
             wfnsym = _guess_wfnsym_cyl_sym(fcivec, strsa, strsb, orbsym)
         else:
             wfnsym = addons.guess_wfnsym(fcivec, norb, nelec, orbsym)
         log.debug('Guessing CI wfn symmetry = %s', wfnsym)
 
     else:
         # verify if the input wfnsym is consistent with the symmetry of fcivec
         strsa = strsb = cistring.gen_strings4orblist(range(norb), neleca)
         if neleca != nelecb:
             strsb = cistring.gen_strings4orblist(range(norb), nelecb)
 
         if groupname in ('Dooh', 'Coov'):
-            if not isinstance(fcivec, numpy.ndarray) or fcivec.ndim > 2:
+            if not isinstance(fcivec, np.ndarray) or fcivec.ndim > 2:
                 fcivec = fcivec[0]
             wfnsym1 = _guess_wfnsym_cyl_sym(fcivec, strsa, strsb, orbsym)
             if wfnsym1 != _id_wfnsym(solver, norb, nelec, orbsym, wfnsym):
                 raise RuntimeError(f'Input wfnsym {wfnsym} is not consistent with '
                                    f'fcivec symmetry {wfnsym1}')
             wfnsym = wfnsym1
         else:
             na, nb = strsa.size, strsb.size
-            orbsym_in_d2h = numpy.asarray(orbsym) % 10
-            airreps = numpy.zeros(na, dtype=numpy.int32)
-            birreps = numpy.zeros(nb, dtype=numpy.int32)
+            orbsym_in_d2h = np.asarray(orbsym) % 10
+            airreps = np.zeros(na, dtype=np.int32)
+            birreps = np.zeros(nb, dtype=np.int32)
             for i, ir in enumerate(orbsym_in_d2h):
-                airreps[numpy.bitwise_and(strsa, 1 << i) > 0] ^= ir
-                birreps[numpy.bitwise_and(strsb, 1 << i) > 0] ^= ir
+                airreps[np.bitwise_and(strsa, 1 << i) > 0] ^= ir
+                birreps[np.bitwise_and(strsb, 1 << i) > 0] ^= ir
 
             wfnsym = _id_wfnsym(solver, norb, nelec, orbsym, wfnsym)
             groupname = getattr(solver.mol, 'groupname', None)
             mask = airreps[:,None] == (wfnsym % 10) ^ birreps
 
-            if isinstance(fcivec, numpy.ndarray) and fcivec.ndim <= 2:
+            if isinstance(fcivec, np.ndarray) and fcivec.ndim <= 2:
                 fcivec = [fcivec]
             if all(abs(c.reshape(na, nb)[mask]).max() < 1e-5 for c in fcivec):
                 raise RuntimeError('Input wfnsym {wfnsym} is not consistent with '
                                    'fcivec coefficients')
-
     return wfnsym
 
+def sym_allowed_indices(nelec, orbsym, wfnsym):
+    '''Indices of symmetry allowed determinants for each irrep'''
+    norb = orbsym.size
+    neleca, nelecb = nelec
+    strsa = strsb = cistring.gen_strings4orblist(range(norb), neleca)
+    aidx = bidx = argsort_strs_by_irrep(strsa, orbsym)
+    if neleca != nelecb:
+        strsb = cistring.gen_strings4orblist(range(norb), nelecb)
+        bidx = argsort_strs_by_irrep(strsb, orbsym)
+    nb = len(strsb)
+    wfnsym_in_d2h = wfnsym % 10
+    ab_idx = [(aidx[ir][:,None] * nb + bidx[wfnsym_in_d2h ^ ir]).ravel()
+              for ir in range(TOTIRREPS)]
+    return ab_idx
 
 class FCISolver(direct_spin1.FCISolver):
 
-    davidson_only = getattr(__config__, 'fci_direct_spin1_symm_FCI_davidson_only', True)
-    # pspace may break point group symmetry
-    pspace_size = getattr(__config__, 'fci_direct_spin1_symm_FCI_pspace_size', 0)
+    pspace_size = getattr(__config__, 'fci_direct_spin1_symm_FCI_pspace_size', 400)
 
     def __init__(self, mol=None, **kwargs):
-        direct_spin1.FCISolver.__init__(self, mol, **kwargs)
         # wfnsym will be guessed based on initial guess if it is None
         self.wfnsym = None
+        self.sym_allowed_idx = None
+        direct_spin1.FCISolver.__init__(self, mol, **kwargs)
 
     def dump_flags(self, verbose=None):
         direct_spin1.FCISolver.dump_flags(self, verbose)
         log = logger.new_logger(self, verbose)
         if isinstance(self.wfnsym, str):
             log.info('Input CI wfn symmetry = %s', self.wfnsym)
-        elif isinstance(self.wfnsym, (int, numpy.number)):
+        elif isinstance(self.wfnsym, (int, np.number)):
             groupname = getattr(self.mol, 'groupname', None)
             if groupname is not None:
                 try:
                     log.info('Input CI wfn symmetry = %s',
                              symm.irrep_id2name(groupname, self.wfnsym))
                 except KeyError:
                     raise RuntimeError('FCISolver cannot find mwfnsym Id %s in group %s. '
                                        'This might be caused by the projection from '
                                        'high-symmetry group to D2h symmetry.' %
                                        (self.wfnsym, groupname))
         else:
             log.info('CI wfn symmetry = %s', self.wfnsym)
         return self
 
-    def absorb_h1e(self, h1e, eri, norb, nelec, fac=1):
-        nelec = _unpack_nelec(nelec, self.spin)
-        return direct_spin1.absorb_h1e(h1e, eri, norb, nelec, fac)
+    absorb_h1e = direct_spin1.FCISolver.absorb_h1e
 
-    def make_hdiag(self, h1e, eri, norb, nelec):
+    def make_hdiag(self, h1e, eri, norb, nelec, compress=False):
         nelec = _unpack_nelec(nelec, self.spin)
-        return direct_spin1.make_hdiag(h1e, eri, norb, nelec)
+        hdiag = direct_spin1.make_hdiag(h1e, eri, norb, nelec)
+        # TODO: hdiag should return symmetry allowed elements only. However,
+        # get_init_guess_cyl_sym does not strictly follow the D2h (and subgroup)
+        # symmetry treatments. The diagonal of entire Hamiltonian is required.
+        if compress and self.sym_allowed_idx is not None:
+            hdiag = hdiag.ravel()[np.hstack(self.sym_allowed_idx)]
+        return hdiag
 
     def pspace(self, h1e, eri, norb, nelec, hdiag, np=400):
         nelec = _unpack_nelec(nelec, self.spin)
-        return direct_spin1.pspace(h1e, eri, norb, nelec, hdiag, np)
+        na = cistring.num_strings(norb, nelec[0])
+        nb = cistring.num_strings(norb, nelec[1])
+        s_idx = numpy.hstack(self.sym_allowed_idx)
+        if hdiag.size == s_idx.size:
+            hdiag, hdiag0 = numpy.empty(na*nb), hdiag.ravel()
+            hdiag[:] = 1e9
+            hdiag[s_idx] = hdiag0
+        elif not getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov'):
+            # Screen symmetry forbidden elements
+            hdiag, hdiag0 = numpy.empty(na*nb), hdiag.ravel()
+            hdiag[:] = 1e9
+            hdiag[s_idx] = hdiag0[s_idx]
+
+        np = min(np, hdiag.size)
+        addr0, h = direct_spin1.pspace(h1e, eri, norb, nelec, hdiag, np)
+
+        # mapping the address in (na,nb) civec to address in sym-allowed civec
+        addr0_sym_allow = numpy.where(numpy.isin(addr0, s_idx))[0]
+        addr0 = addr0[addr0_sym_allow]
+        s_idx_allowed = numpy.where(numpy.isin(s_idx, addr0))[0]
+        addr1 = s_idx[s_idx_allowed]
+        new_idx = numpy.empty_like(s_idx_allowed)
+        new_idx[addr0.argsort()] = addr1.argsort()
+        addr = s_idx_allowed[new_idx]
+        return addr, h[addr0_sym_allow[:,None],addr0_sym_allow]
 
     def contract_1e(self, f1e, fcivec, norb, nelec, link_index=None, **kwargs):
-        nelec = _unpack_nelec(nelec, self.spin)
-        return contract_1e(f1e, fcivec, norb, nelec, link_index, **kwargs)
+        nelec = direct_spin1._unpack_nelec(nelec)
+        na = cistring.num_strings(norb, nelec[0])
+        nb = cistring.num_strings(norb, nelec[1])
+        if fcivec.size != na * nb:
+            fcivec, ci0 = np.zeros(na*nb), fcivec
+            fcivec[np.hstack(self.sym_allowed_idx)] = ci0
+        return direct_spin1.contract_1e(f1e, fcivec, norb, nelec, link_index, **kwargs)
 
     def contract_2e(self, eri, fcivec, norb, nelec, link_index=None,
                     orbsym=None, wfnsym=None, **kwargs):
         if orbsym is None: orbsym = self.orbsym
         if wfnsym is None: wfnsym = self.wfnsym
         wfnsym = _id_wfnsym(self, norb, nelec, orbsym, wfnsym)
         nelec = _unpack_nelec(nelec, self.spin)
         return contract_2e(eri, fcivec, norb, nelec, link_index, orbsym, wfnsym, **kwargs)
 
-    def get_init_guess(self, norb, nelec, nroots, hdiag):
-        wfnsym = _id_wfnsym(self, norb, nelec, self.orbsym, self.wfnsym)
+    def contract_ss(self, fcivec, norb, nelec):
+        nelec = direct_spin1._unpack_nelec(nelec)
+        na = cistring.num_strings(norb, nelec[0])
+        nb = cistring.num_strings(norb, nelec[1])
+        if fcivec.size == na*nb:
+            return contract_ss(fcivec, norb, nelec)
+
+        fcivec, ci0 = np.zeros(na*nb), fcivec
+        s_idx = np.hstack(self.sym_allowed_idx)
+        fcivec[s_idx] = ci0
+        ci1 = contract_ss(fcivec, norb, nelec)
+        return ci1.ravel()[s_idx]
+
+    def get_init_guess(self, norb, nelec, nroots, hdiag, orbsym=None, wfnsym=None):
+        if orbsym is None: orbsym = self.orbsym
+        if wfnsym is None:
+            wfnsym = _id_wfnsym(self, norb, nelec, orbsym, self.wfnsym)
+        s_idx = np.hstack(self.sym_allowed_idx)
         if getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov'):
-            return get_init_guess_cyl_sym(
-                norb, nelec, nroots, hdiag, self.orbsym, wfnsym)
+            ci0 = get_init_guess_cyl_sym(
+                norb, nelec, nroots, hdiag, orbsym, wfnsym)
+            return [x[s_idx] for x in ci0]
         else:
-            return get_init_guess(norb, nelec, nroots, hdiag, self.orbsym, wfnsym)
+            return get_init_guess(norb, nelec, nroots, hdiag.ravel()[s_idx],
+                                  orbsym, wfnsym)
 
     guess_wfnsym = guess_wfnsym
 
     def kernel(self, h1e, eri, norb, nelec, ci0=None,
                tol=None, lindep=None, max_cycle=None, max_space=None,
                nroots=None, davidson_only=None, pspace_size=None,
                orbsym=None, wfnsym=None, ecore=0, **kwargs):
         if nroots is None: nroots = self.nroots
         if orbsym is None: orbsym = self.orbsym
         if wfnsym is None: wfnsym = self.wfnsym
         if self.verbose >= logger.WARN:
+            if 'verbose' not in kwargs:
+                kwargs['verbose'] = self.verbose
             self.check_sanity()
         self.norb = norb
-        self.nelec = nelec
-
-        if (not hasattr(orbsym, 'degen_mapping') and
-            getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov')):
-            degen_mapping = map_degeneracy(h1e.diagonal(), orbsym)
-            orbsym = lib.tag_array(orbsym, degen_mapping=degen_mapping)
+        self.nelec = nelec = _unpack_nelec(nelec, self.spin)
+        link_index = direct_spin1._unpack(norb, nelec, None)
 
-        wfnsym = self.guess_wfnsym(norb, nelec, ci0, orbsym, wfnsym, **kwargs)
+        if getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov'):
+            if not hasattr(orbsym, 'degen_mapping'):
+                degen_mapping = map_degeneracy(h1e.diagonal(), orbsym)
+                orbsym = lib.tag_array(orbsym, degen_mapping=degen_mapping)
+            if davidson_only is None:
+                davidson_only = True
+
+        wfnsym_ir = self.guess_wfnsym(norb, nelec, ci0, orbsym, wfnsym, **kwargs)
+        self.sym_allowed_idx = sym_allowed_indices(nelec, orbsym, wfnsym_ir)
+        s_idx = np.hstack(self.sym_allowed_idx)
+        self.orbsym = orbsym
+        logger.debug(self, 'Num symmetry allowed elements %d',
+                     sum([x.size for x in self.sym_allowed_idx]))
+        if s_idx.size == 0:
+            raise RuntimeError(
+                f'Symmetry allowed determinants not found for wfnsym {wfnsym}')
 
-        if wfnsym > 7:
+        if wfnsym_ir > 7:
             # Symmetry broken for Dooh and Coov groups is often observed.
             # A larger max_space is helpful to reduce the error. Also it is
             # hard to converge to high precision.
             if max_space is None and self.max_space == FCISolver.max_space:
                 max_space = 20 + 7 * nroots
             if tol is None and self.conv_tol == FCISolver.conv_tol:
                 tol = 1e-7
 
-        with lib.temporary_env(self, orbsym=orbsym, wfnsym=wfnsym):
-            e, c = direct_spin1.kernel_ms1(self, h1e, eri, norb, nelec, ci0, None,
-                                           tol, lindep, max_cycle, max_space,
-                                           nroots, davidson_only, pspace_size,
-                                           ecore=ecore, **kwargs)
+        if ci0 is None and getattr(self.mol, 'groupname', None) in ('Dooh', 'Coov'):
+            # self.hdiag returns stripped H_diag (for D2h symmetry).
+            # Different convention of symmetry representations were used in
+            # get_init_guess_cyl_sym (which follows direct_spin1_cyl_sym.py).
+            # Some symmetry forbidden elements for D2h are needed in
+            # get_init_guess_cyl_sym function. Thus the entire hdiag is computed.
+            hdiag = self.make_hdiag(h1e, eri, norb, nelec, compress=False)
+            ci0 = self.get_init_guess(norb, nelec, nroots, hdiag, orbsym, wfnsym_ir)
+
+        with lib.temporary_env(self, wfnsym=wfnsym_ir):
+            e, c = direct_spin1.kernel_ms1(
+                self, h1e, eri, norb, nelec, ci0, link_index, tol, lindep, max_cycle,
+                max_space, nroots, davidson_only, pspace_size, ecore=ecore, **kwargs)
+
+        na = link_index[0].shape[0]
+        nb = link_index[1].shape[0]
+        if nroots > 1:
+            c, c_raw = [], c
+            for vec in c_raw:
+                c1 = np.zeros(na*nb)
+                c1[s_idx] = vec.T
+                c.append(c1.reshape(na, nb).view(direct_spin1.FCIvector))
+        else:
+            c1 = np.zeros(na*nb)
+            c1[s_idx] = c
+            c = c1.reshape(na, nb).view(direct_spin1.FCIvector)
+
         self.eci, self.ci = e, c
         return e, c
 
 FCI = FCISolver
```

### Comparing `pyscf-2.2.1/pyscf/fci/direct_uhf.py` & `pyscf-2.3.0/pyscf/fci/direct_uhf.py`

 * *Files 24% similar despite different names*

```diff
@@ -33,16 +33,17 @@
 
 import ctypes
 import numpy
 from pyscf import lib
 from pyscf import ao2mo
 from pyscf.fci import cistring
 from pyscf.fci import direct_spin1
+from pyscf.fci.spin_op import spin_square
 
-libfci = lib.load_library('libfci')
+libfci = direct_spin1.libfci
 
 # When the spin-orbitals do not have the degeneracy on spacial part,
 # there is only one version of FCI which is close to _spin1 solver.
 # The inputs: h1e has two parts (h1e_a, h1e_b),
 # h2e has three parts (h2e_aa, h2e_ab, h2e_bb)
 
 def contract_1e(f1e, fcivec, norb, nelec, link_index=None):
@@ -118,25 +119,25 @@
             fcinew[maska[:,None] & maskb] += 2*u_ab * fcivec[maska[:,None] & maskb]
     if u_bb != 0:  # u * n_beta^+ n_beta
         for i in range(norb):
             maskb = (strsb & (1 << i)) > 0
             fcinew[:,maskb] += u_bb * fcivec[:,maskb]
     return fcinew.view(direct_spin1.FCIvector)
 
-def make_hdiag(h1e, eri, norb, nelec):
+def make_hdiag(h1e, eri, norb, nelec, compress=False):
     neleca, nelecb = direct_spin1._unpack_nelec(nelec)
     h1e_a = numpy.ascontiguousarray(h1e[0])
     h1e_b = numpy.ascontiguousarray(h1e[1])
     g2e_aa = ao2mo.restore(1, eri[0], norb)
     g2e_ab = ao2mo.restore(1, eri[1], norb)
     g2e_bb = ao2mo.restore(1, eri[2], norb)
 
-    occslsta = occslstb = cistring._gen_occslst(range(norb), neleca)
+    occslsta = occslstb = cistring.gen_occslst(range(norb), neleca)
     if neleca != nelecb:
-        occslstb = cistring._gen_occslst(range(norb), nelecb)
+        occslstb = cistring.gen_occslst(range(norb), nelecb)
     na = len(occslsta)
     nb = len(occslstb)
 
     hdiag = numpy.empty(na*nb)
     jdiag_aa = numpy.asarray(numpy.einsum('iijj->ij',g2e_aa), order='C')
     jdiag_ab = numpy.asarray(numpy.einsum('iijj->ij',g2e_ab), order='C')
     jdiag_bb = numpy.asarray(numpy.einsum('iijj->ij',g2e_bb), order='C')
@@ -183,23 +184,25 @@
     neleca, nelecb = direct_spin1._unpack_nelec(nelec)
     h1e_a = numpy.ascontiguousarray(h1e[0])
     h1e_b = numpy.ascontiguousarray(h1e[1])
     g2e_aa = ao2mo.restore(1, eri[0], norb)
     g2e_ab = ao2mo.restore(1, eri[1], norb)
     g2e_bb = ao2mo.restore(1, eri[2], norb)
     if hdiag is None:
-        hdiag = make_hdiag(h1e, eri, norb, nelec)
+        hdiag = make_hdiag(h1e, eri, norb, nelec, compress=False)
+    na = cistring.num_strings(norb, neleca)
+    nb = cistring.num_strings(norb, nelecb)
+    assert hdiag.size == na * nb
     if hdiag.size < np:
         addr = numpy.arange(hdiag.size)
     else:
         try:
             addr = numpy.argpartition(hdiag, np-1)[:np]
         except AttributeError:
             addr = numpy.argsort(hdiag)[:np]
-    nb = cistring.num_strings(norb, nelecb)
     addra = addr // nb
     addrb = addr % nb
     stra = cistring.addrs2str(norb, neleca, addra)
     strb = cistring.addrs2str(norb, nelecb, addrb)
     np = len(addr)
     h0 = numpy.zeros((np,np))
     libfci.FCIpspace_h0tril_uhf(h0.ctypes.data_as(ctypes.c_void_p),
@@ -230,112 +233,40 @@
 
 def energy(h1e, eri, fcivec, norb, nelec, link_index=None):
     h2e = absorb_h1e(h1e, eri, norb, nelec, .5)
     ci1 = contract_2e(h2e, fcivec, norb, nelec, link_index)
     return numpy.dot(fcivec.reshape(-1), ci1.reshape(-1))
 
 # dm_pq = <|p^+ q|>
-def make_rdm1s(fcivec, norb, nelec, link_index=None):
-    return direct_spin1.make_rdm1s(fcivec, norb, nelec, link_index)
+make_rdm1s = direct_spin1.make_rdm1s
 
 # spacial part of DM, dm_pq = <|p^+ q|>
 def make_rdm1(fcivec, norb, nelec, link_index=None):
     raise ValueError('Spin trace for UHF-FCI density matrices.')
 
-def make_rdm12s(fcivec, norb, nelec, link_index=None, reorder=True):
-    return direct_spin1.make_rdm12s(fcivec, norb, nelec, link_index, reorder)
-
-def trans_rdm1s(cibra, ciket, norb, nelec, link_index=None):
-    return direct_spin1.trans_rdm1s(cibra, ciket, norb, nelec, link_index)
+make_rdm12s = direct_spin1.make_rdm12s
+trans_rdm1s = direct_spin1.trans_rdm1s
 
 # spacial part of DM
 def trans_rdm1(cibra, ciket, norb, nelec, link_index=None):
     raise ValueError('Spin trace for UHF-FCI density matrices.')
 
-def trans_rdm12s(cibra, ciket, norb, nelec, link_index=None, reorder=True):
-    return direct_spin1.trans_rdm12s(cibra, ciket, norb, nelec, link_index, reorder)
+trans_rdm12s = direct_spin1.trans_rdm12s
 
 
 ###############################################################
 # uhf-integral direct-CI driver
 ###############################################################
 
 class FCISolver(direct_spin1.FCISolver):
 
-    def absorb_h1e(self, h1e, eri, norb, nelec, fac=1):
-        return absorb_h1e(h1e, eri, norb, nelec, fac)
-
-    def make_hdiag(self, h1e, eri, norb, nelec):
-        return make_hdiag(h1e, eri, norb, nelec)
-
-    def pspace(self, h1e, eri, norb, nelec, hdiag, np=400):
-        return pspace(h1e, eri, norb, nelec, hdiag, np)
-
-    def contract_1e(self, f1e, fcivec, norb, nelec, link_index=None, **kwargs):
-        return contract_1e(f1e, fcivec, norb, nelec, link_index, **kwargs)
-
-    def contract_2e(self, eri, fcivec, norb, nelec, link_index=None, **kwargs):
-        return contract_2e(eri, fcivec, norb, nelec, link_index, **kwargs)
-
-    def spin_square(self, fcivec, norb, nelec):
-        from pyscf.fci import spin_op
-        return spin_op.spin_square(fcivec, norb, nelec)
-
-    def make_rdm1(self, cibra, ciket, norb, nelec, link_index=None):
-        return trans_rdm1(cibra, ciket, norb, nelec, link_index)
-
-    def trans_rdm1(self, cibra, ciket, norb, nelec, link_index=None):
-        return trans_rdm1(cibra, ciket, norb, nelec, link_index)
+    absorb_h1e = staticmethod(absorb_h1e)
+    make_hdiag = staticmethod(make_hdiag)
+    pspace = staticmethod(pspace)
+
+    contract_1e = lib.module_method(contract_1e)
+    contract_2e = lib.module_method(contract_2e)
+    make_rdm1 = lib.module_method(make_rdm1)
+    trans_rdm1 = lib.module_method(trans_rdm1)
+    spin_square = lib.module_method(spin_square)
 
 FCI = FCISolver
-
-if __name__ == '__main__':
-    from functools import reduce
-    from pyscf import gto
-    from pyscf import scf
-
-    mol = gto.Mole()
-    mol.verbose = 0
-    mol.output = None#"out_h2o"
-    mol.atom = [
-        ['H', ( 1.,-1.    , 0.   )],
-        ['H', ( 0.,-1.    ,-1.   )],
-        ['H', ( 1.,-0.5   ,-1.   )],
-        #['H', ( 0.,-0.5   ,-1.   )],
-        #['H', ( 0.,-0.5   ,-0.   )],
-        ['H', ( 0.,-0.    ,-1.   )],
-        ['H', ( 1.,-0.5   , 0.   )],
-        ['H', ( 0., 1.    , 1.   )],
-    ]
-
-    mol.basis = {'H': 'sto-3g'}
-    mol.charge = 1
-    mol.spin = 1
-    mol.build()
-
-    m = scf.UHF(mol)
-    ehf = m.scf()
-
-    cis = FCISolver(mol)
-    norb = m.mo_energy[0].size
-    nea = (mol.nelectron+1) // 2
-    neb = (mol.nelectron-1) // 2
-    nelec = (nea, neb)
-    mo_a = m.mo_coeff[0]
-    mo_b = m.mo_coeff[1]
-    h1e_a = reduce(numpy.dot, (mo_a.T, m.get_hcore(), mo_a))
-    h1e_b = reduce(numpy.dot, (mo_b.T, m.get_hcore(), mo_b))
-    g2e_aa = ao2mo.incore.general(m._eri, (mo_a,)*4, compact=False)
-    g2e_aa = g2e_aa.reshape(norb,norb,norb,norb)
-    g2e_ab = ao2mo.incore.general(m._eri, (mo_a,mo_a,mo_b,mo_b), compact=False)
-    g2e_ab = g2e_ab.reshape(norb,norb,norb,norb)
-    g2e_bb = ao2mo.incore.general(m._eri, (mo_b,)*4, compact=False)
-    g2e_bb = g2e_bb.reshape(norb,norb,norb,norb)
-    h1e = (h1e_a, h1e_b)
-    eri = (g2e_aa, g2e_ab, g2e_bb)
-    na = cistring.num_strings(norb, nea)
-    nb = cistring.num_strings(norb, neb)
-    numpy.random.seed(15)
-    fcivec = numpy.random.random((na,nb))
-
-    e = kernel(h1e, eri, norb, nelec)[0]
-    print(e, e - -8.65159903476)
```

### Comparing `pyscf-2.2.1/pyscf/fci/fci_dhf_slow.py` & `pyscf-2.3.0/pyscf/fci/fci_dhf_slow.py`

 * *Files 0% similar despite different names*

```diff
@@ -48,15 +48,15 @@
     f1e = h1e + 0.5 * numpy.einsum('jiik->jk', eri.transpose(0, 2, 3, 1), optimize=True)
     h2e = -1.0 * eri.transpose(0, 3, 2, 1)
     h2e[numpy.diag_indices(norb)] += f1e * (2.0 / (nelec + 1e-100))
     return h2e * fac
 
 
 def make_hdiag(h1e, eri, norb, nelec, opt=None):
-    occslist = cistring._gen_occslst(range(norb), nelec)
+    occslist = cistring.gen_occslst(range(norb), nelec)
     diagjk = numpy.einsum('iijj->ij', eri.copy(), optimize=True)
     diagjk -= numpy.einsum('ijji->ij', eri, optimize=True)
     hdiag = []
     for occ in occslist:
         e1 = h1e[occ, occ].sum()
         e2 = diagjk[occ][:, occ].sum()
         hdiag.append(e1 + e2 * 0.5)
```

### Comparing `pyscf-2.2.1/pyscf/fci/fci_slow.py` & `pyscf-2.3.0/pyscf/fci/fci_slow.py`

 * *Files 2% similar despite different names*

```diff
@@ -39,23 +39,26 @@
     for str0, tab in enumerate(link_indexb):
         for a, i, str1, sign in tab:
             t1[a,i,:,str1] += sign * ci0[:,str0]
     fcinew = numpy.dot(f1e.reshape(-1), t1.reshape(-1,na*nb))
     return fcinew.reshape(fcivec.shape)
 
 
-def contract_2e(eri, fcivec, norb, nelec, opt=None):
+def contract_2e(eri, fcivec, norb, nelec, link_index=None):
     '''Compute E_{pq}E_{rs}|CI>'''
     if isinstance(nelec, (int, numpy.integer)):
         nelecb = nelec//2
         neleca = nelec - nelecb
     else:
         neleca, nelecb = nelec
-    link_indexa = cistring.gen_linkstr_index(range(norb), neleca)
-    link_indexb = cistring.gen_linkstr_index(range(norb), nelecb)
+    if link_index is None:
+        link_indexa = cistring.gen_linkstr_index(range(norb), neleca)
+        link_indexb = cistring.gen_linkstr_index(range(norb), nelecb)
+    else:
+        link_indexa, link_indexb = link_index
     na = cistring.num_strings(norb, neleca)
     nb = cistring.num_strings(norb, nelecb)
     ci0 = fcivec.reshape(na,nb)
     t1 = numpy.zeros((norb,norb,na,nb), dtype=fcivec.dtype)
     for str0, tab in enumerate(link_indexa):
         for a, i, str1, sign in tab:
             t1[a,i,str1] += sign * ci0[str0]
@@ -127,15 +130,15 @@
 
 
 def absorb_h1e(h1e, eri, norb, nelec, fac=1):
     '''Modify 2e Hamiltonian to include 1e Hamiltonian contribution.
     '''
     if not isinstance(nelec, (int, numpy.integer)):
         nelec = sum(nelec)
-    h2e = ao2mo.restore(1, eri.copy(), norb)
+    h2e = ao2mo.restore(1, eri.copy(), norb).astype(h1e.dtype, copy=False)
     f1e = h1e - numpy.einsum('jiik->jk', h2e) * .5
     f1e = f1e * (1./(nelec+1e-100))
     for k in range(norb):
         h2e[k,k,:,:] += f1e
         h2e[:,:,k,k] += f1e
     return h2e * fac
 
@@ -143,16 +146,16 @@
 def make_hdiag(h1e, eri, norb, nelec, opt=None):
     if isinstance(nelec, (int, numpy.integer)):
         nelecb = nelec//2
         neleca = nelec - nelecb
     else:
         neleca, nelecb = nelec
 
-    occslista = cistring._gen_occslst(range(norb), neleca)
-    occslistb = cistring._gen_occslst(range(norb), nelecb)
+    occslista = cistring.gen_occslst(range(norb), neleca)
+    occslistb = cistring.gen_occslst(range(norb), nelecb)
     eri = ao2mo.restore(1, eri, norb)
     diagj = numpy.einsum('iijj->ij', eri)
     diagk = numpy.einsum('ijji->ij', eri)
     hdiag = []
     for aocc in occslista:
         for bocc in occslistb:
             e1 = h1e[aocc,aocc].sum() + h1e[bocc,bocc].sum()
```

### Comparing `pyscf-2.2.1/pyscf/fci/rdm.py` & `pyscf-2.3.0/pyscf/fci/rdm.py`

 * *Files 0% similar despite different names*

```diff
@@ -26,15 +26,15 @@
 
 import ctypes
 import numpy
 from pyscf import lib
 from pyscf.fci import cistring
 from pyscf.fci.addons import _unpack_nelec
 
-librdm = lib.load_library('libfci')
+librdm = cistring.libfci
 
 def reorder_rdm(rdm1, rdm2, inplace=False):
     nmo = rdm1.shape[0]
     if not inplace:
         rdm2 = rdm2.copy()
     for k in range(nmo):
         rdm2[:,k,k,:] -= rdm1.T
```

### Comparing `pyscf-2.2.1/pyscf/fci/selected_ci.py` & `pyscf-2.3.0/pyscf/fci/selected_ci.py`

 * *Files 1% similar despite different names*

```diff
@@ -39,15 +39,15 @@
 from pyscf.lib import logger
 from pyscf import ao2mo
 from pyscf.fci import cistring
 from pyscf.fci import direct_spin1
 from pyscf.fci import rdm
 from pyscf import __config__
 
-libfci = lib.load_library('libfci')
+libfci = direct_spin1.libfci
 
 @lib.with_doc(direct_spin1.contract_2e.__doc__)
 def contract_2e(eri, civec_strs, norb, nelec, link_index=None):
     ci_coeff, nelec, ci_strs = _unpack(civec_strs, nelec)
     if link_index is None:
         link_index = _all_linkstr_index(ci_strs, norb, nelec)
     cd_indexa, dd_indexa, cd_indexb, dd_indexb = link_index
@@ -282,15 +282,15 @@
                           ctypes.c_int(norb), ctypes.c_int(nelec),
                           ctypes.c_int(nstrs), ctypes.c_int(ninter),
                           strs.ctypes.data_as(ctypes.c_void_p),
                           inter.ctypes.data_as(ctypes.c_void_p))
     return link_index
 
 
-def make_hdiag(h1e, eri, ci_strs, norb, nelec):
+def make_hdiag(h1e, eri, ci_strs, norb, nelec, compress=False):
     ci_coeff, nelec, ci_strs = _unpack(None, nelec, ci_strs)
     na = len(ci_strs[0])
     nb = len(ci_strs[1])
     hdiag = numpy.empty(na*nb)
 
     h1e = numpy.asarray(h1e, order='C')
     eri = ao2mo.restore(1, eri, norb)
@@ -328,26 +328,28 @@
     ci0, nelec, ci_strs = _unpack(ci0, nelec, ci_strs)
     na = len(ci_strs[0])
     nb = len(ci_strs[1])
     h2e = direct_spin1.absorb_h1e(h1e, eri, norb, nelec, .5)
     h2e = ao2mo.restore(1, h2e, norb)
 
     link_index = _all_linkstr_index(ci_strs, norb, nelec)
-    hdiag = myci.make_hdiag(h1e, eri, ci_strs, norb, nelec)
+    hdiag = myci.make_hdiag(h1e, eri, ci_strs, norb, nelec, compress=True)
 
     if isinstance(ci0, SCIvector):
         if ci0.size == na*nb:
             ci0 = [ci0.ravel()]
         else:
             ci0 = [x.ravel() for x in ci0]
     else:
         ci0 = myci.get_init_guess(ci_strs, norb, nelec, nroots, hdiag)
 
+    cpu0 = [logger.process_clock(), logger.perf_counter()]
     def hop(c):
         hc = myci.contract_2e(h2e, _as_SCIvector(c, ci_strs), norb, nelec, link_index)
+        cpu0[:] = log.timer_debug1('contract_2e', *cpu0)
         return hc.reshape(-1)
     precond = lambda x, e, *args: x/(hdiag-e+1e-4)
 
     #e, c = lib.davidson(hop, ci0, precond, tol=myci.conv_tol)
     e, c = myci.eig(hop, ci0, precond, tol=tol, lindep=lindep,
                     max_cycle=max_cycle, max_space=max_space, nroots=nroots,
                     max_memory=max_memory, verbose=log, **kwargs)
@@ -396,15 +398,15 @@
             ci_strs = (numpy.asarray([int('1'+corea, 2), int('10'+corea, 2)]),
                        numpy.asarray([int('1'+coreb, 2), int('10'+coreb, 2)]))
             ci0 = _as_SCIvector(numpy.ones((2,2)), ci_strs)
             ci0 = myci.enlarge_space(ci0, h2e, norb, nelec)
         if ci0.size < nroots:
             raise RuntimeError('Not enough selected-CI space for %d states' % nroots)
         ci_strs = ci0._strs
-        hdiag = myci.make_hdiag(h1e, eri, ci_strs, norb, nelec)
+        hdiag = myci.make_hdiag(h1e, eri, ci_strs, norb, nelec, compress=True)
         ci0 = myci.get_init_guess(ci_strs, norb, nelec, nroots, hdiag)
 
     def hop(c):
         hc = myci.contract_2e(h2e, _as_SCIvector(c, ci_strs), norb, nelec, link_index)
         return hc.ravel()
     precond = lambda x, e, *args: x/(hdiag-e+myci.level_shift)
 
@@ -418,15 +420,15 @@
         ci_strs = ci0[0]._strs
         float_tol = max(float_tol*tol_decay_rate, tol*1e2)
         log.debug('cycle %d  ci.shape %s  float_tol %g',
                   icycle, (len(ci_strs[0]), len(ci_strs[1])), float_tol)
 
         ci0 = [c.ravel() for c in ci0]
         link_index = _all_linkstr_index(ci_strs, norb, nelec)
-        hdiag = myci.make_hdiag(h1e, eri, ci_strs, norb, nelec)
+        hdiag = myci.make_hdiag(h1e, eri, ci_strs, norb, nelec, compress=True)
         #e, ci0 = lib.davidson(hop, ci0.reshape(-1), precond, tol=float_tol)
         e, ci0 = myci.eig(hop, ci0, precond, tol=float_tol, lindep=lindep,
                           max_cycle=max_cycle, max_space=max_space, nroots=nroots,
                           max_memory=max_memory, verbose=log, **kwargs)
         if nroots > 1:
             ci0 = [_as_SCIvector(c, ci_strs) for c in ci0]
             de, e_last = min(e)-e_last, min(e)
@@ -449,15 +451,15 @@
             # conv = True
             break
 
     ci_strs = ci0[0]._strs
     log.debug('Extra CI in selected space %s', (len(ci_strs[0]), len(ci_strs[1])))
     ci0 = [c.ravel() for c in ci0]
     link_index = _all_linkstr_index(ci_strs, norb, nelec)
-    hdiag = myci.make_hdiag(h1e, eri, ci_strs, norb, nelec)
+    hdiag = myci.make_hdiag(h1e, eri, ci_strs, norb, nelec, compress=True)
     e, c = myci.eig(hop, ci0, precond, tol=tol, lindep=lindep,
                     max_cycle=max_cycle, max_space=max_space, nroots=nroots,
                     max_memory=max_memory, verbose=log, **kwargs)
 
     na = len(ci_strs[0])
     nb = len(ci_strs[1])
     if nroots > 1:
@@ -761,16 +763,15 @@
         '''Initial guess is the single Slater determinant
         '''
         na = len(ci_strs[0])
         nb = len(ci_strs[1])
         ci0 = direct_spin1._get_init_guess(na, nb, nroots, hdiag, nelec)
         return [_as_SCIvector(x, ci_strs) for x in ci0]
 
-    def make_hdiag(self, h1e, eri, ci_strs, norb, nelec):
-        return make_hdiag(h1e, eri, ci_strs, norb, nelec)
+    make_hdiag = staticmethod(make_hdiag)
 
     enlarge_space = enlarge_space
     kernel = kernel_float_space
     kernel_fixed_space = kernel_fixed_space
 
 #    def approx_kernel(self, h1e, eri, norb, nelec, ci0=None, link_index=None,
 #                      tol=None, lindep=None, max_cycle=None,
```

### Comparing `pyscf-2.2.1/pyscf/fci/selected_ci_slow.py` & `pyscf-2.3.0/pyscf/fci/selected_ci_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/fci/selected_ci_spin0.py` & `pyscf-2.3.0/pyscf/fci/selected_ci_spin0.py`

 * *Files 4% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 import ctypes
 import numpy
 from pyscf import lib
 from pyscf import ao2mo
 from pyscf.fci import direct_spin1
 from pyscf.fci import selected_ci
 
-libfci = lib.load_library('libfci')
+libfci = direct_spin1.libfci
 
 def contract_2e(eri, civec_strs, norb, nelec, link_index=None):
     ci_coeff, nelec, ci_strs = selected_ci._unpack(civec_strs, nelec)
     if link_index is None:
         link_index = selected_ci._all_linkstr_index(ci_strs, norb, nelec)
     cd_indexa, dd_indexa, cd_indexb, dd_indexb = link_index
     na, nlinka = nb, nlinkb = cd_indexa.shape[:2]
@@ -113,15 +113,15 @@
 
     if (isinstance(ci_coeff, numpy.ndarray) and
         ci_coeff.shape[0] == na or ci_coeff.shape[0] == na*nb):
         cs = cs[0]
     return cs
 
 
-def make_hdiag(h1e, eri, ci_strs, norb, nelec):
+def make_hdiag(h1e, eri, ci_strs, norb, nelec, compress=False):
     hdiag = selected_ci.make_hdiag(h1e, eri, ci_strs, norb, nelec)
     na = len(ci_strs[0])
     lib.transpose_sum(hdiag.reshape(na,na), inplace=True)
     hdiag *= .5
     return hdiag
 
 def kernel(h1e, eri, norb, nelec, ci0=None, level_shift=1e-3, tol=1e-10,
@@ -152,16 +152,15 @@
         if getattr(civec_strs, '_strs', None) is not None:
             self._strs = civec_strs._strs
         else:
             assert (civec_strs.size == len(self._strs[0])*len(self._strs[1]))
             civec_strs = selected_ci._as_SCIvector(civec_strs, self._strs)
         return contract_2e(eri, civec_strs, norb, nelec, link_index)
 
-    def make_hdiag(self, h1e, eri, ci_strs, norb, nelec):
-        return make_hdiag(h1e, eri, ci_strs, norb, nelec)
+    make_hdiag = staticmethod(make_hdiag)
 
     enlarge_space = enlarge_space
 
 SCI = SelectedCI
 
 
 if __name__ == '__main__':
```

### Comparing `pyscf-2.2.1/pyscf/fci/selected_ci_spin0_symm.py` & `pyscf-2.3.0/pyscf/fci/selected_ci_spin0_symm.py`

 * *Files 3% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 from pyscf import ao2mo
 from pyscf.fci import direct_spin1
 from pyscf.fci import direct_spin1_symm
 from pyscf.fci import selected_ci
 from pyscf.fci import selected_ci_symm
 from pyscf.fci import selected_ci_spin0
 
-libfci = lib.load_library('libfci')
+libfci = direct_spin1.libfci
 
 def contract_2e(eri, civec_strs, norb, nelec, link_index=None, orbsym=None):
     ci_coeff, nelec, ci_strs = selected_ci._unpack(civec_strs, nelec)
     if link_index is None:
         link_index = selected_ci._all_linkstr_index(ci_strs, norb, nelec)
     cd_indexa, dd_indexa, cd_indexb, dd_indexb = link_index
     na, nlinka = nb, nlinkb = cd_indexa.shape[:2]
@@ -110,16 +110,15 @@
         if getattr(civec_strs, '_strs', None) is not None:
             self._strs = civec_strs._strs
         else:
             assert (civec_strs.size == len(self._strs[0])*len(self._strs[1]))
             civec_strs = selected_ci._as_SCIvector(civec_strs, self._strs)
         return contract_2e(eri, civec_strs, norb, nelec, link_index, orbsym)
 
-    def make_hdiag(self, h1e, eri, ci_strs, norb, nelec):
-        return selected_ci_spin0.make_hdiag(h1e, eri, ci_strs, norb, nelec)
+    make_hdiag = staticmethod(selected_ci_spin0.make_hdiag)
 
     enlarge_space = selected_ci_spin0.enlarge_space
 
 SCI = SelectedCI
 
 
 if __name__ == '__main__':
```

### Comparing `pyscf-2.2.1/pyscf/fci/spin_op.py` & `pyscf-2.3.0/pyscf/fci/spin_op.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 from functools import reduce
 import numpy
 from pyscf import lib
 from pyscf.fci import cistring
 from pyscf.fci.addons import _unpack_nelec
 
-librdm = lib.load_library('libfci')
+librdm = cistring.libfci
 
 ######################################################
 # Spin squared operator
 ######################################################
 # S^2 = (S+ * S- + S- * S+)/2 + Sz * Sz
 # S+ = \sum_i S_i+ ~ effective for all beta occupied orbitals.
 # S- = \sum_i S_i- ~ effective for all alpha occupied orbitals.
```

### Comparing `pyscf-2.2.1/pyscf/geomopt/__init__.py` & `pyscf-2.3.0/pyscf/geomopt/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/geomopt/addons.py` & `pyscf-2.3.0/pyscf/geomopt/addons.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/geomopt/berny_solver.py` & `pyscf-2.3.0/pyscf/geomopt/berny_solver.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/geomopt/geometric_solver.py` & `pyscf-2.3.0/pyscf/pbc/geomopt/geometric_solver.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 #!/usr/bin/env python
-# Copyright 2014-2019 The PySCF Developers. All Rights Reserved.
+# Copyright 2014-2021 The PySCF Developers. All Rights Reserved.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
@@ -18,20 +18,18 @@
 '''
 
 import os
 import tempfile
 import numpy
 import geometric
 import geometric.molecule
-#from geometric import molecule
 from pyscf import lib
-from pyscf.geomopt.addons import (as_pyscf_method, dump_mol_geometry,
-                                  symmetrize)  # noqa
+from pyscf.geomopt.addons import dump_mol_geometry
 from pyscf import __config__
-from pyscf.grad.rhf import GradientsMixin
+from pyscf.pbc.grad.krhf import GradientsMixin
 
 try:
     from geometric import internal, optimize, nifty, engine, molecule
 except ImportError:
     msg = ('Geometry optimizer geomeTRIC not found.\ngeomeTRIC library '
            'can be found on github https://github.com/leeping/geomeTRIC.\n'
            'You can install geomeTRIC with "pip install geometric"')
@@ -46,19 +44,19 @@
 
 INCLUDE_GHOST = getattr(__config__, 'geomopt_berny_solver_optimize_include_ghost', True)
 ASSERT_CONV = getattr(__config__, 'geomopt_berny_solver_optimize_assert_convergence', True)
 
 class PySCFEngine(geometric.engine.Engine):
     def __init__(self, scanner):
         molecule = geometric.molecule.Molecule()
-        self.mol = mol = scanner.mol
-        molecule.elem = [mol.atom_symbol(i) for i in range(mol.natm)]
+        self.cell = cell = scanner.cell
+        molecule.elem = [cell.atom_symbol(i) for i in range(cell.natm)]
         # Molecule is the geometry parser for a bunch of formats which use
         # Angstrom for Cartesian coordinates by default.
-        molecule.xyzs = [mol.atom_coords()*lib.param.BOHR]  # In Angstrom
+        molecule.xyzs = [cell.atom_coords()*lib.param.BOHR]  # In Angstrom
         super(PySCFEngine, self).__init__(molecule)
 
         self.scanner = scanner
         self.cycle = 0
         self.e_last = 0
         self.callback = None
         self.maxsteps = 100
@@ -66,28 +64,25 @@
 
     def calc_new(self, coords, dirname):
         if self.cycle >= self.maxsteps:
             raise NotConvergedError('Geometry optimization is not converged in '
                                     '%d iterations' % self.maxsteps)
 
         g_scanner = self.scanner
-        mol = self.mol
+        cell = self.cell
         self.cycle += 1
         lib.logger.note(g_scanner, '\nGeometry optimization cycle %d', self.cycle)
 
         # geomeTRIC requires coords and gradients in atomic unit
         coords = coords.reshape(-1,3)
         if g_scanner.verbose >= lib.logger.NOTE:
-            dump_mol_geometry(mol, coords*lib.param.BOHR)
+            dump_mol_geometry(cell, coords*lib.param.BOHR)
 
-        if mol.symmetry:
-            coords = symmetrize(mol, coords)
-
-        mol.set_geom_(coords, unit='Bohr')
-        energy, gradients = g_scanner(mol)
+        cell.set_geom_(coords, unit='Bohr')
+        energy, gradients = g_scanner(cell)
         lib.logger.note(g_scanner,
                         'cycle %d: E = %.12g  dE = %g  norm(grad) = %g', self.cycle,
                         energy, energy - self.e_last, numpy.linalg.norm(gradients))
         self.e_last = energy
 
         if callable(self.callback):
             self.callback(locals())
@@ -122,46 +117,44 @@
     elif isinstance(method, GradientsMixin):
         g_scanner = method.as_scanner()
     elif getattr(method, 'nuc_grad_method', None):
         g_scanner = method.nuc_grad_method().as_scanner()
     else:
         raise NotImplementedError('Nuclear gradients of %s not available' % method)
     if not include_ghost:
-        g_scanner.atmlst = numpy.where(method.mol.atom_charges() != 0)[0]
+        g_scanner.atmlst = numpy.where(method.cell.atom_charges() != 0)[0]
 
     tmpf = tempfile.mktemp(dir=lib.param.TMPDIR)
     engine = PySCFEngine(g_scanner)
     engine.callback = callback
     engine.maxsteps = maxsteps
     # To avoid overwritting method.mol
-    engine.mol = g_scanner.mol.copy()
+    engine.cell = g_scanner.cell.copy()
 
     # When symmetry is enabled, the molecule may be shifted or rotated to make
     # the z-axis be the main axis. The transformation can cause inconsistency
     # between the optimization steps. The transformation is muted by setting
     # an explict point group to the keyword mol.symmetry (see symmetry
     # detection code in Mole.build function).
-    if engine.mol.symmetry:
-        engine.mol.symmetry = engine.mol.topgroup
 
     # geomeTRIC library on pypi requires to provide config file log.ini.
     if not os.path.exists(os.path.abspath(
-            os.path.join(geometric.optimize.__file__, '..', 'log.ini'))) and kwargs.get('logIni') is None:
+            os.path.join(geometric.optimize.__file__, '..', 'log.ini'))):
         kwargs['logIni'] = os.path.abspath(os.path.join(__file__, '..', 'log.ini'))
 
     engine.assert_convergence = assert_convergence
     try:
         geometric.optimize.run_optimizer(customengine=engine, input=tmpf,
                                          constraints=constraints, **kwargs)
         conv = True
         # method.mol.set_geom_(m.xyzs[-1], unit='Angstrom')
     except NotConvergedError as e:
         lib.logger.note(method, str(e))
         conv = False
-    return conv, engine.mol
+    return conv, engine.cell
 
 def optimize(method, assert_convergence=ASSERT_CONV,
              include_ghost=INCLUDE_GHOST, constraints=None, callback=None,
              maxsteps=100, **kwargs):
     '''Optimize geometry with geomeTRIC library for the given method.
 
     To adjust the convergence threshold, parameters can be set in kwargs as
@@ -190,70 +183,64 @@
     def __init__(self, method):
         self.method = method
         self.callback = None
         self.params = {}
         self.converged = False
         self.max_cycle = 100
 
+
     @property
-    def mol(self):
-        return self.method.mol
-    @mol.setter
-    def mol(self, x):
+    def cell(self):
+        return self.method.cell
+
+    @cell.setter
+    def cell(self, x):
+        self.method.cell = x
         self.method.mol = x
 
     def kernel(self, params=None):
         if params is not None:
             self.params.update(params)
-        self.converged, self.mol = \
+        self.converged, self.cell = \
                 kernel(self.method, callback=self.callback,
                        maxsteps=self.max_cycle, **self.params)
-        return self.mol
+        return self.cell
     optimize = kernel
 
 class NotConvergedError(RuntimeError):
     pass
 
 del (INCLUDE_GHOST, ASSERT_CONV)
 
 
 if __name__ == '__main__':
-    from pyscf import gto
-    from pyscf import scf, dft, cc, mp
-    mol = gto.M(atom='''
-C       1.1879  -0.3829 0.0000
-C       0.0000  0.5526  0.0000
-O       -1.1867 -0.2472 0.0000
-H       -1.9237 0.3850  0.0000
-H       2.0985  0.2306  0.0000
-H       1.1184  -1.0093 0.8869
-H       1.1184  -1.0093 -0.8869
-H       -0.0227 1.1812  0.8852
-H       -0.0227 1.1812  -0.8852
-                ''',
-                basis='3-21g')
-
-    mf = scf.RHF(mol)
+    from pyscf.pbc import gto, scf, grad
+    cell = gto.Cell()
+    cell.atom = '''
+    C 0.000000000000 0.000000000000 0.000000000000
+    C 1.685068664391 1.685068664391 1.685068664391
+    '''
+    cell.atom= [['C', [0.0, 0.0, 0.0]], ['C', [1.685068664391,1.685068664391,1.685068664391]]]
+    cell.a = '''
+    0.000000000, 3.370137329, 3.370137329
+    3.370137329, 0.000000000, 3.370137329
+    3.370137329, 3.370137329, 0.000000000'''
+    cell.basis = 'gth-szv'
+    cell.verbose= 4
+    cell.pseudo = 'gth-pade'
+    cell.unit = 'bohr'
+    cell.build()
+
+    kpts = cell.make_kpts([1,1,3])
+    mf = scf.KRHF(cell, kpts, exxdiv=None)
+    mf.conv_tol = 1e-14
+    mf.conv_tol_grad = 1e-8
     conv_params = {
         'convergence_energy': 1e-4,  # Eh
-        'convergence_grms': 3e-3,    # Eh/Bohr
-        'convergence_gmax': 4.5e-3,  # Eh/Bohr
+        'convergence_grms': 1e-5,    # Eh/Bohr
+        'convergence_gmax': 1e-5,  # Eh/Bohr
         'convergence_drms': 1.2e-2,  # Angstrom
         'convergence_dmax': 1.8e-2,  # Angstrom
     }
     opt = GeometryOptimizer(mf).set(params=conv_params)#.run()
-    opt.max_cycle=1
     opt.run()
-    mol1 = opt.mol
-    print(mf.kernel() - -153.219208484874)
-    print(scf.RHF(mol1).kernel() - -153.222680852335)
-
-    mf = dft.RKS(mol)
-    mf.xc = 'pbe,'
-    mf.conv_tol = 1e-7
-    mol1 = optimize(mf)
-
-    mymp2 = mp.MP2(scf.RHF(mol))
-    mol1 = optimize(mymp2)
-
-    mycc = cc.CCSD(scf.RHF(mol))
-    mol1 = optimize(mycc)
+    cell = opt.cell
```

### Comparing `pyscf-2.2.1/pyscf/grad/__init__.py` & `pyscf-2.3.0/pyscf/grad/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/casci.py` & `pyscf-2.3.0/pyscf/grad/casci.py`

 * *Files 0% similar despite different names*

```diff
@@ -220,14 +220,15 @@
         def __init__(self, g):
             lib.GradScanner.__init__(self, g)
         def __call__(self, mol_or_geom, state=state, **kwargs):
             if isinstance(mol_or_geom, gto.Mole):
                 mol = mol_or_geom
             else:
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
+            self.reset(mol)
 
             if state is None:
                 state = self.state
 
             mc_scanner = self.base
 # TODO: Check root flip
             e_tot = mc_scanner(mol)
@@ -238,15 +239,14 @@
                 if state >= mc_scanner.fcisolver.nroots:
                     raise ValueError('State ID greater than the number of CASCI roots')
                 e_tot = e_tot[state]
                 # target at a specific state, to avoid overwriting self.state
                 # in self.kernel
                 ci = ci[state]
 
-            self.mol = mol
             de = self.kernel(ci=ci, state=state, **kwargs)
             return e_tot, de
     return CASCI_GradScanner(mcscf_grad)
 
 
 class Gradients(rhf_grad.GradientsMixin):
     '''Non-relativistic restricted Hartree-Fock gradients'''
```

### Comparing `pyscf-2.2.1/pyscf/grad/casscf.py` & `pyscf-2.3.0/pyscf/grad/casscf.py`

 * *Files 0% similar despite different names*

```diff
@@ -167,21 +167,21 @@
         def __init__(self, g):
             lib.GradScanner.__init__(self, g)
         def __call__(self, mol_or_geom, **kwargs):
             if isinstance(mol_or_geom, gto.Mole):
                 mol = mol_or_geom
             else:
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
+            self.reset(mol)
 
             mc_scanner = self.base
             e_tot = mc_scanner(mol)
             if isinstance(mc_scanner, StateAverageMCSCFSolver):
                 e_tot = mc_scanner.e_average
 
-            self.mol = mol
             de = self.kernel(**kwargs)
             return e_tot, de
     return CASSCF_GradScanner(mcscf_grad)
 
 
 class Gradients(casci_grad.Gradients):
     '''Non-relativistic restricted Hartree-Fock gradients'''
```

### Comparing `pyscf-2.2.1/pyscf/grad/ccsd.py` & `pyscf-2.3.0/pyscf/grad/ccsd.py`

 * *Files 0% similar despite different names*

```diff
@@ -234,23 +234,22 @@
 
             cc = self.base
             if cc.t2 is not None:
                 last_size = cc.vector_size()
             else:
                 last_size = 0
 
-            cc.reset(mol)
+            self.reset(mol)
             mf_scanner = cc._scf
             mf_scanner(mol)
             cc.mo_coeff = mf_scanner.mo_coeff
             cc.mo_occ = mf_scanner.mo_occ
             if last_size != cc.vector_size():
                 cc.t1 = cc.t2 = cc.l1 = cc.l2 = None
 
-            self.mol = mol
             eris = cc.ao2mo(cc.mo_coeff)
             # Update cc.t1 and cc.t2
             cc.kernel(t1=cc.t1, t2=cc.t2, eris=eris)
             # Update cc.l1 and cc.l2
             cc.solve_lambda(l1=cc.l1, l2=cc.l2, eris=eris)
 
             de = self.kernel(cc.t1, cc.t2, cc.l1, cc.l2, eris=eris, **kwargs)
```

### Comparing `pyscf-2.2.1/pyscf/grad/ccsd_slow.py` & `pyscf-2.3.0/pyscf/grad/ccsd_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/ccsd_t.py` & `pyscf-2.3.0/pyscf/grad/ccsd_t.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/cisd.py` & `pyscf-2.3.0/pyscf/grad/cisd.py`

 * *Files 1% similar despite different names*

```diff
@@ -74,14 +74,15 @@
             lib.GradScanner.__init__(self, g)
 
         def __call__(self, mol_or_geom, state=state, **kwargs):
             if isinstance(mol_or_geom, gto.Mole):
                 mol = mol_or_geom
             else:
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
+            self.reset(mol)
 
             ci_scanner = self.base
             if ci_scanner.nroots > 1 and state >= ci_scanner.nroots:
                 raise ValueError('State ID greater than the number of CISD roots')
 
             mf_scanner = ci_scanner._scf
             mf_scanner(mol)
@@ -97,15 +98,14 @@
             if ci_scanner.nroots > 1:
                 e_tot = ci_scanner.e_tot[state]
                 civec = ci_scanner.ci[state]
             else:
                 e_tot = ci_scanner.e_tot
                 civec = ci_scanner.ci
 
-            self.mol = mol
             de = self.kernel(civec, eris=eris, **kwargs)
             return e_tot, de
         @property
         def converged(self):
             ci_scanner = self.base
             if ci_scanner.nroots > 1:
                 ci_conv = ci_scanner.converged[state]
```

### Comparing `pyscf-2.2.1/pyscf/grad/dhf.py` & `pyscf-2.3.0/pyscf/grad/dhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/lagrange.py` & `pyscf-2.3.0/pyscf/grad/lagrange.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/mp2.py` & `pyscf-2.3.0/pyscf/grad/mp2.py`

 * *Files 0% similar despite different names*

```diff
@@ -220,14 +220,15 @@
         def __init__(self, g):
             lib.GradScanner.__init__(self, g)
         def __call__(self, mol_or_geom, **kwargs):
             if isinstance(mol_or_geom, gto.Mole):
                 mol = mol_or_geom
             else:
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
+            self.reset(mol)
 
             mp_scanner = self.base
             mp_scanner(mol, with_t2=True)
             de = self.kernel(mp_scanner.t2)
             return mp_scanner.e_tot, de
         @property
         def converged(self):
@@ -275,15 +276,15 @@
 class Gradients(rhf_grad.GradientsMixin):
 
     grad_elec = grad_elec
 
     def kernel(self, t2=None, atmlst=None, verbose=None):
         log = logger.new_logger(self, verbose)
         if t2 is None: t2 = self.base.t2
-        if t2 is None: t2 = self.base.kernel()
+        if t2 is None: t2 = self.base.kernel()[1]
         if atmlst is None:
             atmlst = self.atmlst
         else:
             self.atmlst = atmlst
 
         de = self.grad_elec(t2, atmlst, verbose=log)
         self.de = de + self.grad_nuc(atmlst=atmlst)
```

### Comparing `pyscf-2.2.1/pyscf/grad/rhf.py` & `pyscf-2.3.0/pyscf/grad/rhf.py`

 * *Files 3% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 
 
 import numpy
 import ctypes
 from pyscf import gto
 from pyscf import lib
 from pyscf.lib import logger
-from pyscf.scf import _vhf
+from pyscf.scf import hf, _vhf
 from pyscf.gto.mole import is_au
 
 
 def grad_elec(mf_grad, mo_energy=None, mo_coeff=None, mo_occ=None, atmlst=None):
     '''
     Electronic part of RHF/RKS gradients
 
@@ -251,22 +251,23 @@
             lib.GradScanner.__init__(self, g)
         def __call__(self, mol_or_geom, **kwargs):
             if isinstance(mol_or_geom, gto.Mole):
                 mol = mol_or_geom
             else:
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
 
+            self.reset(mol)
             mf_scanner = self.base
             e_tot = mf_scanner(mol)
-            self.mol = mol
 
-            # If second integration grids are created for RKS and UKS
-            # gradients
-            if getattr(self, 'grids', None):
-                self.grids.reset(mol)
+            if isinstance(mf_scanner, hf.KohnShamDFT):
+                if getattr(self, 'grids', None):
+                    self.grids.reset(mol)
+                if getattr(self, 'nlcgrids', None):
+                    self.nlcgrids.reset(mol)
 
             de = self.kernel(**kwargs)
             return e_tot, de
     return SCF_GradScanner(mf_grad)
 
 
 class GradientsMixin(lib.StreamObject):
@@ -297,14 +298,20 @@
             raise NotImplementedError('unit Eh/Ang is not supported')
         else:
             log.info('unit = Eh/Bohr')
         log.info('max_memory %d MB (current use %d MB)',
                  self.max_memory, lib.current_memory()[0])
         return self
 
+    def reset(self, mol=None):
+        if mol is not None:
+            self.mol = mol
+        self.base.reset(mol)
+        return self
+
     def get_hcore(self, mol=None):
         if mol is None: mol = self.mol
         return get_hcore(mol)
 
     hcore_generator = hcore_generator
 
     def get_ovlp(self, mol=None):
```

### Comparing `pyscf-2.2.1/pyscf/grad/rks.py` & `pyscf-2.3.0/pyscf/grad/rks.py`

 * *Files 6% similar despite different names*

```diff
@@ -39,52 +39,45 @@
         ks_grad : grad.uhf.Gradients or grad.uks.Gradients object
     '''
     if mol is None: mol = ks_grad.mol
     if dm is None: dm = ks_grad.base.make_rdm1()
     t0 = (logger.process_clock(), logger.perf_counter())
 
     mf = ks_grad.base
-    if ks_grad.grids is not None:
-        grids = ks_grad.grids
-    else:
-        grids = mf.grids
-    if mf.nlc != '':
-        if ks_grad.nlcgrids is not None:
-            nlcgrids = ks_grad.nlcgrids
-        else:
-            nlcgrids = mf.nlcgrids
-        if nlcgrids.coords is None:
-            nlcgrids.build(with_non0tab=True)
-    if grids.coords is None:
-        grids.build(with_non0tab=True)
-
     ni = mf._numint
+    grids, nlcgrids = _initialize_grids(ks_grad)
+
     mem_now = lib.current_memory()[0]
     max_memory = max(2000, ks_grad.max_memory*.9-mem_now)
     if ks_grad.grid_response:
         exc, vxc = get_vxc_full_response(ni, mol, grids, mf.xc, dm,
                                          max_memory=max_memory,
                                          verbose=ks_grad.verbose)
-        if mf.nlc:
-            assert 'VV10' in mf.nlc.upper()
-            enlc, vnlc = get_vxc_full_response(ni, mol, nlcgrids,
-                                               mf.xc+'__'+mf.nlc, dm,
-                                               max_memory=max_memory,
-                                               verbose=ks_grad.verbose)
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            if ni.libxc.is_nlc(mf.xc):
+                xc = mf.xc
+            else:
+                xc = mf.nlc
+            enlc, vnlc = get_nlc_vxc_full_response(
+                ni, mol, nlcgrids, xc, dm,
+                max_memory=max_memory, verbose=ks_grad.verbose)
             exc += enlc
             vxc += vnlc
         logger.debug1(ks_grad, 'sum(grids response) %s', exc.sum(axis=0))
     else:
         exc, vxc = get_vxc(ni, mol, grids, mf.xc, dm,
                            max_memory=max_memory, verbose=ks_grad.verbose)
-        if mf.nlc:
-            assert 'VV10' in mf.nlc.upper()
-            enlc, vnlc = get_vxc(ni, mol, nlcgrids, mf.xc+'__'+mf.nlc, dm,
-                                 max_memory=max_memory,
-                                 verbose=ks_grad.verbose)
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            if ni.libxc.is_nlc(mf.xc):
+                xc = mf.xc
+            else:
+                xc = mf.nlc
+            enlc, vnlc = get_nlc_vxc(
+                ni, mol, nlcgrids, xc, dm,
+                max_memory=max_memory, verbose=ks_grad.verbose)
             vxc += vnlc
     t0 = logger.timer(ks_grad, 'vxc', *t0)
 
     if not ni.libxc.is_hybrid_xc(mf.xc):
         vj = ks_grad.get_j(mol, dm)
         vxc += vj
     else:
@@ -93,14 +86,34 @@
         vk *= hyb
         if omega != 0:
             vk += ks_grad.get_k(mol, dm, omega=omega) * (alpha - hyb)
         vxc += vj - vk * .5
 
     return lib.tag_array(vxc, exc1_grid=exc)
 
+def _initialize_grids(ks_grad):
+    mf = ks_grad.base
+    ni = mf._numint
+    if ks_grad.grids is not None:
+        grids = ks_grad.grids
+    else:
+        grids = mf.grids
+    if grids.coords is None:
+        grids.build(with_non0tab=True)
+
+    nlcgrids = None
+    if mf.nlc or ni.libxc.is_nlc(mf.xc):
+        if ks_grad.nlcgrids is not None:
+            nlcgrids = ks_grad.nlcgrids
+        else:
+            nlcgrids = mf.nlcgrids
+        if nlcgrids.coords is None:
+            nlcgrids.build(with_non0tab=True)
+    return grids, nlcgrids
+
 
 def get_vxc(ni, mol, grids, xc_code, dms, relativity=0, hermi=1,
             max_memory=2000, verbose=None):
     xctype = ni._xc_type(xc_code)
     make_rho, nset, nao = ni._gen_rho_evaluator(mol, dms, hermi, False, grids)
     ao_loc = mol.ao_loc_nr()
 
@@ -123,39 +136,14 @@
             for idm in range(nset):
                 rho = make_rho(idm, ao[:4], mask, xctype)
                 vxc = ni.eval_xc_eff(xc_code, rho, 1, xctype=xctype)[1]
                 wv = weight * vxc
                 wv[0] *= .5
                 _gga_grad_sum_(vmat[idm], mol, ao, wv, mask, ao_loc)
 
-    elif xctype == 'NLC':
-        nlc_pars = ni.nlc_coeff(xc_code)
-        ao_deriv = 2
-        vvrho = []
-        for ao, mask, weight, coords \
-                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
-            vvrho.append([make_rho(idm, ao[:4], mask, 'GGA')
-                          for idm in range(nset)])
-
-        vv_vxc = []
-        for idm in range(nset):
-            rho = numpy.hstack([r[idm] for r in vvrho])
-            vxc = numint._vv10nlc(rho, grids.coords, rho, grids.weights,
-                                  grids.coords, nlc_pars)[1]
-            vv_vxc.append(xc_deriv.transform_vxc(rho, vxc, 'GGA', spin=0))
-
-        p1 = 0
-        for ao, mask, weight, coords \
-                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
-            p0, p1 = p1, p1 + weight.size
-            for idm in range(nset):
-                wv = vv_vxc[idm][:,p0:p1] * weight
-                wv[0] *= .5  # *.5 because vmat + vmat.T at the end
-                _gga_grad_sum_(vmat[idm], mol, ao, wv, mask, ao_loc)
-
     elif xctype == 'MGGA':
         ao_deriv = 2
         for ao, mask, weight, coords \
                 in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
             for idm in range(nset):
                 rho = make_rho(idm, ao[:10], mask, xctype)
                 vxc = ni.eval_xc_eff(xc_code, rho, 1, xctype=xctype)[1]
@@ -167,14 +155,48 @@
 
     exc = None
     if nset == 1:
         vmat = vmat[0]
     # - sign because nabla_X = -nabla_x
     return exc, -vmat
 
+def get_nlc_vxc(ni, mol, grids, xc_code, dm, relativity=0, hermi=1,
+                max_memory=2000, verbose=None):
+    make_rho, nset, nao = ni._gen_rho_evaluator(mol, dm, hermi, False, grids)
+    assert nset == 1
+    ao_loc = mol.ao_loc_nr()
+
+    vmat = numpy.zeros((3,nao,nao))
+    nlc_coefs = ni.nlc_coeff(xc_code)
+    if len(nlc_coefs) != 1:
+        raise NotImplementedError('Additive NLC')
+    nlc_pars, fac = nlc_coefs[0]
+    ao_deriv = 2
+    vvrho = []
+    for ao, mask, weight, coords \
+            in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
+        vvrho.append(make_rho(0, ao[:4], mask, 'GGA'))
+    rho = numpy.hstack(vvrho)
+
+    vxc = numint._vv10nlc(rho, grids.coords, rho, grids.weights,
+                          grids.coords, nlc_pars)[1]
+    vv_vxc = xc_deriv.transform_vxc(rho, vxc, 'GGA', spin=0)
+
+    p1 = 0
+    for ao, mask, weight, coords \
+            in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
+        p0, p1 = p1, p1 + weight.size
+        wv = vv_vxc[:,p0:p1] * weight
+        wv[0] *= .5  # *.5 because vmat + vmat.T at the end
+        _gga_grad_sum_(vmat, mol, ao, wv, mask, ao_loc)
+
+    exc = None
+    # - sign because nabla_X = -nabla_x
+    return exc, -vmat
+
 def _make_dR_dao_w(ao, wv):
     #:aow = numpy.einsum('npi,p->npi', ao[1:4], wv[0])
     aow = [
         numint._scale_ao(ao[1], wv[0]),  # dX nabla_x
         numint._scale_ao(ao[2], wv[0]),  # dX nabla_y
         numint._scale_ao(ao[3], wv[0]),  # dX nabla_z
     ]
@@ -335,64 +357,14 @@
 
             # response of weights
             excsum += numpy.einsum('r,r,nxr->nx', exc, rho[0], weight1)
             # response of grids coordinates
             excsum[atm_id] += numpy.einsum('xij,ji->x', vtmp, dms) * 2
             rho = vxc = wv = None
 
-    elif xctype == 'NLC':
-        nlc_pars = ni.nlc_coeff(xc_code)
-        ao_deriv = 2
-        vvrho = []
-        vvcoords = []
-        vvweights = []
-        for atm_id, (coords, weight) in enumerate(grids_noresponse_cc(grids)):
-            mask = gen_grid.make_mask(mol, coords)
-            ao = ni.eval_ao(mol, coords, deriv=ao_deriv, non0tab=mask,
-                            cutoff=grids.cutoff)
-            vvrho.append(make_rho(0, ao[:4], mask, 'GGA'))
-            vvcoords.append(coords)
-            vvweights.append(weight)
-
-        vv_vxc = []
-        vvcoords_flat = numpy.vstack(vvcoords)
-        vvweights_flat = numpy.concatenate(vvweights)
-        vvrho_flat = numpy.hstack(vvrho)
-        for atm_id, (coords, weight, weight1) in enumerate(grids_response_cc(grids)):
-            rho = vvrho[atm_id]
-            mask = gen_grid.make_mask(mol, coords)
-            ao = ni.eval_ao(mol, coords, deriv=ao_deriv, non0tab=mask,
-                            cutoff=grids.cutoff)
-
-            exc, vxc = numint._vv10nlc(rho, coords, vvrho_flat, vvweights_flat,
-                                       vvcoords_flat, nlc_pars)
-            vv_vxc = xc_deriv.transform_vxc(rho, vxc, 'GGA', spin=0)
-            wv = vv_vxc * weight
-            wv[0] *= .5
-            vtmp = numpy.zeros((3,nao,nao))
-            _gga_grad_sum_(vtmp, mol, ao, wv, mask, ao_loc)
-            vmat += vtmp
-
-            vvrho_sub = numpy.hstack(
-                [r for i, r in enumerate(vvrho) if i != atm_id])
-            vvcoords_sub = numpy.vstack(
-                [r for i, r in enumerate(vvcoords) if i != atm_id])
-            vvweights_sub = numpy.concatenate(
-                [r for i, r in enumerate(vvweights) if i != atm_id])
-            egrad, Beta = _vv10nlc_grad(rho, coords, vvrho_sub,
-                                        vvweights_sub, vvcoords_sub,
-                                        nlc_pars)
-            # account for factor of 2 in double integration
-            exc -= 0.5 * Beta
-            # response of weights
-            excsum += 2 * numpy.einsum('r,r,nxr->nx', exc, rho[0], weight1)
-            # response of grids coordinates
-            excsum[atm_id] += 2 * numpy.einsum('xij,ji->x', vtmp, dms)
-            excsum[atm_id] += numpy.einsum('r,rx->x', rho[0]*weight, egrad)
-
     elif xctype == 'MGGA':
         ao_deriv = 2
         for atm_id, (coords, weight, weight1) in enumerate(grids_response_cc(grids)):
             mask = gen_grid.make_mask(mol, coords)
             ao = ni.eval_ao(mol, coords, deriv=ao_deriv, non0tab=mask,
                             cutoff=grids.cutoff)
             rho = make_rho(0, ao[:10], mask, xctype)
@@ -411,14 +383,75 @@
             # response of grids coordinates
             excsum[atm_id] += numpy.einsum('xij,ji->x', vtmp, dms) * 2
             rho = vxc = wv = None
 
     # - sign because nabla_X = -nabla_x
     return excsum, -vmat
 
+def get_nlc_vxc_full_response(ni, mol, grids, xc_code, dms, relativity=0, hermi=1,
+                              max_memory=2000, verbose=None):
+    '''Full NLC functional response including the response of the grids'''
+    make_rho, nset, nao = ni._gen_rho_evaluator(mol, dms, hermi, False, grids)
+    ao_loc = mol.ao_loc_nr()
+
+    excsum = numpy.zeros((mol.natm,3))
+    vmat = numpy.zeros((3,nao,nao))
+    nlc_coefs = ni.nlc_coeff(xc_code)
+    if len(nlc_coefs) != 1:
+        raise NotImplementedError('Additive NLC')
+    nlc_pars, fac = nlc_coefs[0]
+    ao_deriv = 2
+    vvrho = []
+    vvcoords = []
+    vvweights = []
+    for atm_id, (coords, weight) in enumerate(grids_noresponse_cc(grids)):
+        mask = gen_grid.make_mask(mol, coords)
+        ao = ni.eval_ao(mol, coords, deriv=ao_deriv, non0tab=mask,
+                        cutoff=grids.cutoff)
+        vvrho.append(make_rho(0, ao[:4], mask, 'GGA'))
+        vvcoords.append(coords)
+        vvweights.append(weight)
+    vvcoords_flat = numpy.vstack(vvcoords)
+    vvweights_flat = numpy.concatenate(vvweights)
+    vvrho_flat = numpy.hstack(vvrho)
+
+    vv_vxc = []
+    for atm_id, (coords, weight, weight1) in enumerate(grids_response_cc(grids)):
+        rho = vvrho[atm_id]
+        mask = gen_grid.make_mask(mol, coords)
+        ao = ni.eval_ao(mol, coords, deriv=ao_deriv, non0tab=mask,
+                        cutoff=grids.cutoff)
+
+        exc, vxc = numint._vv10nlc(rho, coords, vvrho_flat, vvweights_flat,
+                                   vvcoords_flat, nlc_pars)
+        vv_vxc = xc_deriv.transform_vxc(rho, vxc, 'GGA', spin=0)
+        wv = vv_vxc * weight
+        wv[0] *= .5
+        vtmp = numpy.zeros((3,nao,nao))
+        _gga_grad_sum_(vtmp, mol, ao, wv, mask, ao_loc)
+        vmat += vtmp
+
+        vvrho_sub = numpy.hstack(
+            [r for i, r in enumerate(vvrho) if i != atm_id])
+        vvcoords_sub = numpy.vstack(
+            [r for i, r in enumerate(vvcoords) if i != atm_id])
+        vvweights_sub = numpy.concatenate(
+            [r for i, r in enumerate(vvweights) if i != atm_id])
+        egrad, Beta = _vv10nlc_grad(rho, coords, vvrho_sub,
+                                    vvweights_sub, vvcoords_sub, nlc_pars)
+        # account for factor of 2 in double integration
+        exc -= 0.5 * Beta
+        # response of weights
+        excsum += 2 * numpy.einsum('r,r,nxr->nx', exc, rho[0], weight1)
+        # response of grids coordinates
+        excsum[atm_id] += 2 * numpy.einsum('xij,ji->x', vtmp, dms)
+        excsum[atm_id] += numpy.einsum('r,rx->x', rho[0]*weight, egrad)
+    # - sign because nabla_X = -nabla_x
+    return excsum, -vmat
+
 
 # JCP 98, 5612 (1993); DOI:10.1063/1.464906
 def grids_response_cc(grids):
     mol = grids.mol
     atom_grids_tab = grids.gen_atomic_grids(mol, grids.atom_grid,
                                             grids.radi_method,
                                             grids.level, grids.prune)
```

### Comparing `pyscf-2.2.1/pyscf/grad/rohf.py` & `pyscf-2.3.0/pyscf/grad/rohf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/roks.py` & `pyscf-2.3.0/pyscf/grad/roks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/sacasscf.py` & `pyscf-2.3.0/pyscf/grad/sacasscf.py`

 * *Files 3% similar despite different names*

```diff
@@ -369,21 +369,21 @@
             else:
                 self.state = state
         def __call__(self, mol_or_geom, **kwargs):
             if isinstance(mol_or_geom, gto.Mole):
                 mol = mol_or_geom
             else:
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
+            self.reset(mol)
             if 'state' in kwargs: self.state = kwargs['state']
             mc_scanner = self.base
             e_tot = mc_scanner(mol)
             if hasattr (mc_scanner, 'e_mcscf'): self.e_mcscf = mc_scanner.e_mcscf
             if hasattr (mc_scanner, 'e_states') and self.state is not None:
                 e_tot = mc_scanner.e_states[self.state]
-            self.mol = mol
             if not ('state' in kwargs):
                 kwargs['state'] = self.state
             de = self.kernel(**kwargs)
             return e_tot, de
 
     return CASSCF_GradScanner(mcscf_grad)
 
@@ -443,47 +443,88 @@
         xci = []
         for na, nb in zip (self.na_states, self.nb_states):
             xci.append (x[:na*nb].reshape (na, nb))
             x = x[na*nb:]
         return xorb, xci
 
     def make_fcasscf (self, state=None, casscf_attr={}, fcisolver_attr={}):
-        ''' Make a fake CASSCF object for ostensible single-state calculations '''
+        ''' SA-CASSCF nuclear gradients require 1) first derivatives wrt wave function variables
+        and nuclear shifts of the target state's energy, AND 2) first and second derivatives of the
+        objective function used to determine the MO coefficients and CI vectors. This function
+        addresses 1).
+
+        Kwargs:
+            state : integer
+                The specific state whose energy is being differentiated. This kwarg is necessary
+                in the context of state_average_mix, where the number of electrons and the
+                make_rdm* functions differ from state to state.
+            casscf_attr : dictionary
+                Extra attributes to apply to fcasscf. Relevant to child methods (i.e., MC-PDFT;
+                NACs)
+            fcisolver_attr : dictionary
+                Extra attributes to apply to fcasscf.fcisolver. Relevant to child methods (i.e.,
+                MC-PDFT; NACs)
+
+        Returns:
+            fcasscf : object of :class:`mc1step.CASSCF`
+                Set up to evaluate first derivatives of state "state". Only functions, classes,
+                and the nelecas variable are set up; the caller should assign MO coefficients
+                and CI vectors explicitly post facto.
+        '''
         fcasscf = mcscf.CASSCF (self.base._scf, self.base.ncas, self.base.nelecas)
         fcasscf.__dict__.update (self.base.__dict__)
 
+        nelecas = self.base.nelecas
         if isinstance (fcasscf.fcisolver, StateAverageFCISolver):
             if isinstance (fcasscf.fcisolver, StateAverageMixFCISolver):
                 p0 = 0
                 for solver in fcasscf.fcisolver.fcisolvers:
                     p1 = p0 + solver.nroots
                     if p0 <= state < p1:
                         solver_class = solver.__class__
                         solver_obj = solver
+                        nelecas = fcasscf.fcisolver._get_nelec (solver_obj, nelecas)
                         break
                     p0 = p1
             else:
                 solver_class = self.base.fcisolver._base_class
                 solver_obj = self.base.fcisolver
             fcasscf.fcisolver = solver_class (self.base.mol)
             fcasscf.fcisolver.__dict__.update (solver_obj.__dict__)
             fcasscf.fcisolver.nroots = 1
         # Spin penalty method is inapplicable to response calc'ns
         # It must be deactivated for Lagrange multipliers to converge
         if isinstance (fcasscf.fcisolver, SpinPenaltyFCISolver):
             fcasscf.fcisolver = copy.copy (fcasscf.fcisolver)
             fcasscf.fcisolver.ss_penalty = 0
         fcasscf.__dict__.update (casscf_attr)
+        fcasscf.nelecas = nelecas
         fcasscf.fcisolver.__dict__.update (fcisolver_attr)
         fcasscf.verbose, fcasscf.stdout = self.verbose, self.stdout
         fcasscf._tag_gfock_ov_nonzero = True
         return fcasscf
 
     def make_fcasscf_sa (self, casscf_attr={}, fcisolver_attr={}):
-        ''' Make a fake SA-CASSCF object to get around weird inheritance conflicts '''
+        ''' SA-CASSCF nuclear gradients require 1) first derivatives wrt wave function variables
+        and nuclear shifts of the target state's energy, AND 2) first and second derivatives of the
+        objective function used to determine the MO coefficients and CI vectors. This function
+        addresses 2). Note that penalty methods etc. must be removed, and that child methods such
+        as MC-PDFT which do not reoptimize the orbitals also do not alter this function.
+
+        Kwargs:
+            casscf_attr : dictionary
+                Extra attributes to apply to fcasscf. Just in case.
+            fcisolver_attr : dictionary
+                Extra attributes to apply to fcasscf.fcisolver. Just in case.
+
+        Returns:
+            fcasscf : object of :class:`StateAverageMCSCFSolver`
+                Set up to evaluate second derivatives of SA-CASSCF average energy in the
+                absence of (i.e., spin) penalties.
+        '''
         fcasscf = self.make_fcasscf (state=0, casscf_attr={}, fcisolver_attr={})
         fcasscf.__dict__.update (self.base.__dict__)
         if isinstance (self.base, StateAverageMCSCFSolver):
             if isinstance (self.base.fcisolver, StateAverageMixFCISolver):
                 fcisolvers = [copy.copy (f) for f in
                               self.base.fcisolver.fcisolvers]
                 # Spin penalty method is inapplicable to response calc'ns
```

### Comparing `pyscf-2.2.1/pyscf/grad/tdrhf.py` & `pyscf-2.3.0/pyscf/grad/tdrhf.py`

 * *Files 5% similar despite different names*

```diff
@@ -122,18 +122,19 @@
 
     dmz1doo = z1ao + dmzoo
     oo0 = reduce(numpy.dot, (orbo, orbo.T))
     vj, vk = td_grad.get_jk(mol, (oo0, dmz1doo+dmz1doo.T, dmxpy+dmxpy.T,
                                   dmxmy-dmxmy.T))
     vj = vj.reshape(-1,3,nao,nao)
     vk = vk.reshape(-1,3,nao,nao)
+    vhf1 = -vk
     if singlet:
-        vhf1 = vj * 2 - vk
+        vhf1 += vj * 2
     else:
-        vhf1 = numpy.vstack((vj[:2]*2-vk[:2], -vk[2:]))
+        vhf1[:2] += vj[:2]*2
     time1 = log.timer('2e AO integral derivatives', *time1)
 
     if atmlst is None:
         atmlst = range(mol.natm)
     offsetdic = mol.offset_nr_by_atom()
     de = numpy.zeros((len(atmlst),3))
     for k, ia in enumerate(atmlst):
@@ -195,18 +196,18 @@
             lib.GradScanner.__init__(self, g)
             self._keys = self._keys.union(['e_tot'])
         def __call__(self, mol_or_geom, state=state, **kwargs):
             if isinstance(mol_or_geom, gto.Mole):
                 mol = mol_or_geom
             else:
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
+            self.reset(mol)
 
             td_scanner = self.base
             td_scanner(mol)
-            self.mol = mol
 # TODO: Check root flip.  Maybe avoid the initial guess in TDHF otherwise
 # large error may be found in the excited states amplitudes
             de = self.kernel(state=state, **kwargs)
             e_tot = self.e_tot[state-1]
             return e_tot, de
         @property
         def converged(self):
```

### Comparing `pyscf-2.2.1/pyscf/grad/tdrks.py` & `pyscf-2.3.0/pyscf/grad/tdrks.py`

 * *Files 8% similar despite different names*

```diff
@@ -72,18 +72,14 @@
 
     mem_now = lib.current_memory()[0]
     max_memory = max(2000, td_grad.max_memory*.9-mem_now)
 
     ni = mf._numint
     ni.libxc.test_deriv_order(mf.xc, 3, raise_error=True)
     omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
-    # dm0 = mf.make_rdm1(mo_coeff, mo_occ), but it is not used when computing
-    # fxc since rho0 is passed to fxc function.
-    rho0, vxc, fxc = ni.cache_xc_kernel(mf.mol, mf.grids, mf.xc,
-                                        [mo_coeff]*2, [mo_occ*.5]*2, spin=1)
     f1vo, f1oo, vxc1, k1ao = \
             _contract_xc_kernel(td_grad, mf.xc, dmxpy,
                                 dmzoo, True, True, singlet, max_memory)
 
     if ni.libxc.is_hybrid_xc(mf.xc):
         dm = (dmzoo, dmxpy+dmxpy.T, dmxmy-dmxmy.T)
         vj, vk = mf.get_jk(mol, dm, hermi=0)
@@ -91,30 +87,30 @@
         if omega != 0:
             vk += mf.get_k(mol, dm, hermi=0, omega=omega) * (alpha-hyb)
         veff0doo = vj[0] * 2 - vk[0] + f1oo[0] + k1ao[0] * 2
         wvo = reduce(numpy.dot, (orbv.T, veff0doo, orbo)) * 2
         if singlet:
             veff = vj[1] * 2 - vk[1] + f1vo[0] * 2
         else:
-            veff = -vk[1] + f1vo[0] * 2
+            veff = f1vo[0] - vk[1]
         veff0mop = reduce(numpy.dot, (mo_coeff.T, veff, mo_coeff))
         wvo -= numpy.einsum('ki,ai->ak', veff0mop[:nocc,:nocc], xpy) * 2
         wvo += numpy.einsum('ac,ai->ci', veff0mop[nocc:,nocc:], xpy) * 2
         veff = -vk[2]
         veff0mom = reduce(numpy.dot, (mo_coeff.T, veff, mo_coeff))
         wvo -= numpy.einsum('ki,ai->ak', veff0mom[:nocc,:nocc], xmy) * 2
         wvo += numpy.einsum('ac,ai->ci', veff0mom[nocc:,nocc:], xmy) * 2
     else:
         vj = mf.get_j(mol, (dmzoo, dmxpy+dmxpy.T), hermi=1)
         veff0doo = vj[0] * 2 + f1oo[0] + k1ao[0] * 2
         wvo = reduce(numpy.dot, (orbv.T, veff0doo, orbo)) * 2
         if singlet:
             veff = vj[1] * 2 + f1vo[0] * 2
         else:
-            veff = f1vo[0] * 2
+            veff = f1vo[0]
         veff0mop = reduce(numpy.dot, (mo_coeff.T, veff, mo_coeff))
         wvo -= numpy.einsum('ki,ai->ak', veff0mop[:nocc,:nocc], xpy) * 2
         wvo += numpy.einsum('ac,ai->ci', veff0mop[nocc:,nocc:], xpy) * 2
         veff0mom = numpy.zeros((nmo,nmo))
 
     # set singlet=None, generate function for CPHF type response kernel
     vresp = mf.gen_response(singlet=None, hermi=1)
@@ -124,15 +120,15 @@
         return reduce(numpy.dot, (orbv.T, v1ao, orbo)).ravel()
     z1 = cphf.solve(fvind, mo_energy, mo_occ, wvo,
                     max_cycle=td_grad.cphf_max_cycle,
                     tol=td_grad.cphf_conv_tol)[0]
     z1 = z1.reshape(nvir,nocc)
     time1 = log.timer('Z-vector using CPHF solver', *time0)
 
-    z1ao  = reduce(numpy.dot, (orbv, z1, orbo.T))
+    z1ao = reduce(numpy.dot, (orbv, z1, orbo.T))
     veff = vresp(z1ao+z1ao.T)
 
     im0 = numpy.zeros((nmo,nmo))
     im0[:nocc,:nocc] = reduce(numpy.dot, (orbo.T, veff0doo+veff, orbo))
     im0[:nocc,:nocc]+= numpy.einsum('ak,ai->ki', veff0mop[nocc:,:nocc], xpy)
     im0[:nocc,:nocc]+= numpy.einsum('ak,ai->ki', veff0mom[nocc:,:nocc], xmy)
     im0[nocc:,nocc:] = numpy.einsum('ci,ai->ac', veff0mop[nocc:,:nocc], xpy)
@@ -162,33 +158,37 @@
         dm = (oo0, dmz1doo+dmz1doo.T, dmxpy+dmxpy.T, dmxmy-dmxmy.T)
         vj, vk = td_grad.get_jk(mol, dm)
         vk *= hyb
         if omega != 0:
             vk += td_grad.get_k(mol, dm, omega=omega) * (alpha-hyb)
         vj = vj.reshape(-1,3,nao,nao)
         vk = vk.reshape(-1,3,nao,nao)
+        veff1 = -vk
         if singlet:
-            veff1 = vj * 2 - vk
+            veff1 += vj * 2
         else:
-            veff1 = numpy.vstack((vj[:2]*2-vk[:2], -vk[2:]))
+            veff1[:2] += vj[:2] * 2
     else:
         vj = td_grad.get_j(mol, (oo0, dmz1doo+dmz1doo.T, dmxpy+dmxpy.T))
         vj = vj.reshape(-1,3,nao,nao)
         veff1 = numpy.zeros((4,3,nao,nao))
         if singlet:
             veff1[:3] = vj * 2
         else:
             veff1[:2] = vj[:2] * 2
 
     fxcz1 = _contract_xc_kernel(td_grad, mf.xc, z1ao, None,
                                 False, False, True, max_memory)[0]
 
     veff1[0] += vxc1[1:]
     veff1[1] +=(f1oo[1:] + fxcz1[1:] + k1ao[1:]*2)*2 # *2 for dmz1doo+dmz1oo.T
-    veff1[2] += f1vo[1:] * 2
+    if singlet:
+        veff1[2] += f1vo[1:] * 2
+    else:
+        veff1[2] += f1vo[1:]
     time1 = log.timer('2e AO integral derivatives', *time1)
 
     if atmlst is None:
         atmlst = range(mol.natm)
     offsetdic = mol.offset_nr_by_atom()
     de = numpy.zeros((len(atmlst),3))
     for k, ia in enumerate(atmlst):
@@ -203,16 +203,16 @@
 
         e1 += numpy.einsum('xpq,pq->x', h1ao, dmz1doo)
         e1 -= numpy.einsum('xpq,pq->x', s1[:,p0:p1], im0[p0:p1])
         e1 -= numpy.einsum('xqp,pq->x', s1[:,p0:p1], im0[:,p0:p1])
 
         e1 += numpy.einsum('xij,ij->x', veff1[1,:,p0:p1], oo0[p0:p1])
         e1 += numpy.einsum('xij,ij->x', veff1[2,:,p0:p1], dmxpy[p0:p1,:]) * 2
-        e1 += numpy.einsum('xij,ij->x', veff1[3,:,p0:p1], dmxmy[p0:p1,:]) * 2
         e1 += numpy.einsum('xji,ij->x', veff1[2,:,p0:p1], dmxpy[:,p0:p1]) * 2
+        e1 += numpy.einsum('xij,ij->x', veff1[3,:,p0:p1], dmxmy[p0:p1,:]) * 2
         e1 -= numpy.einsum('xji,ij->x', veff1[3,:,p0:p1], dmxmy[:,p0:p1]) * 2
 
         e1 += td_grad.extra_force(ia, locals())
 
         de[k] = e1
 
     log.timer('TDRKS nuclear gradients', *time0)
@@ -252,126 +252,128 @@
         v1ao = None
     if with_kxc:
         k1ao = numpy.zeros((4,nao,nao))
         deriv = 3
     else:
         k1ao = None
 
-    if xctype == 'LDA':
-        ao_deriv = 1
-        if singlet:
-            def lda_sum_(vmat, ao, wv, mask):
-                aow = numint._scale_ao(ao[0], wv)
-                for k in range(4):
-                    vmat[k] += numint._dot_ao_ao(mol, ao[k], aow, mask, shls_slice, ao_loc)
-
-            for ao, mask, weight, coords \
-                    in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
-                rho = ni.eval_rho2(mol, ao[0], mo_coeff, mo_occ, mask, xctype)
-                vxc, fxc, kxc = ni.eval_xc(xc_code, rho, 0, deriv=deriv)[1:]
-
-                wfxc = fxc[0] * weight * 2  # *2 for alpha+beta
-                rho1 = ni.eval_rho(mol, ao[0], dmvo, mask, xctype, hermi=1)
-                lda_sum_(f1vo, ao, wfxc * rho1, mask)
-                if dmoo is not None:
-                    rho2 = ni.eval_rho(mol, ao[0], dmoo, mask, xctype, hermi=1)
-                    lda_sum_(f1oo, ao, wfxc * rho2, mask)
-                if with_vxc:
-                    lda_sum_(v1ao, ao, vxc[0] * weight, mask)
-                if with_kxc:
-                    lda_sum_(k1ao, ao, kxc[0] * weight * rho1**2, mask)
-            if with_kxc:  # for (rho1*2)^2, *2 for alpha+beta in singlet
-                k1ao *= 4
-
-        else:
-            raise NotImplementedError('LDA triplet')
-
+    if xctype == 'HF':
+        return f1vo, f1oo, v1ao, k1ao
+    elif xctype == 'LDA':
+        fmat_, ao_deriv = _lda_eval_mat_, 1
     elif xctype == 'GGA':
-        if singlet:
-            def gga_sum_(vmat, ao, wv, mask):
-                aow = numint._scale_ao(ao[:4], wv[:4])
-                tmp = numint._dot_ao_ao(mol, ao[0], aow, mask, shls_slice, ao_loc)
-                vmat[0] += tmp + tmp.T
-                rks_grad._gga_grad_sum_(vmat[1:], mol, ao, wv, mask, ao_loc)
-            ao_deriv = 2
-            for ao, mask, weight, coords \
-                    in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
-                rho = ni.eval_rho2(mol, ao, mo_coeff, mo_occ, mask, xctype)
-                vxc, fxc, kxc = ni.eval_xc(xc_code, rho, 0, deriv=deriv)[1:]
-
-                rho1 = ni.eval_rho(mol, ao, dmvo, mask, xctype, hermi=1) * 2  # *2 for alpha + beta
-                wv = numint._rks_gga_wv1(rho, rho1, vxc, fxc, weight)
-                gga_sum_(f1vo, ao, wv, mask)
-
-                if dmoo is not None:
-                    rho2 = ni.eval_rho(mol, ao, dmoo, mask, xctype, hermi=1) * 2
-                    wv = numint._rks_gga_wv1(rho, rho2, vxc, fxc, weight)
-                    gga_sum_(f1oo, ao, wv, mask)
-                if with_vxc:
-                    wv = numint._rks_gga_wv0(rho, vxc, weight)
-                    gga_sum_(v1ao, ao, wv, mask)
-                if with_kxc:
-                    wv = numint._rks_gga_wv2(rho, rho1, fxc, kxc, weight)
-                    gga_sum_(k1ao, ao, wv, mask)
-                vxc = fxc = kxc = rho = rho1 = None
-
-        else:
-            raise NotImplementedError('GGA triplet')
-
+        fmat_, ao_deriv = _gga_eval_mat_, 2
     elif xctype == 'MGGA':
-        if singlet:
-            def mgga_sum_(vmat, ao, wv, mask):
-                aow = numint._scale_ao(ao[:4], wv[:4])
-                tmp = numint._dot_ao_ao(mol, ao[0], aow, mask, shls_slice, ao_loc)
-                aow = numint._scale_ao(ao[1], wv[5], aow)
-                tmp += numint._dot_ao_ao(mol, ao[1], aow, mask, shls_slice, ao_loc)
-                aow = numint._scale_ao(ao[2], wv[5], aow)
-                tmp += numint._dot_ao_ao(mol, ao[2], aow, mask, shls_slice, ao_loc)
-                aow = numint._scale_ao(ao[3], wv[5], aow)
-                tmp += numint._dot_ao_ao(mol, ao[3], aow, mask, shls_slice, ao_loc)
-                vmat[0] += tmp + tmp.T
-
-                rks_grad._gga_grad_sum_(vmat[1:], mol, ao, wv[:4], mask, ao_loc)
-                rks_grad._tau_grad_dot_(vmat[1:], mol, ao, wv[5]*2, mask, ao_loc, True)
-
-            ao_deriv = 2
-            for ao, mask, weight, coords \
-                    in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
-                rho = ni.eval_rho2(mol, ao, mo_coeff, mo_occ, mask, xctype)
-                vxc, fxc, kxc = ni.eval_xc(xc_code, rho, 0, deriv=deriv)[1:]
-
-                rho1 = ni.eval_rho(mol, ao, dmvo, mask, xctype, hermi=1) * 2  # *2 for alpha + beta
-                wv = numint._rks_mgga_wv1(rho, rho1, vxc, fxc, weight)
-                mgga_sum_(f1vo, ao, wv, mask)
-
-                if dmoo is not None:
-                    rho2 = ni.eval_rho(mol, ao, dmoo, mask, xctype, hermi=1) * 2
-                    wv = numint._rks_mgga_wv1(rho, rho2, vxc, fxc, weight)
-                    mgga_sum_(f1oo, ao, wv, mask)
-                if with_vxc:
-                    wv = numint._rks_mgga_wv0(rho, vxc, weight)
-                    mgga_sum_(v1ao, ao, wv, mask)
-                if with_kxc:
-                    wv = numint._rks_mgga_wv2(rho, rho1, fxc, kxc, weight)
-                    mgga_sum_(k1ao, ao, wv, mask)
-                vxc = fxc = kxc = rho = rho1 = None
-        else:
-            raise NotImplementedError('MGGA triplet')
-
-    elif xctype == 'HF':
-        pass
+        fmat_, ao_deriv = _mgga_eval_mat_, 2
+        logger.warn(td_grad, 'TDRKS-MGGA Gradients may be inaccurate due to grids response')
     else:
         raise NotImplementedError(f'td-rks for functional {xc_code}')
 
+    if singlet:
+        for ao, mask, weight, coords \
+                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
+            if xctype == 'LDA':
+                ao0 = ao[0]
+            else:
+                ao0 = ao
+            rho = ni.eval_rho2(mol, ao0, mo_coeff, mo_occ, mask, xctype, with_lapl=False)
+            vxc, fxc, kxc = ni.eval_xc_eff(xc_code, rho, deriv, xctype=xctype)[1:]
+
+            rho1 = ni.eval_rho(mol, ao0, dmvo, mask, xctype, hermi=1,
+                               with_lapl=False) * 2  # *2 for alpha + beta
+            if xctype == 'LDA':
+                rho1 = rho1[numpy.newaxis]
+            wv = numpy.einsum('yg,xyg,g->xg', rho1, fxc, weight)
+            fmat_(mol, f1vo, ao, wv, mask, shls_slice, ao_loc)
+
+            if dmoo is not None:
+                rho2 = ni.eval_rho(mol, ao0, dmoo, mask, xctype, hermi=1, with_lapl=False) * 2
+                if xctype == 'LDA':
+                    rho2 = rho2[numpy.newaxis]
+                wv = numpy.einsum('yg,xyg,g->xg', rho2, fxc, weight)
+                fmat_(mol, f1oo, ao, wv, mask, shls_slice, ao_loc)
+            if with_vxc:
+                fmat_(mol, v1ao, ao, vxc * weight, mask, shls_slice, ao_loc)
+            if with_kxc:
+                wv = numpy.einsum('yg,zg,xyzg,g->xg', rho1, rho1, kxc, weight)
+                fmat_(mol, k1ao, ao, wv, mask, shls_slice, ao_loc)
+    else:
+        for ao, mask, weight, coords \
+                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
+            if xctype == 'LDA':
+                ao0 = ao[0]
+            else:
+                ao0 = ao
+            rho = ni.eval_rho2(mol, ao0, mo_coeff, mo_occ, mask, xctype, with_lapl=False)
+            rho *= .5
+            rho = numpy.repeat(rho[numpy.newaxis], 2, axis=0)
+            vxc, fxc, kxc = ni.eval_xc_eff(xc_code, rho, deriv, xctype=xctype)[1:]
+            # fxc_t couples triplet excitation amplitues
+            # 1/2 int (tia - tIA) fxc (tjb - tJB) = tia fxc_t tjb
+            fxc_t = fxc[:,:,0] - fxc[:,:,1]
+            fxc_t = fxc_t[0] - fxc_t[1]
+
+            rho1 = ni.eval_rho(mol, ao0, dmvo, mask, xctype, hermi=1, with_lapl=False)
+            if xctype == 'LDA':
+                rho1 = rho1[numpy.newaxis]
+            wv = numpy.einsum('yg,xyg,g->xg', rho1, fxc_t, weight)
+            fmat_(mol, f1vo, ao, wv, mask, shls_slice, ao_loc)
+
+            if dmoo is not None:
+                # fxc_s == 2 * fxc of spin restricted xc kernel
+                # provides f1oo to couple the interaction between first order MO
+                # and density response of tddft amplitudes, which is described by dmoo
+                fxc_s = fxc[0,:,0] + fxc[0,:,1]
+                rho2 = ni.eval_rho(mol, ao0, dmoo, mask, xctype, hermi=1, with_lapl=False)
+                if xctype == 'LDA':
+                    rho2 = rho2[numpy.newaxis]
+                wv = numpy.einsum('yg,xyg,g->xg', rho2, fxc_s, weight)
+                fmat_(mol, f1oo, ao, wv, mask, shls_slice, ao_loc)
+            if with_vxc:
+                vxc = vxc[0]
+                fmat_(mol, v1ao, ao, vxc * weight, mask, shls_slice, ao_loc)
+            if with_kxc:
+                # kxc in terms of the triplet coupling
+                # 1/2 int (tia - tIA) kxc (tjb - tJB) = tia kxc_t tjb
+                kxc = kxc[0,:,0] - kxc[0,:,1]
+                kxc = kxc[:,:,0] - kxc[:,:,1]
+                wv = numpy.einsum('yg,zg,xyzg,g->xg', rho1, rho1, kxc, weight)
+                fmat_(mol, k1ao, ao, wv, mask, shls_slice, ao_loc)
+
     f1vo[1:] *= -1
     if f1oo is not None: f1oo[1:] *= -1
     if v1ao is not None: v1ao[1:] *= -1
     if k1ao is not None: k1ao[1:] *= -1
     return f1vo, f1oo, v1ao, k1ao
 
+def _lda_eval_mat_(mol, vmat, ao, wv, mask, shls_slice, ao_loc):
+    aow = numint._scale_ao(ao[0], wv[0])
+    for k in range(4):
+        vmat[k] += numint._dot_ao_ao(mol, ao[k], aow, mask, shls_slice, ao_loc)
+    return vmat
+
+def _gga_eval_mat_(mol, vmat, ao, wv, mask, shls_slice, ao_loc):
+    wv[0] *= .5  # *.5 because vmat + vmat.T at the end
+    aow = numint._scale_ao(ao[:4], wv[:4])
+    tmp = numint._dot_ao_ao(mol, ao[0], aow, mask, shls_slice, ao_loc)
+    vmat[0] += tmp + tmp.T
+    rks_grad._gga_grad_sum_(vmat[1:], mol, ao, wv, mask, ao_loc)
+    return vmat
+
+def _mgga_eval_mat_(mol, vmat, ao, wv, mask, shls_slice, ao_loc):
+    wv[0] *= .5  # *.5 because vmat + vmat.T at the end
+    wv[4] *= .5  # *.5 for 1/2 in tau
+    aow = numint._scale_ao(ao[:4], wv[:4])
+    tmp = numint._dot_ao_ao(mol, ao[0], aow, mask, shls_slice, ao_loc)
+    vmat[0] += tmp + tmp.T
+    vmat[0] += numint._tau_dot(mol, ao, ao, wv[4], mask, shls_slice, ao_loc)
+    rks_grad._gga_grad_sum_(vmat[1:], mol, ao, wv[:4], mask, ao_loc)
+    rks_grad._tau_grad_dot_(vmat[1:], mol, ao, wv[4], mask, ao_loc, True)
+    return vmat
+
 
 class Gradients(tdrhf.Gradients):
     @lib.with_doc(grad_elec.__doc__)
     def grad_elec(self, xy, singlet, atmlst=None):
         return grad_elec(self, xy, singlet, atmlst, self.max_memory, self.verbose)
 
 Grad = Gradients
```

### Comparing `pyscf-2.2.1/pyscf/grad/tduhf.py` & `pyscf-2.3.0/pyscf/grad/tduhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/tduks.py` & `pyscf-2.3.0/pyscf/grad/tduks.py`

 * *Files 19% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 
 from functools import reduce
 import numpy
 from pyscf import lib
 from pyscf.lib import logger
 from pyscf.dft import numint
 from pyscf.grad import tdrhf as tdrhf_grad
-from pyscf.grad import rks as rks_grad
+from pyscf.grad import tdrks as tdrks_grad
 from pyscf.scf import ucphf
 
 
 #
 # Given Y = 0, TDHF gradients (XAX+XBY+YBX+YAY)^1 turn to TDA gradients (XAX)^1
 #
 def grad_elec(td_grad, x_y, atmlst=None, max_memory=2000, verbose=logger.INFO):
@@ -315,131 +315,63 @@
         v1ao = None
     if with_kxc:
         k1ao = numpy.zeros((2,4,nao,nao))
         deriv = 3
     else:
         k1ao = None
 
-    if xctype == 'LDA':
-        def lda_sum_(vmat, ao, wv, mask):
-            aow = numint._scale_ao(ao[0], wv)
-            for k in range(4):
-                vmat[k] += numint._dot_ao_ao(mol, ao[k], aow, mask, shls_slice, ao_loc)
-
-        ao_deriv = 1
-        for ao, mask, weight, coords \
-                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
-            rho = (ni.eval_rho2(mol, ao[0], mo_coeff[0], mo_occ[0], mask, xctype),
-                   ni.eval_rho2(mol, ao[0], mo_coeff[1], mo_occ[1], mask, xctype))
-            vxc, fxc, kxc = ni.eval_xc(xc_code, rho, 1, deriv=deriv)[1:]
-
-            u_u, u_d, d_d = fxc[0].T * weight
-            rho1a = ni.eval_rho(mol, ao[0], dmvo[0], mask, xctype, hermi=1)
-            rho1b = ni.eval_rho(mol, ao[0], dmvo[1], mask, xctype, hermi=1)
-            lda_sum_(f1vo[0], ao, u_u*rho1a+u_d*rho1b, mask)
-            lda_sum_(f1vo[1], ao, u_d*rho1a+d_d*rho1b, mask)
-            if dmoo is not None:
-                rho2a = ni.eval_rho(mol, ao[0], dmoo[0], mask, xctype, hermi=1)
-                rho2b = ni.eval_rho(mol, ao[0], dmoo[1], mask, xctype, hermi=1)
-                lda_sum_(f1oo[0], ao, u_u*rho2a+u_d*rho2b, mask)
-                lda_sum_(f1oo[1], ao, u_d*rho2a+d_d*rho2b, mask)
-            if with_vxc:
-                vrho = vxc[0].T * weight
-                lda_sum_(v1ao[0], ao, vrho[0], mask)
-                lda_sum_(v1ao[1], ao, vrho[1], mask)
-            if with_kxc:
-                u_u_u, u_u_d, u_d_d, d_d_d = kxc[0].T * weight
-                lda_sum_(k1ao[0], ao, u_u_u*rho1a*rho1a+u_u_d*rho1a*rho1b*2+u_d_d*rho1b*rho1b, mask)
-                lda_sum_(k1ao[1], ao, u_u_d*rho1a*rho1a+u_d_d*rho1a*rho1b*2+d_d_d*rho1b*rho1b, mask)
-
+    if xctype == 'HF':
+        return f1vo, f1oo, v1ao, k1ao
+    elif xctype == 'LDA':
+        fmat_, ao_deriv = tdrks_grad._lda_eval_mat_, 1
     elif xctype == 'GGA':
-        def gga_sum_(vmat, ao, wv, mask):
-            aow = numint._scale_ao(ao[:4], wv[:4])
-            tmp = numint._dot_ao_ao(mol, ao[0], aow, mask, shls_slice, ao_loc)
-            vmat[0] += tmp + tmp.T
-            rks_grad._gga_grad_sum_(vmat[1:], mol, ao, wv, mask, ao_loc)
-        ao_deriv = 2
-        for ao, mask, weight, coords \
-                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
-            rho = (ni.eval_rho2(mol, ao, mo_coeff[0], mo_occ[0], mask, xctype),
-                   ni.eval_rho2(mol, ao, mo_coeff[1], mo_occ[1], mask, xctype))
-            vxc, fxc, kxc = ni.eval_xc(xc_code, rho, 1, deriv=deriv)[1:]
-
-            rho1 = (ni.eval_rho(mol, ao, dmvo[0], mask, xctype, hermi=1),
-                    ni.eval_rho(mol, ao, dmvo[1], mask, xctype, hermi=1))
-            wv = numint._uks_gga_wv1(rho, rho1, vxc, fxc, weight)
-            gga_sum_(f1vo[0], ao, wv[0], mask)
-            gga_sum_(f1vo[1], ao, wv[1], mask)
-
-            if dmoo is not None:
-                rho2 = (ni.eval_rho(mol, ao, dmoo[0], mask, xctype, hermi=1),
-                        ni.eval_rho(mol, ao, dmoo[1], mask, xctype, hermi=1))
-                wv = numint._uks_gga_wv1(rho, rho2, vxc, fxc, weight)
-                gga_sum_(f1oo[0], ao, wv[0], mask)
-                gga_sum_(f1oo[1], ao, wv[1], mask)
-            if with_vxc:
-                wv = numint._uks_gga_wv0(rho, vxc, weight)
-                gga_sum_(v1ao[0], ao, wv[0], mask)
-                gga_sum_(v1ao[1], ao, wv[1], mask)
-            if with_kxc:
-                wv = numint._uks_gga_wv2(rho, rho1, fxc, kxc, weight)
-                gga_sum_(k1ao[0], ao, wv[0], mask)
-                gga_sum_(k1ao[1], ao, wv[1], mask)
-            vxc = fxc = kxc = rho = rho1 = None
-
+        fmat_, ao_deriv = tdrks_grad._gga_eval_mat_, 2
     elif xctype == 'MGGA':
-        logger.warn(mol, 'TD-MGGA gradients may be incorrect.')
-        def mgga_sum_(vmat, ao, wv, mask):
-            aow = numint._scale_ao(ao[:4], wv[:4])
-            tmp = numint._dot_ao_ao(mol, ao[0], aow, mask, shls_slice, ao_loc)
-            aow = numint._scale_ao(ao[1], wv[5], aow)
-            tmp += numint._dot_ao_ao(mol, ao[1], aow, mask, shls_slice, ao_loc)
-            aow = numint._scale_ao(ao[2], wv[5], aow)
-            tmp += numint._dot_ao_ao(mol, ao[2], aow, mask, shls_slice, ao_loc)
-            aow = numint._scale_ao(ao[3], wv[5], aow)
-            tmp += numint._dot_ao_ao(mol, ao[3], aow, mask, shls_slice, ao_loc)
-            vmat[0] += tmp + tmp.T
-
-            rks_grad._gga_grad_sum_(vmat[1:], mol, ao, wv[:4], mask, ao_loc)
-            rks_grad._tau_grad_dot_(vmat[1:], mol, ao, wv[5]*2, mask, ao_loc, True)
-
-        ao_deriv = 2
-        for ao, mask, weight, coords \
-                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
-            rho = (ni.eval_rho2(mol, ao, mo_coeff[0], mo_occ[0], mask, xctype),
-                   ni.eval_rho2(mol, ao, mo_coeff[1], mo_occ[1], mask, xctype))
-            vxc, fxc, kxc = ni.eval_xc(xc_code, rho, 1, deriv=deriv)[1:]
-
-            rho1 = (ni.eval_rho(mol, ao, dmvo[0], mask, xctype, hermi=1),
-                    ni.eval_rho(mol, ao, dmvo[1], mask, xctype, hermi=1))
-            wv = numint._uks_mgga_wv1(rho, rho1, vxc, fxc, weight)
-            mgga_sum_(f1vo[0], ao, wv[0], mask)
-            mgga_sum_(f1vo[1], ao, wv[1], mask)
-
-            if dmoo is not None:
-                rho2 = (ni.eval_rho(mol, ao, dmoo[0], mask, xctype, hermi=1),
-                        ni.eval_rho(mol, ao, dmoo[1], mask, xctype, hermi=1))
-                wv = numint._uks_mgga_wv1(rho, rho2, vxc, fxc, weight)
-                mgga_sum_(f1oo[0], ao, wv[0], mask)
-                mgga_sum_(f1oo[1], ao, wv[1], mask)
-            if with_vxc:
-                wv = numint._uks_mgga_wv0(rho, vxc, weight)
-                mgga_sum_(v1ao[0], ao, wv[0], mask)
-                mgga_sum_(v1ao[1], ao, wv[1], mask)
-            if with_kxc:
-                wv = numint._uks_mgga_wv2(rho, rho1, fxc, kxc, weight)
-                mgga_sum_(k1ao[0], ao, wv[0], mask)
-                mgga_sum_(k1ao[1], ao, wv[1], mask)
-            vxc = fxc = kxc = rho = rho1 = None
-
-    elif xctype == 'HF':
-        pass
+        fmat_, ao_deriv = tdrks_grad._mgga_eval_mat_, 2
+        logger.warn(td_grad, 'TDUKS-MGGA Gradients may be inaccurate due to grids response')
     else:
         raise NotImplementedError(f'td-uks for functional {xc_code}')
 
+    for ao, mask, weight, coords \
+            in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
+        if xctype == 'LDA':
+            ao0 = ao[0]
+        else:
+            ao0 = ao
+        rho = (ni.eval_rho2(mol, ao0, mo_coeff[0], mo_occ[0], mask, xctype, with_lapl=False),
+               ni.eval_rho2(mol, ao0, mo_coeff[1], mo_occ[1], mask, xctype, with_lapl=False))
+        vxc, fxc, kxc = ni.eval_xc_eff(xc_code, rho, deriv, xctype=xctype)[1:]
+
+        rho1 = numpy.asarray((
+            ni.eval_rho(mol, ao0, dmvo[0], mask, xctype, hermi=1, with_lapl=False),
+            ni.eval_rho(mol, ao0, dmvo[1], mask, xctype, hermi=1, with_lapl=False)))
+        if xctype == 'LDA':
+            rho1 = rho1[:,numpy.newaxis]
+        wv = numpy.einsum('axg,axbyg,g->byg', rho1, fxc, weight)
+        fmat_(mol, f1vo[0], ao, wv[0], mask, shls_slice, ao_loc)
+        fmat_(mol, f1vo[1], ao, wv[1], mask, shls_slice, ao_loc)
+
+        if dmoo is not None:
+            rho2 = numpy.asarray((
+                ni.eval_rho(mol, ao0, dmoo[0], mask, xctype, hermi=1, with_lapl=False),
+                ni.eval_rho(mol, ao0, dmoo[1], mask, xctype, hermi=1, with_lapl=False)))
+            if xctype == 'LDA':
+                rho2 = rho2[:,numpy.newaxis]
+            wv = numpy.einsum('axg,axbyg,g->byg', rho2, fxc, weight)
+            fmat_(mol, f1oo[0], ao, wv[0], mask, shls_slice, ao_loc)
+            fmat_(mol, f1oo[1], ao, wv[1], mask, shls_slice, ao_loc)
+        if with_vxc:
+            wv = vxc * weight
+            fmat_(mol, v1ao[0], ao, wv[0], mask, shls_slice, ao_loc)
+            fmat_(mol, v1ao[1], ao, wv[1], mask, shls_slice, ao_loc)
+        if with_kxc:
+            wv = numpy.einsum('axg,byg,axbyczg,g->czg', rho1, rho1, kxc, weight)
+            fmat_(mol, k1ao[0], ao, wv[0], mask, shls_slice, ao_loc)
+            fmat_(mol, k1ao[1], ao, wv[1], mask, shls_slice, ao_loc)
+
     f1vo[:,1:] *= -1
     if f1oo is not None: f1oo[:,1:] *= -1
     if v1ao is not None: v1ao[:,1:] *= -1
     if k1ao is not None: k1ao[:,1:] *= -1
     return f1vo, f1oo, v1ao, k1ao
```

### Comparing `pyscf-2.2.1/pyscf/grad/uccsd.py` & `pyscf-2.3.0/pyscf/grad/uccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/uccsd_t.py` & `pyscf-2.3.0/pyscf/grad/uccsd_t.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/ucisd.py` & `pyscf-2.3.0/pyscf/grad/ucisd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/uhf.py` & `pyscf-2.3.0/pyscf/grad/uhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/grad/uks.py` & `pyscf-2.3.0/pyscf/grad/uks.py`

 * *Files 10% similar despite different names*

```diff
@@ -36,51 +36,46 @@
         ks_grad : grad.uhf.Gradients or grad.uks.Gradients object
     '''
     if mol is None: mol = ks_grad.mol
     if dm is None: dm = ks_grad.base.make_rdm1()
     t0 = (logger.process_clock(), logger.perf_counter())
 
     mf = ks_grad.base
-    if ks_grad.grids is not None:
-        grids = ks_grad.grids
-    else:
-        grids = mf.grids
-    if mf.nlc != '':
-        if ks_grad.nlcgrids is not None:
-            nlcgrids = ks_grad.nlcgrids
-        else:
-            nlcgrids = mf.nlcgrids
-        if nlcgrids.coords is None:
-            nlcgrids.build(with_non0tab=True)
-    if grids.coords is None:
-        grids.build(with_non0tab=True)
+    ni = mf._numint
+    grids, nlcgrids = rks_grad._initialize_grids(ks_grad)
 
     ni = mf._numint
     mem_now = lib.current_memory()[0]
     max_memory = max(2000, ks_grad.max_memory*.9-mem_now)
     if ks_grad.grid_response:
         exc, vxc = get_vxc_full_response(ni, mol, grids, mf.xc, dm,
                                          max_memory=max_memory,
                                          verbose=ks_grad.verbose)
-        logger.debug1(ks_grad, 'sum(grids response) %s', exc.sum(axis=0))
-        if mf.nlc:
-            assert 'VV10' in mf.nlc.upper()
-            enlc, vnlc = rks_grad.get_vxc_full_response(
-                ni, mol, nlcgrids, mf.xc+'__'+mf.nlc, dm[0]+dm[1],
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            if ni.libxc.is_nlc(mf.xc):
+                xc = mf.xc
+            else:
+                xc = mf.nlc
+            enlc, vnlc = rks_grad.get_nlc_vxc_full_response(
+                ni, mol, nlcgrids, xc, dm[0]+dm[1],
                 max_memory=max_memory, verbose=ks_grad.verbose)
             exc += enlc
             vxc += vnlc
+        logger.debug1(ks_grad, 'sum(grids response) %s', exc.sum(axis=0))
     else:
         exc, vxc = get_vxc(ni, mol, grids, mf.xc, dm,
                            max_memory=max_memory, verbose=ks_grad.verbose)
-        if mf.nlc:
-            assert 'VV10' in mf.nlc.upper()
-            enlc, vnlc = rks_grad.get_vxc(ni, mol, nlcgrids, mf.xc+'__'+mf.nlc,
-                                          dm[0]+dm[1], max_memory=max_memory,
-                                          verbose=ks_grad.verbose)
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            if ni.libxc.is_nlc(mf.xc):
+                xc = mf.xc
+            else:
+                xc = mf.nlc
+            enlc, vnlc = rks_grad.get_nlc_vxc(
+                ni, mol, nlcgrids, xc, dm[0]+dm[1],
+                max_memory=max_memory, verbose=ks_grad.verbose)
             vxc += vnlc
     t0 = logger.timer(ks_grad, 'vxc', *t0)
 
     if not ni.libxc.is_hybrid_xc(mf.xc):
         vj = ks_grad.get_j(mol, dm)
         vxc += vj[0] + vj[1]
     else:
```

### Comparing `pyscf-2.2.1/pyscf/grad/ump2.py` & `pyscf-2.3.0/pyscf/grad/ump2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/__init__.py` & `pyscf-2.3.0/pyscf/gto/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/Burkatzi-Filippi-Dolg-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/Burkatzi-Filippi-Dolg-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/DgaussA1_dft_cfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/DgaussA1_dft_cfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/DgaussA1_dft_xfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/DgaussA1_dft_xfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/DgaussA2_dft_cfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/DgaussA2_dft_cfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/DgaussA2_dft_xfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/DgaussA2_dft_xfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/__init__.py` & `pyscf-2.3.0/pyscf/gto/basis/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/adzp.dat` & `pyscf-2.3.0/pyscf/gto/basis/adzp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ahlrichs_cfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/ahlrichs_cfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ano.dat` & `pyscf-2.3.0/pyscf/gto/basis/ano.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aqzp.dat` & `pyscf-2.3.0/pyscf/gto/basis/aqzp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/atzp.dat` & `pyscf-2.3.0/pyscf/gto/basis/atzp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pV5Z-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pV5Z-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pV5Z_MP2FIT.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pV5Z_MP2FIT.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVDZ-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVDZ-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVQZ-DK3.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVQZ-DK3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVQZ-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVQZ-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVQZ_MP2FIT.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVQZ_MP2FIT.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVTZ-DK3.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVTZ-DK3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pVTZ-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pVTZ-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pv5z-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pv5z-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pv5z-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pv5z-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pv5z-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pv5z-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pv5z.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pv5z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdpdz.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdpdz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdz-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdz-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdz-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdz-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdz-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdz-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdz.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdzp-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdzp-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvdzp-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvdzp-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvqz-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvqz-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvqz-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvqz-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvqz-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvqz-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvqz.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvqz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvtz-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvtz-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvtz-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvtz-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvtz-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvtz-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pvtz.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pvtz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVQZ-DK.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVQZ-DK.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVQZ-DK3.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVQZ-DK3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVTZ-DK.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVTZ-DK.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVTZ-DK3.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVTZ-DK3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwCVTZ_MP2FIT.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwCVTZ_MP2FIT.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcv5z-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcv5z-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcv5z.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcv5z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcvdz.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcvdz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcvqz.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcvqz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-cc-pwcvtz.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-cc-pwcvtz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pc-0.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pc-0.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pc-1.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pc-1.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pc-2.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pc-2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pc-3.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pc-3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pc-4.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pc-4.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-0.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-0.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-1.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-1.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-2.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-3.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/aug-pcseg-4.dat` & `pyscf-2.3.0/pyscf/gto/basis/aug-pcseg-4.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/bfd_pp.dat` & `pyscf-2.3.0/pyscf/gto/basis/bfd_pp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/bfd_v5z.dat` & `pyscf-2.3.0/pyscf/gto/basis/bfd_v5z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/bfd_vdz.dat` & `pyscf-2.3.0/pyscf/gto/basis/bfd_vdz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/bfd_vqz.dat` & `pyscf-2.3.0/pyscf/gto/basis/bfd_vqz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/bfd_vtz.dat` & `pyscf-2.3.0/pyscf/gto/basis/bfd_vtz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/bse.py` & `pyscf-2.3.0/pyscf/gto/basis/bse.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pCV5Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pCV5Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pCV6Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pCV6Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pCVDZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pCVDZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pCVQZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pCVQZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pCVTZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pCVTZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pV5Z_MP2FIT.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pV5Z_MP2FIT.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pVDZ-PP-NR.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pVDZ-PP-NR.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pVQZ-DK3.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pVQZ-DK3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pVQZ_MP2FIT.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pVQZ_MP2FIT.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pVTZ-DK3.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pVTZ-DK3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pVTZ-PP-NR.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pVTZ-PP-NR.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pv5z-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pv5z-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pv5z-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pv5z-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pv5z-pp.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pv5z-pp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pv5z-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pv5z-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pv5z.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pv5z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvdpdz.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvdpdz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvdz-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvdz-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvdz-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvdz-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvdz-pp.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvdz-pp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvdz-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvdz-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvdz.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvdz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvdz_fit.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvdz_fit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvqz-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvqz-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvqz-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvqz-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvqz-pp.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvqz-pp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvqz-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvqz-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvqz.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvqz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvtz-dk.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvtz-dk.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvtz-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvtz-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvtz-pp.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvtz-pp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvtz-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvtz-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvtz.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvtz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pvtz_fit.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pvtz_fit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCV5Z-DK.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCV5Z-DK.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCV5Z-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCV5Z-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCV5Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCV5Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVDZ-DK.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVDZ-DK.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVDZ-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVDZ-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVDZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVDZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVQZ-DK.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVQZ-DK.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVQZ-DK3.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVQZ-DK3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVQZ-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVQZ-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVQZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVQZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ-DK.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ-DK.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ-DK3.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ-DK3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ-PP.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ-PP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/cc-pwCVTZ_MP2FIT.dat` & `pyscf-2.3.0/pyscf/gto/basis/cc-pwCVTZ_MP2FIT.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pV5Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pV5Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pV6Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pV6Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVDZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVDZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVQZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVQZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVTZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_aug-cc-pVTZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pV5Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pV5Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pV6Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pV6Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVDZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVDZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVQZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVQZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVTZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP/ccECP_cc-pVTZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pV5Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pV5Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVDZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVDZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVQZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVQZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVTZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_aug-cc-pVTZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pV5Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pV5Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVDZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVDZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVQZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVQZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVTZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_He_core/ccECP_cc-pVTZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pV5Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pV5Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVDZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVDZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVQZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVQZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVTZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_aug-cc-pVTZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pV5Z.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pV5Z.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVDZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVDZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVQZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVQZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVTZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/ccecp-basis/ccECP_reg/ccECP_cc-pVTZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/crenbl.dat` & `pyscf-2.3.0/pyscf/gto/basis/crenbl.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/crenbs.dat` & `pyscf-2.3.0/pyscf/gto/basis/crenbs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/crystal-cc-pvdz.dat` & `pyscf-2.3.0/pyscf/gto/basis/crystal-cc-pvdz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-qzvp-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-qzvp-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-qzvp.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-qzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-qzvpd.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-qzvpd.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-qzvpp-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-qzvpp-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-qzvpp.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-qzvpp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-qzvppd-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-qzvppd-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-qzvppd.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-qzvppd.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-svp-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-svp-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-svp.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-svp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-svpd-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-svpd-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-svpd.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-svpd.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-tzvp-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-tzvp-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-tzvp.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-tzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-tzvpd-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-tzvpd-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-tzvpd.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-tzvpd.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-tzvpp-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-tzvpp-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-tzvpp.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-tzvpp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-tzvppd-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-tzvppd-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-tzvppd.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-tzvppd.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-universal-jfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-universal-jfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/def2-universal-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/def2-universal-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/demon_cfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/demon_cfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dyall_dz.py` & `pyscf-2.3.0/pyscf/gto/basis/dyall_dz.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dyall_qz.py` & `pyscf-2.3.0/pyscf/gto/basis/dyall_qz.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dyall_tz.py` & `pyscf-2.3.0/pyscf/gto/basis/dyall_tz.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dz.dat` & `pyscf-2.3.0/pyscf/gto/basis/dz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dzp-dkh.dat` & `pyscf-2.3.0/pyscf/gto/basis/dzp-dkh.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dzp.dat` & `pyscf-2.3.0/pyscf/gto/basis/dzp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dzp_dunning.py` & `pyscf-2.3.0/pyscf/gto/basis/dzp_dunning.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dzvp.dat` & `pyscf-2.3.0/pyscf/gto/basis/dzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/dzvp2.dat` & `pyscf-2.3.0/pyscf/gto/basis/dzvp2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/aug-cc-pV5Z-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/aug-cc-pV5Z-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/aug-cc-pVDZ-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/aug-cc-pVDZ-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/aug-cc-pVQZ-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/aug-cc-pVQZ-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/aug-cc-pVTZ-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/aug-cc-pVTZ-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pCVDZ-F12-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pCVDZ-F12-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pCVQZ-F12-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pCVQZ-F12-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pCVTZ-F12-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pCVTZ-F12-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pV5Z-F12.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pV5Z-F12.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pV5Z-F12rev2.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pV5Z-F12rev2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVDZ-F12-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVDZ-F12-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVDZ-F12-nZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVDZ-F12-nZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVDZ-F12rev2.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVDZ-F12rev2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVQZ-F12-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVQZ-F12-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVQZ-F12-nZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVQZ-F12-nZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVQZ-F12rev2.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVQZ-F12rev2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVTZ-F12-OptRI.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVTZ-F12-OptRI.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVTZ-F12-nZ.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVTZ-F12-nZ.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/f12-basis/cc-pVTZ-F12rev2.dat` & `pyscf-2.3.0/pyscf/gto/basis/f12-basis/cc-pVTZ-F12rev2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/faegre_dz.py` & `pyscf-2.3.0/pyscf/gto/basis/faegre_dz.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/heavy-aug-cc-pvdz-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/heavy-aug-cc-pvdz-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/heavy-aug-cc-pvdz-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/heavy-aug-cc-pvdz-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/heavy-aug-cc-pvtz-jkfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/heavy-aug-cc-pvtz-jkfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/heavy-aug-cc-pvtz-ri.dat` & `pyscf-2.3.0/pyscf/gto/basis/heavy-aug-cc-pvtz-ri.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/iglo3.py` & `pyscf-2.3.0/pyscf/gto/basis/iglo3.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/lanl08.dat` & `pyscf-2.3.0/pyscf/gto/basis/lanl08.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/lanl2dz.dat` & `pyscf-2.3.0/pyscf/gto/basis/lanl2dz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/lanl2tz.dat` & `pyscf-2.3.0/pyscf/gto/basis/lanl2tz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/minao.py` & `pyscf-2.3.0/pyscf/gto/basis/minao.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/parse_bfd_pp.py` & `pyscf-2.3.0/pyscf/gto/basis/parse_bfd_pp.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/parse_gaussian.py` & `pyscf-2.3.0/pyscf/gto/basis/parse_gaussian.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/parse_molpro.py` & `pyscf-2.3.0/pyscf/gto/basis/parse_molpro.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/parse_nwchem.py` & `pyscf-2.3.0/pyscf/gto/basis/parse_nwchem.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pc-0.dat` & `pyscf-2.3.0/pyscf/gto/basis/pc-0.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pc-1.dat` & `pyscf-2.3.0/pyscf/gto/basis/pc-1.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pc-2.dat` & `pyscf-2.3.0/pyscf/gto/basis/pc-2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pc-3.dat` & `pyscf-2.3.0/pyscf/gto/basis/pc-3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pc-4.dat` & `pyscf-2.3.0/pyscf/gto/basis/pc-4.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pcseg-0.dat` & `pyscf-2.3.0/pyscf/gto/basis/pcseg-0.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pcseg-1.dat` & `pyscf-2.3.0/pyscf/gto/basis/pcseg-1.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pcseg-2.dat` & `pyscf-2.3.0/pyscf/gto/basis/pcseg-2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pcseg-3.dat` & `pyscf-2.3.0/pyscf/gto/basis/pcseg-3.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pcseg-4.dat` & `pyscf-2.3.0/pyscf/gto/basis/pcseg-4.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pob-tzvp.dat` & `pyscf-2.3.0/pyscf/gto/basis/pob-tzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pob-tzvpp.dat` & `pyscf-2.3.0/pyscf/gto/basis/pob-tzvpp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21++G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21++G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21++Gs.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21++Gs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21G-diffuse.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21G-diffuse.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21G-polarization.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21G-polarization.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/3-21Gs.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/3-21Gs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/4-31G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/4-31G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31++G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31++G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31++Gs.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31++Gs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31++Gss.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31++Gss.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31+G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31+G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31+Gs.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31+Gs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31+Gss.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31+Gss.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311++G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311++G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311++Gs.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311++Gs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311++Gss.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311++Gss.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311+G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311+G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311+Gs.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311+Gs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311+Gss.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311+Gss.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-diffuse.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-diffuse.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-2d.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-2d.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-2p.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-2p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-3d.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-3d.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-3p.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-3p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-d.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-d.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-f.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-f.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G-polarization-p.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G-polarization-p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311Gs.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311Gs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-311Gss.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-311Gss.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-diffuse.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-diffuse.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-2d.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-2d.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-2p.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-2p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-3d.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-3d.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-3p.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-3p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-d.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-d.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G-polarization-f.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G-polarization-f.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31G.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31G.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31Gs.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31Gs.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/pople-basis/6-31Gss.dat` & `pyscf-2.3.0/pyscf/gto/basis/pople-basis/6-31Gss.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/qzp-dkh.dat` & `pyscf-2.3.0/pyscf/gto/basis/qzp-dkh.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/qzp.dat` & `pyscf-2.3.0/pyscf/gto/basis/qzp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/roos-dz.dat` & `pyscf-2.3.0/pyscf/gto/basis/roos-dz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/roos-tz.dat` & `pyscf-2.3.0/pyscf/gto/basis/roos-tz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/sarc-dkh2.dat` & `pyscf-2.3.0/pyscf/gto/basis/sarc-dkh2.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/sbkjc.dat` & `pyscf-2.3.0/pyscf/gto/basis/sbkjc.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS10MDFSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS10MDFSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS28MDFSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS28MDFSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS28MWBSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS28MWBSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS46MDFSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS46MDFSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS60MDFSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS60MDFSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS60MWBSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS60MWBSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS78MDFSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS78MDFSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS92MDFBQSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS92MDFBQSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/soecp/ECPDS92MDFBSO.dat` & `pyscf-2.3.0/pyscf/gto/basis/soecp/ECPDS92MDFBSO.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/sto-3g.dat` & `pyscf-2.3.0/pyscf/gto/basis/sto-3g.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/sto-6g.dat` & `pyscf-2.3.0/pyscf/gto/basis/sto-6g.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/stuttgart_dz.dat` & `pyscf-2.3.0/pyscf/gto/basis/stuttgart_dz.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/stuttgart_rsc.dat` & `pyscf-2.3.0/pyscf/gto/basis/stuttgart_rsc.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/tzp-dkh.dat` & `pyscf-2.3.0/pyscf/gto/basis/tzp-dkh.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/tzp.dat` & `pyscf-2.3.0/pyscf/gto/basis/tzp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/tzv.dat` & `pyscf-2.3.0/pyscf/gto/basis/tzv.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/basis/weigend_cfit.dat` & `pyscf-2.3.0/pyscf/gto/basis/weigend_cfit.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/cmd_args.py` & `pyscf-2.3.0/pyscf/gto/cmd_args.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/ecp.py` & `pyscf-2.3.0/pyscf/gto/ecp.py`

 * *Files 2% similar despite different names*

```diff
@@ -55,15 +55,15 @@
         dj = (lj*2+1) * mol.bas_nctr(shls[1])
     cache_size = libecp.ECPscalar_cache_size(
         ctypes.c_int(1), (ctypes.c_int*2)(*shls),
         mol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.natm),
         mol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.nbas),
         mol._env.ctypes.data_as(ctypes.c_void_p))
     cache = numpy.empty(cache_size)
-    buf = numpy.empty((di,dj), order='F')
+    buf = numpy.zeros((di,dj), order='F')
 
     fn(buf.ctypes.data_as(ctypes.c_void_p),
        (ctypes.c_int*2)(*shls),
        mol._ecpbas.ctypes.data_as(ctypes.c_void_p),
        ctypes.c_int(len(mol._ecpbas)),
        mol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.natm),
        mol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.nbas),
@@ -84,15 +84,15 @@
         dj = (lj*2+1) * mol.bas_nctr(shls[1])
     cache_size = libecp.ECPscalar_cache_size(
         ctypes.c_int(1), (ctypes.c_int*2)(*shls),
         mol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.natm),
         mol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.nbas),
         mol._env.ctypes.data_as(ctypes.c_void_p))
     cache = numpy.empty(cache_size)
-    buf = numpy.empty((di,dj), order='F')
+    buf = numpy.zeros((di,dj), order='F')
 
     fn(buf.ctypes.data_as(ctypes.c_void_p),
        (ctypes.c_int*2)(*shls),
        mol._ecpbas.ctypes.data_as(ctypes.c_void_p),
        ctypes.c_int(len(mol._ecpbas)),
        mol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.natm),
        mol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.nbas),
@@ -109,15 +109,15 @@
     li = mol.bas_angular(shls[0])
     lj = mol.bas_angular(shls[1])
     di = (li*4+2) * mol.bas_nctr(shls[0])
     dj = (lj*4+2) * mol.bas_nctr(shls[1])
     bas = numpy.vstack((mol._bas, mol._ecpbas))
     mol._env[AS_ECPBAS_OFFSET] = len(mol._bas)
     mol._env[AS_NECPBAS] = len(mol._ecpbas)
-    buf = numpy.empty((di,dj), order='F', dtype=numpy.complex128)
+    buf = numpy.zeros((di,dj), order='F', dtype=numpy.complex128)
     cache = numpy.empty(buf.size*48+100000)
     fn = libecp.ECPso_spinor
     fn(buf.ctypes.data_as(ctypes.c_void_p),
        (ctypes.c_int*2)(di, dj),
        (ctypes.c_int*2)(*shls),
        mol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.natm),
        bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.nbas),
```

### Comparing `pyscf-2.2.1/pyscf/gto/eval_gto.py` & `pyscf-2.3.0/pyscf/gto/eval_gto.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/ft_ao.py` & `pyscf-2.3.0/pyscf/gto/ft_ao.py`

 * *Files 13% similar despite different names*

```diff
@@ -28,83 +28,113 @@
 from pyscf.gto.moleintor import libcgto
 
 #
 # \int mu*nu*exp(-ik*r) dr
 #
 # gxyz is the index for Gvbase
 def ft_aopair(mol, Gv, shls_slice=None, aosym='s1', b=numpy.eye(3),
-              gxyz=None, Gvbase=None, buf=None, intor='GTO_ft_ovlp',
-              comp=1, verbose=None):
+              gxyz=None, Gvbase=None, out=None, intor='GTO_ft_ovlp',
+              comp=1, q=numpy.zeros(3), return_complex=True, ovlp_mask=None,
+              verbose=None):
     r''' FT transform AO pair
     \int i(r) j(r) exp(-ikr) dr^3
     '''
 
     intor = mol._add_suffix(intor)
 
     if shls_slice is None:
         shls_slice = (0, mol.nbas, 0, mol.nbas)
+
+    GvT = numpy.asarray(Gv.T, order='C') + q[:,None]
     nGv = Gv.shape[0]
     if (gxyz is None or b is None or Gvbase is None
         # backward compatibility for pyscf-1.2, in which the argument Gvbase is gs
         or (Gvbase is not None and isinstance(Gvbase[0], (int, numpy.integer)))):
-        GvT = numpy.asarray(Gv.T, order='C')
         p_gxyzT = lib.c_null_ptr()
         p_gs = (ctypes.c_int*3)(0,0,0)
         p_b = (ctypes.c_double*1)(0)
         eval_gz = 'GTO_Gv_general'
     else:
         if abs(b-numpy.diag(b.diagonal())).sum() < 1e-8:
             eval_gz = 'GTO_Gv_orth'
         else:
             eval_gz = 'GTO_Gv_nonorth'
-        GvT = numpy.asarray(Gv.T, order='C')
         gxyzT = numpy.asarray(gxyz.T, order='C', dtype=numpy.int32)
         p_gxyzT = gxyzT.ctypes.data_as(ctypes.c_void_p)
-        b = numpy.hstack((b.ravel(), numpy.zeros(3)) + Gvbase)
-        p_b = b.ctypes.data_as(ctypes.c_void_p)
+        bqGv = numpy.hstack((b.ravel(), q) + Gvbase)
+        p_b = bqGv.ctypes.data_as(ctypes.c_void_p)
         p_gs = (ctypes.c_int*3)(*[len(x) for x in Gvbase])
 
     ao_loc = gto.moleintor.make_loc(mol._bas, intor)
 
     if aosym == 's1':
         if (shls_slice[:2] == shls_slice[2:4] and
             intor.startswith('GTO_ft_ovlp')):
-            fill = getattr(libcgto, 'GTO_ft_fill_s1hermi')
+            fill = 'fill_s1hermi'
         else:
-            fill = getattr(libcgto, 'GTO_ft_fill_s1')
+            fill = 'fill_s1'
         ni = ao_loc[shls_slice[1]] - ao_loc[shls_slice[0]]
         nj = ao_loc[shls_slice[3]] - ao_loc[shls_slice[2]]
-        shape = (comp, ni, nj, nGv)
+        shape = (nj, ni, nGv)
     else:
-        fill = getattr(libcgto, 'GTO_ft_fill_s2')
+        fill = 'fill_s2'
         i0 = ao_loc[shls_slice[0]]
         i1 = ao_loc[shls_slice[1]]
         nij = i1*(i1+1)//2 - i0*(i0+1)//2
-        shape = (comp, nij, nGv)
-    mat = numpy.ndarray(shape, order='C', dtype=numpy.complex128, buffer=buf)
-    mat[:] = 0
+        shape = (nij, nGv)
+    if comp != 1:
+        shape = (comp,) + shape
+
+    if return_complex:
+        fill = 'GTO_ft_z' + fill
+        dtype = numpy.complex128
+    else:
+        if fill == 'fill_s2':
+            raise NotImplementedError
+        fill = 'GTO_ft_d' + fill
+        dtype = numpy.double
+        shape = (2,) + shape
+
+    if out is None:
+        out = numpy.zeros(shape, dtype=dtype)
+    else:
+        out = numpy.ndarray(shape, dtype=dtype, buffer=out)
+        out[:] = 0
+
+    if aosym == 's1':
+        out = numpy.rollaxis(out, -2, -3)
+        out = numpy.rollaxis(out, -1, -3)
+    else:
+        out = numpy.rollaxis(out, -1, -2)
+    if nGv == 0:
+        return out
 
     fn = libcgto.GTO_ft_fill_drv
     intor = getattr(libcgto, intor)
     eval_gz = getattr(libcgto, eval_gz)
+    fill = getattr(libcgto, fill)
     phase = 0
+    if ovlp_mask is None:
+        nish = shls_slice[1] - shls_slice[0]
+        njsh = shls_slice[3] - shls_slice[2]
+        ovlp_mask = numpy.ones((nish,njsh), dtype=numpy.int8, order='F')
+    else:
+        ovlp_mask = numpy.asarray(ovlp_mask, dtype=numpy.int8, order='F')
 
-    fn(intor, eval_gz, fill, mat.ctypes.data_as(ctypes.c_void_p),
+    fn(intor, eval_gz, fill,
+       out.ctypes.data_as(ctypes.c_void_p),
+       ovlp_mask.ctypes.data_as(ctypes.c_void_p),
        ctypes.c_int(comp), (ctypes.c_int*4)(*shls_slice),
        ao_loc.ctypes.data_as(ctypes.c_void_p), ctypes.c_double(phase),
        GvT.ctypes.data_as(ctypes.c_void_p),
        p_b, p_gxyzT, p_gs, ctypes.c_int(nGv),
        mol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.natm),
        mol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(mol.nbas),
        mol._env.ctypes.data_as(ctypes.c_void_p))
-
-    mat = numpy.rollaxis(mat, -1, 1)
-    if comp == 1:
-        mat = mat[0]
-    return mat
+    return out
 
 
 # gxyz is the index for Gvbase
 def ft_ao(mol, Gv, shls_slice=None, b=numpy.eye(3),
           gxyz=None, Gvbase=None, verbose=None):
     r'''Analytical FT transform AO
     \int mu(r) exp(-ikr) dr^3
@@ -136,32 +166,39 @@
 
     fn = libcgto.GTO_ft_fill_drv
     if mol.cart:
         intor = getattr(libcgto, 'GTO_ft_ovlp_cart')
     else:
         intor = getattr(libcgto, 'GTO_ft_ovlp_sph')
     eval_gz = getattr(libcgto, eval_gz)
-    fill = getattr(libcgto, 'GTO_ft_fill_s1')
+    fill = getattr(libcgto, 'GTO_ft_zfill_s1')
 
     ghost_atm = numpy.array([[0,0,0,0,0,0]], dtype=numpy.int32)
     ghost_bas = numpy.array([[0,0,1,1,0,0,3,0]], dtype=numpy.int32)
     ghost_env = numpy.zeros(4)
     ghost_env[3] = numpy.sqrt(4*numpy.pi)  # s function spherical norm
     atm, bas, env = gto.conc_env(mol._atm, mol._bas, mol._env,
                                  ghost_atm, ghost_bas, ghost_env)
     ao_loc = mol.ao_loc_nr()
     nao = ao_loc[mol.nbas]
     ao_loc = numpy.asarray(numpy.hstack((ao_loc, [nao+1])), dtype=numpy.int32)
     ni = ao_loc[shls_slice[1]] - ao_loc[shls_slice[0]]
     shape = (ni, nGv)
     mat = numpy.zeros(shape, order='C', dtype=numpy.complex128)
     phase = 0
+    if nGv == 0:
+        return mat
+
+    nish = shls_slice[1] - shls_slice[0]
+    ovlp_mask = numpy.ones(nish, dtype=numpy.int8)
 
     shls_slice = shls_slice + (mol.nbas, mol.nbas+1)
-    fn(intor, eval_gz, fill, mat.ctypes.data_as(ctypes.c_void_p),
+    fn(intor, eval_gz, fill,
+       mat.ctypes.data_as(ctypes.c_void_p),
+       ovlp_mask.ctypes.data_as(ctypes.c_void_p),
        ctypes.c_int(1), (ctypes.c_int*4)(*shls_slice),
        ao_loc.ctypes.data_as(ctypes.c_void_p), ctypes.c_double(phase),
        GvT.ctypes.data_as(ctypes.c_void_p),
        p_b, p_gxyzT, p_gs, ctypes.c_int(nGv),
        atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(len(atm)),
        bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(len(bas)),
        env.ctypes.data_as(ctypes.c_void_p))
```

### Comparing `pyscf-2.2.1/pyscf/gto/mole.py` & `pyscf-2.3.0/pyscf/gto/mole.py`

 * *Files 1% similar despite different names*

```diff
@@ -60,15 +60,16 @@
     unicode = str
 
 
 # for _atm, _bas, _env
 CHARGE_OF  = 0
 PTR_COORD  = 1
 NUC_MOD_OF = 2
-PTR_ZETA   = PTR_FRAC_CHARGE = 3
+PTR_ZETA   = 3
+PTR_FRAC_CHARGE = 4
 ATM_SLOTS  = 6
 ATOM_OF    = 0
 ANG_OF     = 1
 NPRIM_OF   = 2
 NCTR_OF    = 3
 RADI_POWER = 3 # for ECP
 KAPPA_OF   = 4
@@ -99,14 +100,15 @@
 
 BASE = getattr(__config__, 'BASE', 0)
 NORMALIZE_GTO = getattr(__config__, 'NORMALIZE_GTO', True)
 DISABLE_EVAL = getattr(__config__, 'DISABLE_EVAL', False)
 # Whether to disable the explicit call to gc.collect(). gc.collect() may cause
 # non-negligible overhead (https://github.com/pyscf/pyscf/issues/1038).
 DISABLE_GC = getattr(__config__, 'DISABLE_GC', False)
+ARGPARSE = getattr(__config__, 'ARGPARSE', False)
 
 def M(**kwargs):
     r'''This is a shortcut to build up Mole object.
 
     Args: Same to :func:`Mole.build`
 
     Examples:
@@ -143,15 +145,15 @@
         normalization factor
 
     Examples:
 
     >>> print(gto_norm(0, 1))
     2.5264751109842591
     '''
-    if l >= 0:
+    if numpy.all(l >= 0):
         #f = 2**(2*l+3) * math.factorial(l+1) * (2*expnt)**(l+1.5) \
         #        / (math.factorial(2*l+2) * math.sqrt(math.pi))
         #return math.sqrt(f)
         return 1/numpy.sqrt(gaussian_int(l*2+2, 2*expnt))
     else:
         raise ValueError('l should be >= 0')
 
@@ -1516,15 +1518,15 @@
         strl = param.ANGULAR[l]
         nc = mol.bas_nctr(ib)
         symb = mol.atom_symbol(ia)
         nelec_ecp = mol.atom_nelec_core(ia)
         if nelec_ecp == 0 or l > 3:
             shl_start = count[ia,l]+l+1
         else:
-            coreshl = core_configuration(nelec_ecp, atom_symbol=symb)
+            coreshl = core_configuration(nelec_ecp, atom_symbol=_std_symbol(symb))
             shl_start = coreshl[l]+count[ia,l]+l+1
         count[ia,l] += nc
         for n in range(shl_start, shl_start+nc):
             for m in range(-l, l+1):
                 label.append((ia+base, symb, '%d%s' % (n, strl),
                               str(param.REAL_SPHERIC[l][l+m])))
 
@@ -1566,15 +1568,15 @@
         strl = param.ANGULAR[l]
         nc = mol.bas_nctr(ib)
         symb = mol.atom_symbol(ia)
         nelec_ecp = mol.atom_nelec_core(ia)
         if nelec_ecp == 0 or l > 3:
             shl_start = count[ia,l]+l+1
         else:
-            coreshl = core_configuration(nelec_ecp)
+            coreshl = core_configuration(nelec_ecp, atom_symbol=_std_symbol(symb))
             shl_start = coreshl[l]+count[ia,l]+l+1
         count[ia,l] += nc
         ncart = (l + 1) * (l + 2) // 2
         for n in range(shl_start, shl_start+nc):
             for m in range(ncart):
                 label.append((ia+base, symb, '%d%s' % (n, strl), cartxyz[l][m]))
 
@@ -1616,15 +1618,15 @@
         strl = param.ANGULAR[l]
         nc = mol.bas_nctr(ib)
         symb = mol.atom_symbol(ia)
         nelec_ecp = mol.atom_nelec_core(ia)
         if nelec_ecp == 0 or l > 3:
             shl_start = count[ia,l]+l+1
         else:
-            coreshl = core_configuration(nelec_ecp)
+            coreshl = core_configuration(nelec_ecp, atom_symbol=_std_symbol(symb))
             shl_start = coreshl[l]+count[ia,l]+l+1
         count[ia,l] += nc
         for n in range(shl_start, shl_start+nc):
             if kappa >= 0:
                 for m in range(-l*2+1, l*2, 2):
                     label.append((ia+base, symb, '%d%s%d/2' % (n, strl, l*2-1),
                                   '%d/2'%m))
@@ -2426,15 +2428,15 @@
         return loads(molstr)
 
     @lib.with_doc(loads.__doc__)
     def loads_(self, molstr):
         self.__dict__.update(loads(molstr).__dict__)
         return self
 
-    def build(self, dump_input=True, parse_arg=True,
+    def build(self, dump_input=True, parse_arg=ARGPARSE,
               verbose=None, output=None, max_memory=None,
               atom=None, basis=None, unit=None, nucmod=None, ecp=None,
               charge=None, spin=0, symmetry=None, symmetry_subgroup=None,
               cart=None, magmom=None):
         '''Setup moleclue and initialize some control parameters.  Whenever you
         change the value of the attributes of :class:`Mole`, you need call
         this function to refresh the internal data of Mole.
@@ -3946,29 +3948,35 @@
 
 def fakemol_for_charges(coords, expnt=1e16):
     '''Construct a fake Mole object that holds the charges on the given
     coordinates (coords).  The shape of the charge can be a normal
     distribution with the Gaussian exponent (expnt).
     '''
     nbas = coords.shape[0]
+    expnt = numpy.asarray(expnt).ravel()
+    if expnt.size == 1:
+        expnt = numpy.repeat(expnt, nbas)
+    assert expnt.size == nbas
+
     fakeatm = numpy.zeros((nbas,ATM_SLOTS), dtype=numpy.int32)
     fakebas = numpy.zeros((nbas,BAS_SLOTS), dtype=numpy.int32)
     fakeenv = [0] * PTR_ENV_START
     ptr = PTR_ENV_START
     fakeatm[:,PTR_COORD] = numpy.arange(ptr, ptr+nbas*3, 3)
     fakeenv.append(coords.ravel())
     ptr += nbas*3
     fakebas[:,ATOM_OF] = numpy.arange(nbas)
     fakebas[:,NPRIM_OF] = 1
     fakebas[:,NCTR_OF] = 1
-# approximate point charge with gaussian distribution exp(-1e16*r^2)
-    fakebas[:,PTR_EXP] = ptr
-    fakebas[:,PTR_COEFF] = ptr+1
-    fakeenv.append([expnt, 1/(2*numpy.sqrt(numpy.pi)*gaussian_int(2,expnt))])
-    ptr += 2
+# approximate point charge with gaussian distribution exp(-expnt*r^2)
+    fakebas[:,PTR_EXP] = ptr + numpy.arange(nbas) * 2
+    fakebas[:,PTR_COEFF] = ptr + numpy.arange(nbas) * 2 + 1
+    coeff = 1 / (2 * numpy.sqrt(numpy.pi) * gaussian_int(2, expnt))
+    fakeenv.append(numpy.vstack((expnt, coeff)).T.ravel())
+
     fakemol = Mole()
     fakemol._atm = fakeatm
     fakemol._bas = fakebas
     fakemol._env = numpy.hstack(fakeenv)
     fakemol._built = True
     return fakemol
```

### Comparing `pyscf-2.2.1/pyscf/gto/moleintor.py` & `pyscf-2.3.0/pyscf/gto/moleintor.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gto/pp_int.py` & `pyscf-2.3.0/pyscf/gto/pp_int.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gw/__init__.py` & `pyscf-2.3.0/pyscf/gw/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gw/gw_ac.py` & `pyscf-2.3.0/pyscf/gw/gw_ac.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gw/gw_cd.py` & `pyscf-2.3.0/pyscf/gw/gw_cd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gw/gw_exact.py` & `pyscf-2.3.0/pyscf/gw/gw_exact.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gw/gw_slow.py` & `pyscf-2.3.0/pyscf/gw/gw_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gw/rpa.py` & `pyscf-2.3.0/pyscf/gw/rpa.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gw/ugw_ac.py` & `pyscf-2.3.0/pyscf/gw/ugw_ac.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/gw/urpa.py` & `pyscf-2.3.0/pyscf/gw/urpa.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/hessian/__init__.py` & `pyscf-2.3.0/pyscf/hessian/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/hessian/rhf.py` & `pyscf-2.3.0/pyscf/hessian/rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/hessian/rks.py` & `pyscf-2.3.0/pyscf/hessian/rks.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,27 +36,27 @@
 def partial_hess_elec(hessobj, mo_energy=None, mo_coeff=None, mo_occ=None,
                       atmlst=None, max_memory=4000, verbose=None):
     log = logger.new_logger(hessobj, verbose)
     time0 = t1 = (logger.process_clock(), logger.perf_counter())
 
     mol = hessobj.mol
     mf = hessobj.base
+    ni = mf._numint
+    if mf.nlc or ni.libxc.is_nlc(mf.xc):
+        raise NotImplementedError('RKS Hessian for NLC functional')
+
     if mo_energy is None: mo_energy = mf.mo_energy
     if mo_occ is None:    mo_occ = mf.mo_occ
     if mo_coeff is None:  mo_coeff = mf.mo_coeff
     if atmlst is None: atmlst = range(mol.natm)
 
     nao, nmo = mo_coeff.shape
     mocc = mo_coeff[:,mo_occ>0]
     dm0 = numpy.dot(mocc, mocc.T) * 2
 
-    if mf.nlc != '':
-        raise NotImplementedError
-
-    ni = mf._numint
     omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, spin=mol.spin)
     hybrid = ni.libxc.is_hybrid_xc(mf.xc)
 
     de2, ej, ek = rhf_hess._partial_hess_ejk(hessobj, mo_energy, mo_coeff, mo_occ,
                                              atmlst, max_memory, verbose,
                                              with_k=hybrid)
     de2 += ej - hyb * ek  # (A,B,dR_A,dR_B)
```

### Comparing `pyscf-2.2.1/pyscf/hessian/thermo.py` & `pyscf-2.3.0/pyscf/hessian/thermo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/hessian/uhf.py` & `pyscf-2.3.0/pyscf/hessian/uhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/hessian/uks.py` & `pyscf-2.3.0/pyscf/hessian/uks.py`

 * *Files 0% similar despite different names*

```diff
@@ -35,14 +35,18 @@
 def partial_hess_elec(hessobj, mo_energy=None, mo_coeff=None, mo_occ=None,
                       atmlst=None, max_memory=4000, verbose=None):
     log = logger.new_logger(hessobj, verbose)
     time0 = t1 = (logger.process_clock(), logger.perf_counter())
 
     mol = hessobj.mol
     mf = hessobj.base
+    ni = mf._numint
+    if mf.nlc or ni.libxc.is_nlc(mf.xc):
+        raise NotImplementedError('RKS Hessian for NLC functional')
+
     if mo_energy is None: mo_energy = mf.mo_energy
     if mo_occ is None:    mo_occ = mf.mo_occ
     if mo_coeff is None:  mo_coeff = mf.mo_coeff
     if atmlst is None: atmlst = range(mol.natm)
 
     nao, nmo = mo_coeff[0].shape
     mocca = mo_coeff[0][:,mo_occ[0]>0]
@@ -52,17 +56,14 @@
 
     # Energy weighted density matrix
     mo_ea = mo_energy[0][mo_occ[0]>0]
     mo_eb = mo_energy[1][mo_occ[1]>0]
     dme0 = numpy.einsum('pi,qi,i->pq', mocca, mocca, mo_ea)
     dme0+= numpy.einsum('pi,qi,i->pq', moccb, moccb, mo_eb)
 
-    if mf.nlc != '':
-        raise NotImplementedError
-    ni = mf._numint
     omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, spin=mol.spin)
     hybrid = ni.libxc.is_hybrid_xc(mf.xc)
     de2, ej, ek = uhf_hess._partial_hess_ejk(hessobj, mo_energy, mo_coeff, mo_occ,
                                              atmlst, max_memory, verbose,
                                              with_k=hybrid)
     de2 += ej - hyb * ek  # (A,B,dR_A,dR_B)
```

### Comparing `pyscf-2.2.1/pyscf/lib/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/CMakeLists.txt`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 cmake_minimum_required (VERSION 3.5)
 project (pyscf)
 
 if (NOT CMAKE_BUILD_TYPE)
   set(CMAKE_BUILD_TYPE RELWITHDEBINFO)
 endif()
-#set(CMAKE_BUILD_TYPE DEBUG)
 set(CMAKE_VERBOSE_MAKEFILE OFF)
 if (CMAKE_COMPILER_IS_GNUCC) # Does it skip the link flag on old OsX?
   # TODO: If updating to minimum requirement cmake>=3.7, use
   # CMAKE_SHARED_LINKER_FLAGS_INIT to combine LDFLAGS options.
   # https://cmake.org/cmake/help/v3.7/variable/CMAKE_SHARED_LINKER_FLAGS_INIT.html
   # see also issue #661
   if(UNIX AND NOT APPLE AND NOT DEFINED ENV{LDFLAGS})
@@ -161,17 +160,18 @@
     if(NOT BUILD_MARCH_NATIVE)
       message(WARNING "The BUILD_MARCH_NATIVE option is not specified! qcint may not compile unless you explicitly pass compiler flags that turn on vectorization!")    
     endif()
   endif()
 
   ExternalProject_Add(libcint
     GIT_REPOSITORY ${LIBCINT_GIT}
-    GIT_TAG v5.3.0
+    GIT_TAG v5.4.0
     PREFIX ${PROJECT_BINARY_DIR}/deps
     INSTALL_DIR ${PROJECT_SOURCE_DIR}/deps
+    CMAKE_ARGS -DCMAKE_BUILD_TYPE=RELEASE
     CMAKE_CACHE_ARGS
         -DWITH_F12:STRING=${WITH_F12}
         -DWITH_RANGE_COULOMB:STRING=1
         -DWITH_FORTRAN:STRING=0
         -DWITH_CINT2_INTERFACE:STRING=0
         -DMIN_EXPCUTOFF:STRING=20
         -DKEEP_GOING:STRING=1
@@ -203,14 +203,15 @@
     INSTALL_DIR ${PROJECT_SOURCE_DIR}/deps
     CMAKE_ARGS -DCMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=1
             -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR>
             -DCMAKE_INSTALL_LIBDIR:PATH=lib
             -DENABLE_FORTRAN=0 -DDISABLE_KXC=0 -DDISABLE_LXC=1
             -DCMAKE_C_CREATE_SHARED_LIBRARY=${C_LINK_TEMPLATE}
             -DENABLE_XHOST:STRING=${BUILD_MARCH_NATIVE}
+            -DCMAKE_C_COMPILER:STRING=${CMAKE_C_COMPILER}
   )
   add_dependencies(xc_itrf libxc)
   add_dependencies(dft libxc)
 endif() # ENABLE_LIBXC
 
 if(ENABLE_XCFUN AND BUILD_XCFUN)
   ExternalProject_Add(libxcfun
@@ -223,14 +224,15 @@
     #PATCH_COMMAND patch -p1 < ${PROJECT_SOURCE_DIR}/libxcfun.patch
     PREFIX ${PROJECT_BINARY_DIR}/deps
     INSTALL_DIR ${PROJECT_SOURCE_DIR}/deps
     CMAKE_ARGS -DCMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=1
             -DXCFUN_MAX_ORDER=3 -DENABLE_TESTALL=0
             -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR>
             -DCMAKE_CXX_CREATE_SHARED_LIBRARY=${CXX_LINK_TEMPLATE}
+            -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
   )
   add_dependencies(xcfun_itrf libxcfun)
   add_dependencies(dft libxcfun)
 endif() # ENABLE_XCFUN
 endif() # DISABLE_DFT
 
 if(EXISTS "${PROJECT_SOURCE_DIR}/cmake.user.inc")
```

### Comparing `pyscf-2.2.1/pyscf/lib/__init__.py` & `pyscf-2.3.0/pyscf/lib/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/agf2/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/agf2/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/agf2/ragf2.c` & `pyscf-2.3.0/pyscf/lib/agf2/ragf2.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/agf2/ragf2.h` & `pyscf-2.3.0/pyscf/lib/agf2/ragf2.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/agf2/uagf2.c` & `pyscf-2.3.0/pyscf/lib/agf2/uagf2.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/ao2mo/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/nr_ao2mo.c` & `pyscf-2.3.0/pyscf/lib/ao2mo/nr_ao2mo.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/nr_ao2mo.h` & `pyscf-2.3.0/pyscf/lib/ao2mo/nr_ao2mo.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/nr_incore.c` & `pyscf-2.3.0/pyscf/lib/ao2mo/nr_incore.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/nr_incore.h` & `pyscf-2.3.0/pyscf/lib/ao2mo/nr_incore.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/nrr_ao2mo.c` & `pyscf-2.3.0/pyscf/lib/ao2mo/nrr_ao2mo.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/r_ao2mo.c` & `pyscf-2.3.0/pyscf/lib/ao2mo/r_ao2mo.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/r_ao2mo.h` & `pyscf-2.3.0/pyscf/lib/ao2mo/r_ao2mo.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ao2mo/restore_eri.c` & `pyscf-2.3.0/pyscf/lib/ao2mo/restore_eri.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/cc/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/cc/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/cc/ccsd_grad.c` & `pyscf-2.3.0/pyscf/lib/cc/ccsd_grad.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/cc/ccsd_pack.c` & `pyscf-2.3.0/pyscf/lib/cc/ccsd_pack.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/cc/ccsd_t.c` & `pyscf-2.3.0/pyscf/lib/cc/ccsd_t.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/cc/uccsd_t.c` & `pyscf-2.3.0/pyscf/lib/cc/uccsd_t.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/chkfile.py` & `pyscf-2.3.0/pyscf/lib/chkfile.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/dft/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/CxLebedevGrid.c` & `pyscf-2.3.0/pyscf/lib/dft/CxLebedevGrid.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/grid_basis.c` & `pyscf-2.3.0/pyscf/lib/dft/grid_basis.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/grid_basis.h` & `pyscf-2.3.0/pyscf/lib/dft/grid_basis.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/libxc_itrf.c` & `pyscf-2.3.0/pyscf/lib/dft/libxc_itrf.c`

 * *Files 2% similar despite different names*

```diff
@@ -369,14 +369,17 @@
         if(xc_func_init(&func, xc_id, XC_UNPOLARIZED) != 0){
                 fprintf(stderr, "XC functional %d not found\n", xc_id);
                 raise_error -1;
         }
         switch(func.info->family)
         {
                 case XC_FAMILY_LDA:
+#ifdef XC_FAMILY_HYB_LDA
+                case XC_FAMILY_HYB_LDA:
+#endif
                         lda = 1;
                         break;
                 default:
                         lda = 0;
         }
 
         xc_func_end(&func);
@@ -905,19 +908,29 @@
 }
 
 void LIBXC_xc_reference(int xc_id, const char **refs)
 {
         xc_func_type func;
         if(xc_func_init(&func, xc_id, XC_UNPOLARIZED) != 0){
                 fprintf(stderr, "XC functional %d not found\n", xc_id);
-                exit(1);
+                raise_error;
         }
 
         int i;
         for (i = 0; i < XC_MAX_REFERENCES; i++) {
                 if (func.info->refs[i] == NULL || func.info->refs[i]->ref == NULL) {
                         refs[i] = NULL;
                         break;
                 }
                 refs[i] = func.info->refs[i]->ref;
         }
 }
+
+int LIBXC_is_nlc(int xc_id)
+{
+        xc_func_type func;
+        if(xc_func_init(&func, xc_id, XC_UNPOLARIZED) != 0){
+                fprintf(stderr, "XC functional %d not found\n", xc_id);
+                raise_error -1;
+        }
+        return func.info->flags & XC_FLAGS_VV10;
+}
```

### Comparing `pyscf-2.2.1/pyscf/lib/dft/nr_numint.c` & `pyscf-2.3.0/pyscf/lib/dft/nr_numint.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/nr_numint_sparse.c` & `pyscf-2.3.0/pyscf/lib/dft/nr_numint_sparse.c`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
  *
  * Author: Qiming Sun <osirpt.sun@gmail.com>
  */
 
 #include <stdlib.h>
 #include <stdint.h>
-#include <assert.h>
 #include "config.h"
 #include "np_helper/np_helper.h"
 #include "cint.h"
 #include "vhf/fblas.h"
 
 #define ALIGNMENT       8
 #define UNROLL_SIZE     (ALIGNMENT*7)
@@ -601,15 +600,14 @@
 }
 
 /* vv[nao,nao] = bra[i,nao] * ket[i,nao] */
 void VXCdot_aow_ao_sparse(double *out, double *bra, double *ket, double *wv,
                           int nao, int ngrids, int nbas, int hermi, int nbins,
                           uint8_t *screen_index, uint8_t *pair_mask, int *ao_loc)
 {
-        assert(ngrids & 0xfffffffffff8 == ngrids);
         size_t Nao = nao;
         int shls_slice[2] = {0, nbas};
         int *box_l1_loc = malloc(sizeof(int) * (nbas+1));
         int nbox_l1 = CVHFshls_block_partition(box_l1_loc, shls_slice, ao_loc, BOXSIZE1_N);
         int mask_l1_size = (ngrids + BOXSIZE1_M - 1)/BOXSIZE1_M * nbox_l1;
         uint8_t *mask_l1 = malloc(sizeof(uint8_t) * mask_l1_size);
         mask_l1_abstract(mask_l1, screen_index, box_l1_loc, nbox_l1, ngrids, nbas);
@@ -889,15 +887,14 @@
 }
 
 /* out = bra.T.dot(ket) */
 void VXCdot_ao_ao_sparse(double *out, double *bra, double *ket,
                          int nao, int ngrids, int nbas, int hermi, int nbins,
                          uint8_t *screen_index, uint8_t *pair_mask, int *ao_loc)
 {
-        assert(ngrids & 0xfffffffffff8 == ngrids);
         size_t Nao = nao;
         int shls_slice[2] = {0, nbas};
         int *box_l1_loc = malloc(sizeof(int) * (nbas+1));
         int nbox_l1 = CVHFshls_block_partition(box_l1_loc, shls_slice, ao_loc, BOXSIZE1_N);
         int mask_l1_size = (ngrids + BOXSIZE1_M - 1)/BOXSIZE1_M * nbox_l1;
         uint8_t *mask_l1 = malloc(sizeof(uint8_t) * mask_l1_size);
         mask_l1_abstract(mask_l1, screen_index, box_l1_loc,
```

### Comparing `pyscf-2.2.1/pyscf/lib/dft/numint_uniform_grid.c` & `pyscf-2.3.0/pyscf/lib/dft/numint_uniform_grid.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/r_numint.c` & `pyscf-2.3.0/pyscf/lib/dft/r_numint.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/vxc.h` & `pyscf-2.3.0/pyscf/lib/dft/vxc.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/xc_deriv.c` & `pyscf-2.3.0/pyscf/lib/dft/xc_deriv.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/dft/xcfun_itrf.c` & `pyscf-2.3.0/pyscf/lib/dft/xcfun_itrf.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/diis.py` & `pyscf-2.3.0/pyscf/lib/diis.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/exceptions.py` & `pyscf-2.3.0/pyscf/lib/exceptions.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/gto/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/autocode/auto_eval1.c` & `pyscf-2.3.0/pyscf/lib/gto/autocode/auto_eval1.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/deriv1.c` & `pyscf-2.3.0/pyscf/lib/gto/deriv1.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/deriv2.c` & `pyscf-2.3.0/pyscf/lib/gto/deriv2.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/fastexp.c` & `pyscf-2.3.0/pyscf/lib/gto/fastexp.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/fill_grids_int2c.c` & `pyscf-2.3.0/pyscf/lib/gto/fill_grids_int2c.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/fill_int2c.c` & `pyscf-2.3.0/pyscf/lib/gto/fill_int2c.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/fill_int2e.c` & `pyscf-2.3.0/pyscf/lib/gto/fill_int2e.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/fill_nr_3c.c` & `pyscf-2.3.0/pyscf/lib/gto/fill_nr_3c.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/fill_r_3c.c` & `pyscf-2.3.0/pyscf/lib/gto/fill_r_3c.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/fill_r_4c.c` & `pyscf-2.3.0/pyscf/lib/gto/fill_r_4c.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/ft_ao.c` & `pyscf-2.3.0/pyscf/lib/gto/ft_ao.c`

 * *Files 5% similar despite different names*

```diff
@@ -354,16 +354,16 @@
                         }
                 }
                 outR += nf * ngrids;
                 outI += nf * ngrids;
         }
 }
 
-int GTO_ft_aopair_loop(double *gctr, FTEnvVars *envs,
-                       FPtr_eval_gz eval_gz, double *cache)
+int GTO_ft_aopair_loop(double *gctr, FTEnvVars *envs, FPtr_eval_gz eval_gz,
+                       double *cache)
 {
         int *shls  = envs->shls;
         int *bas = envs->bas;
         double *env = envs->env;
         int i_sh = shls[0];
         int j_sh = shls[1];
         int i_l = envs->i_l;
@@ -384,50 +384,44 @@
         double aij, dij, eij;
         int ip, jp;
         int empty[3] = {1, 1, 1};
         int *jempty = empty + 0;
         int *iempty = empty + 1;
         int *gempty = empty + 2;
         int block_size = envs->block_size;
-        size_t len1 = envs->g_size * 3 * (1<<envs->gbits) * block_size * OF_CMPLX;
-        size_t leng = nf * n_comp * block_size * OF_CMPLX;
+        size_t leng = envs->g_size * 3 * (1<<envs->gbits) * block_size * OF_CMPLX;
+        size_t len0 = nf * n_comp * block_size * OF_CMPLX;
         size_t leni = nf * i_ctr * n_comp * block_size * OF_CMPLX;
-        size_t lenj = 0;
-        if (n_comp > 1) {
-                lenj = nf * i_ctr * j_ctr * n_comp * block_size * OF_CMPLX;
-        }
-        double *g = malloc(sizeof(double) * (len1+leng+leni+lenj));
-        if (g == NULL) {
-                fprintf(stderr, "g = malloc(%zu) falied in GTO_ft_aopair_loop\n",
-                        sizeof(double) * (len1 + leng + leni + lenj));
-        }
-        double *g1 = g + len1;
+        double *g = cache;
+        cache = g + leng;
         double *gout, *gctri, *gctrj;
 
         if (n_comp == 1) {
                 gctrj = gctr;
         } else {
-                gctrj = g1;
-                g1 += lenj;
+                gctrj = cache;
+                cache += nf * i_ctr * j_ctr * n_comp * block_size * OF_CMPLX;
         }
         if (j_ctr == 1) {
                 gctri = gctrj;
                 iempty = jempty;
         } else {
-                gctri = g1;
-                g1 += leni;
+                gctri = cache;
+                cache += leni;
         }
         if (i_ctr == 1) {
                 gout = gctri;
                 gempty = iempty;
         } else {
-                gout = g1;
+                gout = cache;
+                cache += len0;
         }
 
-        int *idx = malloc(sizeof(int) * nf * 3);
+        int *idx = (int *)cache;
+        cache += (envs->nf * 3 + 1) / 2;
         _g2c_index_xyz(idx, envs);
 
         double rrij = CINTsquare_dist(ri, rj);
         double fac1 = SQRTPI * M_PI * CINTcommon_fac_sp(i_l) * CINTcommon_fac_sp(j_l);
 
         *jempty = 1;
         for (jp = 0; jp < j_prim; jp++) {
@@ -468,16 +462,14 @@
                         *jempty = 0;
                 }
         }
 
         if (n_comp > 1 && !*jempty) {
                 transpose(gctr, gctrj, nf*i_ctr*j_ctr, n_comp, block_size);
         }
-        free(g);
-        free(idx);
         return !*jempty;
 }
 
 void GTO_Gv_general(double *gzR, double *gzI, double fac, double aij,
                     double *rij, FTEnvVars *envs, double *cache)
 {
         int nGv = envs->ngrids;
@@ -682,66 +674,68 @@
                         gzI[n] = 0;
                 }
         }
 }
 
 
 static void daxpy_ij(double *out, double *gctr,
-                     int mi, int mj, int ni, int ngrids)
+                     int bs, int mi, int mj, int ni, size_t ngrids)
 {
         int i, j, k;
         for (j = 0; j < mj; j++) {
                 for (i = 0; i < mi; i++) {
-                        for (k = 0; k < ngrids; k++) {
-                                out[i*ngrids+k] += gctr[i*ngrids+k];
+                        for (k = 0; k < bs; k++) {
+                                out[i*ngrids+k] += gctr[i*bs+k];
                         }
                 }
                 out  += ni * ngrids;
-                gctr += mi * ngrids;
+                gctr += mi * bs;
         }
 }
 
 void GTO_ft_c2s_cart(double *out, double *gctr, int *dims,
                      FTEnvVars *envs, double *cache)
 {
         int i_ctr = envs->x_ctr[0];
         int j_ctr = envs->x_ctr[1];
         int bs = envs->block_size;
         int nfi = envs->nfi;
         int nfj = envs->nfj;
         int mi = nfi*i_ctr;
         int mj = nfj*j_ctr;
-        int ni = dims[0];
-        int nf = envs->nf;
+        int ni = dims[1];
+        size_t ng = dims[0];
+        size_t nf = envs->nf;
         int ic, jc;
         size_t off;
 
         for (jc = 0; jc < mj; jc += nfj) {
         for (ic = 0; ic < mi; ic += nfi) {
-                off = (ni * jc + ic) * bs;
-                daxpy_ij(out+off, gctr, nfi, nfj, ni, bs);
+                off = (ni * jc + ic) * ng;
+                daxpy_ij(out+off, gctr, bs, nfi, nfj, ni, ng);
                 gctr += nf * bs;
         } }
 }
 
 void GTO_ft_c2s_sph(double *out, double *gctr, int *dims,
                     FTEnvVars *envs, double *cache)
 {
         int i_l = envs->i_l;
         int j_l = envs->j_l;
         int i_ctr = envs->x_ctr[0];
         int j_ctr = envs->x_ctr[1];
         int bs = envs->block_size;
         int di = i_l * 2 + 1;
         int dj = j_l * 2 + 1;
+        int nfi = envs->nfi;
         int mi = di*i_ctr;
         int mj = dj*j_ctr;
-        int ni = dims[0];
-        int nfi = envs->nfi;
-        int nf = envs->nf;
+        int ni = dims[1];
+        size_t ng = dims[0];
+        size_t nf = envs->nf;
         int ic, jc, k;
         size_t off;
         int buflen = nfi*dj;
         double *buf1 = cache;
         double *buf2 = buf1 + buflen * bs;
         double *pij, *buf;
 
@@ -749,178 +743,299 @@
         for (ic = 0; ic < mi; ic += di) {
                 buf = CINTc2s_ket_sph(buf1, nfi*bs, gctr, j_l);
                 pij = CINTc2s_ket_sph(buf2, bs, buf, i_l);
                 for (k = bs; k < dj*bs; k+=bs) {
                         CINTc2s_ket_sph(buf2+k*di, bs, buf+k*nfi, i_l);
                 }
 
-                off = (ni * jc + ic) * bs;
-                daxpy_ij(out+off, pij, di, dj, ni, bs);
+                off = (ni * jc + ic) * ng;
+                daxpy_ij(out+off, pij, bs, di, dj, ni, ng);
                 gctr += nf * bs;
         } }
 }
 
 /*************************************************
  *
  * eval_gz is one of GTO_Gv_general, GTO_Gv_nonorth, GTO_Gv_orth
  *
  *************************************************/
 
+static int ft_aopair_cache_size(FTEnvVars *envs)
+{
+        int i_ctr = envs->x_ctr[0];
+        int j_ctr = envs->x_ctr[1];
+        int n_comp = envs->ncomp_e1 * envs->ncomp_tensor;
+        int block_size = envs->block_size;
+        int *gs = envs->gs;
+        int ngs = gs[0] + gs[1] + gs[2];
+        if (ngs == 0) {
+                ngs = envs->ngrids;
+        }
+        int leng = envs->g_size * 3 * (1<<envs->gbits) * OF_CMPLX;
+        int len0 = envs->nf * n_comp * OF_CMPLX;
+        int nc = envs->nf * i_ctr * j_ctr;
+        int cache_size = leng+len0+nc*OF_CMPLX*n_comp*3 +
+                (ngs*3 + envs->nf*3) / block_size + 3;
+        return cache_size;
+}
+
 int GTO_ft_aopair_drv(double *outR, double *outI, int *dims,
-                      FPtr_eval_gz eval_gz, void (*f_c2s)(),
+                      FPtr_eval_gz eval_gz, double *cache, void (*f_c2s)(),
                       FTEnvVars *envs)
 {
         if (eval_gz == NULL) {
                 eval_gz = GTO_Gv_general;
         }
         if (eval_gz != GTO_Gv_general) {
                 assert(envs->gxyz != NULL);
         }
 
         int i_ctr = envs->x_ctr[0];
         int j_ctr = envs->x_ctr[1];
         int n_comp = envs->ncomp_e1 * envs->ncomp_tensor;
         int block_size = envs->block_size;
-        int nc = envs->nf * i_ctr * j_ctr * block_size;
-        int *gs = envs->gs;
-        int ngs = gs[0] + gs[1] + gs[2];
-        if (ngs == 0) {
-                ngs = envs->ngrids;
+        size_t nc = envs->nf * i_ctr * j_ctr * block_size;
+        if (outR == NULL) {
+                return ft_aopair_cache_size(envs);
+        }
+
+        double *stack = NULL;
+        if (cache == NULL) {
+                size_t cache_size = ft_aopair_cache_size(envs) * (size_t)block_size;
+                stack = malloc(sizeof(double)*cache_size);
+                if (stack == NULL) {
+                        fprintf(stderr, "gctr = malloc(%zu) falied in GTO_ft_aopair_drv\n",
+                                sizeof(double) * cache_size);
+                        return 0;
+                }
+                cache = stack;
         }
-        double *gctrR = malloc(sizeof(double) * (nc * n_comp * OF_CMPLX + ngs * 3 + block_size * envs->nf * 2));
+        double *gctrR = cache;
         double *gctrI = gctrR + nc * n_comp;
-        double *cache = gctrI + nc * n_comp;
-        if (gctrR == NULL) {
-                fprintf(stderr, "gctr = malloc(%zu) falied in GTO_ft_aopair_drv\n",
-                        sizeof(double) * (nc * n_comp * OF_CMPLX + ngs * 3 + block_size * envs->nf * 2));
-        }
+        cache = gctrI + nc * n_comp;
 
         int has_value = GTO_ft_aopair_loop(gctrR, envs, eval_gz, cache);
 
-        int counts[4];
-        if (f_c2s == &GTO_ft_c2s_sph) {
-                counts[0] = (envs->i_l*2+1) * i_ctr;
-                counts[1] = (envs->j_l*2+1) * j_ctr;
-        } else {  // f_c2s == &GTO_ft_c2s_cart
-                counts[0] = envs->nfi * i_ctr;
-                counts[1] = envs->nfj * j_ctr;
-        }
+        int counts[3];
         if (dims == NULL) {
+                if (f_c2s == &GTO_ft_c2s_sph) {
+                        counts[0] = block_size;
+                        counts[1] = (envs->i_l*2+1) * i_ctr;
+                        counts[2] = (envs->j_l*2+1) * j_ctr;
+                } else {  // f_c2s == &GTO_ft_c2s_cart
+                        counts[0] = block_size;
+                        counts[1] = envs->nfi * i_ctr;
+                        counts[2] = envs->nfj * j_ctr;
+                }
                 dims = counts;
         }
-        size_t nout = dims[0] * dims[1] * block_size;
+        size_t nout = (size_t)dims[0] * dims[1] * dims[2];
         int n;
         if (has_value) {
                 for (n = 0; n < n_comp; n++) {
                         (*f_c2s)(outR+nout*n, gctrR+nc*n, dims, envs, cache);
                         (*f_c2s)(outI+nout*n, gctrI+nc*n, dims, envs, cache);
                 }
         }
-        free(gctrR);
+        if (stack != NULL) {
+                free(stack);
+        }
         return has_value;
 }
 
 int GTO_ft_ovlp_cart(double *outR, double *outI, int *shls, int *dims,
                      FPtr_eval_gz eval_gz, double complex fac,
-                     double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                     int block_size,
-                     int *atm, int natm, int *bas, int nbas, double *env)
+                     double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                     int *atm, int natm, int *bas, int nbas, double *env, double *cache)
 {
         FTEnvVars envs;
         int ng[] = {0, 0, 0, 0, 0, 1, 0, 1};
         GTO_ft_init1e_envs(&envs, ng, shls, fac, Gv, b, gxyz, gs, nGv, block_size,
                            atm, natm, bas, nbas, env);
         envs.f_gout = &inner_prod;
-        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, &GTO_ft_c2s_cart, &envs);
+        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, cache, &GTO_ft_c2s_cart, &envs);
 }
 
 int GTO_ft_ovlp_sph(double *outR, double *outI, int *shls, int *dims,
                     FPtr_eval_gz eval_gz, double complex fac,
-                    double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                    int block_size,
-                    int *atm, int natm, int *bas, int nbas, double *env)
+                    double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                    int *atm, int natm, int *bas, int nbas, double *env, double *cache)
 {
         FTEnvVars envs;
         int ng[] = {0, 0, 0, 0, 0, 1, 0, 1};
         GTO_ft_init1e_envs(&envs, ng, shls, fac, Gv, b, gxyz, gs, nGv, block_size,
                            atm, natm, bas, nbas, env);
         envs.f_gout = &inner_prod;
-        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, &GTO_ft_c2s_sph, &envs);
+        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, cache, &GTO_ft_c2s_sph, &envs);
 }
 
 // TODO: put kkpool in opt??
 void GTO_ft_ovlp_optimizer()
 {
 }
 
 
 /*************************************************
  *
  *************************************************/
 
-void GTO_ft_fill_s1(int (*intor)(), FPtr_eval_gz eval_gz,
-                    double *out, int comp, int ish, int jsh, double *buf,
-                    int *shls_slice, int *ao_loc, double complex fac,
-                    double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                    int *atm, int natm, int *bas, int nbas, double *env)
+void GTO_ft_dfill_s1(FPtrIntor intor, FPtr_eval_gz eval_gz,
+                     double *out, int comp, int ish, int jsh, double *buf,
+                     int *shls_slice, int *ao_loc, double complex fac,
+                     double *Gv, double *b, int *gxyz, int *gs, int nGv,
+                     int *atm, int natm, int *bas, int nbas, double *env)
+{
+        int ish0 = shls_slice[0];
+        int ish1 = shls_slice[1];
+        int jsh0 = shls_slice[2];
+        int jsh1 = shls_slice[3];
+        ish += ish0;
+        jsh += jsh0;
+        int ioff = ao_loc[ish] - ao_loc[ish0];
+        int joff = ao_loc[jsh] - ao_loc[jsh0];
+        size_t ni = ao_loc[ish1] - ao_loc[ish0];
+        size_t nj = ao_loc[jsh1] - ao_loc[jsh0];
+        size_t nij = ni * nj;
+        int shls[2] = {ish, jsh};
+        int dims[3] = {nGv, ni, nj};
+        int grid0, grid1, dg;
+        size_t off;
+        double *outR = out;
+        double *outI = outR + comp * nij * nGv;
+
+        for (grid0 = 0; grid0 < nGv; grid0 += BLKSIZE) {
+                grid1 = MIN(grid0+BLKSIZE, nGv);
+                dg = grid1 - grid0;
+                off = (joff * ni + ioff) * nGv + grid0;
+                (*intor)(outR+off, outI+off, shls, dims, eval_gz,
+                         fac, Gv+grid0, b, gxyz+grid0, gs, nGv, dg,
+                         atm, natm, bas, nbas, env, buf);
+        }
+}
+
+void GTO_ft_dfill_s1hermi(FPtrIntor intor, FPtr_eval_gz eval_gz,
+                          double *out, int comp, int ish, int jsh, double *buf,
+                          int *shls_slice, int *ao_loc, double complex fac,
+                          double *Gv, double *b, int *gxyz, int *gs, int nGv,
+                          int *atm, int natm, int *bas, int nbas, double *env)
+{
+        int ish0 = shls_slice[0];
+        int ish1 = shls_slice[1];
+        int jsh0 = shls_slice[2];
+        int jsh1 = shls_slice[3];
+        ish += ish0;
+        jsh += jsh0;
+        int ioff = ao_loc[ish] - ao_loc[ish0];
+        int joff = ao_loc[jsh] - ao_loc[jsh0];
+        if (ioff < joff) {
+                return;
+        }
+
+        int di = ao_loc[ish+1] - ao_loc[ish];
+        int dj = ao_loc[jsh+1] - ao_loc[jsh];
+        size_t ni = ao_loc[ish1] - ao_loc[ish0];
+        size_t nj = ao_loc[jsh1] - ao_loc[jsh0];
+        size_t nij = ni * nj;
+        size_t NGv = nGv;
+        int shls[2] = {ish, jsh};
+        int dims[3] = {nGv, ni, nj};
+        int grid0, grid1, dg;
+        int i, j, n, ic;
+        size_t off, ij, ji;
+        double *outR = out;
+        double *outI = outR + comp * nij * nGv;
+
+        for (grid0 = 0; grid0 < nGv; grid0 += BLKSIZE) {
+                grid1 = MIN(grid0+BLKSIZE, nGv);
+                dg = grid1 - grid0;
+                off = (joff * ni + ioff) * nGv + grid0;
+                if ((*intor)(outR+off, outI+off, shls, dims, eval_gz,
+                             fac, Gv+grid0, b, gxyz+grid0, gs, nGv, dg,
+                             atm, natm, bas, nbas, env, buf)) {
+                        if (ioff == joff) {
+                                continue;
+                        }
+for (ic = 0; ic < comp; ic++) {
+        off = nij * NGv * ic + grid0;
+        for (j = 0; j < dj; j++) {
+        for (i = 0; i < di; i++) {
+                ij = off + ((j+joff)*nj+i+ioff) * NGv;
+                ji = off + ((i+ioff)*nj+j+joff) * NGv;
+#pragma GCC ivdep
+                for (n = 0; n < dg; n++) {
+                        outR[ji+n] = outR[ij+n];
+                        outI[ji+n] = outI[ij+n];
+                }
+        } }
+}
+                }
+        }
+}
+
+void GTO_ft_zfill_s1(FPtrIntor intor, FPtr_eval_gz eval_gz,
+                     double *out, int comp, int ish, int jsh, double *buf,
+                     int *shls_slice, int *ao_loc, double complex fac,
+                     double *Gv, double *b, int *gxyz, int *gs, int nGv,
+                     int *atm, int natm, int *bas, int nbas, double *env)
 {
         int ish0 = shls_slice[0];
         int ish1 = shls_slice[1];
         int jsh0 = shls_slice[2];
         int jsh1 = shls_slice[3];
         ish += ish0;
         jsh += jsh0;
         int di = ao_loc[ish+1] - ao_loc[ish];
         int dj = ao_loc[jsh+1] - ao_loc[jsh];
         int dij = di * dj;
-        int nrow = ao_loc[ish1] - ao_loc[ish0];
-        int ncol = ao_loc[jsh1] - ao_loc[jsh0];
+        int ni = ao_loc[ish1] - ao_loc[ish0];
+        int nj = ao_loc[jsh1] - ao_loc[jsh0];
         int ioff = ao_loc[ish] - ao_loc[ish0];
         int joff = ao_loc[jsh] - ao_loc[jsh0];
-        size_t nij = nrow * ncol;
-        size_t off = joff + ioff * ncol;
+        size_t nij = ni * nj;
+        size_t off = joff * ni + ioff;
         size_t NGv = nGv;
         int shls[2] = {ish, jsh};
         double *bufR = buf;
         double *bufI = bufR + dij * BLKSIZE * comp;
+        double *cache = bufI + dij * BLKSIZE * comp;
         int grid0, grid1, dg, dijg;
         int i, j, n, ic, ij;
         double *pout, *pbufR, *pbufI;
 
         for (grid0 = 0; grid0 < nGv; grid0 += BLKSIZE) {
                 grid1 = MIN(grid0+BLKSIZE, nGv);
                 dg = grid1 - grid0;
                 dijg = dij * dg;
                 NPdset0(bufR, dijg * comp);
                 NPdset0(bufI, dijg * comp);
-                (*intor)(bufR, bufI, shls, NULL, eval_gz,
-                         fac, Gv+grid0, b, gxyz+grid0, gs, nGv, dg,
-                         atm, natm, bas, nbas, env);
-
-                for (ic = 0; ic < comp; ic++) {
-                        pout = out + ((off + ic * nij) * NGv + grid0) * OF_CMPLX;
-                        for (i = 0; i < di; i++) {
-                        for (j = 0; j < dj; j++) {
-                                pbufR = bufR + ic * dijg + dg * (j*di+i);
-                                pbufI = bufI + ic * dijg + dg * (j*di+i);
-                                ij = i * ncol + j;
-                                for (n = 0; n < dg; n++) {
-                                        pout[(ij*NGv+n)*OF_CMPLX  ] += pbufR[n];
-                                        pout[(ij*NGv+n)*OF_CMPLX+1] += pbufI[n];
-                                }
-                        } }
+                if ((*intor)(bufR, bufI, shls, NULL, eval_gz,
+                            fac, Gv+grid0, b, gxyz+grid0, gs, nGv, dg,
+                            atm, natm, bas, nbas, env, cache)) {
+for (ic = 0; ic < comp; ic++) {
+        pout = out + ((off + ic * nij) * NGv + grid0) * OF_CMPLX;
+        for (j = 0; j < dj; j++) {
+        for (i = 0; i < di; i++) {
+                pbufR = bufR + ic * dijg + dg * (j*di+i);
+                pbufI = bufI + ic * dijg + dg * (j*di+i);
+                ij = j * ni + i;
+                for (n = 0; n < dg; n++) {
+                        pout[(ij*NGv+n)*OF_CMPLX  ] += pbufR[n];
+                        pout[(ij*NGv+n)*OF_CMPLX+1] += pbufI[n];
+                }
+        } }
+}
                 }
         }
 }
 
-void GTO_ft_fill_s1hermi(int (*intor)(), FPtr_eval_gz eval_gz,
-                         double *out, int comp, int ish, int jsh, double *buf,
-                         int *shls_slice, int *ao_loc, double complex fac,
-                         double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                         int *atm, int natm, int *bas, int nbas, double *env)
+void GTO_ft_zfill_s1hermi(FPtrIntor intor, FPtr_eval_gz eval_gz,
+                          double *out, int comp, int ish, int jsh, double *buf,
+                          int *shls_slice, int *ao_loc, double complex fac,
+                          double *Gv, double *b, int *gxyz, int *gs, int nGv,
+                          int *atm, int natm, int *bas, int nbas, double *env)
 {
         int ish0 = shls_slice[0];
         int ish1 = shls_slice[1];
         int jsh0 = shls_slice[2];
         int jsh1 = shls_slice[3];
         ish += ish0;
         jsh += jsh0;
@@ -929,78 +1044,80 @@
         if (ioff < joff) {
                 return;
         }
 
         int di = ao_loc[ish+1] - ao_loc[ish];
         int dj = ao_loc[jsh+1] - ao_loc[jsh];
         int dij = di * dj;
-        int nrow = ao_loc[ish1] - ao_loc[ish0];
-        int ncol = ao_loc[jsh1] - ao_loc[jsh0];
-        size_t nij = nrow * ncol;
-        size_t ij_off = joff + ioff * ncol;
-        size_t ji_off = ioff + joff * ncol;
+        int ni = ao_loc[ish1] - ao_loc[ish0];
+        int nj = ao_loc[jsh1] - ao_loc[jsh0];
+        size_t nij = ni * nj;
+        size_t ij_off = joff * ni + ioff;
+        size_t ji_off = ioff * ni + joff;
         size_t NGv = nGv;
         int shls[2] = {ish, jsh};
         double *bufR = buf;
         double *bufI = bufR + dij * BLKSIZE * comp;
+        double *cache = bufI + dij * BLKSIZE * comp;
         int grid0, grid1, dg, dijg;
         int i, j, n, ic, ij, ji;
         double *pout_ij, *pout_ji, *pbufR, *pbufI;
 
         for (grid0 = 0; grid0 < nGv; grid0 += BLKSIZE) {
                 grid1 = MIN(grid0+BLKSIZE, nGv);
                 dg = grid1 - grid0;
                 dijg = dij * dg;
                 NPdset0(bufR, dijg * comp);
                 NPdset0(bufI, dijg * comp);
-                (*intor)(bufR, bufI, shls, NULL, eval_gz,
-                         fac, Gv+grid0, b, gxyz+grid0, gs, nGv, dg,
-                         atm, natm, bas, nbas, env);
-
-                if (ioff == joff) {
-                        for (ic = 0; ic < comp; ic++) {
-                                pout_ij = out + ((ij_off + ic * nij) * NGv + grid0) * OF_CMPLX;
-                                for (i = 0; i < di; i++) {
-                                for (j = 0; j < dj; j++) {
-                                        pbufR = bufR + ic * dijg + dg * (j*di+i);
-                                        pbufI = bufI + ic * dijg + dg * (j*di+i);
-                                        ij = i * ncol + j;
-                                        for (n = 0; n < dg; n++) {
-                                                pout_ij[(ij*NGv+n)*OF_CMPLX  ] += pbufR[n];
-                                                pout_ij[(ij*NGv+n)*OF_CMPLX+1] += pbufI[n];
-                                        }
-                                } }
-                        }
-                } else {
-                        for (ic = 0; ic < comp; ic++) {
-                                pout_ij = out + ((ij_off + ic * nij) * NGv + grid0) * OF_CMPLX;
-                                pout_ji = out + ((ji_off + ic * nij) * NGv + grid0) * OF_CMPLX;
-                                for (i = 0; i < di; i++) {
-                                for (j = 0; j < dj; j++) {
-                                        pbufR = bufR + ic * dijg + dg * (j*di+i);
-                                        pbufI = bufI + ic * dijg + dg * (j*di+i);
-                                        ij = i * ncol + j;
-                                        ji = j * ncol + i;
-                                        for (n = 0; n < dg; n++) {
-                                                pout_ij[(ij*NGv+n)*OF_CMPLX  ] += pbufR[n];
-                                                pout_ij[(ij*NGv+n)*OF_CMPLX+1] += pbufI[n];
-                                                pout_ji[(ji*NGv+n)*OF_CMPLX  ] += pbufR[n];
-                                                pout_ji[(ji*NGv+n)*OF_CMPLX+1] += pbufI[n];
-                                        }
-                                } }
-                        }
+                if ((*intor)(bufR, bufI, shls, NULL, eval_gz,
+                             fac, Gv+grid0, b, gxyz+grid0, gs, nGv, dg,
+                             atm, natm, bas, nbas, env, cache)) {
+
+if (ioff == joff) {
+        for (ic = 0; ic < comp; ic++) {
+                pout_ij = out + ((ij_off + ic * nij) * NGv + grid0) * OF_CMPLX;
+                for (j = 0; j < dj; j++) {
+                for (i = 0; i < di; i++) {
+                        pbufR = bufR + ic * dijg + dg * (j*di+i);
+                        pbufI = bufI + ic * dijg + dg * (j*di+i);
+                        ij = j * ni + i;
+                        for (n = 0; n < dg; n++) {
+                                pout_ij[(ij*NGv+n)*OF_CMPLX  ] += pbufR[n];
+                                pout_ij[(ij*NGv+n)*OF_CMPLX+1] += pbufI[n];
+                        }
+                } }
+        }
+} else {
+        for (ic = 0; ic < comp; ic++) {
+                pout_ij = out + ((ij_off + ic * nij) * NGv + grid0) * OF_CMPLX;
+                pout_ji = out + ((ji_off + ic * nij) * NGv + grid0) * OF_CMPLX;
+                for (j = 0; j < dj; j++) {
+                for (i = 0; i < di; i++) {
+                        pbufR = bufR + ic * dijg + dg * (j*di+i);
+                        pbufI = bufI + ic * dijg + dg * (j*di+i);
+                        ij = j * nj + i;
+                        ji = i * nj + j;
+                        for (n = 0; n < dg; n++) {
+                                pout_ij[(ij*NGv+n)*OF_CMPLX  ] += pbufR[n];
+                                pout_ij[(ij*NGv+n)*OF_CMPLX+1] += pbufI[n];
+                                pout_ji[(ji*NGv+n)*OF_CMPLX  ] += pbufR[n];
+                                pout_ji[(ji*NGv+n)*OF_CMPLX+1] += pbufI[n];
+                        }
+                } }
+        }
+}
                 }
         }
 }
 
-void GTO_ft_fill_s2(int (*intor)(), FPtr_eval_gz eval_gz,
-                    double *out, int comp, int ish, int jsh, double *buf,
-                    int *shls_slice, int *ao_loc, double complex fac,
-                    double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                    int *atm, int natm, int *bas, int nbas, double *env)
+void GTO_ft_zfill_s2(FPtrIntor intor, FPtr_eval_gz eval_gz,
+                     double *out, int comp, int ish, int jsh, double *buf,
+                     int *shls_slice, int *ao_loc, double complex fac,
+                     double *Gv, double *b, int *gxyz, int *gs, int nGv,
+                     int *atm, int natm, int *bas, int nbas, double *env)
 {
         int ish0 = shls_slice[0];
         int ish1 = shls_slice[1];
         int jsh0 = shls_slice[2];
         ish += ish0;
         jsh += jsh0;
         int ioff = ao_loc[ish] - ao_loc[ish0];
@@ -1016,91 +1133,125 @@
         size_t off0 = i0 * (i0 + 1) / 2;
         size_t off = ioff * (ioff + 1) / 2 - off0 + joff;
         size_t nij = ao_loc[ish1] * (ao_loc[ish1] + 1) / 2 - off0;
         size_t NGv = nGv;
         int shls[2] = {ish, jsh};
         double *bufR = buf;
         double *bufI = bufR + dij * BLKSIZE * comp;
+        double *cache = bufI + dij * BLKSIZE * comp;
         int grid0, grid1, dg, dijg;
         int i, j, n, ic, ip1;
         double *pout, *pbufR, *pbufI;
 
         for (grid0 = 0; grid0 < nGv; grid0 += BLKSIZE) {
                 grid1 = MIN(grid0+BLKSIZE, nGv);
                 dg = grid1 - grid0;
                 dijg = dij * dg;
                 NPdset0(bufR, dijg * comp);
                 NPdset0(bufI, dijg * comp);
-                (*intor)(bufR, bufI, shls, NULL, eval_gz,
-                         fac, Gv+grid0, b, gxyz+grid0, gs, nGv, dg,
-                         atm, natm, bas, nbas, env);
-
-                if (ioff == joff) {
-                        ip1 = ioff + 1;
-                        for (ic = 0; ic < comp; ic++) {
-                                pout = out + ((off + ic * nij) * NGv + grid0) * OF_CMPLX;
-                                for (i = 0; i < di; i++) {
-                                        for (j = 0; j <= i; j++) {
-                                                pbufR = bufR + ic * dijg + dg * (j*di+i);
-                                                pbufI = bufI + ic * dijg + dg * (j*di+i);
-                                                for (n = 0; n < dg; n++) {
-                                                        pout[(j*NGv+n)*OF_CMPLX  ] += pbufR[n];
-                                                        pout[(j*NGv+n)*OF_CMPLX+1] += pbufI[n];
-                                                }
-                                        }
-                                        pout += (ip1 + i) * NGv * OF_CMPLX;
+                if ((*intor)(bufR, bufI, shls, NULL, eval_gz,
+                             fac, Gv+grid0, b, gxyz+grid0, gs, nGv, dg,
+                             atm, natm, bas, nbas, env, cache)) {
+
+if (ioff == joff) {
+        ip1 = ioff + 1;
+        for (ic = 0; ic < comp; ic++) {
+                pout = out + ((off + ic * nij) * NGv + grid0) * OF_CMPLX;
+                for (i = 0; i < di; i++) {
+                        for (j = 0; j <= i; j++) {
+                                pbufR = bufR + ic * dijg + dg * (j*di+i);
+                                pbufI = bufI + ic * dijg + dg * (j*di+i);
+                                for (n = 0; n < dg; n++) {
+                                        pout[(j*NGv+n)*OF_CMPLX  ] += pbufR[n];
+                                        pout[(j*NGv+n)*OF_CMPLX+1] += pbufI[n];
                                 }
                         }
-                } else {
-                        ip1 = ioff + 1;
-                        for (ic = 0; ic < comp; ic++) {
-                                pout = out + ((off + ic * nij) * NGv + grid0) * OF_CMPLX;
-                                for (i = 0; i < di; i++) {
-                                        for (j = 0; j < dj; j++) {
-                                                pbufR = bufR + ic * dijg + dg * (j*di+i);
-                                                pbufI = bufI + ic * dijg + dg * (j*di+i);
-                                                for (n = 0; n < dg; n++) {
-                                                        pout[(j*NGv+n)*OF_CMPLX  ] += pbufR[n];
-                                                        pout[(j*NGv+n)*OF_CMPLX+1] += pbufI[n];
-                                                }
-                                        }
-                                        pout += (ip1 + i) * NGv * OF_CMPLX;
+                        pout += (ip1 + i) * NGv * OF_CMPLX;
+                }
+        }
+} else {
+        ip1 = ioff + 1;
+        for (ic = 0; ic < comp; ic++) {
+                pout = out + ((off + ic * nij) * NGv + grid0) * OF_CMPLX;
+                for (i = 0; i < di; i++) {
+                        for (j = 0; j < dj; j++) {
+                                pbufR = bufR + ic * dijg + dg * (j*di+i);
+                                pbufI = bufI + ic * dijg + dg * (j*di+i);
+                                for (n = 0; n < dg; n++) {
+                                        pout[(j*NGv+n)*OF_CMPLX  ] += pbufR[n];
+                                        pout[(j*NGv+n)*OF_CMPLX+1] += pbufI[n];
                                 }
                         }
+                        pout += (ip1 + i) * NGv * OF_CMPLX;
+                }
+        }
+}
                 }
         }
 }
 
+static size_t max_cache_size(FPtrIntor intor, FPtr_eval_gz eval_gz, int *shls_slice,
+                             double *Gv, double *b, int *gxyz, int *gs, int nGv,
+                             int *atm, int natm, int *bas, int nbas, double *env)
+{
+        double complex fac = 0.;
+        int ish0 = shls_slice[0];
+        int ish1 = shls_slice[1];
+        int jsh0 = shls_slice[2];
+        int jsh1 = shls_slice[3];
+        int sh0 = MIN(ish0, jsh0);
+        int sh1 = MAX(ish1, jsh1);
+        int blksize = MIN(nGv, BLKSIZE);
+        int shls[2];
+        int i, cache_size;
+        size_t max_size = 0;
+        for (i = sh0; i < sh1; i++) {
+                shls[0] = i;
+                shls[1] = i;
+                cache_size = (*intor)(NULL, NULL, shls, NULL, eval_gz,
+                                      fac, Gv, b, gxyz, gs, nGv, blksize,
+                                      atm, natm, bas, nbas, env, NULL);
+                max_size = MAX(max_size, cache_size);
+        }
+        return max_size * blksize;
+}
+
 /*
  * Fourier transform AO pairs and add to out (inplace)
  */
-void GTO_ft_fill_drv(int (*intor)(), FPtr_eval_gz eval_gz, void (*fill)(),
-                     double complex *out, int comp,
+void GTO_ft_fill_drv(FPtrIntor intor, FPtr_eval_gz eval_gz, void (*fill)(),
+                     double *out, int8_t *ovlp_mask, int comp,
                      int *shls_slice, int *ao_loc, double phase,
                      double *Gv, double *b, int *gxyz, int *gs, int nGv,
                      int *atm, int natm, int *bas, int nbas, double *env)
 {
         int ish0 = shls_slice[0];
         int ish1 = shls_slice[1];
         int jsh0 = shls_slice[2];
         int jsh1 = shls_slice[3];
         int nish = ish1 - ish0;
         int njsh = jsh1 - jsh0;
         double complex fac = cos(phase) + sin(phase)*_Complex_I;
-        size_t di = GTOmax_shell_dim(ao_loc, shls_slice  , 1);
-        size_t dj = GTOmax_shell_dim(ao_loc, shls_slice+2, 1);
+        size_t di = GTOmax_shell_dim(ao_loc, shls_slice  , 2);
+        size_t cache_size = max_cache_size(intor, eval_gz, shls_slice,
+                                           Gv, b, gxyz, gs, nGv,
+                                           atm, natm, bas, nbas, env);
 
 #pragma omp parallel
 {
         int i, j, ij;
-        double *buf = malloc(sizeof(double) * di*dj*comp*BLKSIZE * OF_CMPLX);
-#pragma omp for schedule(dynamic)
+        double *buf = malloc(sizeof(double) * (cache_size +
+                                               di*di*comp*BLKSIZE * OF_CMPLX));
+#pragma omp for schedule(dynamic, 4)
         for (ij = 0; ij < nish*njsh; ij++) {
-                i = ij / njsh;
-                j = ij % njsh;
+                j = ij / nish;
+                i = ij % nish;
+                if (!ovlp_mask[ij]) {
+                        continue;
+                }
                 (*fill)(intor, eval_gz, out,
                         comp, i, j, buf, shls_slice, ao_loc, fac,
                         Gv, b, gxyz, gs, nGv, atm, natm, bas, nbas, env);
         }
         free(buf);
 }
 }
```

### Comparing `pyscf-2.2.1/pyscf/lib/gto/ft_ao.h` & `pyscf-2.3.0/pyscf/lib/gto/ft_ao.h`

 * *Files 14% similar despite different names*

```diff
@@ -64,39 +64,41 @@
         int block_size;
 } FTEnvVars;
 #endif
 
 typedef void (*FPtr_eval_gz)(double *gzR, double *gzI, double fac, double aij,
                              double *rij, FTEnvVars *envs, double *cache);
 
+typedef int (*FPtrIntor)(double *outR, double *outI, int *shls, int *dims,
+                         FPtr_eval_gz eval_gz, double complex fac,
+                         double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                         int *atm, int natm, int *bas, int nbas, double *env, double *cache);
 
 void GTO_ft_init1e_envs(FTEnvVars *envs, int *ng, int *shls, double complex fac,
                         double *Gv, double *b, int *gxyz, int *gs,
                         int nGv, int block_size,
                         int *atm, int natm, int *bas, int nbas, double *env);
 
 int GTO_ft_aopair_drv(double *outR, double *outI, int *dims,
-                      FPtr_eval_gz eval_gz, void (*f_c2s)(),
+                      FPtr_eval_gz eval_gz, double *cache, void (*f_c2s)(),
                       FTEnvVars *envs);
 
 void GTO_ft_c2s_cart(double *out, double *gctr, int *dims,
                      FTEnvVars *envs, double *cache);
 void GTO_ft_c2s_sph(double *out, double *gctr, int *dims,
                     FTEnvVars *envs, double *cache);
 
 int GTO_ft_ovlp_cart(double *outR, double *outI, int *shls, int *dims,
                      FPtr_eval_gz eval_gz, double complex fac,
-                     double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                     int block_size,
-                     int *atm, int natm, int *bas, int nbas, double *env);
+                     double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                     int *atm, int natm, int *bas, int nbas, double *env, double *cache);
 int GTO_ft_ovlp_sph(double *outR, double *outI, int *shls, int *dims,
                     FPtr_eval_gz eval_gz, double complex fac,
-                    double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                    int block_size,
-                    int *atm, int natm, int *bas, int nbas, double *env);
+                    double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                    int *atm, int natm, int *bas, int nbas, double *env, double *cache);
 
 #define ZMUL(outR, outI, gx, gy, gz) \
         xyR = gx##R[ix*bs+k] * gy##R[iy*bs+k] - gx##I[ix*bs+k] * gy##I[iy*bs+k]; \
         xyI = gx##R[ix*bs+k] * gy##I[iy*bs+k] + gx##I[ix*bs+k] * gy##R[iy*bs+k]; \
         outR = xyR * gz##R[iz*bs+k] - xyI * gz##I[iz*bs+k]; \
         outI = xyR * gz##I[iz*bs+k] + xyI * gz##R[iz*bs+k];
```

### Comparing `pyscf-2.2.1/pyscf/lib/gto/ft_ao_deriv.c` & `pyscf-2.3.0/pyscf/lib/gto/ft_ao_deriv.c`

 * *Files 2% similar despite different names*

```diff
@@ -175,38 +175,36 @@
                         }
                 }
         }
 }
 
 int GTO_ft_pdotp_cart(double *outR, double *outI, int *shls, int *dims,
                       FPtr_eval_gz eval_gz, double complex fac,
-                      double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                      int block_size,
-                      int *atm, int natm, int *bas, int nbas, double *env)
+                      double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                      int *atm, int natm, int *bas, int nbas, double *env, double *cache)
 {
         FTEnvVars envs;
         int ng[] = {1, 1, 0, 0, 2, 1, 0, 1};
         GTO_ft_init1e_envs(&envs, ng, shls, fac, Gv, b, gxyz, gs, nGv, block_size,
                            atm, natm, bas, nbas, env);
         envs.f_gout = &inner_prod_pdotp;
-        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, &GTO_ft_c2s_cart, &envs);
+        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, cache, &GTO_ft_c2s_cart, &envs);
 }
 
 int GTO_ft_pdotp_sph(double *outR, double *outI, int *shls, int *dims,
                      FPtr_eval_gz eval_gz, double complex fac,
-                     double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                     int block_size,
-                     int *atm, int natm, int *bas, int nbas, double *env)
+                     double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                     int *atm, int natm, int *bas, int nbas, double *env, double *cache)
 {
         FTEnvVars envs;
         int ng[] = {1, 1, 0, 0, 2, 1, 0, 1};
         GTO_ft_init1e_envs(&envs, ng, shls, fac, Gv, b, gxyz, gs, nGv, block_size,
                            atm, natm, bas, nbas, env);
         envs.f_gout = &inner_prod_pdotp;
-        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, &GTO_ft_c2s_sph, &envs);
+        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, cache, &GTO_ft_c2s_sph, &envs);
 }
 
 
 static void inner_prod_pxp(double *gout, double *g, int *idx, FTEnvVars *envs, int empty)
 {
         int nf = envs->nf;
         int ix, iy, iz, n, k;
@@ -268,32 +266,30 @@
                         }
                 }
         }
 }
 
 int GTO_ft_pxp_cart(double *outR, double *outI, int *shls, int *dims,
                     void (*eval_gz)(), double complex fac,
-                    double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                    int block_size,
-                    int *atm, int natm, int *bas, int nbas, double *env)
+                    double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                    int *atm, int natm, int *bas, int nbas, double *env, double *cache)
 {
         FTEnvVars envs;
         int ng[] = {1, 1, 0, 0, 2, 1, 0, 3};
         GTO_ft_init1e_envs(&envs, ng, shls, fac, Gv, b, gxyz, gs, nGv, block_size,
                            atm, natm, bas, nbas, env);
         envs.f_gout = &inner_prod_pxp;
-        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, &GTO_ft_c2s_cart, &envs);
+        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, cache, &GTO_ft_c2s_cart, &envs);
 }
 
 int GTO_ft_pxp_sph(double *outR, double *outI, int *shls, int *dims,
                    void (*eval_gz)(), double complex fac,
-                   double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                   int block_size,
-                   int *atm, int natm, int *bas, int nbas, double *env)
+                   double *Gv, double *b, int *gxyz, int *gs, int nGv, int block_size,
+                   int *atm, int natm, int *bas, int nbas, double *env, double *cache)
 {
         FTEnvVars envs;
         int ng[] = {1, 1, 0, 0, 2, 1, 0, 3};
         GTO_ft_init1e_envs(&envs, ng, shls, fac, Gv, b, gxyz, gs, nGv, block_size,
                            atm, natm, bas, nbas, env);
         envs.f_gout = &inner_prod_pxp;
-        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, &GTO_ft_c2s_sph, &envs);
+        return GTO_ft_aopair_drv(outR, outI, dims, eval_gz, cache, &GTO_ft_c2s_sph, &envs);
 }
```

### Comparing `pyscf-2.2.1/pyscf/lib/gto/grid_ao_drv.c` & `pyscf-2.3.0/pyscf/lib/gto/grid_ao_drv.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/grid_ao_drv.h` & `pyscf-2.3.0/pyscf/lib/gto/grid_ao_drv.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/gto.h` & `pyscf-2.3.0/pyscf/lib/gto/gto.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/gto/nr_ecp.c` & `pyscf-2.3.0/pyscf/lib/gto/nr_ecp.c`

 * *Files 0% similar despite different names*

```diff
@@ -17,61 +17,20 @@
  */
 
 #include <stdlib.h>
 #include <stdint.h>
 #include <math.h>
 #include <complex.h>
 #include "cint.h"
+#include "np_helper/np_helper.h"
 #include "vhf/fblas.h"
-
-//#define ATOM_OF         0
-//#define ANG_OF          1
-#define RADI_POWER      3
-#define SO_TYPE_OF      4
-
-#define ECP_LMAX        5
-//#define PTR_EXP         5
-//#define PTR_COEFF       6
-#define SIM_ZERO        1e-50
-#define EXPCUTOFF       39   // 1e-17
-#define CUTOFF          460  // ~ 1e200
-#define CLOSE_ENOUGH(x, y)      (fabs(x-y) < 1e-12*fabs(y) || fabs(x-y) < 1e-12)
-#define SQUARE(r)       (r[0]*r[0]+r[1]*r[1]+r[2]*r[2])
-#define CART_CUM        (455+1) // upto l = 12
-#define K_TAYLOR_MAX    7
-#define K_TAB_COL       24      // >= (7*2+1+K_TAYLOR_MAX)
-#define K_TAB_ENTRIES   400
-#define K_TAB_INTERVAL  (16./K_TAB_ENTRIES)    // [0,16], interval 0.04
-#define MAX(X,Y)        ((X)>(Y)?(X):(Y))
-#define MALLOC_INSTACK(var, n) \
-                var = (void *)cache; \
-                cache = (void *)(((uintptr_t)(var + (n)) + 7) & (-(uintptr_t)8));
-#define MARK_STACK      cache0 = cache;
-#define RESTORE_STACK   cache = cache0;
-
-// Held in env, to get *ecpbas, necpbas
-#define AS_ECPBAS_OFFSET        18
-#define AS_NECPBAS              19
-
-
-// for radial grids
-#define LEVEL0          5
-//#define LEVEL_MAX       11      // 2047 points
-#define LEVEL_MAX       11
+#include "gto/nr_ecp.h"
 
 double CINTcommon_fac_sp(int);
 
-typedef struct {
-    double *u_ecp;
-} ECPOpt;
-
-typedef int Function_cart(double *gctr, int *shls, int *ecpbas, int necpbas,
-                          int *atm, int natm, int *bas, int nbas, double *env,
-                          ECPOpt *opt, double *cache);
-
 static double _sph_ine_tab[] = { // 400x24
 9.802640211919197e-01, 6.534919212092035e-03, 2.613937811451498e-05, 7.468346329123935e-08, 1.659625812043017e-10, 3.017493035919202e-13, 4.642287455711235e-16, 6.189706898282851e-19, 7.281999097680386e-22, 7.665254523625293e-25, 7.300236357712470e-28, 6.348027199385843e-31, 5.078418750076879e-34, 3.761789744992798e-37, 2.594336600846831e-40, 1.673764894480139e-43, 1.014402615043443e-46, 5.796584581226479e-50, 3.133288094277013e-53, 1.606814005366913e-56, 7.838115320992611e-60, 3.645634279400473e-63, 1.620281595519583e-66, 6.894814102547425e-70,
 9.423296940236874e-01, 1.884207224818979e-02, 2.260816141980705e-04, 1.937731683913445e-06, 1.291774150186003e-08, 7.045863444090539e-11, 3.251876940391953e-13, 1.300732413080320e-15, 4.590769115454675e-18, 1.449703482841226e-20, 4.141979079274455e-23, 1.080509516656789e-25, 2.593209009591830e-28, 5.762660193098549e-31, 1.192269748342981e-33, 2.307610747161589e-36, 4.195642826638227e-39, 7.192510565377163e-42, 1.166350154849031e-44, 1.794380813740386e-47, 2.625917780013486e-50, 3.664064504096460e-53, 4.885411023215048e-56, 6.236685174215352e-59,
 9.063462346100909e-01, 3.019141928900223e-02, 6.036559400239012e-04, 8.622287807164008e-06, 9.579352242057132e-08, 8.707893125883569e-10, 6.698035852053903e-12, 4.465182134941749e-14, 2.626496412795802e-16, 1.382331888858186e-18, 6.582396524955082e-21, 2.861861761817600e-23, 1.144727746014053e-25, 4.239678246653739e-28, 1.461941754380445e-30, 4.715895044881049e-33, 1.429046731905972e-35, 4.082959134165019e-38, 1.103494821514312e-40, 2.829456206258353e-43, 6.901073554470799e-46, 1.604892532642074e-48, 3.566410987925639e-51, 7.588075536423757e-54,
 8.722009233724092e-01, 4.064962396752648e-02, 1.137552639698620e-03, 2.274397829003244e-05, 3.537251969982054e-07, 4.501340147805141e-09, 4.847109923004117e-11, 4.523621584594117e-13, 3.725109389920223e-15, 2.744682624160316e-17, 1.829714169367008e-19, 1.113701098036058e-21, 6.236545062744792e-24, 3.233683163047443e-26, 1.561054390080907e-28, 7.049787985018583e-31, 2.990768393494177e-33, 1.196289251644110e-35, 4.526438390070580e-38, 1.624855402807172e-40, 5.548225060005377e-43, 1.806380559727397e-45, 5.619798551249213e-48, 1.673968300753623e-50,
 8.397879831360249e-01, 5.027877721939270e-02, 1.808362812813033e-03, 4.647686347510318e-05, 9.292332256868268e-07, 1.520219076183037e-08, 2.104569083041292e-10, 2.525162087703369e-12, 2.673432884835239e-14, 2.532520256428454e-16, 2.170586052040690e-18, 1.698623809823192e-20, 1.222950443880237e-22, 8.152665619678108e-25, 5.060092852017936e-27, 2.938025380983860e-29, 1.602514346193933e-31, 8.241296164981470e-34, 4.009189198003429e-36, 1.850357521979083e-38, 8.123371541285905e-41, 3.400424173842929e-43, 1.360148833507746e-45, 5.209007356442930e-48,
 8.090081339019514e-01, 5.913671199826918e-02, 2.598424834644346e-03, 8.160211998856853e-05, 1.993744098983762e-06, 3.986139377821739e-08, 6.744100728921062e-10, 9.889470956573337e-12, 1.279622166510847e-13, 1.481488080423163e-15, 1.551879635695967e-17, 1.484281679217320e-19, 1.306074233139604e-21, 1.064142859516303e-23, 8.072373323154131e-26, 5.728510053119174e-28, 3.818846680199104e-30, 2.400328205168628e-32, 1.427174308308297e-34, 8.050483194653290e-37, 4.319652884952700e-39, 2.209999687114206e-41, 1.080419567502579e-43, 5.057176802023883e-46,
@@ -5388,15 +5347,14 @@
         const int li = bas[ANG_OF+ish*BAS_SLOTS];
         const int lj = bas[ANG_OF+jsh*BAS_SLOTS];
         const int nci = bas[NCTR_OF+ish*BAS_SLOTS];
         const int ncj = bas[NCTR_OF+jsh*BAS_SLOTS];
         const int nfi = (li+1) * (li+2) / 2;
         const int nfj = (lj+1) * (lj+2) / 2;
         const int di = nfi * nci;
-        const int ngctr = nci * ncj * nfi * nfj;
         const double *ri = env + atm[PTR_COORD+bas[ATOM_OF+ish*BAS_SLOTS]*ATM_SLOTS];
         const double *rj = env + atm[PTR_COORD+bas[ATOM_OF+jsh*BAS_SLOTS]*ATM_SLOTS];
         const double D0 = 0;
         const double D1 = 1;
         const char TRANS_N = 'N';
         const char TRANS_T = 'T';
         const double common_fac = CINTcommon_fac_sp(li) *
@@ -5433,16 +5391,14 @@
         int ljlc1 = lj + ECP_LMAX + 1;
         int d2 = lilc1 * ljlc1;
         int d3 = lilj1 * d2;
         MALLOC_INSTACK(plast, d2);
         int8_t *converged;
         MALLOC_INSTACK(converged, nci*ncj*lilj1);
 
-        for (i = 0; i < ngctr; i++) { gctr[i] = 0; }
-
         for (iloc = 0; iloc < nslots; iloc++) {
                 lc = ecpbas[ANG_OF+ecploc[iloc]*BAS_SLOTS];
                 if (lc == -1 ||
                     ecpbas[SO_TYPE_OF+ecploc[iloc]*BAS_SLOTS] == 1) {
                         continue;
                 }
                 atm_id = ecpbas[ATOM_OF+ecploc[iloc]*BAS_SLOTS];
@@ -5644,16 +5600,14 @@
                 ecp_lmax[i] = 0;
         }
         for (i = 0; i < necpbas; i++) {
                 n = ecpbas[ATOM_OF +i*BAS_SLOTS];
                 ecp_lmax[n] = MAX(ecp_lmax[n], ecpbas[ANG_OF +i*BAS_SLOTS]);
         }
 
-        for (i = 0; i < ngctr*4; i++) { gctr[i] = 0; }
-
         for (iloc = 0; iloc < nslots; iloc++) {
                 if (ecpbas[SO_TYPE_OF+ecploc[iloc]*BAS_SLOTS] != 1) {
                         continue;
                 }
                 lc = ecpbas[ANG_OF+ecploc[iloc]*BAS_SLOTS];
                 if (lc == -1) { // Treat Ul term as L_max in SO-ECP
                         n = ecpbas[ATOM_OF+ecploc[iloc]*BAS_SLOTS];
@@ -5864,15 +5818,14 @@
         const int lj = bas[ANG_OF+jsh*BAS_SLOTS];
         const int npi = bas[NPRIM_OF+ish*BAS_SLOTS];
         const int npj = bas[NPRIM_OF+jsh*BAS_SLOTS];
         const int nci = bas[NCTR_OF+ish*BAS_SLOTS];
         const int ncj = bas[NCTR_OF+jsh*BAS_SLOTS];
         const int nfi = (li+1) * (li+2) / 2;
         const int nfj = (lj+1) * (lj+2) / 2;
-        const int ngctr = nci * ncj * nfi * nfj;
         const double *ai = env + bas[PTR_EXP+ish*BAS_SLOTS];
         const double *aj = env + bas[PTR_EXP+jsh*BAS_SLOTS];
         const double *ci = env + bas[PTR_COEFF+ish*BAS_SLOTS];
         const double *cj = env + bas[PTR_COEFF+jsh*BAS_SLOTS];
         const double *ri = env + atm[PTR_COORD+bas[ATOM_OF+ish*BAS_SLOTS]*ATM_SLOTS];
         const double *rj = env + atm[PTR_COORD+bas[ATOM_OF+jsh*BAS_SLOTS]*ATM_SLOTS];
 
@@ -5912,15 +5865,14 @@
         double rij[3];
         double fac;
         double *rc, *pifac, *pjfac, *pout;
         int has_value = 0;
         int8_t *converged;
         MALLOC_INSTACK(converged, npi*npj);
 
-        for (i = 0; i < ngctr; i++) { gctr[i] = 0; }
         for (i = 0; i < d3; i++) { rad_all[i] = 0; }
 
         for (iloc = 0; iloc < nslots; iloc++) {
                 if (ecpbas[ANG_OF+ecploc[iloc]*BAS_SLOTS] != -1) {
                         continue;
                 }
                 atm_id = ecpbas[ATOM_OF+ecploc[iloc]*BAS_SLOTS];
@@ -6029,19 +5981,30 @@
                         LOOP_XYZ(j1, j2, j3, jx, jy, jz) {
                                 *pout += pifac[i1*di2+i2*di1+i3] *
                                          pjfac[j1*dj2+j2*dj1+j3] *
                                          prad[(i1+j1)*d2+(i2+j2)*d1+i3+j3];
                         } }
                 } }
         } }
-
         }
         return has_value;
 }
 
+int ECPtype_scalar_cart(double *gctr, int *shls, int *ecpbas, int necpbas,
+                        int *atm, int natm, int *bas, int nbas, double *env,
+                        ECPOpt *opt, double *cache)
+{
+        int has_value1, has_value2;
+        has_value1 = ECPtype1_cart(gctr, shls, ecpbas, necpbas,
+                                   atm, natm, bas, nbas, env, opt, cache);
+        has_value2 = ECPtype2_cart(gctr, shls, ecpbas, necpbas,
+                                   atm, natm, bas, nbas, env, opt, cache);
+        return has_value1 | has_value2;
+}
+
 int ECPscalar_cache_size(int comp, int *shls,
                          int *atm, int natm, int *bas, int nbas, double *env)
 {
         const int ish = shls[0];
         const int jsh = shls[1];
         const int li = bas[ANG_OF+ish*BAS_SLOTS];
         const int lj = bas[ANG_OF+jsh*BAS_SLOTS];
@@ -6100,26 +6063,29 @@
         const int jsh = shls[1];
         const int li = bas[ANG_OF+ish*BAS_SLOTS];
         const int lj = bas[ANG_OF+jsh*BAS_SLOTS];
         const int nfi = (li+1) * (li+2) / 2;
         const int nfj = (lj+1) * (lj+2) / 2;
         const int nci = bas[NCTR_OF+ish*BAS_SLOTS];
         const int ncj = bas[NCTR_OF+jsh*BAS_SLOTS];
+        int ngcart = nfi*nfj*nci*ncj * comp;
 
         if (li < 2 && lj < 2) {
+                NPdset0(gctr, ngcart);
                 return fcart(gctr, shls, ecpbas, necpbas,
                              atm, natm, bas, nbas, env, opt, cache);
         }
 
         int j;
         int di = nfi * nci;
         int dji = di * (lj*2+1);
         int nij = (li*2+1) * (lj*2+1) * nci * ncj;
         double *gcart, *gtmp;
-        MALLOC_INSTACK(gcart, nfi*nfj*nci*ncj * comp);
+        MALLOC_INSTACK(gcart, ngcart);
+        NPdset0(gcart, ngcart);
         gtmp = cache;
         int has_value = fcart(gcart, shls, ecpbas, necpbas,
                               atm, natm, bas, nbas, env, opt, cache);
 
         if (has_value) {
                 if (li < 2) {
                         for (j = 0; j < ncj * comp; j++) {
@@ -6151,14 +6117,22 @@
                  int *atm, int natm, int *bas, int nbas, double *env,
                  ECPOpt *opt, double *cache)
 {
         return ECPscalar_c2s_factory(ECPtype2_cart, gctr, 1, shls, ecpbas, necpbas,
                                      atm, natm, bas, nbas, env, opt, cache);
 }
 
+int ECPtype_scalar_sph(double *gctr, int *shls, int *ecpbas, int necpbas,
+                       int *atm, int natm, int *bas, int nbas, double *env,
+                       ECPOpt *opt, double *cache)
+{
+        return ECPscalar_c2s_factory(ECPtype_scalar_cart, gctr, 1, shls, ecpbas, necpbas,
+                                     atm, natm, bas, nbas, env, opt, cache);
+}
+
 void ECPscalar_distribute(double *out, double *gctr, const int *dims,
                           const int comp, const int di, const int dj)
 {
         const int dij = di * dj;
         int i, j, ni, icomp;
         if (dims == NULL) {
                 for (i = 0; i < dij * comp; i++) {
@@ -6225,28 +6199,19 @@
                                                       atm, natm, bas, nbas, env);
                 stack = malloc(sizeof(double) * cache_size);
                 cache = stack;
         }
 
         int *ecpbas = bas + (int)(env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
         int necpbas = (int)(env[AS_NECPBAS]);
-        double *buf1, *buf2;
+        double *buf1;
         MALLOC_INSTACK(buf1, dij * comp);
-        MALLOC_INSTACK(buf2, dij * comp);
-        int has_value;
-        has_value = ECPtype1_sph(buf1, shls, ecpbas, necpbas,
-                                 atm, natm, bas, nbas, env, opt, cache);
-        has_value =(ECPtype2_sph(buf2, shls, ecpbas, necpbas,
-                                 atm, natm, bas, nbas, env, opt, cache) | has_value);
-
+        int has_value = ECPtype_scalar_sph(buf1, shls, ecpbas, necpbas,
+                                           atm, natm, bas, nbas, env, opt, cache);
         if (has_value) {
-                int i;
-                for (i = 0; i < dij; i++) {
-                        buf1[i] += buf2[i];
-                }
                 ECPscalar_distribute(out, buf1, dims, 1, di, dj);
         } else {
                 ECPscalar_distribute0(out, dims, 1, di, dj);
         }
 
         if (stack != NULL) {
                 free(stack);
@@ -6277,28 +6242,21 @@
                                                       atm, natm, bas, nbas, env);
                 stack = malloc(sizeof(double) * cache_size);
                 cache = stack;
         }
 
         int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
         int necpbas = (int)env[AS_NECPBAS];
-        double *buf1, *buf2;
-        MALLOC_INSTACK(buf1, dij * comp);
-        MALLOC_INSTACK(buf2, dij * comp);
-        int has_value;
-        has_value = ECPtype1_cart(buf1, shls, ecpbas, necpbas,
-                                  atm, natm, bas, nbas, env, opt, cache);
-        has_value =(ECPtype2_cart(buf2, shls, ecpbas, necpbas,
-                                  atm, natm, bas, nbas, env, opt, cache) | has_value);
-
+        int ngcart = dij * comp;
+        double *buf1;
+        MALLOC_INSTACK(buf1, ngcart);
+        NPdset0(buf1, ngcart);
+        int has_value = ECPtype_scalar_cart(buf1, shls, ecpbas, necpbas,
+                                            atm, natm, bas, nbas, env, opt, cache);
         if (has_value) {
-                int i;
-                for (i = 0; i < dij; i++) {
-                        buf1[i] += buf2[i];
-                }
                 ECPscalar_distribute(out, buf1, dims, 1, di, dj);
         } else {
                 ECPscalar_distribute0(out, dims, 1, di, dj);
         }
 
         if (stack != NULL) {
                 free(stack);
@@ -6401,16 +6359,15 @@
         for (ib = 0; ib < necpbas; ib++) {
                 npk = ecpbas[ib*BAS_SLOTS+NPRIM_OF];
                 ak = env + ecpbas[ib*BAS_SLOTS+PTR_EXP];
                 ck = env + ecpbas[ib*BAS_SLOTS+PTR_COEFF];
 
                 for (i = 0; i < (1 << LEVEL_MAX); i++) {
                         r2 = rs_gauss_chebyshev2047[i]*rs_gauss_chebyshev2047[i];
-                        uk[i] = ck[0] * exp(-ak[0]*r2);
-                        s = uk[i];
+                        s = ck[0] * exp(-ak[0]*r2);
                         for (kp = 1; kp < npk; kp++) {
                                 s += ck[kp] * exp(-ak[kp]*r2);
                         }
                         uk[i] = s;
                 }
                 uk += (1 << LEVEL_MAX);
         }
@@ -6463,16 +6420,18 @@
                                                       atm, natm, bas, nbas, env);
                 stack = malloc(sizeof(double) * cache_size);
                 cache = stack;
         }
 
         int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
         int necpbas = (int)env[AS_NECPBAS];
+        int ngcart = dij * comp;
         double *buf1;
-        MALLOC_INSTACK(buf1, dij * comp);
+        MALLOC_INSTACK(buf1, ngcart);
+        NPdset0(buf1, ngcart);
         int has_value = ECPtype_so_cart(buf1, shls, ecpbas, necpbas,
                                         atm, natm, bas, nbas, env, opt, cache);
 
         if (has_value) {
                 // comp-1 for x, y, z components only
                 ECPscalar_distribute(out, buf1, dims, comp-1, di, dj);
         } else {
@@ -6515,15 +6474,14 @@
         int *ecpbas = bas + (int)(env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
         int necpbas = (int)(env[AS_NECPBAS]);
         double *buf1;
         MALLOC_INSTACK(buf1, dij * comp);
         int has_value = ECPscalar_c2s_factory(ECPtype_so_cart, buf1, comp,
                                               shls, ecpbas, necpbas,
                                               atm, natm, bas, nbas, env, opt, cache);
-
         if (has_value) {
                 // comp-1 for x, y, z components only
                 ECPscalar_distribute(out, buf1, dims, comp-1, di, dj);
         } else {
                 ECPscalar_distribute0(out, dims, comp-1, di, dj);
         }
 
@@ -6561,16 +6519,18 @@
                                                       atm, natm, bas, nbas, env);
                 stack = malloc(sizeof(double) * (cache_size + ngctr*8*OF_CMPLX));
                 cache = stack;
         }
 
         int *ecpbas = bas + (int)(env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
         int necpbas = (int)(env[AS_NECPBAS]);
+        int ngcart = ngctr * comp;
         double *buf1;
-        MALLOC_INSTACK(buf1, ngctr * comp);
+        MALLOC_INSTACK(buf1, ngcart);
+        NPdset0(buf1, ngcart);
         int has_value = ECPtype_so_cart(buf1, shls, ecpbas, necpbas,
                                         atm, natm, bas, nbas, env, opt, cache);
         int counts[2] = {di, dj};
         if (dims == NULL) {
                 dims = counts;
         }
         cart2spinor(out, buf1, dims, shls, bas, cache);
```

### Comparing `pyscf-2.2.1/pyscf/lib/gto/nr_ecp_deriv.c` & `pyscf-2.3.0/pyscf/lib/gto/nr_ecp_deriv.c`

 * *Files 4% similar despite different names*

```diff
@@ -17,42 +17,25 @@
  */
 
 #include <stdlib.h>
 #include <stdint.h>
 #include <math.h>
 #include <complex.h>
 #include "cint.h"
+#include "np_helper/np_helper.h"
 #include "vhf/fblas.h"
-
-#define SIM_ZERO        1e-50
-#define EXPCUTOFF       39   // 1e-17
-#define CUTOFF          460  // ~ 1e200
-#define CLOSE_ENOUGH(x, y)      (fabs(x-y) < 1e-10*fabs(y) || fabs(x-y) < 1e-10)
-#define SQUARE(r)       (r[0]*r[0]+r[1]*r[1]+r[2]*r[2])
-#define CART_CUM        (455+1) // upto l = 12
-#define MALLOC_INSTACK(var, n) \
-                var = (void *)cache; \
-                cache = (void *)(((uintptr_t)(var + (n)) + 7) & (-(uintptr_t)8));
-
-// Held in env, to get *ecpbas, necpbas
-#define AS_RINV_ORIG_ATOM       17
-#define AS_ECPBAS_OFFSET        18
-#define AS_NECPBAS              19
-
-typedef struct {
-    double *u_ecp;
-} ECPOpt;
+#include "gto/nr_ecp.h"
 
 int ECPtype1_cart(double *gctr, int *shls, int *ecpbas, int necpbas,
                   int *atm, int natm, int *bas, int nbas, double *env,
                   ECPOpt *opt, double *cache);
 int ECPtype2_cart(double *gctr, int *shls, int *ecpbas, int necpbas,
                   int *atm, int natm, int *bas, int nbas, double *env,
                   ECPOpt *opt, double *cache);
-int ECPscalar_c2s_factory(int (*fcart)(), double *gctr, int comp, int *shls,
+int ECPscalar_c2s_factory(Function_cart fcart, double *gctr, int comp, int *shls,
                           int *ecpbas, int necpbas, int *atm, int natm,
                           int *bas, int nbas, double *env, ECPOpt *opt,
                           double *cache);
 void ECPscalar_distribute(double *out, double *gctr, const int *dims,
                           const int comp, const int di, const int dj);
 void ECPscalar_distribute0(double *out, const int *dims,
                            const int comp, const int di, const int dj);
@@ -104,30 +87,39 @@
         5, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3,
         4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4,
         5, 6, 7, 8, 9,10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11, 0, 1,
         2, 3, 4, 5, 6, 7, 8, 9,10,11,12, 0, 1, 2, 3, 4, 5, 6, 7, 8,
         9,10,11,12,13, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,
 };
 
-static int _one_shell_ecpbas(int *ecpbas, int atm_id,
+// ecpbas needs to be grouped according to atom Id. Searching for the first
+// shell that matches the atm_id
+static int _one_shell_ecpbas(int *nsh, int atm_id,
                              int *atm, int natm, int *bas, int nbas, double *env)
 {
         int *all_ecp = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
         int necpbas = (int)env[AS_NECPBAS];
-        int i, j;
+        int i;
         int n = 0;
+        int shl_id = -1;
         for (i = 0; i < necpbas; i++) {
                 if (atm_id == all_ecp[ATOM_OF+i*BAS_SLOTS]) {
-                        for (j = 0; j < BAS_SLOTS; j++) {
-                                ecpbas[n*BAS_SLOTS+j] = all_ecp[i*BAS_SLOTS+j];
-                        }
-                        n += 1;
+                        shl_id = i;
+                        break;
                 }
         }
-        return n;
+        for (; i < necpbas; i++) {
+                if (atm_id == all_ecp[ATOM_OF+i*BAS_SLOTS]) {
+                        n++;
+                } else {
+                        break;
+                }
+        }
+        *nsh = n;
+        return shl_id;
 }
 
 static void _uncontract_bas(int *fakbas, int *shls,
                             int *atm, int natm, int *bas, int nbas, double *env)
 {
         const int ish = shls[0];
         const int jsh = shls[1];
@@ -233,26 +225,22 @@
         const double *ci = env + bas[PTR_COEFF+ish*BAS_SLOTS];
         const double *cj = env + bas[PTR_COEFF+jsh*BAS_SLOTS];
         int nfakbas = npi + npj;
         int *fakbas;
         MALLOC_INSTACK(fakbas, (npi+npj) * BAS_SLOTS);
         _uncontract_bas(fakbas, shls, atm, natm, bas, nbas, env);
         double *buf1;
-        MALLOC_INSTACK(buf1, (nfi1*nfj * 2 + nfi*nfj*3));
-        double *buf2 = buf1 + nfi1*nfj;
-        double *gprim = buf2 + nfi1*nfj;
+        MALLOC_INSTACK(buf1, (nfi1*nfj + nfi*nfj*3));
+        double *gprim = buf1 + nfi1*nfj;
 
         int has_value = 0;
         int shls1[2];
         double fac;
 
         int i, j, ip, jp, ic, jc, n;
-        for (i = 0; i < dij*3; i++) {
-                gctr[i] = 0;
-        }
         double *gctrx = gctr;
         double *gctry = gctrx + dij;
         double *gctrz = gctry + dij;
         double *gpx = gprim;
         double *gpy = gpx + nfi*nfj;
         double *gpz = gpy + nfi*nfj;
 
@@ -260,32 +248,28 @@
         for (ip = 0; ip < npi; ip++) {
                 shls1[0] = ip;
                 shls1[1] = npi + jp;
 /* divide (expi[ip] * expj[jp]) because the exponents were used as normalization
  * coefficients for primitive GTOs in function _uncontract_bas */
                 fac = 1. / (expi[ip] * expj[jp]);
                 fakbas[ip*BAS_SLOTS+ANG_OF] = li + 1;
+                NPdset0(buf1, nfi1*nfj);
                 has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                for (i = 0; i < nfi1 * nfj; i++) {
-                        buf1[i] += buf2[i];
-                }
                 _l_down(gprim, buf1, fac, expi[ip], li, nfj);
 
                 if (li > 0) {
                         fakbas[ip*BAS_SLOTS+ANG_OF] = li - 1;
+                        NPdset0(buf1, nfi0*nfj);
                         has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                    fakbas, nfakbas, env, opt, cache) | has_value);
-                        has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                        has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                    fakbas, nfakbas, env, opt, cache) | has_value);
-                        for (i = 0; i < nfi0 * nfj; i++) {
-                                buf1[i] += buf2[i];
-                        }
                         _l_up(gprim, buf1, fac, li, nfj);
                 }
 
                 for (jc = 0; jc < ncj; jc++) {
                 for (ic = 0; ic < nci; ic++) {
                         fac = ci[ic*npi+ip] * cj[jc*npj+jp];
                         n = jc*nfj*di + ic*nfi;
@@ -297,15 +281,15 @@
                         } }
                 } }
         } }
 
         return has_value;
 }
 
-static int _cart_factory(int (*intor_cart)(), double *out, int comp,
+static int _cart_factory(Function_cart intor_cart, double *out, int comp,
                          int *dims, int *shls, int *ecpbas, int necpbas,
                          int *atm, int natm, int *bas, int nbas, double *env,
                          ECPOpt *opt, double *cache)
 {
         const int ish = shls[0];
         const int jsh = shls[1];
         const int li = bas[ANG_OF+ish*BAS_SLOTS];
@@ -323,19 +307,21 @@
         if (cache == NULL) {
                 int cache_size = ECPscalar_cache_size(comp*2, shls,
                                                       atm, natm, bas, nbas, env);
                 stack = malloc(sizeof(double) * cache_size);
                 cache = stack;
         }
 
-        double *buf = cache;
-        cache += dij * comp;
+        int ngcart = dij * comp;
+        double *buf;
+        MALLOC_INSTACK(buf, ngcart);
+        NPdset0(buf, ngcart);
         int has_value;
-        has_value = (*intor_cart)(buf, shls, ecpbas, necpbas,
-                                  atm, natm, bas, nbas, env, opt, cache);
+        has_value = intor_cart(buf, shls, ecpbas, necpbas,
+                               atm, natm, bas, nbas, env, opt, cache);
         if (has_value) {
                 ECPscalar_distribute(out, buf, dims, comp, di, dj);
         } else {
                 ECPscalar_distribute0(out, dims, comp, di, dj);
         }
 
         if (stack != NULL) {
@@ -343,41 +329,40 @@
         }
         return has_value;
 }
 
 int ECPscalar_iprinv_cart(double *out, int *dims, int *shls, int *atm, int natm,
                           int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
-        int atm_id = (int)env[AS_RINV_ORIG_ATOM];
         int necpbas = (int)env[AS_NECPBAS];
-        // Switch off opt for iprinv.
-        // iprinv requires potential on a specific atom.
-        // opt->u_ecp used by ECPrad_part was initialized as the sum of
-        // potentials on all atoms rather than a specific atom.
-        opt = NULL;
         if (out == NULL) {
                 int cache_size = _cart_factory(_deriv1_cart, out, 3,
                                                dims, shls, NULL, necpbas,
                                                atm, natm, bas, nbas, env, opt, cache);
                 cache_size += necpbas * BAS_SLOTS;
                 return cache_size;
         } else {
-                int *ecpbas;
-                if (cache == NULL) {
-                        ecpbas = malloc(sizeof(int) * necpbas * BAS_SLOTS);
-                } else {
-                        MALLOC_INSTACK(ecpbas, necpbas * BAS_SLOTS);
+                int atm_id = (int)env[AS_RINV_ORIG_ATOM];
+                int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
+                int shl_id = _one_shell_ecpbas(&necpbas, atm_id, atm, natm, bas, nbas, env);
+                if (shl_id < 0) {
+                        return 0;
+                }
+                ecpbas += shl_id * BAS_SLOTS;
+                ECPOpt opt1;
+                if (opt != NULL) {
+                        // iprinv requires potential on a specific atom.
+                        // opt->u_ecp used by ECPrad_part was initialized for all atoms.
+                        // shifts the u_ecp pointer to the u_ecp of atm_id
+                        opt1.u_ecp = opt->u_ecp + shl_id * (1 << LEVEL_MAX);
+                        opt = &opt1;
                 }
-                necpbas = _one_shell_ecpbas(ecpbas, atm_id, atm, natm, bas, nbas, env);
                 int has_value = _cart_factory(_deriv1_cart, out, 3,
                                               dims, shls, ecpbas, necpbas,
                                               atm, natm, bas, nbas, env, opt, cache);
-                if (cache == NULL) {
-                        free(ecpbas);
-                }
                 return has_value;
         }
 }
 
 int ECPscalar_ipnuc_cart(double *out, int *dims, int *shls, int *atm, int natm,
                          int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
@@ -385,15 +370,15 @@
         int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
         int has_value = _cart_factory(_deriv1_cart, out, 3,
                                       dims, shls, ecpbas, necpbas,
                                       atm, natm, bas, nbas, env, opt, cache);
         return has_value;
 }
 
-static int _sph_factory(int (*intor_cart)(), double *out, int comp,
+static int _sph_factory(Function_cart intor_cart, double *out, int comp,
                         int *dims, int *shls, int *ecpbas, int necpbas,
                         int *atm, int natm, int *bas, int nbas, double *env,
                         ECPOpt *opt, double *cache)
 {
         const int ish = shls[0];
         const int jsh = shls[1];
         const int li = bas[ANG_OF+ish*BAS_SLOTS];
@@ -431,41 +416,40 @@
         }
         return has_value;
 }
 
 int ECPscalar_iprinv_sph(double *out, int *dims, int *shls, int *atm, int natm,
                           int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
-        int atm_id = (int)env[AS_RINV_ORIG_ATOM];
         int necpbas = (int)env[AS_NECPBAS];
-        // Switch off opt for iprinv.
-        // iprinv requires potential on a specific atom.
-        // opt->u_ecp used by ECPrad_part was initialized as the sum of
-        // potentials on all atoms rather than a specific atom.
-        opt = NULL;
         if (out == NULL) {
                 int cache_size = _sph_factory(_deriv1_cart, out, 3,
                                               dims, shls, NULL, necpbas,
                                               atm, natm, bas, nbas, env, opt, cache);
                 cache_size += necpbas * BAS_SLOTS;
                 return cache_size;
         } else {
-                int *ecpbas;
-                if (cache == NULL) {
-                        ecpbas = malloc(sizeof(int) * necpbas * BAS_SLOTS);
-                } else {
-                        MALLOC_INSTACK(ecpbas, necpbas * BAS_SLOTS);
+                int atm_id = (int)env[AS_RINV_ORIG_ATOM];
+                int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
+                int shl_id = _one_shell_ecpbas(&necpbas, atm_id, atm, natm, bas, nbas, env);
+                if (shl_id < 0) {
+                        return 0;
+                }
+                ecpbas += shl_id * BAS_SLOTS;
+                ECPOpt opt1;
+                if (opt != NULL) {
+                        // iprinv requires potential on a specific atom.
+                        // opt->u_ecp used by ECPrad_part was initialized for all atoms.
+                        // shifts the u_ecp pointer to the u_ecp of atm_id
+                        opt1.u_ecp = opt->u_ecp + shl_id * (1 << LEVEL_MAX);
+                        opt = &opt1;
                 }
-                necpbas = _one_shell_ecpbas(ecpbas, atm_id, atm, natm, bas, nbas, env);
                 int has_value = _sph_factory(_deriv1_cart, out, 3,
                                              dims, shls, ecpbas, necpbas,
                                              atm, natm, bas, nbas, env, opt, cache);
-                if (cache == NULL) {
-                        free(ecpbas);
-                }
                 return has_value;
         }
 }
 
 int ECPscalar_ipnuc_sph(double *out, int *dims, int *shls, int *atm, int natm,
                          int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
@@ -506,17 +490,16 @@
         const double *ci = env + bas[PTR_COEFF+ish*BAS_SLOTS];
         const double *cj = env + bas[PTR_COEFF+jsh*BAS_SLOTS];
         int nfakbas = npi + npj;
         int *fakbas;
         MALLOC_INSTACK(fakbas, (npi+npj) * BAS_SLOTS);
         _uncontract_bas(fakbas, shls, atm, natm, bas, nbas, env);
         double *buf1;
-        MALLOC_INSTACK(buf1, (nfi2*nfj*2 + nfi1*nfj*3 + nfi*nfj*9));
-        double *buf2 = buf1 + nfi2*nfj;
-        double *buf  = buf2 + nfi2*nfj;
+        MALLOC_INSTACK(buf1, (nfi2*nfj + nfi1*nfj*3 + nfi*nfj*9));
+        double *buf = buf1 + nfi2*nfj;
         double *gprim = buf + nfi1*nfj * 3;
 
         int has_value = 0;
         int shls1[2];
         double fac;
 
         int i, j, k, ip, jp, ic, jc, n;
@@ -526,46 +509,40 @@
 
         for (jp = 0; jp < npj; jp++) {
         for (ip = 0; ip < npi; ip++) {
                 shls1[0] = ip;
                 shls1[1] = npi + jp;
                 fac = 1. / (expi[ip] * expj[jp]);
                 fakbas[ip*BAS_SLOTS+ANG_OF] = li + 2;
+                NPdset0(buf1, nfi2*nfj);
                 has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                for (i = 0; i < nfi2 * nfj; i++) {
-                        buf1[i] += buf2[i];
-                }
                 _l_down(buf, buf1, fac, expi[ip], li+1, nfj);
 
                 fakbas[ip*BAS_SLOTS+ANG_OF] = li;
+                NPdset0(buf1, nfi*nfj);
                 has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                for (i = 0; i < nfi * nfj; i++) {
-                        buf1[i] += buf2[i];
-                }
                 _l_up(buf, buf1, fac, li+1, nfj);
                 _l_down(gprim, buf, 1., expi[ip], li, nfj*3);
 
                 if (li > 0) {
                         _l_down(buf, buf1, fac, expi[ip], li-1, nfj);
 
                         if (li > 1) {
                                 fakbas[ip*BAS_SLOTS+ANG_OF] = li - 2;
+                                NPdset0(buf1, nfi_1*nfj);
                                 has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                                has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                                has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                                for (i = 0; i < nfi_1 * nfj; i++) {
-                                        buf1[i] += buf2[i];
-                                }
                                 _l_up(buf, buf1, fac, li-1, nfj);
                         }
                         _l_up(gprim, buf, 1., li, nfj*3);
                 }
 
                 for (jc = 0; jc < ncj; jc++) {
                 for (ic = 0; ic < nci; ic++) {
@@ -581,40 +558,40 @@
 
         return has_value;
 }
 
 int ECPscalar_ipiprinv_cart(double *out, int *dims, int *shls, int *atm, int natm,
                           int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
-        int atm_id = (int)env[AS_RINV_ORIG_ATOM];
         int necpbas = (int)env[AS_NECPBAS];
-        // Switch off opt for rinv operator.
-        // rinv requires potential on a specific atom while opt->u_ecp was
-        // initialized as the sum of potentials on all atoms
-        opt = NULL;
         if (out == NULL) {
                 int cache_size = _cart_factory(_ipipv_cart, out, 9,
                                                dims, shls, NULL, necpbas,
                                                atm, natm, bas, nbas, env, opt, cache);
                 cache_size += necpbas * BAS_SLOTS;
                 return cache_size;
         } else {
-                int *ecpbas;
-                if (cache == NULL) {
-                        ecpbas = malloc(sizeof(int) * necpbas * BAS_SLOTS);
-                } else {
-                        MALLOC_INSTACK(ecpbas, necpbas * BAS_SLOTS);
+                int atm_id = (int)env[AS_RINV_ORIG_ATOM];
+                int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
+                int shl_id = _one_shell_ecpbas(&necpbas, atm_id, atm, natm, bas, nbas, env);
+                if (shl_id < 0) {
+                        return 0;
+                }
+                ecpbas += shl_id * BAS_SLOTS;
+                ECPOpt opt1;
+                if (opt != NULL) {
+                        // iprinv requires potential on a specific atom.
+                        // opt->u_ecp used by ECPrad_part was initialized for all atoms.
+                        // shifts the u_ecp pointer to the u_ecp of atm_id
+                        opt1.u_ecp = opt->u_ecp + shl_id * (1 << LEVEL_MAX);
+                        opt = &opt1;
                 }
-                necpbas = _one_shell_ecpbas(ecpbas, atm_id, atm, natm, bas, nbas, env);
                 int has_value = _cart_factory(_ipipv_cart, out, 9,
                                               dims, shls, ecpbas, necpbas,
                                               atm, natm, bas, nbas, env, opt, cache);
-                if (cache == NULL) {
-                        free(ecpbas);
-                }
                 return has_value;
         }
 }
 
 int ECPscalar_ipipnuc_cart(double *out, int *dims, int *shls, int *atm, int natm,
                          int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
@@ -625,40 +602,40 @@
                                       atm, natm, bas, nbas, env, opt, cache);
         return has_value;
 }
 
 int ECPscalar_ipiprinv_sph(double *out, int *dims, int *shls, int *atm, int natm,
                           int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
-        int atm_id = (int)env[AS_RINV_ORIG_ATOM];
         int necpbas = (int)env[AS_NECPBAS];
-        // Switch off opt for rinv operator.
-        // rinv requires potential on a specific atom while opt->u_ecp was
-        // initialized as the sum of potentials on all atoms
-        opt = NULL;
         if (out == NULL) {
                 int cache_size = _sph_factory(_ipipv_cart, out, 9,
                                               dims, shls, NULL, necpbas,
                                               atm, natm, bas, nbas, env, opt, cache);
                 cache_size += necpbas * BAS_SLOTS;
                 return cache_size;
         } else {
-                int *ecpbas;
-                if (cache == NULL) {
-                        ecpbas = malloc(sizeof(int) * necpbas * BAS_SLOTS);
-                } else {
-                        MALLOC_INSTACK(ecpbas, necpbas * BAS_SLOTS);
+                int atm_id = (int)env[AS_RINV_ORIG_ATOM];
+                int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
+                int shl_id = _one_shell_ecpbas(&necpbas, atm_id, atm, natm, bas, nbas, env);
+                if (shl_id < 0) {
+                        return 0;
+                }
+                ecpbas += shl_id * BAS_SLOTS;
+                ECPOpt opt1;
+                if (opt != NULL) {
+                        // iprinv requires potential on a specific atom.
+                        // opt->u_ecp used by ECPrad_part was initialized for all atoms.
+                        // shifts the u_ecp pointer to the u_ecp of atm_id
+                        opt1.u_ecp = opt->u_ecp + shl_id * (1 << LEVEL_MAX);
+                        opt = &opt1;
                 }
-                necpbas = _one_shell_ecpbas(ecpbas, atm_id, atm, natm, bas, nbas, env);
                 int has_value = _sph_factory(_ipipv_cart, out, 9,
                                              dims, shls, ecpbas, necpbas,
                                              atm, natm, bas, nbas, env, opt, cache);
-                if (cache == NULL) {
-                        free(ecpbas);
-                }
                 return has_value;
         }
 }
 
 int ECPscalar_ipipnuc_sph(double *out, int *dims, int *shls, int *atm, int natm,
                          int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
@@ -700,17 +677,16 @@
         const double *ci = env + bas[PTR_COEFF+ish*BAS_SLOTS];
         const double *cj = env + bas[PTR_COEFF+jsh*BAS_SLOTS];
         int nfakbas = npi + npj;
         int *fakbas;
         MALLOC_INSTACK(fakbas, (npi+npj) * BAS_SLOTS);
         _uncontract_bas(fakbas, shls, atm, natm, bas, nbas, env);
         double *buf1;
-        MALLOC_INSTACK(buf1, (nfi1*nfj1*2 + nfi*nfj1*3 + nfi*nfj*9));
-        double *buf2 = buf1 + nfi1*nfj1;
-        double *buf  = buf2 + nfi1*nfj1;
+        MALLOC_INSTACK(buf1, (nfi1*nfj1 + nfi*nfj1*3 + nfi*nfj*9));
+        double *buf = buf1 + nfi1*nfj1;
         double *gprim = buf + nfi*nfj1 * 3;
         double *pg, *pbuf;
 
         int has_value = 0;
         int shls1[2];
         double fac, xfac, yfac, zfac;
 
@@ -722,32 +698,28 @@
         for (jp = 0; jp < npj; jp++) {
         for (ip = 0; ip < npi; ip++) {
                 shls1[0] = ip;
                 shls1[1] = npi + jp;
                 fac = 1. / (expi[ip] * expj[jp]);
                 fakbas[(npi+jp)*BAS_SLOTS+ANG_OF] = lj + 1;
                 fakbas[ip*BAS_SLOTS+ANG_OF] = li + 1;
+                NPdset0(buf1, nfi1*nfj1);
                 has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                for (i = 0; i < nfi1 * nfj1; i++) {
-                        buf1[i] += buf2[i];
-                }
                 _l_down(buf, buf1, fac, expi[ip], li, nfj1);
 
                 if (li > 0) {
                         fakbas[ip*BAS_SLOTS+ANG_OF] = li - 1;
+                        NPdset0(buf1, nfi0*nfj1);
                         has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                    fakbas, nfakbas, env, opt, cache) | has_value);
-                        has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                        has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                    fakbas, nfakbas, env, opt, cache) | has_value);
-                        for (i = 0; i < nfi0 * nfj1; i++) {
-                                buf1[i] += buf2[i];
-                        }
                         _l_up(buf, buf1, fac, li, nfj1);
                 }
                 if (lj == 0) {
                         fac = -2./sqrt(3.) * expj[jp];
                 } else if (lj == 1) {
                         fac = -2.*0.488602511902919921 * expj[jp];
                 } else {
@@ -764,32 +736,28 @@
                         } }
                 }
 
                 if (lj > 0) {
                         fac = 1. / (expi[ip] * expj[jp]);
                         fakbas[(npi+jp)*BAS_SLOTS+ANG_OF] = lj - 1;
                         fakbas[ip*BAS_SLOTS+ANG_OF] = li + 1;
+                        NPdset0(buf1, nfi1*nfj0);
                         has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                    fakbas, nfakbas, env, opt, cache) | has_value);
-                        has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                        has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                    fakbas, nfakbas, env, opt, cache) | has_value);
-                        for (i = 0; i < nfi1 * nfj0; i++) {
-                                buf1[i] += buf2[i];
-                        }
                         _l_down(buf, buf1, fac, expi[ip], li, nfj0);
 
                         if (li > 0) {
                                 fakbas[ip*BAS_SLOTS+ANG_OF] = li - 1;
+                                NPdset0(buf1, nfi0*nfj0);
                                 has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                                has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+                                has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                                            fakbas, nfakbas, env, opt, cache) | has_value);
-                                for (i = 0; i < nfi0 * nfj0; i++) {
-                                        buf1[i] += buf2[i];
-                                }
                                 _l_up(buf, buf1, fac, li, nfj0);
                         }
                         if (lj == 1) {
                                 fac = sqrt(3.);
                         } else if (lj == 2) {
                                 fac = 1./0.488602511902919921;
                         } else {
@@ -825,40 +793,40 @@
 
         return has_value;
 }
 
 int ECPscalar_iprinvip_cart(double *out, int *dims, int *shls, int *atm, int natm,
                             int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
-        int atm_id = (int)env[AS_RINV_ORIG_ATOM];
         int necpbas = (int)env[AS_NECPBAS];
-        // Switch off opt for rinv operator.
-        // rinv requires potential on a specific atom while opt->u_ecp was
-        // initialized as the sum of potentials on all atoms
-        opt = NULL;
         if (out == NULL) {
                 int cache_size = _cart_factory(_ipvip_cart, out, 9,
                                                dims, shls, NULL, necpbas,
                                                atm, natm, bas, nbas, env, opt, cache);
                 cache_size += necpbas * BAS_SLOTS;
                 return cache_size;
         } else {
-                int *ecpbas;
-                if (cache == NULL) {
-                        ecpbas = malloc(sizeof(int) * necpbas * BAS_SLOTS);
-                } else {
-                        MALLOC_INSTACK(ecpbas, necpbas * BAS_SLOTS);
+                int atm_id = (int)env[AS_RINV_ORIG_ATOM];
+                int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
+                int shl_id = _one_shell_ecpbas(&necpbas, atm_id, atm, natm, bas, nbas, env);
+                if (shl_id < 0) {
+                        return 0;
+                }
+                ecpbas += shl_id * BAS_SLOTS;
+                ECPOpt opt1;
+                if (opt != NULL) {
+                        // iprinv requires potential on a specific atom.
+                        // opt->u_ecp used by ECPrad_part was initialized for all atoms.
+                        // shifts the u_ecp pointer to the u_ecp of atm_id
+                        opt1.u_ecp = opt->u_ecp + shl_id * (1 << LEVEL_MAX);
+                        opt = &opt1;
                 }
-                necpbas = _one_shell_ecpbas(ecpbas, atm_id, atm, natm, bas, nbas, env);
                 int has_value = _cart_factory(_ipvip_cart, out, 9,
                                               dims, shls, ecpbas, necpbas,
                                               atm, natm, bas, nbas, env, opt, cache);
-                if (cache == NULL) {
-                        free(ecpbas);
-                }
                 return has_value;
         }
 }
 
 int ECPscalar_ipnucip_cart(double *out, int *dims, int *shls, int *atm, int natm,
                            int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
@@ -869,40 +837,40 @@
                                       atm, natm, bas, nbas, env, opt, cache);
         return has_value;
 }
 
 int ECPscalar_iprinvip_sph(double *out, int *dims, int *shls, int *atm, int natm,
                            int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
-        int atm_id = (int)env[AS_RINV_ORIG_ATOM];
         int necpbas = (int)env[AS_NECPBAS];
-        // Switch off opt for rinv operator.
-        // rinv requires potential on a specific atom while opt->u_ecp was
-        // initialized as the sum of potentials on all atoms
-        opt = NULL;
         if (out == NULL) {
                 int cache_size = _sph_factory(_ipvip_cart, out, 9,
                                               dims, shls, NULL, necpbas,
                                               atm, natm, bas, nbas, env, opt, cache);
                 cache_size += necpbas * BAS_SLOTS;
                 return cache_size;
         } else {
-                int *ecpbas;
-                if (cache == NULL) {
-                        ecpbas = malloc(sizeof(int) * necpbas * BAS_SLOTS);
-                } else {
-                        MALLOC_INSTACK(ecpbas, necpbas * BAS_SLOTS);
+                int atm_id = (int)env[AS_RINV_ORIG_ATOM];
+                int *ecpbas = bas + ((int)env[AS_ECPBAS_OFFSET])*BAS_SLOTS;
+                int shl_id = _one_shell_ecpbas(&necpbas, atm_id, atm, natm, bas, nbas, env);
+                if (shl_id < 0) {
+                        return 0;
+                }
+                ecpbas += shl_id * BAS_SLOTS;
+                ECPOpt opt1;
+                if (opt != NULL) {
+                        // iprinv requires potential on a specific atom.
+                        // opt->u_ecp used by ECPrad_part was initialized for all atoms.
+                        // shifts the u_ecp pointer to the u_ecp of atm_id
+                        opt1.u_ecp = opt->u_ecp + shl_id * (1 << LEVEL_MAX);
+                        opt = &opt1;
                 }
-                necpbas = _one_shell_ecpbas(ecpbas, atm_id, atm, natm, bas, nbas, env);
                 int has_value = _sph_factory(_ipvip_cart, out, 9,
                                              dims, shls, ecpbas, necpbas,
                                              atm, natm, bas, nbas, env, opt, cache);
-                if (cache == NULL) {
-                        free(ecpbas);
-                }
                 return has_value;
         }
 }
 
 int ECPscalar_ipnucip_sph(double *out, int *dims, int *shls, int *atm, int natm,
                           int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
@@ -929,19 +897,20 @@
         const int lj = bas[ANG_OF+jsh*BAS_SLOTS];
         const int nfi = (li+1) * (li+2) / 2;
         const int nfj = (lj+1) * (lj+2) / 2;
         const int nfi1 = (li+2) * (li+3) / 2;
         const int di = nfi * nci;
         const int dj = nfj * ncj;
         const int dij = di * dj;
+        int ngcart = nfi1*nci*nfj*ncj;
         const double *ri = env + atm[PTR_COORD+bas[ATOM_OF+ish*BAS_SLOTS]*ATM_SLOTS];
         const double *rj = env + atm[PTR_COORD+bas[ATOM_OF+jsh*BAS_SLOTS]*ATM_SLOTS];
         double *buf1;
-        MALLOC_INSTACK(buf1, nfi1*nci*nfj*ncj * 2);
-        double *buf2 = buf1 + nfi1*nci*nfj*ncj;
+        MALLOC_INSTACK(buf1, ngcart * 2);
+        double *buf2 = buf1 + ngcart;
 
         int i, j;
         double *gctrx = gctr;
         double *gctry = gctrx + dij;
         double *gctrz = gctry + dij;
         double rirj[3];
         rirj[0] = ri[0] - rj[0];
@@ -954,27 +923,26 @@
                 fakbas[BAS_SLOTS+i] = bas[jsh*BAS_SLOTS+i];
         }
         int has_value = 0;
         int shls1[2] = {0, 1};
         double fac, vx, vy, vz;
 
         fakbas[ANG_OF] = li + 1;
+        NPdset0(buf1, ngcart);
         has_value = (ECPtype1_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                    fakbas, 2, env, opt, cache) | has_value);
-        has_value = (ECPtype2_cart(buf2, shls1, ecpbas, necpbas, atm, natm,
+        has_value = (ECPtype2_cart(buf1, shls1, ecpbas, necpbas, atm, natm,
                                    fakbas, 2, env, opt, cache) | has_value);
-        for (i = 0; i < nfi1*nci*nfj*ncj; i++) {
-                buf1[i] += buf2[i];
-        }
+        NPdset0(buf2, dij);
         has_value = (ECPtype1_cart(buf2, shls, ecpbas, necpbas, atm, natm,
                                    bas, nbas, env, opt, cache) | has_value);
-        has_value = (ECPtype2_cart(gctr, shls, ecpbas, necpbas, atm, natm,
+        has_value = (ECPtype2_cart(buf2, shls, ecpbas, necpbas, atm, natm,
                                    bas, nbas, env, opt, cache) | has_value);
-        for (i = 0; i < di*dj; i++) {
-                buf2[i] += gctr[i];
+        if (!has_value) {
+                return has_value;
         }
 
         if (li == 0) {
                 fac = 1./sqrt(3.);
         } else if (li == 1) {
                 fac = 0.488602511902919921;
         } else {
@@ -986,15 +954,14 @@
                         vy = fac * buf1[j*nfi1+_y_addr[i]] + ri[1] * buf2[j*nfi+i];
                         vz = fac * buf1[j*nfi1+_z_addr[i]] + ri[2] * buf2[j*nfi+i];
                         gctrx[j*nfi+i] = -.5 * (rirj[1] * vz - rirj[2] * vy);
                         gctry[j*nfi+i] = -.5 * (rirj[2] * vx - rirj[0] * vz);
                         gctrz[j*nfi+i] = -.5 * (rirj[0] * vy - rirj[1] * vx);
                 }
         }
-
         return has_value;
 }
 
 int ECPscalar_ignuc_cart(double *out, int *dims, int *shls, int *atm, int natm,
                          int *bas, int nbas, double *env, ECPOpt *opt, double *cache)
 {
         int necpbas = (int)env[AS_NECPBAS];
```

### Comparing `pyscf-2.2.1/pyscf/lib/linalg_helper.py` & `pyscf-2.3.0/pyscf/lib/linalg_helper.py`

 * *Files 1% similar despite different names*

```diff
@@ -415,16 +415,15 @@
             space = 0
 # Orthogonalize xt space because the basis of subspace xs must be orthogonal
 # but the eigenvectors x0 might not be strictly orthogonal
             xt = None
             x0len = len(x0)
             xt = _qr(x0, dot, lindep)[0]
             if len(xt) != x0len:
-                log.warn('QR decomposition removed %d vectors.  The davidson may fail.',
-                         x0len - len(xt))
+                log.warn('QR decomposition removed %d vectors.', x0len - len(xt))
                 if callable(pick):
                     log.warn('Check to see if `pick` function %s is providing '
                              'linear dependent vectors', pick.__name__)
                 if len(xt) == 0:
                     if icyc == 0:
                         msg = 'Initial guess is empty or zero'
                     else:
@@ -801,15 +800,15 @@
             space = 0
 # Orthogonalize xt space because the basis of subspace xs must be orthogonal
 # but the eigenvectors x0 might not be strictly orthogonal
             xt = None
             x0len = len(x0)
             xt, x0 = _qr(x0, dot, lindep)[0], None
             if len(xt) != x0len:
-                log.warn('QR decomposition removed %d vectors.  The davidson may fail.'
+                log.warn('QR decomposition removed %d vectors. '
                          'Check to see if `pick` function :%s: is providing linear dependent '
                          'vectors' % (x0len - len(xt), pick.__name__))
             max_dx_last = 1e9
             if SORT_EIG_BY_SIMILARITY:
                 conv = numpy.zeros(nroots, dtype=bool)
         elif len(xt) > 1:
             xt = _qr(xt, dot, lindep)[0]
@@ -1458,15 +1457,15 @@
     '''Solve ax = b, where a is a positive definite hermitian matrix
 
     Kwargs:
         strict_sym_pos (bool) : Whether to impose the strict positive definition
             on matrix a
     '''
     try:
-        return scipy.linalg.solve(a, b, sym_pos=True)
+        return scipy.linalg.solve(a, b, assume_a='pos')
     except numpy.linalg.LinAlgError:
         if strict_sym_pos:
             raise
         else:
             fname, lineno = inspect.stack()[1][1:3]
             warnings.warn('%s:%s: matrix a is not strictly postive definite' %
                           (fname, lineno))
```

### Comparing `pyscf-2.2.1/pyscf/lib/logger.py` & `pyscf-2.3.0/pyscf/lib/logger.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/mcscf/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/fci.h` & `pyscf-2.3.0/pyscf/lib/mcscf/fci.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/fci_4pdm.c` & `pyscf-2.3.0/pyscf/lib/mcscf/fci_4pdm.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/fci_contract.c` & `pyscf-2.3.0/pyscf/lib/mcscf/fci_contract.c`

 * *Files 12% similar despite different names*

```diff
@@ -765,108 +765,257 @@
                         clink[j].sign = 0;
                 }
                 clink += nlink;
                 link_index += nlink * 4;
         }
 }
 
-static void ctr_rhf2esym_kern1(double *eri, double *ci0, double *ci1ab,
-                              double *ci1buf, double *t1buf, int ncol_ci1buf,
-                              int bcount, int stra_id, int strb_id,
+static void ctr_rhf2esym_kern(double *eri, double *ci0a, double *ci0b,
+                              double *ci1a, double *ci1b,
+                              double *t1buf, int ncol_ci1buf,
+                              int bcount, int intera_id, int interb_id,
                               int nnorb, int nb_intermediate,
                               int na, int nb, int nlinka, int nlinkb,
                               _LinkTrilT *clink_indexa, _LinkTrilT *clink_indexb)
 {
         const char TRANS_N = 'N';
         const double D0 = 0;
         const double D1 = 1;
         double *t1 = t1buf;
         double *vt1 = t1buf + nnorb*bcount;
 
         NPdset0(t1, nnorb*bcount);
-        FCIprog_a_t1(ci0, t1, bcount, stra_id, strb_id,
-                     0, nb, nlinka, clink_indexa);
+        if (na > 0) {
+                // (stra,interb) * ia(alpha) -> (intera,interb)
+                FCIprog_a_t1(ci0a, t1, bcount, intera_id, interb_id,
+                             0, nb_intermediate, nlinka, clink_indexa);
+        }
+        if (nb > 0) {
+                // (intera,strb) * ia(beta) -> (intera,interb)
+                FCIprog_b_t1(ci0b, t1, bcount, intera_id, interb_id,
+                             0, nb, nlinkb, clink_indexb);
+        }
         dgemm_(&TRANS_N, &TRANS_N, &bcount, &nnorb, &nnorb,
                &D1, t1, &bcount, eri, &nnorb, &D0, vt1, &bcount);
-        FCIspread_b_t1(ci1ab, vt1, bcount, stra_id, strb_id,
-                       0, nb_intermediate, nlinkb, clink_indexb);
-        spread_bufa_t1(ci1buf, vt1, bcount, bcount, stra_id, 0,
-                       0, ncol_ci1buf, nlinka, clink_indexa);
+
+        if (nb > 0) {
+                // (intera,interb) * ia(beta) -> (intera,strb)
+                FCIspread_b_t1(ci1b, vt1, bcount, intera_id, interb_id,
+                               0, nb, nlinkb, clink_indexb);
+        }
+        if (na > 0) {
+                // (intera,interb) * ia(alpha) -> (stra,interb)
+                spread_bufa_t1(ci1a, vt1, bcount, bcount, intera_id, 0,
+                               0, ncol_ci1buf, nlinka, clink_indexa);
+        }
 }
 
-static void loop_c2e_symm1(double *eri, double *ci0, double *ci1aa, double *ci1ab,
-                           int nnorb, int na_intermediate, int nb_intermediate,
-                           int na, int nb, int nlinka, int nlinkb,
-                           _LinkTrilT *clinka, _LinkTrilT *clinkb)
-{
-        double *ci1bufs[MAX_THREADS];
-#pragma omp parallel
+// ci0a and ci1a ~ (stra,interb)
+// ci0b and ci1b ~ (intera,strb)
+static void loop_c2e_symm(double *eri, double *ci0a, double *ci0b,
+                          double *ci1a, double *ci1b, double *t1buf, double **ci1bufs,
+                          int nnorb, int na, int nb, int na_intermediate, int nb_intermediate,
+                          int nlinka, int nlinkb, _LinkTrilT *clinka, _LinkTrilT *clinkb)
 {
         int strk, ib;
         size_t blen;
-        double *t1buf = malloc(sizeof(double) * (STRB_BLKSIZE*nnorb*2+2));
-        double *ci1buf = malloc(sizeof(double) * (na*STRB_BLKSIZE+2));
-        ci1bufs[omp_get_thread_num()] = ci1buf;
-        for (ib = 0; ib < nb; ib += STRB_BLKSIZE) {
-                blen = MIN(STRB_BLKSIZE, nb-ib);
-                NPdset0(ci1buf, ((size_t)na) * blen);
+        double *ci1buf = ci1bufs[omp_get_thread_num()];
+        if (na > 0) {
+                for (ib = 0; ib < nb_intermediate; ib += STRB_BLKSIZE) {
+                        blen = MIN(STRB_BLKSIZE, nb_intermediate-ib);
+                        NPdset0(ci1buf, ((size_t)na) * blen);
 #pragma omp for schedule(static)
-                for (strk = 0; strk < na_intermediate; strk++) {
-                        ctr_rhf2esym_kern1(eri, ci0, ci1ab, ci1buf, t1buf,
-                                           blen, blen, strk, ib,
-                                           nnorb, nb_intermediate, na, nb,
-                                           nlinka, nlinkb, clinka, clinkb);
-                }
-//                NPomp_dsum_reduce_inplace(ci1bufs, blen*na);
-//#pragma omp master
-//                FCIaxpy2d(ci1aa+ib, ci1buf, na, nb, blen);
+                        for (strk = 0; strk < na_intermediate; strk++) {
+                                ctr_rhf2esym_kern(eri, ci0a, ci0b, ci1buf, ci1b, t1buf,
+                                                  blen, blen, strk, ib,
+                                                  nnorb, nb_intermediate, na, nb,
+                                                  nlinka, nlinkb, clinka, clinkb);
+                        }
 #pragma omp barrier
-                _reduce(ci1aa+ib, ci1bufs, na, nb, blen);
+                        _reduce(ci1a+ib, ci1bufs, na, nb_intermediate, blen);
 // An explicit barrier to ensure ci1 is updated. Without barrier, there may
-// occur race condition between FCIaxpy2d and ctr_rhf2esym_kern1
+// occur race condition between FCIaxpy2d and ctr_rhf2esym_kern
 #pragma omp barrier
+                }
+        } else {
+                for (ib = 0; ib < nb_intermediate; ib += STRB_BLKSIZE) {
+                        blen = MIN(STRB_BLKSIZE, nb_intermediate-ib);
+#pragma omp for schedule(static)
+                        for (strk = 0; strk < na_intermediate; strk++) {
+                                ctr_rhf2esym_kern(eri, ci0a, ci0b, ci1buf, ci1b, t1buf,
+                                                  blen, blen, strk, ib,
+                                                  nnorb, nb_intermediate, na, nb,
+                                                  nlinka, nlinkb, clinka, clinkb);
+                        }
+                }
+        }
+}
+
+void FCIcontract_2e_symm1(double *eris, double *ci0, double *ci1,
+                          int *eris_ir_dims, int *ci_ir_size,
+                          int *nas, int *nbs, int *linka, int *linkb,
+                          int norb, int nlinka, int nlinkb, int nirreps, int wfnsym)
+{
+        int i;
+        int na = 0;
+        int nb = 0;
+        int *linka_loc = malloc(sizeof(int) * (nirreps*4+4));
+        int *linkb_loc = linka_loc + nirreps + 1;
+        int *eris_loc = linkb_loc + nirreps + 1;
+        int *ci_loc = eris_loc + nirreps + 1;
+        linka_loc[0] = 0;
+        linkb_loc[0] = 0;
+        eris_loc[0] = 0;
+        ci_loc[0] = 0;
+        for (i = 0; i < nirreps; i++) {
+                na = MAX(nas[i], na);
+                nb = MAX(nbs[i], nb);
+                linka_loc[i+1] = linka_loc[i] + nas[i] * nlinka * 4;
+                linkb_loc[i+1] = linkb_loc[i] + nbs[i] * nlinkb * 4;
+                eris_loc[i+1] = eris_loc[i] + eris_ir_dims[i]*eris_ir_dims[i];
+                ci_loc[i+1] = ci_loc[i] + ci_ir_size[i];
         }
+
+        double *ci1bufs[MAX_THREADS];
+#pragma omp parallel
+{
+        _LinkTrilT *clinka = malloc(sizeof(_LinkTrilT) * nlinka * na);
+        _LinkTrilT *clinkb = malloc(sizeof(_LinkTrilT) * nlinkb * nb);
+        double *t1buf = malloc(sizeof(double) * (STRB_BLKSIZE*norb*(norb+1)+2));
+        double *ci1buf = malloc(sizeof(double) * (na*STRB_BLKSIZE+2));
+        ci1bufs[omp_get_thread_num()] = ci1buf;
+
+        int ai_ir, t1_ir, intera_ir, interb_ir, stra_ir, strb_ir;
+        for (intera_ir = 0; intera_ir < nirreps; intera_ir++) {
+// TODO: pick_link_by_irrep to extract link_index for all nirreps in one pass
+        for (ai_ir = 0; ai_ir < nirreps; ai_ir++) {
+                if (eris_ir_dims[ai_ir] > 0) {
+                        t1_ir = wfnsym ^ ai_ir;
+                        interb_ir = t1_ir ^ intera_ir;
+                        stra_ir = ai_ir ^ intera_ir;
+                        strb_ir = ai_ir ^ interb_ir;
+                        if (nas[intera_ir] > 0 && nbs[interb_ir] > 0 &&
+                            (nas[stra_ir] > 0 || nbs[strb_ir] > 0)) {
+// clinka for intera_ir*ai_ir -> stra_ir
+pick_link_by_irrep(clinka, linka+linka_loc[intera_ir], nas[intera_ir], nlinka, ai_ir);
+// clinkb for interb_ir*ai_ir -> strb_ir
+pick_link_by_irrep(clinkb, linkb+linkb_loc[interb_ir], nbs[interb_ir], nlinkb, ai_ir);
+loop_c2e_symm(eris+eris_loc[ai_ir],
+              ci0+ci_loc[stra_ir], ci0+ci_loc[wfnsym^strb_ir],
+              ci1+ci_loc[stra_ir], ci1+ci_loc[wfnsym^strb_ir], t1buf, ci1bufs,
+              eris_ir_dims[ai_ir], nas[stra_ir], nbs[strb_ir],
+              nas[intera_ir], nbs[interb_ir], nlinka, nlinkb, clinka, clinkb);
+                        }
+                }
+        } }
         free(ci1buf);
         free(t1buf);
+        free(clinka);
+        free(clinkb);
 }
+        free(linka_loc);
 }
 
-#define TOTIRREPS       8
-void FCIcontract_2e_symm1(double **eris, double **ci0, double **ci1,
-                          int norb, int *nas, int *nbs, int nlinka, int nlinkb,
-                          int **linka, int **linkb, int *dimirrep, int wfnsym)
+#define IRREP_OF(l, g)  (l + max_momentum + (g) * ug_offsets)
+void FCIcontract_2e_cyl_sym(double *eris, double *ci0, double *ci1,
+                            int *eris_ir_dims, int *ci_ir_size,
+                            int *nas, int *nbs, int *linka, int *linkb,
+                            int norb, int nlinka, int nlinkb,
+                            int max_momentum, int max_gerades,
+                            int wfn_momentum, int wfn_ungerade)
 {
+        int nirreps = (max_momentum * 2 + 1) * max_gerades;
+        int ug_offsets = max_momentum * 2 + 1;
         int i;
         int na = 0;
         int nb = 0;
-        for (i = 0; i < TOTIRREPS; i++) {
+        int *linka_loc = malloc(sizeof(int) * (nirreps*4+4));
+        int *linkb_loc = linka_loc + nirreps + 1;
+        int *ci_loc = linkb_loc + nirreps + 1;
+        int *eris_loc = ci_loc + nirreps + 1;
+        linka_loc[0] = 0;
+        linkb_loc[0] = 0;
+        eris_loc[0] = 0;
+        ci_loc[0] = 0;
+        for (i = 0; i < nirreps; i++) {
                 na = MAX(nas[i], na);
                 nb = MAX(nbs[i], nb);
+                linka_loc[i+1] = linka_loc[i] + nas[i] * nlinka * 4;
+                linkb_loc[i+1] = linkb_loc[i] + nbs[i] * nlinkb * 4;
+                eris_loc[i+1] = eris_loc[i] + eris_ir_dims[i]*eris_ir_dims[i];
+                ci_loc[i+1] = ci_loc[i] + ci_ir_size[i];
         }
+
+        double *ci1bufs[MAX_THREADS];
+#pragma omp parallel
+{
         _LinkTrilT *clinka = malloc(sizeof(_LinkTrilT) * nlinka * na);
         _LinkTrilT *clinkb = malloc(sizeof(_LinkTrilT) * nlinkb * nb);
-        int ai_ir, stra_ir, strb_ir, intera_ir, interb_ir, ma, mb;
-        for (stra_ir = 0; stra_ir < TOTIRREPS; stra_ir++) {
-        for (ai_ir = 0; ai_ir < TOTIRREPS; ai_ir++) {
-                strb_ir = wfnsym^stra_ir;
-                ma = nas[stra_ir];
-                mb = nbs[strb_ir];
-                if (ma > 0 && mb > 0 && dimirrep[ai_ir] > 0) {
-                        intera_ir = ai_ir^stra_ir;
-                        interb_ir = ai_ir^strb_ir;
-                        // clinka for inter_ir*ai_ir -> stra_ir
-                        pick_link_by_irrep(clinka, linka[intera_ir],
-                                           nas[intera_ir], nlinka, ai_ir);
-                        // clinka for strb_ir*ai_ir -> inter_ir
-                        pick_link_by_irrep(clinkb, linkb[strb_ir],
-                                           nbs[strb_ir], nlinkb, ai_ir);
-                        loop_c2e_symm1(eris[ai_ir], ci0[stra_ir],
-                                       ci1[stra_ir], ci1[intera_ir],
-                                       dimirrep[ai_ir], nas[intera_ir],
-                                       nbs[interb_ir], ma, mb,
-                                       nlinka, nlinkb, clinka, clinkb);
+        double *t1buf = malloc(sizeof(double) * (STRB_BLKSIZE*norb*(norb+1)+2));
+        double *ci1buf = malloc(sizeof(double) * (na*STRB_BLKSIZE+2));
+        ci1bufs[omp_get_thread_num()] = ci1buf;
+
+        int stra_l, strb_l, stra_g, strb_g;
+        int stra_ir = 0;
+        int strb_ir = 0;
+        int intera_l, interb_l, intera_g, interb_g, intera_ir, interb_ir;
+        int ai_l, ai_g, ai_ir, t1_l, t1_g;
+        int eri_m0, eri_m1;
+        int ma, mb;
+
+        for (intera_g = 0; intera_g < max_gerades; intera_g++) {
+        for (intera_l = -max_momentum; intera_l <= max_momentum; intera_l++) {
+                // abs(ai_l) < max_momentum
+                // t1_l := wfn_momentum - ai_l
+                // abs(interb_l := t1_l-intera_l) < max_momentum
+                //      => range for ai_l
+                eri_m0 = MAX(0, wfn_momentum-intera_l) - max_momentum;;
+                eri_m1 = MIN(0, wfn_momentum-intera_l) + max_momentum;;
+// TODO: pick_link_by_irrep to extract link_index for all nirreps in one pass
+                for (ai_g = 0; ai_g < max_gerades; ai_g++) {
+                for (ai_l = eri_m0; ai_l <= eri_m1; ai_l++) {
+                        ai_ir = IRREP_OF(ai_l, ai_g);
+
+                        if (eris_ir_dims[ai_ir] > 0) {
+                                t1_l = wfn_momentum - ai_l;
+                                t1_g = wfn_ungerade ^ ai_g;
+                                interb_l = t1_l - intera_l;
+                                interb_g = t1_g ^ intera_g;
+                                intera_ir = IRREP_OF(intera_l, intera_g);
+                                interb_ir = IRREP_OF(interb_l, interb_g);
+
+                                stra_l = intera_l + ai_l;
+                                stra_g = intera_g ^ ai_g;
+                                strb_l = interb_l + ai_l; // = wfn_momentum-intera_l
+                                strb_g = interb_g ^ ai_g; // = wfn_ungerade^intera_g
+                                ma = 0;
+                                if (abs(stra_l) <= max_momentum) {
+                                        stra_ir = IRREP_OF(stra_l, stra_g);
+                                        ma = nas[stra_ir];
+                                }
+                                mb = 0;
+                                if (abs(strb_l) <= max_momentum) {
+                                        strb_ir = IRREP_OF(strb_l, strb_g);
+                                        mb = nbs[strb_ir];
+                                }
+                                if (nas[intera_ir] > 0 && nas[interb_ir] > 0 &&
+                                    (ma > 0 || mb > 0)) {
+// clinka for intera*ai -> stra.
+pick_link_by_irrep(clinka, linka+linka_loc[intera_ir], nas[intera_ir], nlinka, ai_ir);
+// clinkb for interb*ai -> strb
+pick_link_by_irrep(clinkb, linkb+linkb_loc[interb_ir], nbs[interb_ir], nlinkb, ai_ir);
+loop_c2e_symm(eris+eris_loc[ai_ir],
+              ci0+ci_loc[stra_ir], ci0+ci_loc[intera_ir],
+              ci1+ci_loc[stra_ir], ci1+ci_loc[intera_ir], t1buf, ci1bufs,
+              eris_ir_dims[ai_ir], ma, mb, nas[intera_ir], nbs[interb_ir],
+              nlinka, nlinkb, clinka, clinkb);
+                                }
+                        } }
                 }
         } }
+        free(ci1buf);
+        free(t1buf);
         free(clinka);
         free(clinkb);
 }
-
+        free(linka_loc);
+}
```

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/fci_contract_nosym.c` & `pyscf-2.3.0/pyscf/lib/mcscf/fci_contract_nosym.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/fci_rdm.c` & `pyscf-2.3.0/pyscf/lib/mcscf/fci_rdm.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/fci_string.c` & `pyscf-2.3.0/pyscf/lib/mcscf/fci_string.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/nevpt_contract.c` & `pyscf-2.3.0/pyscf/lib/mcscf/nevpt_contract.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/mcscf/select_ci.c` & `pyscf-2.3.0/pyscf/lib/mcscf/select_ci.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/misc.py` & `pyscf-2.3.0/pyscf/lib/misc.py`

 * *Files 1% similar despite different names*

```diff
@@ -749,14 +749,20 @@
     terms of the corresponding attributes of self, i.e.
 
     .. code-block:: python
         def fn1(self, a=None, b=None):
             if a is None: a = self.a
             if b is None: b = self.b
             return fn(a, b)
+
+    This function can be used to replace "staticmethod" when inserting a module
+    method into a class. In a child class, it allows one to call the method of a
+    base class with either "self.__class__.method_name(self, args)" or
+    "self.super().method_name(args)". For method created with "staticmethod",
+    calling "self.super().method_name(args)" is the only option.
     '''
     _locals = {}
     name = fn.__name__
     sig = inspect.signature(fn)
     body = []
     var_args = []
     for k, v in sig.parameters.items():
@@ -812,14 +818,15 @@
 
 def invalid_method(name):
     '''
     The statement "fn1 = invalid_method(name)" can de-register a method
     '''
     def fn(obj, *args, **kwargs):
         raise NotImplementedError(f'Method {name} invalid or not implemented')
+    fn.__name__ = name
     return fn
 
 def overwrite_mro(obj, mro):
     '''A hacky function to overwrite the __mro__ attribute'''
     class HackMRO(type):
         pass
 # Overwrite type.mro function so that Temp class can use the given mro
```

### Comparing `pyscf-2.2.1/pyscf/lib/np_helper/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/np_helper/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/np_helper/np_helper.c` & `pyscf-2.3.0/pyscf/lib/np_helper/np_helper.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/np_helper/np_helper.h` & `pyscf-2.3.0/pyscf/lib/np_helper/np_helper.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/np_helper/npdot.c` & `pyscf-2.3.0/pyscf/lib/np_helper/npdot.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/np_helper/omp_reduce.c` & `pyscf-2.3.0/pyscf/lib/np_helper/omp_reduce.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/np_helper/pack_tril.c` & `pyscf-2.3.0/pyscf/lib/np_helper/pack_tril.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/np_helper/transpose.c` & `pyscf-2.3.0/pyscf/lib/np_helper/transpose.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/numpy_helper.py` & `pyscf-2.3.0/pyscf/lib/numpy_helper.py`

 * *Files 2% similar despite different names*

```diff
@@ -1042,45 +1042,59 @@
 
         for i,i0 in enumerate(loc_x[:-1]):
             i1 = loc_x[i+1]
             for j,j0 in enumerate(loc_y[:-1]):
                 j1 = loc_y[j+1]
                 out[i,j] = op(a[i0:i1, j0:j1])
     '''
+    assert a.ndim == 2
     if loc_y is None:
         loc_y = loc_x
     loc_x = numpy.asarray(loc_x, numpy.int32)
     loc_y = numpy.asarray(loc_y, numpy.int32)
     nloc_x = loc_x.size - 1
     nloc_y = loc_y.size - 1
     opname = opname.replace('numpy.', '').replace('np.', '')
     if opname.startswith('NP_'):
         opname = opname[3:]
 
-    if (a.dtype != numpy.double or
-        opname not in ('sum', 'max', 'min', 'abssum', 'absmax', 'absmin', 'norm')):
-        tmp = numpy.empty((nloc_x, a.shape[1]), dtype=a.dtype)
-        out = numpy.empty((nloc_x, nloc_y), dtype=a.dtype)
-        op = getattr(numpy, opname)
-        for i, (i0, i1) in enumerate(zip(loc_x[:-1], loc_x[1:])):
-            tmp[i] = op(a[i0:i1], axis=0)
-        for j, (j0, j1) in enumerate(zip(loc_y[:-1], loc_y[1:])):
-            out[:,j] = op(tmp[:,j0:j1], axis=1)
+    if (a.dtype == numpy.double and
+        opname in ('sum', 'max', 'min', 'abssum', 'absmax', 'absmin', 'norm')):
+        op = getattr(_np_helper, 'NP_' + opname)
+        if a.flags.f_contiguous:
+            a = transpose(a.T)
+        a = numpy.asarray(a, order='C')
+        out = numpy.zeros((nloc_x, nloc_y))
+        _np_helper.NPcondense(op, out.ctypes.data_as(ctypes.c_void_p),
+                              a.ctypes.data_as(ctypes.c_void_p),
+                              loc_x.ctypes.data_as(ctypes.c_void_p),
+                              loc_y.ctypes.data_as(ctypes.c_void_p),
+                              ctypes.c_int(nloc_x), ctypes.c_int(nloc_y))
         return out
 
-    op = getattr(_np_helper, 'NP_' + opname)
-    if a.flags.f_contiguous:
-        a = transpose(a.T)
-    a = numpy.asarray(a, order='C')
-    out = numpy.zeros((nloc_x, nloc_y))
-    _np_helper.NPcondense(op, out.ctypes.data_as(ctypes.c_void_p),
-                          a.ctypes.data_as(ctypes.c_void_p),
-                          loc_x.ctypes.data_as(ctypes.c_void_p),
-                          loc_y.ctypes.data_as(ctypes.c_void_p),
-                          ctypes.c_int(nloc_x), ctypes.c_int(nloc_y))
+    if a.dtype in (bool, numpy.int8) and opname in ('any', 'all'):
+        op = getattr(_np_helper, 'NP_' + opname)
+        if a.flags.f_contiguous:
+            a = transpose(a.T)
+        a = numpy.asarray(a, order='C')
+        out = numpy.zeros((nloc_x, nloc_y), dtype=a.dtype)
+        _np_helper.NPbcondense(op, out.ctypes.data_as(ctypes.c_void_p),
+                               a.ctypes.data_as(ctypes.c_void_p),
+                               loc_x.ctypes.data_as(ctypes.c_void_p),
+                               loc_y.ctypes.data_as(ctypes.c_void_p),
+                               ctypes.c_int(nloc_x), ctypes.c_int(nloc_y))
+        return out
+
+    tmp = numpy.empty((nloc_x, a.shape[1]), dtype=a.dtype)
+    out = numpy.empty((nloc_x, nloc_y), dtype=a.dtype)
+    op = getattr(numpy, opname)
+    for i, (i0, i1) in enumerate(zip(loc_x[:-1], loc_x[1:])):
+        tmp[i] = op(a[i0:i1], axis=0)
+    for j, (j0, j1) in enumerate(zip(loc_y[:-1], loc_y[1:])):
+        out[:,j] = op(tmp[:,j0:j1], axis=1)
     return out
 
 def expm(a):
     '''Equivalent to scipy.linalg.expm'''
     bs = [a.copy()]
     n = 0
     for n in range(1, 14):
```

### Comparing `pyscf-2.2.1/pyscf/lib/parameters.py` & `pyscf-2.3.0/pyscf/lib/parameters.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/pbc/CMakeLists.txt`

 * *Files 5% similar despite different names*

```diff
@@ -9,14 +9,14 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 add_library(pbc SHARED ft_ao.c fill_ints.c fill_ints_sr.c optimizer.c grid_ao.c
-  nr_direct.c symmetry.c inner_dot.c cint2e.c cint3c2e.c)
+  nr_direct.c symmetry.c inner_dot.c cint2e.c cint3c2e.c nr_ecp.c transform_mo.c)
 add_dependencies(pbc cgto cvhf np_helper)
 
 set_target_properties(pbc PROPERTIES
   LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR})
 
 target_link_libraries(pbc cgto cint cvhf np_helper ${BLAS_LIBRARIES} ${OPENMP_C_PROPERTIES})
```

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/fill_ints.c` & `pyscf-2.3.0/pyscf/lib/pbc/fill_ints.c`

 * *Files 13% similar despite different names*

```diff
@@ -30,145 +30,250 @@
 #include "pbc/pbc.h"
 
 #define INTBUFMAX10     8000
 #define OF_CMPLX        2
 
 typedef void (*FPtrSort)(double *outR, double *outI, double *bufkkR, double *bufkkI,
                          int *shls, int *ao_loc, BVKEnvs *envs_bvk);
-typedef void (*FPtrFill)(int (*intor)(double *, int *, int *, double, CINTEnvVars *, BVKEnvs *),
+typedef int (*FPtrIntor)(double *, int *, int *, int, float *, CINTEnvVars *, BVKEnvs *);
+typedef void (*FPtrFill)(FPtrIntor intor,
                          double *outR, double *outI, double *cache, int *cell0_shls,
-                         CINTEnvVars *envs_cint, BVKEnvs *envs_bvk);
+                         float *rij_cond, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk);
+void PBCapprox_bvk_rcond(float *rcond, int ish_bvk, int jsh_bvk, BVKEnvs *envs_bvk,
+                         int *atm, int natm, int *bas, int nbas, double *env,
+                         float *cache);
 
 void PBCminimal_CINTEnvVars(CINTEnvVars *envs, int *atm, int natm, int *bas, int nbas, double *env,
                             CINTOpt *cintopt)
 {
         envs->atm = atm;
         envs->bas = bas;
         envs->env = env;
         envs->natm = natm;
         envs->nbas = nbas;
         envs->opt = cintopt;
         envs->ncomp_e1 = 1;
         envs->ncomp_e2 = 1;
         envs->ncomp_tensor = 1;
-
 }
 
 /*
  * contract basis in supmol to basis of bvk-cell
- * sh_loc indicates the boundary of each bvkcell basis
  */
-static int _assemble3c(double *out, int *cell0_shls, int *bvk_cells, double cutoff,
-                       CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+static int _assemble3c(double *out, int *cell0_shls, int *bvk_cells, int cutoff,
+                       float *rij_cond, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         int *atm = envs_cint->atm;
         int *bas = envs_cint->bas;
         double *env = envs_cint->env;
         int natm = envs_cint->natm;
         int nbas = envs_cint->nbas;
         size_t Nbas = nbas;
         int ncomp = envs_bvk->ncomp;
         int nbasp = envs_bvk->nbasp;
         int nbas_bvk = nbasp * envs_bvk->ncells;
+        int *seg_loc = envs_bvk->seg_loc;
+        int *seg2sh = envs_bvk->seg2sh;
         int *cell0_ao_loc = envs_bvk->ao_loc;
-        int *sh_loc = envs_bvk->sh_loc;
         int ish_cell0 = cell0_shls[0];
         int jsh_cell0 = cell0_shls[1];
         int ksh_cell0 = cell0_shls[2];
         int cell_i = bvk_cells[0];
         int cell_j = bvk_cells[1];
         int ish_bvk = ish_cell0 + cell_i * nbasp;
         int jsh_bvk = jsh_cell0 + cell_j * nbasp;
         int ksh_bvk = ksh_cell0 - nbasp + nbas_bvk;
-        int ish0 = sh_loc[ish_bvk];
-        int jsh0 = sh_loc[jsh_bvk];
-        int ksh0 = sh_loc[ksh_bvk];
-        int ish1 = sh_loc[ish_bvk+1];
-        int jsh1 = sh_loc[jsh_bvk+1];
-        int ksh1 = sh_loc[ksh_bvk+1];
+        int iseg0 = seg_loc[ish_bvk];
+        int jseg0 = seg_loc[jsh_bvk];
+        int kseg0 = seg_loc[ksh_bvk];
+        int iseg1 = seg_loc[ish_bvk+1];
+        int jseg1 = seg_loc[jsh_bvk+1];
+        int kseg1 = seg_loc[ksh_bvk+1];
+        int nish = seg2sh[iseg1] - seg2sh[iseg0];
+        int njsh = seg2sh[jseg1] - seg2sh[jseg0];
+        int nij = nish * njsh;
+        int rij_off = seg2sh[iseg0] * njsh + seg2sh[jseg0];
+
+        if (iseg0 == iseg1 || jseg0 == jseg1) {
+                return 0;
+        }
+
         int i0 = cell0_ao_loc[ish_cell0];
         int j0 = cell0_ao_loc[jsh_cell0];
         int k0 = cell0_ao_loc[ksh_cell0];
         int i1 = cell0_ao_loc[ish_cell0+1];
         int j1 = cell0_ao_loc[jsh_cell0+1];
         int k1 = cell0_ao_loc[ksh_cell0+1];
         int di = i1 - i0;
         int dj = j1 - j0;
         int dk = k1 - k0;
         int dijkc = di * dj * dk * ncomp;
+        int empty = 1;
+        NPdset0(out, dijkc);
         CINTOpt *cintopt = envs_cint->opt;
         double *bufL = out + dijkc;
         double *cache = bufL + dijkc;
         int shls[3];
-        int n, ish, jsh, ksh;
-        int8_t *ovlp_mask = envs_bvk->ovlp_mask;
-        // aux_mask to skip smooth auxiliary basis if needed
-        int *aux_mask = envs_bvk->bas_map;
-        double *qcond = envs_bvk->q_cond;
-        double *qcond_k;
-        double kj_cutoff;
+        int ish, jsh, ksh, ptr, n;
+        int iseg, jseg, kseg;
+        int ish0, jsh0;
+        int ish1, jsh1;
+        int16_t *sindex = envs_bvk->qindex;
+        float *xij_cond = rij_cond;
+        float *yij_cond = rij_cond + nij;
+        float *zij_cond = rij_cond + nij * 2;
+        int16_t *sij_idx;
+        float xk, yk, zk, dx, dy, dz, r2;
         int (*intor)() = envs_bvk->intor;
 
-        int empty = 1;
-        NPdset0(out, dijkc);
-
-        if (ish0 == ish1 || jsh0 == jsh1 || ksh0 == ksh1) {
-                return 0;
-        }
-
-        if (qcond != NULL) {
-                for (ksh = ksh0; ksh < ksh1; ksh++) {
-                        // (ksh - nbas) because ksh the basis in auxcell was appended to
-                        // the end of supmol basis
-                        if (!aux_mask[ksh]) {
-                                continue;
-                        }
-                        qcond_k = qcond + (ksh - Nbas) * Nbas;
+        if (sindex == NULL) {
+                ish0 = seg2sh[iseg0];
+                ish1 = seg2sh[iseg1];
+                jsh0 = seg2sh[jseg0];
+                jsh1 = seg2sh[jseg1];
+                for (kseg = kseg0; kseg < kseg1; kseg++) {
+                        ksh = seg2sh[kseg];
                         shls[2] = ksh;
                         for (ish = ish0; ish < ish1; ish++) {
-                                kj_cutoff = cutoff / qcond_k[ish];
                                 shls[0] = ish;
                                 for (jsh = jsh0; jsh < jsh1; jsh++) {
-                                        if (!ovlp_mask[ish*Nbas+jsh] ||
-                                            qcond_k[jsh] < kj_cutoff) {
-                                                continue;
-                                        }
                                         shls[1] = jsh;
                                         if ((*intor)(bufL, NULL, shls, atm, natm,
                                                      bas, nbas, env, cintopt, cache)) {
                                                 for (n = 0; n < dijkc; n++) {
                                                         out[n] += bufL[n];
                                                 }
                                                 empty = 0;
                                         }
                                 }
                         }
                 }
-        } else {
-                for (ksh = ksh0; ksh < ksh1; ksh++) {
-                        // (ksh - nbas) because ksh the basis in auxcell was appended to
-                        // the end of supmol basis
-                        if (!aux_mask[ksh]) {
-                                continue;
+                return !empty;
+        }
+
+        int lk = bas(ANG_OF, seg2sh[kseg0]);
+        float omega = env[PTR_RANGE_OMEGA];
+        float ai, aj, ak, aij;
+        float omega2, eta, theta, theta_k, theta_r2, fac;
+        float ij_cutoff, sij;
+
+        // FIXME: Is it correct to assemble PP 3c integrals this way?
+        if (omega < 0.f) {
+                // Short-range integrals
+                omega2 = omega * omega;
+                // the factor for aux-basis
+                // ~ log(sqrt(2/sqrt(pi*theta)/r^2)*r^lk)
+                fac = .25f*logf(omega2);
+                ij_cutoff = cutoff + fac * LOG_ADJUST;
+
+                for (kseg = kseg0; kseg < kseg1; kseg++) {
+                        ksh = seg2sh[kseg];
+                        shls[2] = ksh;
+                        ak = env[bas(PTR_EXP,ksh) + bas(NPRIM_OF,ksh)-1];
+                        ptr = atm(PTR_COORD, bas(ATOM_OF, ksh));
+                        xk = env[ptr];
+                        yk = env[ptr+1];
+                        zk = env[ptr+2];
+                        lk = bas(ANG_OF, ksh);
+                        theta_k = omega2 * ak / (omega2 + ak);
+                        // factor for aux-basis
+                        // ~ log(sqrt(2/sqrt(pi*theta)/r^2) * (theta*r/ak)^lk
+                        //     * (pi/ak)^1.5 * norm_k)
+                        if (lk >= 0) {  // exclude ECP
+                                ij_cutoff = cutoff + (fac - lk*logf(theta_k*8.f)) * LOG_ADJUST;
+                        }
+                        for (iseg = iseg0; iseg < iseg1; iseg++) {
+                                ish0 = seg2sh[iseg];
+                                ish1 = seg2sh[iseg+1];
+                                ai = env[bas(PTR_EXP,ish0) + bas(NPRIM_OF,ish0)-1];
+                                for (jseg = jseg0; jseg < jseg1; jseg++) {
+                                        jsh0 = seg2sh[jseg];
+                                        jsh1 = seg2sh[jseg+1];
+                                        aj = env[bas(PTR_EXP,jsh0) + bas(NPRIM_OF,jsh0)-1];
+                                        aij = ai + aj;
+                                        theta = theta_k * aij / (theta_k + aij);
+for (ish = ish0; ish < ish1; ish++) {
+        shls[0] = ish;
+        sij_idx = sindex + ish * Nbas;
+        for (jsh = jsh0; jsh < jsh1; jsh++) {
+                sij = sij_idx[jsh];
+                dx = xk - xij_cond[ish * njsh + jsh - rij_off];
+                dy = yk - yij_cond[ish * njsh + jsh - rij_off];
+                dz = zk - zij_cond[ish * njsh + jsh - rij_off];
+                r2 = dx * dx + dy * dy + dz * dz;
+                theta_r2 = theta * r2 + logf(r2 + 1e-30f);
+                if (theta_r2*LOG_ADJUST + ij_cutoff < sij) {
+                        shls[1] = jsh;
+                        if ((*intor)(bufL, NULL, shls, atm, natm,
+                                     bas, nbas, env, cintopt, cache)) {
+                                for (n = 0; n < dijkc; n++) {
+                                        out[n] += bufL[n];
+                                }
+                                empty = 0;
                         }
+                }
+        }
+}
+                                }
+                        }
+                }
+        } else {
+                // TODO: for int3c1e_ovlp, eta = ak[ksh]
+                eta = envs_bvk->eta;
+                theta_k = eta;
+                if (omega > 0.f) {
+                        omega2 = omega * omega;
+                        theta_k = omega2 * eta / (omega2 + eta);
+                }
+                fac = .25f*logf(eta);
+                ij_cutoff = cutoff + fac * LOG_ADJUST;
+                for (kseg = kseg0; kseg < kseg1; kseg++) {
+                        ksh = seg2sh[kseg];
                         shls[2] = ksh;
-                        for (ish = ish0; ish < ish1; ish++) {
-                                shls[0] = ish;
-                                for (jsh = jsh0; jsh < jsh1; jsh++) {
-                                        if (!ovlp_mask[ish*Nbas+jsh]) {
-                                                continue;
-                                        }
-                                        shls[1] = jsh;
-                                        if ((*intor)(bufL, NULL, shls, atm, natm,
-                                                     bas, nbas, env, cintopt, cache)) {
-                                                for (n = 0; n < dijkc; n++) {
-                                                        out[n] += bufL[n];
-                                                }
-                                                empty = 0;
-                                        }
+                        ak = env[bas(PTR_EXP,ksh) + bas(NPRIM_OF,ksh)-1];
+                        ptr = atm(PTR_COORD, bas(ATOM_OF, ksh));
+                        xk = env[ptr];
+                        yk = env[ptr+1];
+                        zk = env[ptr+2];
+                        lk = bas(ANG_OF, ksh);
+                        if (lk > 0) {  // exclude ECP
+                                ij_cutoff = cutoff + (fac - lk*logf(theta_k*8.f)) * LOG_ADJUST;
+                        }
+                        for (iseg = iseg0; iseg < iseg1; iseg++) {
+                                ish0 = seg2sh[iseg];
+                                ish1 = seg2sh[iseg+1];
+                                ai = env[bas(PTR_EXP,ish0) + bas(NPRIM_OF,ish0)-1];
+                                for (jseg = jseg0; jseg < jseg1; jseg++) {
+                                        jsh0 = seg2sh[jseg];
+                                        jsh1 = seg2sh[jseg+1];
+                                        aj = env[bas(PTR_EXP,jsh0) + bas(NPRIM_OF,jsh0)-1];
+                                        aij = ai + aj;
+                                        theta = theta_k * aij / (theta_k + aij);
+for (ish = ish0; ish < ish1; ish++) {
+        shls[0] = ish;
+        sij_idx = sindex + ish * Nbas;
+        for (jsh = jsh0; jsh < jsh1; jsh++) {
+                sij = sij_idx[jsh];
+                dx = xk - xij_cond[ish * njsh + jsh - rij_off];
+                dy = yk - yij_cond[ish * njsh + jsh - rij_off];
+                dz = zk - zij_cond[ish * njsh + jsh - rij_off];
+                r2 = dx * dx + dy * dy + dz * dz;
+                theta_r2 = theta * r2 + logf(r2 + 1e-30f);
+                if (theta_r2*LOG_ADJUST + ij_cutoff < sij) {
+                        shls[1] = jsh;
+                        if ((*intor)(bufL, NULL, shls, atm, natm,
+                                     bas, nbas, env, cintopt, cache)) {
+                                for (n = 0; n < dijkc; n++) {
+                                        out[n] += bufL[n];
+                                }
+                                empty = 0;
+                        }
+                }
+        }
+}
                                 }
                         }
                 }
         }
         return !empty;
 }
 
@@ -323,27 +428,30 @@
                         outI += nao3;
                         bufkkR += KKdij * dk;
                         bufkkI += KKdij * dk;
                 }
         }
 }
 
-static void _fill_kk(int (*intor)(), FPtrSort fsort,
+static void _fill_kk(FPtrIntor intor, FPtrSort fsort,
                      double *outR, double *outI, double *cache, int *cell0_shls,
-                     CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+                     float *rij_cond, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         char TRANS_N = 'N';
         char TRANS_T = 'T';
         double D0 = 0;
         double D1 = 1;
         double ND1 = -1;
 
+        int *cell0_ao_loc = envs_bvk->ao_loc;
+        int *seg_loc = envs_bvk->seg_loc;
+        int *seg2sh = envs_bvk->seg2sh;
         int bvk_ncells = envs_bvk->ncells;
         int nkpts = envs_bvk->nkpts;
-        int *cell0_ao_loc = envs_bvk->ao_loc;
+        int nbasp = envs_bvk->nbasp;
         int ish_cell0 = cell0_shls[0];
         int jsh_cell0 = cell0_shls[1];
         int ksh_cell0 = cell0_shls[2];
         int di = cell0_ao_loc[ish_cell0+1] -  cell0_ao_loc[ish_cell0];
         int dj = cell0_ao_loc[jsh_cell0+1] -  cell0_ao_loc[jsh_cell0];
         int dk = cell0_ao_loc[ksh_cell0+1] -  cell0_ao_loc[ksh_cell0];
         int dij = di * dj;
@@ -353,30 +461,42 @@
         int d3ck = d3c * nkpts;
         double *bufkLR = cache;
         double *bufkLI = bufkLR + (size_t)d3cL * nkpts;
         double *bufkkR = bufkLI + (size_t)d3cL * nkpts;
         double *bufkkI = bufkkR + (size_t)d3c * nkpts * nkpts;
         double *bufL = bufkkR;
         double *pbuf = bufL;
-        int iL, jL;
+        int iL, ish_bvk, iseg0, iseg1, nish;
+        int jL, jsh_bvk, jseg0, jseg1, njsh;
         int bvk_cells[2];
+        int cutoff = envs_bvk->cutoff;
 
         int iLmax = -1;
         int jLmax = -1;
         for (iL = 0; iL < bvk_ncells; iL++) {
-        for (jL = 0; jL < bvk_ncells; jL++) {
                 bvk_cells[0] = iL;
-                bvk_cells[1] = jL;
-                if ((*intor)(pbuf, cell0_shls, bvk_cells, envs_bvk->cutoff,
-                             envs_cint, envs_bvk)) {
-                        iLmax = iL;
-                        jLmax = MAX(jL, jLmax);
+                ish_bvk = iL * nbasp + ish_cell0;
+                iseg0 = seg_loc[ish_bvk];
+                iseg1 = seg_loc[ish_bvk+1];
+                nish = seg2sh[iseg1] - seg2sh[iseg0];
+                for (jL = 0; jL < bvk_ncells; jL++) {
+                        bvk_cells[1] = jL;
+                        jsh_bvk = jL * nbasp + jsh_cell0;
+                        jseg0 = seg_loc[jsh_bvk];
+                        jseg1 = seg_loc[jsh_bvk+1];
+                        njsh = seg2sh[jseg1] - seg2sh[jseg0];
+                        if ((*intor)(pbuf, cell0_shls, bvk_cells, cutoff,
+                                     rij_cond, envs_cint, envs_bvk)) {
+                                iLmax = iL;
+                                jLmax = MAX(jL, jLmax);
+                        }
+                        pbuf += d3c;
+                        rij_cond += nish * njsh * 3;
                 }
-                pbuf += d3c;
-        } }
+        }
 
         int nLi = iLmax + 1;
         int nLj = jLmax + 1;
         double *expLkR = envs_bvk->expLkR;
         double *expLkI = envs_bvk->expLkI;
 
         if (jLmax >= 0) {  // ensure j3c buf is not empty
@@ -401,29 +521,33 @@
                        &D1, expLkI, &nkpts, bufkLR, &d3ck,
                        &D1, bufkkI, &nkpts);
 
                 (*fsort)(outR, outI, bufkkR, bufkkI, cell0_shls, cell0_ao_loc, envs_bvk);
         }
 }
 
-void PBCfill_nr3c_kks1(int (*intor)(), double *outR, double *outI, double *cache,
-                       int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+void PBCfill_nr3c_kks1(FPtrIntor intor, double *outR, double *outI, double *cache,
+                       int *cell0_shls, float *rij_cond,
+                       CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
-        _fill_kk(intor, _sort_kks1, outR, outI, cache, cell0_shls, envs_cint, envs_bvk);
+        _fill_kk(intor, _sort_kks1, outR, outI, cache, cell0_shls,
+                 rij_cond, envs_cint, envs_bvk);
 }
 
-void PBCfill_nr3c_kks2(int (*intor)(), double *outR, double *outI, double *cache,
-                       int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+void PBCfill_nr3c_kks2(FPtrIntor intor, double *outR, double *outI, double *cache,
+                       int *cell0_shls, float *rij_cond,
+                       CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         int ish_cell0 = cell0_shls[0];
         int jsh_cell0 = cell0_shls[1];
         if (ish_cell0 < jsh_cell0) {
                 return;
         }
-        _fill_kk(intor, _sort_kks2, outR, outI, cache, cell0_shls, envs_cint, envs_bvk);
+        _fill_kk(intor, _sort_kks2, outR, outI, cache, cell0_shls,
+                 rij_cond, envs_cint, envs_bvk);
 }
 
 // [kI, i, j, k, comp] in Fortran order => [kI, comp, i, j, k] in C order
 static void _sort_ks1(double *outR, double *outI, double *bufkR, double *bufkI,
                       int *shls, int *ao_loc, BVKEnvs *envs_bvk)
 {
         int *shls_slice = envs_bvk->shls_slice;
@@ -564,26 +688,29 @@
                         outI += nao3;
                         bufkR += Kdij * dk;
                         bufkI += Kdij * dk;
                 }
         }
 }
 
-static void _fill_k(int (*intor)(), FPtrSort fsort,
-                    double *outR, double *outI, double *cache,
-                    int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+static void _fill_k(FPtrIntor intor, FPtrSort fsort,
+                    double *outR, double *outI, double *cache, int *cell0_shls,
+                    float *rij_cond, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         char TRANS_N = 'N';
         char TRANS_T = 'T';
         double D0 = 0;
         double D1 = 1;
 
+        int *cell0_ao_loc = envs_bvk->ao_loc;
+        int *seg_loc = envs_bvk->seg_loc;
+        int *seg2sh = envs_bvk->seg2sh;
         int bvk_ncells = envs_bvk->ncells;
+        int nbasp = envs_bvk->nbasp;
         int nkpts = envs_bvk->nkpts;
-        int *cell0_ao_loc = envs_bvk->ao_loc;
         int ish_cell0 = cell0_shls[0];
         int jsh_cell0 = cell0_shls[1];
         int ksh_cell0 = cell0_shls[2];
         int di = cell0_ao_loc[ish_cell0+1] -  cell0_ao_loc[ish_cell0];
         int dj = cell0_ao_loc[jsh_cell0+1] -  cell0_ao_loc[jsh_cell0];
         int dk = cell0_ao_loc[ksh_cell0+1] -  cell0_ao_loc[ksh_cell0];
         int dij = di * dj;
@@ -593,34 +720,46 @@
         int d3ck = d3c * nkpts;
         double *bufkR = cache;
         double *bufkI = bufkR + d3ck;
         double *bufL = bufkI + d3ck;
         double *bufLkR = bufL + d3cL;
         double *bufLkI = bufLkR + d3ck;
         double *pbuf;
-        int iL, jL, jLmax, nLj, i, k;
+        int jLmax, nLj, i, k;
+        int iL, ish_bvk, iseg0, iseg1, nish;
+        int jL, jsh_bvk, jseg0, jseg1, njsh;
         int bvk_cells[2];
         double *expLkR = envs_bvk->expLkR;
         double *expLkI = envs_bvk->expLkI;
+        int cutoff = envs_bvk->cutoff;
 
         int empty = 1;
         NPdset0(bufkR, d3ck);
         NPdset0(bufkI, d3ck);
 
         for (iL = 0; iL < bvk_ncells; iL++) {
                 jLmax = -1;
+                bvk_cells[0] = iL;
+                ish_bvk = iL * nbasp + ish_cell0;
+                iseg0 = seg_loc[ish_bvk];
+                iseg1 = seg_loc[ish_bvk+1];
+                nish = seg2sh[iseg1] - seg2sh[iseg0];
                 pbuf = bufL;
                 for (jL = 0; jL < bvk_ncells; jL++) {
-                        bvk_cells[0] = iL;
                         bvk_cells[1] = jL;
-                        if ((*intor)(pbuf, cell0_shls, bvk_cells, envs_bvk->cutoff,
-                                     envs_cint, envs_bvk)) {
+                        jsh_bvk = jL * nbasp + jsh_cell0;
+                        jseg0 = seg_loc[jsh_bvk];
+                        jseg1 = seg_loc[jsh_bvk+1];
+                        njsh = seg2sh[jseg1] - seg2sh[jseg0];
+                        if ((*intor)(pbuf, cell0_shls, bvk_cells, cutoff,
+                                     rij_cond, envs_cint, envs_bvk)) {
                                 jLmax = MAX(jL, jLmax);
                         }
                         pbuf += d3c;
+                        rij_cond += nish * njsh * 3;
                 }
                 if (jLmax >= 0) {  // ensure j3c buf is not empty
                         nLj = jLmax + 1;
                         dgemm_(&TRANS_N, &TRANS_T, &nkpts, &d3c, &nLj,
                                &D1, expLkR, &nkpts, bufL, &d3c,
                                &D0, bufLkR, &nkpts);
                         dgemm_(&TRANS_N, &TRANS_T, &nkpts, &d3c, &nLj,
@@ -638,29 +777,33 @@
                 }
         }
         if (!empty) {
                 (*fsort)(outR, outI, bufkR, bufkI, cell0_shls, cell0_ao_loc, envs_bvk);
         }
 }
 
-void PBCfill_nr3c_ks1(int (*intor)(), double *outR, double *outI, double *cache,
-                      int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+void PBCfill_nr3c_ks1(FPtrIntor intor, double *outR, double *outI, double *cache,
+                      int *cell0_shls, float *rij_cond,
+                      CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
-        _fill_k(intor, _sort_ks1, outR, outI, cache, cell0_shls, envs_cint, envs_bvk);
+        _fill_k(intor, _sort_ks1, outR, outI, cache, cell0_shls, rij_cond,
+                envs_cint, envs_bvk);
 }
 
-void PBCfill_nr3c_ks2(int (*intor)(), double *outR, double *outI, double *cache,
-                      int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+void PBCfill_nr3c_ks2(FPtrIntor intor, double *outR, double *outI, double *cache,
+                      int *cell0_shls, float *rij_cond,
+                      CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         int ish_cell0 = cell0_shls[0];
         int jsh_cell0 = cell0_shls[1];
         if (ish_cell0 < jsh_cell0) {
                 return;
         }
-        _fill_k(intor, _sort_ks2, outR, outI, cache, cell0_shls, envs_cint, envs_bvk);
+        _fill_k(intor, _sort_ks2, outR, outI, cache, cell0_shls, rij_cond,
+                envs_cint, envs_bvk);
 }
 
 // [i, j, k, comp] in Fortran order => [comp, i, j, k] in C order
 // Note: just need to copy real part. imaginary part may be NULL pointer
 static void _sort_gs1(double *outR, double *outI, double *bufR, double *bufI,
                       int *shls, int *ao_loc, BVKEnvs *envs_bvk)
 {
@@ -774,220 +917,270 @@
                         } }
                         outR += nao3;
                         bufR += dijk;
                 }
         }
 }
 
-static void _fill_nk1(int (*intor)(), FPtrSort fsort,
-                      double *outR, double *outI, double *cache,
-                      int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+static void _fill_nk1(FPtrIntor intor, FPtrSort fsort,
+                      double *outR, double *outI, double *cache, int *cell0_shls,
+                      float *rij_cond, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
-        int bvk_ncells = envs_bvk->ncells;
+        int *seg_loc = envs_bvk->seg_loc;
+        int *seg2sh = envs_bvk->seg2sh;
         int *cell0_ao_loc = envs_bvk->ao_loc;
+        int bvk_ncells = envs_bvk->ncells;
+        int nbasp = envs_bvk->nbasp;
         int ish_cell0 = cell0_shls[0];
         int jsh_cell0 = cell0_shls[1];
         int ksh_cell0 = cell0_shls[2];
         int di = cell0_ao_loc[ish_cell0+1] -  cell0_ao_loc[ish_cell0];
         int dj = cell0_ao_loc[jsh_cell0+1] -  cell0_ao_loc[jsh_cell0];
         int dk = cell0_ao_loc[ksh_cell0+1] -  cell0_ao_loc[ksh_cell0];
         int dij = di * dj;
         int ncomp = envs_bvk->ncomp;
         int d3c = dij * dk * ncomp;
         double *bufR = cache;
         double *bufI = bufR + d3c;
         double *bufL = bufI + d3c;
-        int iL, jL, n;
+        int n;
+        int iL, ish_bvk, iseg0, iseg1, nish;
+        int jL, jsh_bvk, jseg0, jseg1, njsh;
         int bvk_cells[2];
         double *expLkR = envs_bvk->expLkR;
         double *expLkI = envs_bvk->expLkI;
         double facR, facI;
+        int cutoff = envs_bvk->cutoff;
 
         int empty = 1;
         NPdset0(bufR, d3c);
         NPdset0(bufI, d3c);
         for (iL = 0; iL < bvk_ncells; iL++) {
-        for (jL = 0; jL < bvk_ncells; jL++) {
                 bvk_cells[0] = iL;
-                bvk_cells[1] = jL;
-                if ((*intor)(bufL, cell0_shls, bvk_cells, envs_bvk->cutoff,
-                             envs_cint, envs_bvk)) {
-                        empty = 0;
-                        facR = expLkR[iL] * expLkR[jL] + expLkI[iL] * expLkI[jL];
-                        facI = expLkR[iL] * expLkI[jL] - expLkI[iL] * expLkR[jL];
-                        for (n = 0; n < d3c; n++) {
-                                bufR[n] += bufL[n] * facR;
-                                bufI[n] += bufL[n] * facI;
+                ish_bvk = iL * nbasp + ish_cell0;
+                iseg0 = seg_loc[ish_bvk];
+                iseg1 = seg_loc[ish_bvk+1];
+                nish = seg2sh[iseg1] - seg2sh[iseg0];
+                for (jL = 0; jL < bvk_ncells; jL++) {
+                        bvk_cells[1] = jL;
+                        jsh_bvk = jL * nbasp + jsh_cell0;
+                        jseg0 = seg_loc[jsh_bvk];
+                        jseg1 = seg_loc[jsh_bvk+1];
+                        njsh = seg2sh[jseg1] - seg2sh[jseg0];
+                        if ((*intor)(bufL, cell0_shls, bvk_cells, cutoff,
+                                     rij_cond, envs_cint, envs_bvk)) {
+                                empty = 0;
+                                facR = expLkR[iL] * expLkR[jL] + expLkI[iL] * expLkI[jL];
+                                facI = expLkR[iL] * expLkI[jL] - expLkI[iL] * expLkR[jL];
+                                for (n = 0; n < d3c; n++) {
+                                        bufR[n] += bufL[n] * facR;
+                                        bufI[n] += bufL[n] * facI;
+                                }
                         }
+                        rij_cond += nish * njsh * 3;
                 }
-        } }
+        }
 
         if (!empty) {
                 (*fsort)(outR, NULL, bufR, NULL, cell0_shls, cell0_ao_loc, envs_bvk);
                 (*fsort)(outI, NULL, bufI, NULL, cell0_shls, cell0_ao_loc, envs_bvk);
         }
 }
 
-void PBCfill_nr3c_nk1s1(int (*intor)(), double *outR, double *outI, double *cache,
-                        int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+void PBCfill_nr3c_nk1s1(FPtrIntor intor, double *outR, double *outI, double *cache,
+                        int *cell0_shls, float *rij_cond,
+                        CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
-        _fill_nk1(intor, _sort_gs1, outR, outI, cache, cell0_shls, envs_cint, envs_bvk);
+        _fill_nk1(intor, _sort_gs1, outR, outI, cache, cell0_shls, rij_cond,
+                  envs_cint, envs_bvk);
 }
 
-void PBCfill_nr3c_nk1s2(int (*intor)(), double *outR, double *outI, double *cache,
-                        int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+void PBCfill_nr3c_nk1s2(FPtrIntor intor, double *outR, double *outI, double *cache,
+                        int *cell0_shls, float *rij_cond,
+                        CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         int ish_cell0 = cell0_shls[0];
         int jsh_cell0 = cell0_shls[1];
         if (ish_cell0 < jsh_cell0) {
                 return;
         }
-        _fill_nk1(intor, _sort_gs2, outR, outI, cache, cell0_shls, envs_cint, envs_bvk);
+        _fill_nk1(intor, _sort_gs2, outR, outI, cache, cell0_shls, rij_cond,
+                  envs_cint, envs_bvk);
 }
 
 
-static void _fill_g(int (*intor)(), FPtrSort fsort,
-                    double *outR, double *outI, double *cache,
-                    int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+static void _fill_g(FPtrIntor intor, FPtrSort fsort,
+                    double *outR, double *outI, double *cache, int *cell0_shls,
+                    float *rij_cond, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         int *cell0_ao_loc = envs_bvk->ao_loc;
         double *buf = cache;
         int bvk_cells[2] = {0, 0};
+        int cutoff = envs_bvk->cutoff;
 
-        if ((*intor)(buf, cell0_shls, bvk_cells, envs_bvk->cutoff,
-                     envs_cint, envs_bvk)) {
+        if ((*intor)(buf, cell0_shls, bvk_cells, cutoff,
+                     rij_cond, envs_cint, envs_bvk)) {
                 (*fsort)(outR, NULL, buf, NULL, cell0_shls, cell0_ao_loc, envs_bvk);
         }
 }
 
-void PBCfill_nr3c_gs1(int (*intor)(), double *outR, double *outI, double *cache,
-                      int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+void PBCfill_nr3c_gs1(FPtrIntor intor, double *outR, double *outI, double *cache,
+                      int *cell0_shls, float *rij_cond,
+                      CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
-        _fill_g(intor, _sort_gs1, outR, NULL, cache, cell0_shls, envs_cint, envs_bvk);
+        _fill_g(intor, _sort_gs1, outR, NULL, cache, cell0_shls, rij_cond,
+                envs_cint, envs_bvk);
 }
 
-void PBCfill_nr3c_gs2(int (*intor)(), double *outR, double *outI, double *cache,
-                      int *cell0_shls, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
+void PBCfill_nr3c_gs2(FPtrIntor intor, double *outR, double *outI, double *cache,
+                      int *cell0_shls, float *rij_cond,
+                      CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         int ish_cell0 = cell0_shls[0];
         int jsh_cell0 = cell0_shls[1];
         if (ish_cell0 < jsh_cell0) {
                 return;
         }
-        _fill_g(intor, _sort_gs2, outR, NULL, cache, cell0_shls, envs_cint, envs_bvk);
+        _fill_g(intor, _sort_gs2, outR, NULL, cache, cell0_shls, rij_cond,
+                envs_cint, envs_bvk);
 }
 
-void PBCfill_nr3c_drv(int (*intor)(), FPtrFill fill, int is_pbcintor,
+static int bvk_rcond_size(int *cell0_shls, BVKEnvs *envs_bvk)
+{
+        int *seg_loc = envs_bvk->seg_loc;
+        int *seg2sh = envs_bvk->seg2sh;
+        int bvk_ncells = envs_bvk->ncells;
+        int nbasp = envs_bvk->nbasp;
+        int ish_cell0 = cell0_shls[0];
+        int jsh_cell0 = cell0_shls[1];
+        int iL, ish_bvk, iseg0, iseg1;
+        int jsh_bvk, jseg0, jseg1;
+        int nish = 0;
+        int njsh = 0;
+        for (iL = 0; iL < bvk_ncells; iL++) {
+                ish_bvk = iL * nbasp + ish_cell0;
+                jsh_bvk = iL * nbasp + jsh_cell0;
+                iseg0 = seg_loc[ish_bvk];
+                jseg0 = seg_loc[jsh_bvk];
+                iseg1 = seg_loc[ish_bvk+1];
+                jseg1 = seg_loc[jsh_bvk+1];
+                nish += seg2sh[iseg1] - seg2sh[iseg0];
+                njsh += seg2sh[jseg1] - seg2sh[jseg0];
+        }
+        return nish * njsh * 3;
+}
+static void approx_bvk_rcond(float *rcond, int *cell0_shls, BVKEnvs *envs_bvk,
+                             int *atm, int natm, int *bas, int nbas, double *env)
+{
+        int *seg_loc = envs_bvk->seg_loc;
+        int *seg2sh = envs_bvk->seg2sh;
+        int bvk_ncells = envs_bvk->ncells;
+        int nbasp = envs_bvk->nbasp;
+        int ish_cell0 = cell0_shls[0];
+        int jsh_cell0 = cell0_shls[1];
+        int iL, ish_bvk, iseg0, iseg1, nish;
+        int jL, jsh_bvk, jseg0, jseg1, njsh;
+
+        float *cache = malloc(sizeof(float) * nbas*3);
+        for (iL = 0; iL < bvk_ncells; iL++) {
+        for (jL = 0; jL < bvk_ncells; jL++) {
+                ish_bvk = iL * nbasp + ish_cell0;
+                jsh_bvk = jL * nbasp + jsh_cell0;
+                iseg0 = seg_loc[ish_bvk];
+                jseg0 = seg_loc[jsh_bvk];
+                iseg1 = seg_loc[ish_bvk+1];
+                jseg1 = seg_loc[jsh_bvk+1];
+                nish = seg2sh[iseg1] - seg2sh[iseg0];
+                njsh = seg2sh[jseg1] - seg2sh[jseg0];
+                PBCapprox_bvk_rcond(rcond, ish_bvk, jsh_bvk, envs_bvk,
+                                    atm, natm, bas, nbas, env, cache);
+                rcond += nish * njsh * 3;
+        } }
+        free(cache);
+}
+
+void PBCfill_nr3c_drv(FPtrIntor intor, FPtrFill fill, int is_pbcintor,
                       double *eriR, double *eriI, double *expLkR, double *expLkI,
                       int *kpt_ij_idx, int kpt_ij_size, int bvk_ncells, int nimgs,
-                      int nkpts, int nbasp, int comp,
-                      int *sh_loc, int *cell0_ao_loc, int *shls_slice,
-                      int8_t *ovlp_mask, int8_t *cell0_ovlp_mask, int *bas_map,
-                      double *q_cond, double cutoff, CINTOpt *cintopt, int cache_size,
+                      int nkpts, int nbasp, int comp, int *seg_loc, int *seg2sh,
+                      int *cell0_ao_loc, int *shls_slice, int8_t *cell0_ovlp_mask,
+                      int16_t *sindex, int cutoff, CINTOpt *cintopt, int cache_size,
                       int *atm, int natm, int *bas, int nbas, double *env)
 {
         int ish0 = shls_slice[0];
         int ish1 = shls_slice[1];
         int jsh0 = shls_slice[2];
         int jsh1 = shls_slice[3];
         int ksh0 = shls_slice[4];
         int ksh1 = shls_slice[5];
         int nish = ish1 - ish0;
         int njsh = jsh1 - jsh0;
-        int nksh = ksh1 - ksh0;
-        size_t nij = nish * njsh;
-        size_t nijk = nij * nksh;
-        // int di = GTOmax_shell_dim(bvk_ao_loc, shls_slice, 1);
+        int nij = nish * njsh;
+        int nbas_bvk = nbasp * bvk_ncells;
 
         BVKEnvs envs_bvk = {bvk_ncells, nimgs,
                 nkpts, nkpts, nbasp, comp, 0, kpt_ij_size,
-                sh_loc, cell0_ao_loc, bas_map, shls_slice, kpt_ij_idx,
-                expLkR, expLkI, ovlp_mask, q_cond, cutoff};
+                seg_loc, seg2sh, cell0_ao_loc, shls_slice, kpt_ij_idx,
+                expLkR, expLkI, NULL, sindex, cutoff};
+
+        int k;
+        float ak;
+        float eta = 1.f;
+        int kseg0 = seg_loc[ksh0-nbasp+nbas_bvk];
+        int kseg1 = seg_loc[ksh1-nbasp+nbas_bvk];
+        for (k = seg2sh[kseg0]; k < seg2sh[kseg1]; k++) {
+                ak = env[bas(PTR_EXP,k) + bas(NPRIM_OF,k)-1];
+                eta = MIN(eta, ak);
+        }
+        envs_bvk.eta = eta;
 
         // if intor is a regular molecular integral function, calling the
         // general assemble3c function
         if (!is_pbcintor) {
                 envs_bvk.intor = intor;
                 intor = &_assemble3c;
         }
 
 #pragma omp parallel
 {
         CINTEnvVars envs_cint;
         PBCminimal_CINTEnvVars(&envs_cint, atm, natm, bas, nbas, env, cintopt);
 
-        size_t n, ij;
-        int ish, jsh, ksh;
+        int ij;
+        int ish, jsh, ksh, ksh_bvk, rij_size;
         int cell0_shls[3];
         double *cache = malloc(sizeof(double) * cache_size);
+        float *rij_cond;
 #pragma omp for schedule(dynamic)
-        for (n = 0; n < nijk; n++) {
-                ksh = n / nij + ksh0;
-                ij = n % nij;
+        for (ij = 0; ij < nij; ij++) {
                 ish = ij / njsh + ish0;
                 jsh = ij % njsh + jsh0;
+                // rij_cond for all ish and jsh??
                 if (!cell0_ovlp_mask[ish*nbasp+jsh]) {
                         continue;
                 }
                 cell0_shls[0] = ish;
                 cell0_shls[1] = jsh;
-                cell0_shls[2] = ksh;
-                (*fill)(intor, eriR, eriI, cache, cell0_shls, &envs_cint, &envs_bvk);
-        }
-        free(cache);
-}
-}
-
-void PBC_nr3c_q_cond(int (*intor)(), CINTOpt *cintopt,
-                     double *q_cond, int *shls_slice, int *ao_loc,
-                     int *atm, int natm, int *bas, int nbas, double *env)
-{
-        int ish0 = shls_slice[0];
-        int ish1 = shls_slice[1];
-        int ksh0 = shls_slice[2];
-        int ksh1 = shls_slice[3];
-        int nish = ish1 - ish0;
-        int nksh = ksh1 - ksh0;
-        const int cache_size = GTOmax_cache_size(intor, shls_slice, 2,
-                                                 atm, natm, bas, nbas, env);
-#pragma omp parallel
-{
-        double qtmp, tmp;
-        size_t ik, i, k, di, dk;
-        int ish, ksh;
-        int shls[3];
-        di = 0;
-        for (ish = MIN(ish0, ksh0); ish < MAX(ish1, ksh1); ish++) {
-                dk = ao_loc[ish+1] - ao_loc[ish];
-                di = MAX(di, dk);
-        }
-        double *buf = malloc(sizeof(double) * (di*di*di + cache_size));
-        double *cache = buf + di * di * di;
-#pragma omp for schedule(dynamic, 4)
-        for (ik = 0; ik < nish*nksh; ik++) {
-                ksh = ik / nish + ksh0;
-                ish = ik % nish;
-                di = ao_loc[ish+1] - ao_loc[ish];
-                dk = ao_loc[ksh+1] - ao_loc[ksh];
-                shls[0] = ish;
-                shls[1] = ish;
-                shls[2] = ksh;
-                qtmp = 1e-200;
-                if (0 != (*intor)(buf, NULL, shls, atm, natm, bas, nbas, env,
-                                  cintopt, cache)) {
-                        for (k = 0; k < dk; k++) {
-                        for (i = 0; i < di; i++) {
-                                tmp = fabs(buf[i+di*i+di*di*k]);
-                                qtmp = MAX(qtmp, tmp);
-                        } }
-                        qtmp = sqrt(qtmp);
+                rij_size = bvk_rcond_size(cell0_shls, &envs_bvk);
+                rij_cond = malloc(sizeof(float) * rij_size*3);
+                approx_bvk_rcond(rij_cond, cell0_shls, &envs_bvk,
+                                 atm, natm, bas, nbas, env);
+                for (ksh = ksh0; ksh < ksh1; ksh++) {
+                        ksh_bvk = ksh - nbasp + nbas_bvk;
+                        if (seg_loc[ksh_bvk] == seg_loc[ksh_bvk+1]) {
+                                // skip aux basis if exclude_d_aux enabled
+                                continue;
+                        }
+                        cell0_shls[2] = ksh;
+                        (*fill)(intor, eriR, eriI, cache, cell0_shls, rij_cond,
+                                &envs_cint, &envs_bvk);
                 }
-                q_cond[ik] = qtmp;
+                free(rij_cond);
         }
-        free(buf);
+        free(cache);
 }
 }
 
 void PBCnr3c_fuse_dd_s1(double *j3c, double *j3c_dd,
                         int *ao_idx, int *orig_slice, int *dd_slice,
                         int nao, int naod, int naux)
 {
@@ -1018,16 +1211,16 @@
                         int *ao_idx, int *orig_slice, int *dd_slice,
                         int nao, int naod, int naux)
 {
         size_t Naux = naux;
         int ip0 = orig_slice[0];
         int jp0 = orig_slice[2];
         int i0 = dd_slice[0];
-        int j0 = dd_slice[2];
         int i1 = dd_slice[1];
+        int j0 = dd_slice[2];
         int off_o = ip0 * (ip0 + 1) / 2 + jp0;
         int off_i = i0 * naod + j0;
         int i, j, ip, jp, n;
         double *pj3c, *pj3c_dd;
         for (i = i0; i < i1; i++) {
         for (j = 0; j <= i; j++) {
                 ip = ao_idx[i];
```

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/fill_ints_sr.c` & `pyscf-2.3.0/pyscf/lib/pbc/fill_ints_sr.c`

 * *Files 1% similar despite different names*

```diff
@@ -143,25 +143,23 @@
     jsh += jsh0;
     int jptrxyz = atm[PTR_COORD+bas[ATOM_OF+jsh*BAS_SLOTS]*ATM_SLOTS];
     const int dj = ao_loc[jsh+1] - ao_loc[jsh];
     int dimax = INTBUFMAX10 / dj;
     int ishloc[ish1-ish0+1];
     int nishloc = shloc_partition(ishloc, ao_loc, ish0, ish1, dimax);
 
-    int m, msh0, msh1, dmjc, ish, di, empty;
+    int m, msh0, msh1, dmjc, ish, di;
     int jL;
     int shls[2];
     double *bufk_r = buf;
     double *bufk_i, *bufL, *pbuf, *pbuf2, *cache;
-// >>>>>>>>>
     int iptrxyz, dijc, ISH, JSH, IJSH, i;
     JSH = refuniqshl_map[jsh-jsh0];
     double *ri, *rj, Rij2, Rij2_cut;
     const double omega = fabs(env_loc[PTR_RANGE_OMEGA]);
-// <<<<<<<<<
 
     shls[1] = jsh;
     for (m = 0; m < nishloc; m++) {
         msh0 = ishloc[m];
         msh1 = ishloc[m+1];
         dimax = ao_loc[msh1] - ao_loc[msh0];
         dmjc = dj * dimax * comp;
@@ -169,33 +167,29 @@
         bufL   = bufk_i + dmjc * nkpts;
         pbuf2  = bufL   + dmjc * nimgs;
         cache  = pbuf2  + dmjc;
 
         pbuf = bufL;
         for (jL = 0; jL < nimgs; jL++) {
             shift_bas(env_loc, env, Ls, jptrxyz, jL);
-// >>>>>>>>>>>
             rj = env_loc + jptrxyz;
-// <<<<<<<<<<<
             for (ish = msh0; ish < msh1; ish++) {
                 shls[0] = ish;
                 di = ao_loc[ish+1] - ao_loc[ish];
                 dijc = di * dj * comp;
                 iptrxyz = atm[PTR_COORD+bas[ATOM_OF+ish*BAS_SLOTS]*ATM_SLOTS];
                 ri = env_loc + iptrxyz;
                 Rij2 = get_dsqure(ri,rj);
                 ISH = refuniqshl_map[ish];
                 IJSH = (ISH>=JSH)?(ISH*(ISH+1)/2+JSH):(JSH*(JSH+1)/2+ISH);
                 Rij2_cut = uniq_Rcut2s[IJSH];
                 if (Rij2 < Rij2_cut) {
                     env_loc[PTR_RANGE_OMEGA] = 0.;
-                    if ((*intor)(pbuf, NULL, shls, atm, natm, bas, nbas,
-                                 env_loc, cintopt, cache)) {
-                        empty = 0;
-                    }
+                    (*intor)(pbuf, NULL, shls, atm, natm, bas, nbas,
+                             env_loc, cintopt, cache);
                     env_loc[PTR_RANGE_OMEGA] = omega;
                     if ((*intor)(pbuf2, NULL, shls, atm, natm, bas, nbas,
                                  env_loc, cintopt, cache)) {
                         for (i = 0; i < dijc; ++i) {
                             pbuf[i] -= pbuf2[i];
                         }
                     }
@@ -775,15 +769,15 @@
     const int dj = ao_loc[jsh+1] - ao_loc[jsh];
     const int dij = di * dj;
     const int dkaomax = GTOmax_shell_dim(ao_loc, shls_slice+4, 1);
     int dkmax = MAX(INTBUFMAX10 / dij, dkaomax); // buf can hold at least 1 ksh
     int kshloc[ksh1-ksh0+1];
     int nkshloc = shloc_partition(kshloc, ao_loc, ksh0, ksh1, dkmax);
 
-    int i, m, msh0, msh1, dijmc, empty;
+    int i, m, msh0, msh1, dijmc;
     size_t dijmk, dijkc;
     int ksh, dk;
     int iL_bvk, iL0, iL1, iL, jL_bvk, jL0, jL1, jL;
     int shls[3];
     double *bufexp_r = buf;
     double *bufexp_i = bufexp_r + bvk_nimgs * nkpts;
     double *bufk_r = bufexp_i + bvk_nimgs * nkpts;
@@ -857,19 +851,16 @@
                             Rcut2 = uniq_Rcut2s_K[Ksh];
                             kptrxyz = atm[PTR_COORD+bas[ATOM_OF+
                                                 ksh*BAS_SLOTS]*ATM_SLOTS];
                             rk = env_loc + kptrxyz;
                             Rijk2 = get_dsqure(rc, rk);
                             if (Rijk2 < Rcut2) {
                                 env_loc[PTR_RANGE_OMEGA] = 0.;
-                                if ((*intor)(pbuf1, NULL, shls, atm, natm,
-                                             bas, nbas, env_loc, cintopt,
-                                             cache)) {
-                                    empty = 0;
-                                }
+                                (*intor)(pbuf1, NULL, shls, atm, natm, bas, nbas,
+                                         env_loc, cintopt, cache);
                                 env_loc[PTR_RANGE_OMEGA] = omega;
                                 if ((*intor)(pbuf2, NULL, shls, atm, natm,
                                              bas, nbas, env_loc, cintopt,
                                              cache)) {
                                     for (i = 0; i < dijkc; i++) {
                                         pbuf1[i] -= pbuf2[i];
                                     }
@@ -1066,15 +1057,15 @@
     const int dj = ao_loc[jsh+1] - ao_loc[jsh];
     const int dij = di * dj;
     const int dkaomax = GTOmax_shell_dim(ao_loc, shls_slice+4, 1);
     int dkmax = MAX(INTBUFMAX10 / dij, dkaomax); // buf can hold at least 1 ksh
     int kshloc[ksh1-ksh0+1];
     int nkshloc = shloc_partition(kshloc, ao_loc, ksh0, ksh1, dkmax);
 
-    int i, m, msh0, msh1, dijmc, empty;
+    int i, m, msh0, msh1, dijmc; 
     size_t dijmk, dijkc;
     int ksh, dk;
     int iL, jL, jLcount;
     int shls[3];
     double *bufexp_r = buf;
     double *bufexp_i = bufexp_r + nimgs * nkpts;
     double *bufk_r = bufexp_i + nimgs * nkpts;
@@ -1137,19 +1128,16 @@
                     Rcut2 = uniq_Rcut2s_K[Ksh];
                     kptrxyz = atm[PTR_COORD+bas[ATOM_OF+
                                         ksh*BAS_SLOTS]*ATM_SLOTS];
                     rk = env_loc + kptrxyz;
                     Rijk2 = get_dsqure(rc, rk);
                     if (Rijk2 < Rcut2) {
                         env_loc[PTR_RANGE_OMEGA] = 0.;
-                        if ((*intor)(pbuf, NULL, shls, atm, natm,
-                                     bas, nbas, env_loc, cintopt,
-                                     cache)) {
-                            empty = 0;
-                        }
+                        (*intor)(pbuf, NULL, shls, atm, natm, bas, nbas,
+                                 env_loc, cintopt, cache);
                         env_loc[PTR_RANGE_OMEGA] = omega;
                         if ((*intor)(pbuf2, NULL, shls, atm, natm,
                                      bas, nbas, env_loc, cintopt,
                                      cache)) {
                             for (i = 0; i < dijkc; i++) {
                                 pbuf[i] -= pbuf2[i];
                             }
@@ -1471,15 +1459,15 @@
     const int dj = ao_loc[jsh+1] - ao_loc[jsh];
     const int dij = di * dj;
     const int dkaomax = GTOmax_shell_dim(ao_loc, shls_slice+4, 1);
     int dkmax = MAX(INTBUFMAX / dij, dkaomax);
     int kshloc[ksh1-ksh0+1];
     int nkshloc = shloc_partition(kshloc, ao_loc, ksh0, ksh1, dkmax);
 
-    int i, m, msh0, msh1, dijm, dijmc, dijmk, dijkc, empty;
+    int i, m, msh0, msh1, dijm, dijmc, dijmk, dijkc;
     int ksh, dk;
     int iL_bvk, iL0_bvk, iLcount_bvk, iL0, iL1, iL, jL_bvk, jL0, jL1, jL;
     int shls[3];
     double *bufkk_r, *bufkk_i, *bufkL_r, *bufkL_i, *bufL, *pbuf, *cache;
     double *buf_rs, *buf_rs0, *pbuf_rs;
 
     const double omega = fabs(env_loc[PTR_RANGE_OMEGA]);
@@ -1556,19 +1544,16 @@
                                 Rcut2 = uniq_Rcut2s_K[Ksh];
                                 kptrxyz = atm[PTR_COORD+bas[ATOM_OF+
                                                     ksh*BAS_SLOTS]*ATM_SLOTS];
                                 rk = env_loc + kptrxyz;
                                 Rijk2 = get_dsqure(rc, rk);
                                 if (Rijk2 < Rcut2) {
                                     env_loc[PTR_RANGE_OMEGA] = 0.;
-                                    if ((*intor)(buf_rs, NULL, shls, atm, natm,
-                                                 bas, nbas, env_loc, cintopt,
-                                                 cache)) {
-                                        empty = 0;
-                                    }
+                                    (*intor)(buf_rs, NULL, shls, atm, natm, bas, nbas,
+                                             env_loc, cintopt, cache);
                                     env_loc[PTR_RANGE_OMEGA] = omega;
                                     if ((*intor)(pbuf_rs, NULL, shls, atm, natm,
                                                  bas, nbas, env_loc, cintopt,
                                                  cache)) {
                                         for (i = 0; i < dijkc; i++) {
                                             buf_rs[i] -= pbuf_rs[i];
                                         }
@@ -1753,15 +1738,15 @@
     const int dj = ao_loc[jsh+1] - ao_loc[jsh];
     const int dij = di * dj;
     const int dkaomax = GTOmax_shell_dim(ao_loc, shls_slice+4, 1);
     int dkmax = MAX(INTBUFMAX / dij, dkaomax); // buf can hold at least 1 ksh
     int kshloc[ksh1-ksh0+1];
     int nkshloc = shloc_partition(kshloc, ao_loc, ksh0, ksh1, dkmax);
 
-    int i, m, msh0, msh1, dijm, dijmc, dijmk, dijkc, empty;
+    int i, m, msh0, msh1, dijm, dijmc, dijmk, dijkc;
     int ksh, dk, iL0, iL, jL, iLcount;
     int shls[3];
     double *bufkk_r, *bufkk_i, *bufkL_r, *bufkL_i, *bufL, *pbuf, *pbuf2, *cache;
 
     shls[0] = ish;
     shls[1] = jsh;
 
@@ -1828,19 +1813,16 @@
                         Rcut2 = uniq_Rcut2s_K[Ksh];
                         kptrxyz = atm[PTR_COORD+bas[ATOM_OF+
                                             ksh*BAS_SLOTS]*ATM_SLOTS];
                         rk = env_loc + kptrxyz;
                         Rijk2 = get_dsqure(rc, rk);
                         if (Rijk2 < Rcut2) {
                             env_loc[PTR_RANGE_OMEGA] = 0.;
-                            if ((*intor)(pbuf, NULL, shls, atm, natm,
-                                         bas, nbas, env_loc, cintopt,
-                                         cache)) {
-                                empty = 0;
-                            }
+                            (*intor)(pbuf, NULL, shls, atm, natm, bas, nbas,
+                                     env_loc, cintopt, cache);
                             env_loc[PTR_RANGE_OMEGA] = omega;
                             if ((*intor)(pbuf2, NULL, shls, atm, natm,
                                          bas, nbas, env_loc, cintopt,
                                          cache)) {
                                 for (i = 0; i < dijkc; i++) {
                                     pbuf[i] -= pbuf2[i];
                                 }
```

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/ft_ao.c` & `pyscf-2.3.0/pyscf/lib/pbc/ft_ao.c`

 * *Files 2% similar despite different names*

```diff
@@ -29,78 +29,70 @@
 #include "vhf/nr_direct.h"
 #include "pbc/pbc.h"
 #include "np_helper/np_helper.h"
 
 #define OF_CMPLX        2
 #define BLOCK_SIZE      104
 
-typedef int (*FPtrIntor)(double *outR, double *outI, int *shls, int *dims,
-                         FPtr_eval_gz eval_gz, double complex fac,
-                         double *Gv, double *b, int *gxyz, int *gs, int nGv,
-                         int block_size,
-                         int *atm, int natm, int *bas, int nbas, double *env);
-
 typedef int (*FPtrSort)(double *out, double *in, int fill_zero,
                         int *shls_slice, int *ao_loc, int nkpts, int comp,
                         int nGv, int ish, int jsh, int grid0, int grid1);
 
 typedef int (*FPtrFill)(FPtrIntor intor, FPtr_eval_gz eval_gz, FPtrSort fsort,
                         double *out, double *buf, int *cell0_shls,
                         CINTEnvVars *envs_cint, BVKEnvs *envs_bvk);
 
 void PBCminimal_CINTEnvVars(CINTEnvVars *envs, int *atm, int natm, int *bas, int nbas, double *env,
                             CINTOpt *cintopt);
 
 static int _assemble2c(FPtrIntor intor, FPtr_eval_gz eval_gz,
-                       double *eriR, double *eriI, //double *cache,
+                       double *eriR, double *eriI, double *cache,
                        int grid0, int grid1, int ish_cell0, int jsh_bvk,
                        double complex fac, CINTEnvVars *envs_cint, BVKEnvs *envs_bvk)
 {
         int natm = envs_cint->natm;
         int nbas = envs_cint->nbas;
 //        int ncomp = envs_cint->ncomp;
-        int *sh_loc = envs_bvk->sh_loc;
-        int ish0 = sh_loc[ish_cell0];
-        int ish1 = sh_loc[ish_cell0+1];
-        int jsh0 = sh_loc[jsh_bvk];
-        int jsh1 = sh_loc[jsh_bvk+1];
+        int *seg_loc = envs_bvk->seg_loc;
+        int *seg2sh = envs_bvk->seg2sh;
+        int iseg0 = seg_loc[ish_cell0];
+        int iseg1 = seg_loc[ish_cell0+1];
+        int jseg0 = seg_loc[jsh_bvk];
+        int jseg1 = seg_loc[jsh_bvk+1];
         int empty = 1;
-        if (ish0 == ish1 || jsh0 == jsh1) {
+        if (iseg0 == iseg1 || jseg0 == jseg1) {
                 return !empty;
         }
 
-        int nimgs = envs_bvk->nimgs;
+        int jsh0 = seg2sh[jseg0];
+        int jsh1 = seg2sh[jseg1];
         int ngrids = envs_bvk->nGv;
         int dg = grid1 - grid0;
         int *atm = envs_cint->atm;
         int *bas = envs_cint->bas;
         double *env = envs_cint->env;
         double *Gv = envs_bvk->Gv;
         double *b = envs_bvk->b;
         int *gxyz = envs_bvk->gxyz;
         int *gs = envs_bvk->gs;
         int8_t *ovlp_mask = envs_bvk->ovlp_mask;
-        int *bas_map = envs_bvk->bas_map;
-        int shls[2];
-        int ish, jsh, ishp;
+        int shls[2] = {0,};
+        int ish, jsh, iseg;
 
-        for (ish = ish0; ish < ish1; ish++) {
-                if (bas_map[ish] % nimgs != 0) {
-                        continue;
-                }
-                ishp = bas_map[ish] / nimgs;
+        for (iseg = iseg0; iseg < iseg1; iseg++) {
+                ish = seg2sh[iseg];
                 for (jsh = jsh0; jsh < jsh1; jsh++) {
-                        if (!ovlp_mask[ishp*nbas+jsh]) {
+                        if (!ovlp_mask[iseg*nbas+jsh]) {
                                 continue;
                         }
                         shls[0] = ish;
                         shls[1] = jsh;
                         if ((*intor)(eriR, eriI, shls, NULL, eval_gz,
                                      fac, Gv+grid0, b, gxyz+grid0, gs, ngrids, dg,
-                                     atm, natm, bas, nbas, env)) {
+                                     atm, natm, bas, nbas, env, NULL)) {
                                 empty = 0;
                         }
                 }
         }
         return !empty;
 }
 
@@ -133,15 +125,15 @@
         int nbasp = envs_bvk->nbasp;
         double *expLkR = envs_bvk->expLkR;
         double *expLkI = envs_bvk->expLkI;
         double *bufkR = buf;
         double *bufkI = bufkR + ((size_t)dij) * BLOCK_SIZE * comp * nkpts;
         double *bufLR = bufkI + ((size_t)dij) * BLOCK_SIZE * comp * nkpts;
         double *bufLI = bufLR + ((size_t)dij) * BLOCK_SIZE * comp * bvk_ncells;
-        //double *cache = bufLI + ((size_t)dij) * BLOCK_SIZE * comp * bvk_ncells;
+        double *cache = bufLI + ((size_t)dij) * BLOCK_SIZE * comp * bvk_ncells;
         double *pbufR, *pbufI;
         int grid0, grid1, dg, dijg, jL, jLmax, nLj, empty;
 
         // TODO: precompute opts??
 
         for (grid0 = 0; grid0 < nGv; grid0 += BLOCK_SIZE) {
                 grid1 = MIN(grid0+BLOCK_SIZE, nGv);
@@ -150,17 +142,17 @@
 
                 jLmax = -1;
                 for (jL = 0; jL < bvk_ncells; jL++) {
                         pbufR = bufLR + jL * dijg;
                         pbufI = bufLI + jL * dijg;
                         NPdset0(pbufR, dijg);
                         NPdset0(pbufI, dijg);
-                        if (_assemble2c(intor, eval_gz, pbufR, pbufI, grid0, grid1,
-                                        ish_cell0, jL*nbasp+jsh_cell0, Z1,
-                                        envs_cint, envs_bvk)) {
+                        if (_assemble2c(intor, eval_gz, pbufR, pbufI, cache,
+                                        grid0, grid1, ish_cell0, jL*nbasp+jsh_cell0,
+                                        Z1, envs_cint, envs_bvk)) {
                                 jLmax = jL;
                         }
                 }
 
                 empty = jLmax == -1;
                 if (!empty) {
                         nLj = jLmax + 1;
@@ -199,30 +191,31 @@
         int bvk_ncells = envs_bvk->ncells;
         int nkpts = envs_bvk->nkpts;
         int nbasp = envs_bvk->nbasp;
         double *expLkR = envs_bvk->expLkR;
         double *expLkI = envs_bvk->expLkI;
         double *bufR = buf;
         double *bufI = bufR + dij * BLOCK_SIZE * comp;
+        double *cache = bufI + dij * BLOCK_SIZE * comp;
         double complex fac;
         int grid0, grid1, dg, jL, dijg, empty;
 
         for (grid0 = 0; grid0 < nGv; grid0 += BLOCK_SIZE) {
                 grid1 = MIN(grid0+BLOCK_SIZE, nGv);
                 dg = grid1 - grid0;
                 dijg = dij * dg * comp;
                 NPdset0(bufR, dijg);
                 NPdset0(bufI, dijg);
 
                 empty = 1;
                 for (jL = 0; jL < bvk_ncells; jL++) {
                         fac = expLkR[jL] + expLkI[jL] * _Complex_I;
-                        if (_assemble2c(intor, eval_gz, bufR, bufI, grid0, grid1,
-                                        ish_cell0, jL*nbasp+jsh_cell0, fac,
-                                        envs_cint, envs_bvk)) {
+                        if (_assemble2c(intor, eval_gz, bufR, bufI, cache,
+                                        grid0, grid1, ish_cell0, jL*nbasp+jsh_cell0,
+                                        fac, envs_cint, envs_bvk)) {
                                 empty = 0;
                         }
                 }
 
                 (*fsort)(out, bufR, empty, shls_slice, cell0_ao_loc,
                          nkpts, comp, nGv, ish_cell0, jsh_cell0, grid0, grid1);
         }
@@ -600,43 +593,81 @@
                           int *shls_slice, int *ao_loc, int nkpts, int comp,
                           int nGv, int ish, int jsh, int grid0, int grid1)
 {
         PBC_ft_zsort_s1(out, in, fill_zero, shls_slice, ao_loc, nkpts, comp,
                         nGv, ish, jsh, grid0, grid1);
 }
 
+static size_t max_cache_size(FPtrIntor intor, FPtr_eval_gz eval_gz, int *shls_slice,
+                             int *seg_loc, int *seg2sh,
+                             double *Gv, double *b, int *gxyz, int *gs, int nGv,
+                             int *atm, int natm, int *bas, int nbas, double *env)
+{
+        int ish_cell0 = shls_slice[0];
+        int ish_cell1 = shls_slice[1];
+        int jsh_cell0 = shls_slice[2];
+        int jsh_cell1 = shls_slice[3];
+        int iseg0 = seg_loc[ish_cell0];
+        int iseg1 = seg_loc[ish_cell1];
+        int jseg0 = seg_loc[jsh_cell0];
+        int jseg1 = seg_loc[jsh_cell1];
+        int ish0 = seg2sh[iseg0];
+        int ish1 = seg2sh[iseg1];
+        int jsh0 = seg2sh[jseg0];
+        int jsh1 = seg2sh[jseg1];
+        int sh0 = MIN(ish0, jsh0);
+        int sh1 = MAX(ish1, jsh1);
+        int blksize = MIN(nGv, BLOCK_SIZE);
+        double complex fac = 0.;
+        int shls[2];
+        int i, cache_size;
+        size_t max_size = 0;
+        for (i = sh0; i < sh1; i++) {
+                shls[0] = i;
+                shls[1] = i;
+                cache_size = (*intor)(NULL, NULL, shls, NULL, eval_gz,
+                                      fac, Gv, b, gxyz, gs, nGv, blksize,
+                                      atm, natm, bas, nbas, env, NULL);
+                max_size = MAX(max_size, cache_size);
+        }
+        return max_size * blksize;
+}
+
 void PBC_ft_bvk_drv(FPtrIntor intor, FPtr_eval_gz eval_gz, FPtrFill fill, FPtrSort fsort,
                     double *out, double *expLkR, double *expLkI,
                     int bvk_ncells, int nimgs, int nkpts, int nbasp, int comp,
-                    int *sh_loc, int *cell0_ao_loc, int *shls_slice,
-                    int8_t *ovlp_mask, int8_t *cell0_ovlp_mask, int *bas_map,
+                    int *seg_loc, int *seg2sh, int *cell0_ao_loc, int *shls_slice,
+                    int8_t *ovlp_mask, int8_t *cell0_ovlp_mask,
                     double *Gv, double *b, int *gxyz, int *gs, int nGv,
                     int *atm, int natm, int *bas, int nbas, double *env)
 {
         int ish0 = shls_slice[0];
         int ish1 = shls_slice[1];
         int jsh0 = shls_slice[2];
         int jsh1 = shls_slice[3];
         int nish = ish1 - ish0;
         int njsh = jsh1 - jsh0;
         int di = GTOmax_shell_dim(cell0_ao_loc, shls_slice, 2);
         BVKEnvs envs_bvk = {bvk_ncells, nimgs,
                 nkpts, nkpts, nbasp, comp, nGv, 0,
-                sh_loc, cell0_ao_loc, bas_map, shls_slice, NULL,
-                expLkR, expLkI, ovlp_mask, NULL, 0., Gv, b, gxyz, gs};
+                seg_loc, seg2sh, cell0_ao_loc, shls_slice, NULL,
+                expLkR, expLkI, ovlp_mask, NULL, 0, 0.f, Gv, b, gxyz, gs};
         size_t count = nkpts + bvk_ncells;
-        size_t size_v = di * di * BLOCK_SIZE * count * comp * OF_CMPLX;
+        size_t buf_size = di * di * BLOCK_SIZE * count * comp * OF_CMPLX;
+        size_t cache_size = max_cache_size(intor, eval_gz, shls_slice,
+                                           seg_loc, seg2sh, Gv, b, gxyz, gs, nGv,
+                                           atm, natm, bas, nbas, env);
 
 #pragma omp parallel
 {
         CINTEnvVars envs_cint;
         PBCminimal_CINTEnvVars(&envs_cint, atm, natm, bas, nbas, env, NULL);
         int ish, jsh, ij;
         int cell0_shls[2];
-        double *buf = malloc(sizeof(double) * size_v);
+        double *buf = malloc(sizeof(double) * (buf_size+cache_size));
 #pragma omp for schedule(dynamic)
         for (ij = 0; ij < nish*njsh; ij++) {
                 ish = ij / njsh + ish0;
                 jsh = ij % njsh + jsh0;
                 cell0_shls[0] = ish;
                 cell0_shls[1] = jsh;
                 if (!cell0_ovlp_mask[ish*nbasp+jsh]) {
```

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/grid_ao.c` & `pyscf-2.3.0/pyscf/lib/pbc/grid_ao.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/optimizer.c` & `pyscf-2.3.0/pyscf/lib/pbc/optimizer.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/optimizer.h` & `pyscf-2.3.0/pyscf/lib/pbc/optimizer.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/pbc.h` & `pyscf-2.3.0/pyscf/lib/pbc/pbc.h`

 * *Files 24% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 
  *
  * Author: Qiming Sun <osirpt.sun@gmail.com>
  */
 
 #include <stdint.h>
 
-#if !defined(HAVE_DEFINED_BVKENV_H)
+#ifndef HAVE_DEFINED_BVKENV_H
 #define HAVE_DEFINED_BVKENV_H
 typedef struct {
         // number of primitive cells in bvk-cell
         int ncells;
         // number of repeated images associated to cell.rcut
         int nimgs;
         int nkpts;
@@ -31,33 +31,38 @@
         int nbasp;
         int ncomp;
         // number of grids (or planewaves)
         int nGv;
         // length of kpt_ij_idx
         int kpt_ij_size;
         // indicates how to map basis in bvk-cell to supmol basis
-        int *sh_loc;
+        int *seg_loc;
+        int *seg2sh;
         int *ao_loc;
-        // Map from supmol._bas to [bvk_cell-id, rs_basis-id, image-id]
-        int *bas_map;
         int *shls_slice;
         // index to get a sbuset of nkpts x nkpts output
         int *kpt_ij_idx;
         double *expLkR;
         double *expLkI;
 
         // Integral mask of SupMole based on s-function overlap
         int8_t *ovlp_mask;
-        // Integral screening condition
-        double *q_cond;
+        // Integral screening condition ~log((ij|ij))/2
+        int16_t *qindex;
         // cutoff for schwarz condtion
-        double cutoff;
+        int cutoff;
+        float eta;
 
         // parameters for ft_ao
         double *Gv;
         double *b;
         int *gxyz;
         int *gs;
 
         int (*intor)();
 } BVKEnvs;
+
+// It is preferable to use the float16 type to save log value. fp16 type is
+// platform dependent. Here log value is saved in int16_t instead with an
+// adjustment factor 32 to ensure accuracy.
+#define LOG_ADJUST      32
 #endif
```

### Comparing `pyscf-2.2.1/pyscf/lib/pbc/symmetry.c` & `pyscf-2.3.0/pyscf/lib/pbc/symmetry.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ri/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/ri/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/ri/r_df_incore.c` & `pyscf-2.3.0/pyscf/lib/ri/r_df_incore.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/scipy_helper.py` & `pyscf-2.3.0/pyscf/lib/scipy_helper.py`

 * *Files 2% similar despite different names*

```diff
@@ -80,31 +80,31 @@
 
     Returns:
         the factor, the permutation vector, the rank
     '''
     N = A.shape[0]
     assert (A.shape == (N, N))
 
-    D = numpy.diag(A).copy()
+    D = numpy.diag(A.real).copy()
     if tol < 0:
         machine_epsilon = numpy.finfo(numpy.double).eps
         tol = N * machine_epsilon * numpy.amax(numpy.diag(A))
 
-    L = numpy.zeros((N, N))
+    L = numpy.zeros_like(A)
     piv = numpy.arange(N)
     rank = 0
     for k in range(N):
         s = k + numpy.argmax(D[k:])
         piv[k], piv[s] = piv[s], piv[k]
         D[k], D[s] = D[s], D[k]
         L[[k, s], :] = L[[s, k], :]
         if D[k] <= tol:
             break
         rank += 1
         L[k, k] = numpy.sqrt(D[k])
-        L[k+1:, k] = (A[piv[k+1:], piv[k]] - numpy.dot(L[k+1:, :k], L[k, :k])) / L[k, k]
-        D[k+1:] -= L[k+1:, k] ** 2
+        L[k+1:, k] = (A[piv[k+1:], piv[k]] - numpy.dot(L[k+1:, :k], L[k, :k].conj())) / L[k, k]
+        D[k+1:] -= abs(L[k+1:, k]) ** 2
 
     if lower:
         return L, piv, rank
     else:
-        return L.T, piv, rank
+        return L.conj().T, piv, rank
```

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/CMakeLists.txt` & `pyscf-2.3.0/pyscf/lib/vhf/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/cvhf.h` & `pyscf-2.3.0/pyscf/lib/vhf/cvhf.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/fblas.h` & `pyscf-2.3.0/pyscf/lib/vhf/fblas.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/fill_nr_s8.c` & `pyscf-2.3.0/pyscf/lib/vhf/fill_nr_s8.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/hessian_screen.c` & `pyscf-2.3.0/pyscf/lib/vhf/hessian_screen.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/nr_direct.c` & `pyscf-2.3.0/pyscf/lib/vhf/nr_direct.c`

 * *Files 0% similar despite different names*

```diff
@@ -23,16 +23,14 @@
 #include "config.h"
 #include "cint.h"
 #include "optimizer.h"
 #include "nr_direct.h"
 #include "np_helper/np_helper.h"
 #include "gto/gto.h"
 
-#define AO_BLOCK_SIZE   64
-
 #define DECLARE_ALL \
         const int *atm = envs->atm; \
         const int *bas = envs->bas; \
         const double *env = envs->env; \
         const int natm = envs->natm; \
         const int nbas = envs->nbas; \
         const int *ao_loc = envs->ao_loc; \
```

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/nr_direct.h` & `pyscf-2.3.0/pyscf/lib/vhf/nr_direct.h`

 * *Files 0% similar despite different names*

```diff
@@ -15,15 +15,15 @@
  *
  * Author: Qiming Sun <osirpt.sun@gmail.com>
  */
 
 #include "cint.h"
 #include "optimizer.h"
 
-#define AO_BLOCK_SIZE   32
+#define AO_BLOCK_SIZE   64
 
 #define NOVALUE 0xffffffff
 
 #if !defined(HAVE_DEFINED_INTORENV_H)
 #define HAVE_DEFINED_INTORENV_H
 typedef struct {
         int v_ket_nsh;  /* v_ket_sh1 - v_ket_sh0 */
```

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/nr_direct_dot.c` & `pyscf-2.3.0/pyscf/lib/vhf/nr_direct_dot.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/nr_incore.c` & `pyscf-2.3.0/pyscf/lib/vhf/nr_incore.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/nr_sgx_direct.c` & `pyscf-2.3.0/pyscf/lib/vhf/nr_sgx_direct.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/optimizer.c` & `pyscf-2.3.0/pyscf/lib/vhf/optimizer.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/optimizer.h` & `pyscf-2.3.0/pyscf/lib/vhf/optimizer.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/r_direct_dot.c` & `pyscf-2.3.0/pyscf/lib/vhf/r_direct_dot.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/r_direct_dot.h` & `pyscf-2.3.0/pyscf/lib/vhf/r_direct_dot.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/r_direct_o1.c` & `pyscf-2.3.0/pyscf/lib/vhf/r_direct_o1.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/rah_direct_dot.c` & `pyscf-2.3.0/pyscf/lib/vhf/rah_direct_dot.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/rha_direct_dot.c` & `pyscf-2.3.0/pyscf/lib/vhf/rha_direct_dot.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/rkb_screen.c` & `pyscf-2.3.0/pyscf/lib/vhf/rkb_screen.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/time_rev.c` & `pyscf-2.3.0/pyscf/lib/vhf/time_rev.c`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lib/vhf/time_rev.h` & `pyscf-2.3.0/pyscf/lib/vhf/time_rev.h`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lo/__init__.py` & `pyscf-2.3.0/pyscf/lo/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lo/boys.py` & `pyscf-2.3.0/pyscf/lo/boys.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lo/cholesky.py` & `pyscf-2.3.0/pyscf/lo/cholesky.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lo/edmiston.py` & `pyscf-2.3.0/pyscf/lo/edmiston.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lo/iao.py` & `pyscf-2.3.0/pyscf/lo/iao.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lo/ibo.py` & `pyscf-2.3.0/pyscf/lo/ibo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lo/nao.py` & `pyscf-2.3.0/pyscf/lo/nao.py`

 * *Files 1% similar despite different names*

```diff
@@ -163,15 +163,15 @@
         ia = mol.bas_atom(ib)
         # Avoid calling mol.atom_charge because we should include ECP core electrons here
         nuc = mole.charge(mol.atom_symbol(ia))
         l = mol.bas_angular(ib)
         nc = mol.bas_nctr(ib)
 
         nelec_ecp = mol.atom_nelec_core(ia)
-        ecpcore = core_configuration(nelec_ecp)
+        ecpcore = core_configuration(nelec_ecp, atom_symbol=mol.atom_pure_symbol(ia))
         coreshell = [int(x) for x in AOSHELL[nuc][0][::2]]
         cvshell = [int(x) for x in AOSHELL[nuc][1][::2]]
         if mol.cart:
             deg = (l + 1) * (l + 2) // 2
         else:
             deg = 2 * l + 1
         for n in range(nc):
```

### Comparing `pyscf-2.2.1/pyscf/lo/orth.py` & `pyscf-2.3.0/pyscf/lo/orth.py`

 * *Files 1% similar despite different names*

```diff
@@ -177,15 +177,15 @@
         if symb in nelec_ecp_dic and nelec_ecp_dic[symb] > 0:
             # If ECP basis has good atomic character, ECP basis can be used in the
             # localization/population analysis directly. Otherwise project ECP
             # basis to ANO basis.
             if not PROJECT_ECP_BASIS:
                 continue
 
-            ecpcore = core_configuration(nelec_ecp_dic[symb])
+            ecpcore = core_configuration(nelec_ecp_dic[symb], atom_symbol=gto.mole._std_symbol(symb))
             # Comparing to ANO valence basis, to check whether the ECP basis set has
             # reasonable AO-character contraction.  The ANO valence AO should have
             # significant overlap to ECP basis if the ECP basis has AO-character.
             if abs(ecp_ano_det_ovlp(atm, atmp, ecpcore)) > .1:
                 aos[symb] = numpy.diag(1./numpy.sqrt(s0.diagonal()))
                 continue
         else:
```

### Comparing `pyscf-2.2.1/pyscf/lo/pipek.py` & `pyscf-2.3.0/pyscf/lo/pipek.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/lo/vvo.py` & `pyscf-2.3.0/pyscf/lo/vvo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/PiOS.py` & `pyscf-2.3.0/pyscf/mcscf/PiOS.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/__init__.py` & `pyscf-2.3.0/pyscf/mcscf/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/addons.py` & `pyscf-2.3.0/pyscf/mcscf/addons.py`

 * *Files 0% similar despite different names*

```diff
@@ -928,73 +928,78 @@
             else:
                 e, c = fcibase_class.kernel(self, h1, h2, norb, nelec, ci0=ci0,
                                             nroots=self.nroots,
                                             wfnsym=self.wfnsym, **kwargs)
             return numpy.einsum('i,i->', e, self.weights), c
 
         def states_make_rdm1(self, ci0, norb, nelec, *args, **kwargs):
-            dm1 = [fcibase_class.make_rdm1(self, c, norb, nelec, *args, **kwargs) for c in ci0]
+            fcibase = super()
+            dm1 = [fcibase.make_rdm1(c, norb, nelec, *args, **kwargs) for c in ci0]
             return dm1
 
         def make_rdm1(self, ci0, norb, nelec, *args, **kwargs):
             return sum ([w * dm for w, dm in zip(self.weights,
                                                  self.states_make_rdm1(ci0, norb, nelec, *args, **kwargs))])
 
         def states_make_rdm1s(self, ci0, norb, nelec, *args, **kwargs):
+            fcibase = super()
             dm1a = []
             dm1b = []
             for c in ci0:
-                dm1s = fcibase_class.make_rdm1s(self, c, norb, nelec, *args, **kwargs)
+                dm1s = fcibase.make_rdm1s(c, norb, nelec, *args, **kwargs)
                 dm1a.append (dm1s[0])
                 dm1b.append (dm1s[1])
             return dm1a, dm1b
 
         def make_rdm1s(self, ci0, norb, nelec, *args, **kwargs):
             dm1s = self.states_make_rdm1s(ci0, norb, nelec, *args, **kwargs)
             dm1s = numpy.einsum ('r,srpq->spq', self.weights, dm1s)
             return dm1s[0], dm1s[1]
 
         def states_make_rdm12(self, ci0, norb, nelec, *args, **kwargs):
+            fcibase = super()
             rdm1 = []
             rdm2 = []
             for c in ci0:
-                dm1, dm2 = fcibase_class.make_rdm12(self, c, norb, nelec, *args, **kwargs)
+                dm1, dm2 = fcibase.make_rdm12(c, norb, nelec, *args, **kwargs)
                 rdm1.append (dm1)
                 rdm2.append (dm2)
             return rdm1, rdm2
 
         def make_rdm12(self, ci0, norb, nelec, *args, **kwargs):
             rdm1, rdm2 = self.states_make_rdm12(ci0, norb, nelec, *args, **kwargs)
             rdm1 = numpy.einsum ('r,rpq->pq', self.weights, rdm1)
             rdm2 = numpy.einsum ('r,rpqst->pqst', self.weights, rdm2)
             return rdm1, rdm2
 
         def states_make_rdm12s(self, ci0, norb, nelec, *args, **kwargs):
+            fcibase = super()
             dm1a, dm1b = [], []
             dm2aa, dm2ab, dm2bb = [], [], []
             for c in ci0:
-                dm1s, dm2s = fcibase_class.make_rdm12s(self, c, norb, nelec, *args, **kwargs)
+                dm1s, dm2s = fcibase.make_rdm12s(c, norb, nelec, *args, **kwargs)
                 dm1a.append(dm1s[0])
                 dm1b.append(dm1s[1])
                 dm2aa.append(dm2s[0])
                 dm2ab.append(dm2s[1])
                 dm2bb.append(dm2s[2])
             return (dm1a, dm1b), (dm2aa, dm2ab, dm2bb)
 
         def make_rdm12s(self, ci0, norb, nelec, *args, **kwargs):
             rdm1s, rdm2s = self.states_make_rdm12s(ci0, norb, nelec, *args, **kwargs)
             rdm1s = numpy.einsum ('r,srpq->spq', self.weights, rdm1s)
             rdm2s = numpy.einsum ('r,srpqtu->spqtu', self.weights, rdm2s)
             return rdm1s, rdm2s
 
         def states_trans_rdm12 (self, ci1, ci0, norb, nelec, *args, **kwargs):
+            fcibase = super()
             tdm1 = []
             tdm2 = []
             for c1, c0 in zip (ci1, ci0):
-                dm1, dm2 = fcibase_class.trans_rdm12 (self, c1, c0, norb, nelec)
+                dm1, dm2 = fcibase.trans_rdm12 (c1, c0, norb, nelec)
                 tdm1.append (dm1)
                 tdm2.append (dm2)
             return tdm1, tdm2
 
         def trans_rdm12 (self, ci1, ci0, norb, nelec, *args, **kwargs):
             tdm1, tdm2 = self.states_trans_rdm12 (ci1, ci0, norb, nelec, *args, **kwargs)
             tdm1 = numpy.einsum ('r,rpq->pq', self.weights, tdm1)
@@ -1004,15 +1009,16 @@
         if has_spin_square:
             def spin_square(self, ci0, norb, nelec, *args, **kwargs):
                 ss, multip = self.states_spin_square(ci0, norb, nelec, *args, **kwargs)
                 weights = self.weights
                 return numpy.dot(ss, weights), numpy.dot(multip, weights)
 
             def states_spin_square(self, ci0, norb, nelec, *args, **kwargs):
-                s = [fcibase_class.spin_square(self, ci0[i], norb, nelec, *args, **kwargs)
+                fcibase = super()
+                s = [fcibase.spin_square(ci0[i], norb, nelec, *args, **kwargs)
                      for i, wi in enumerate(self.weights)]
                 return [x[0] for x in s], [x[1] for x in s]
 
     # No recursion of FakeCISolver is allowed!
     if isinstance (casscf.fcisolver, StateAverageFCISolver):
         fcisolver = casscf.fcisolver
         fcisolver.nroots = len(weights)
@@ -1141,15 +1147,16 @@
             if state == 0:
                 e = [e]
                 c = [c]
             self._civec = c
             log = logger.new_logger(self, kwargs.get('verbose'))
             if log.verbose >= logger.DEBUG:
                 if getattr(fcibase_class, 'spin_square', None):
-                    ss = fcibase_class.spin_square(self, c[state], norb, nelec)
+                    fcibase = super()
+                    ss = fcibase.spin_square(c[state], norb, nelec)
                     log.debug('state %d  E = %.15g S^2 = %.7f',
                               state, e[state], ss[0])
                 else:
                     log.debug('state %d  E = %.15g', state, e[state])
             return e[state], c[state]
 
         def approx_kernel(self, h1, h2, norb, nelec, ci0=None, **kwargs):
```

### Comparing `pyscf-2.2.1/pyscf/mcscf/avas.py` & `pyscf-2.3.0/pyscf/mcscf/avas.py`

 * *Files 0% similar despite different names*

```diff
@@ -127,15 +127,15 @@
         c = iao.iao(mol, mo_coeff[:,ncore:nocc], avas_obj.minao)[:,baslst]
         s2 = reduce(numpy.dot, (c.T, ovlp, c))
         s21 = reduce(numpy.dot, (c.T, ovlp, mo_coeff[:, ncore:]))
     else:
         s2 = pmol.intor_symmetric('int1e_ovlp')[baslst][:,baslst]
         s21 = gto.intor_cross('int1e_ovlp', pmol, mol)[baslst]
         s21 = numpy.dot(s21, mo_coeff[:, ncore:])
-    sa = s21.T.dot(scipy.linalg.solve(s2, s21, sym_pos=True))
+    sa = s21.T.dot(scipy.linalg.solve(s2, s21, assume_a='pos'))
 
     threshold = avas_obj.threshold
     if avas_obj.openshell_option == 2:
         wocc, u = numpy.linalg.eigh(sa[:(nocc-ncore), :(nocc-ncore)])
         log.info('Option 2: threshold %s', threshold)
         ncas_occ = (wocc > threshold).sum()
         nelecas = (mol.nelectron - ncore * 2) - (wocc < threshold).sum() * 2
```

### Comparing `pyscf-2.2.1/pyscf/mcscf/casci.py` & `pyscf-2.3.0/pyscf/mcscf/casci.py`

 * *Files 0% similar despite different names*

```diff
@@ -638,14 +638,15 @@
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
 
             # These properties can be updated when calling mf_scanner(mol) if
             # they are shared with mc._scf. In certain scenario the properties
             # may be created for mc separately, e.g. when mcscf.approx_hessian is
             # called. For safety, the code below explicitly resets these
             # properties.
+            self.reset (mol)
             for key in ('with_df', 'with_x2c', 'with_solvent', 'with_dftd3'):
                 sub_mod = getattr(self, key, None)
                 if sub_mod:
                     sub_mod.reset(mol)
 
             if mo_coeff is None:
                 mf_scanner = self._scf
```

### Comparing `pyscf-2.2.1/pyscf/mcscf/casci_symm.py` & `pyscf-2.3.0/pyscf/mcscf/casci_symm.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,14 +33,15 @@
 
         assert (self.mol.symmetry)
         fcisolver = self.fcisolver
         if isinstance(fcisolver, fci.direct_spin0.FCISolver):
             self.fcisolver = fci.direct_spin0_symm.FCISolver(self.mol)
         else:
             self.fcisolver = fci.direct_spin1_symm.FCISolver(self.mol)
+        delattr(fcisolver, '_keys')
         self.fcisolver.__dict__.update(fcisolver.__dict__)
 
     @property
     def wfnsym(self):
         return self.fcisolver.wfnsym
     @wfnsym.setter
     def wfnsym(self, wfnsym):
```

### Comparing `pyscf-2.2.1/pyscf/mcscf/chkfile.py` & `pyscf-2.3.0/pyscf/mcscf/chkfile.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/df.py` & `pyscf-2.3.0/pyscf/mcscf/df.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/dmet_cas.py` & `pyscf-2.3.0/pyscf/mcscf/dmet_cas.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/mc1step.py` & `pyscf-2.3.0/pyscf/mcscf/mc1step.py`

 * *Files 1% similar despite different names*

```diff
@@ -545,14 +545,15 @@
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
 
             # These properties can be updated when calling mf_scanner(mol) if
             # they are shared with mc._scf. In certain scenario the properties
             # may be created for mc separately, e.g. when mcscf.approx_hessian is
             # called. For safety, the code below explicitly resets these
             # properties.
+            self.reset (mol)
             for key in ('with_df', 'with_x2c', 'with_solvent', 'with_dftd3'):
                 sub_mod = getattr(self, key, None)
                 if sub_mod:
                     sub_mod.reset(mol)
 
             mf_scanner = self._scf
             mf_scanner(mol)
@@ -562,14 +563,28 @@
             else:
                 mo = self.mo_coeff
             mo = project_init_guess(self, mo)
             e_tot = self.kernel(mo, self.ci)[0]
             return e_tot
     return CASSCF_Scanner(mc)
 
+def max_stepsize_scheduler(casscf, envs):
+    if not WITH_STEPSIZE_SCHEDULER:
+        return casscf.max_stepsize
+
+    _max_stepsize = envs.get ('max_stepsize', None)
+    if _max_stepsize is None:
+        _max_stepsize = casscf.max_stepsize
+    if envs['de'] > -casscf.conv_tol:  # Avoid total energy increasing
+        _max_stepsize *= .3
+        logger.debug(casscf, 'set max_stepsize to %g', _max_stepsize)
+    else:
+        _max_stepsize = (casscf.max_stepsize*_max_stepsize)**.5
+    casscf._max_stepsize = _max_stepsize # for inspection by user
+    return _max_stepsize
 
 # To extend CASSCF for certain CAS space solver, it can be done by assign an
 # object or a module to CASSCF.fcisolver.  The fcisolver object or module
 # should at least have three member functions "kernel" (wfn for given
 # hamiltonain), "make_rdm12" (1- and 2-pdm), "absorb_h1e" (effective
 # 2e-hamiltonain) in 1-step CASSCF solver, and two member functions "kernel"
 # and "make_rdm12" in 2-step CASSCF solver
@@ -1226,26 +1241,15 @@
     def micro_cycle_scheduler(self, envs):
         if not WITH_MICRO_SCHEDULER:
             return self.max_cycle_micro
 
         log_norm_ddm = numpy.log(envs['norm_ddm'])
         return max(self.max_cycle_micro, int(self.max_cycle_micro-1-log_norm_ddm))
 
-    def max_stepsize_scheduler(self, envs):
-        if not WITH_STEPSIZE_SCHEDULER:
-            return self.max_stepsize
-
-        if self._max_stepsize is None:
-            self._max_stepsize = self.max_stepsize
-        if envs['de'] > -self.conv_tol:  # Avoid total energy increasing
-            self._max_stepsize *= .3
-            logger.debug(self, 'set max_stepsize to %g', self._max_stepsize)
-        else:
-            self._max_stepsize = (self.max_stepsize*self._max_stepsize)**.5
-        return self._max_stepsize
+    max_stepsize_scheduler=max_stepsize_scheduler
 
     def ah_scheduler(self, envs):
         pass
 
     @property
     def max_orb_stepsize(self):  # pragma: no cover
         return self.max_stepsize
@@ -1292,14 +1296,18 @@
         # MRH, 04/08/2019: enable state-average CASSCF second-order algorithm
         if isinstance(self, StateAverageMCSCFSolver):
             # FIXME: (QS) Should not need to pass wfnsym for general CASSCF object.
             wfnsym = getattr(self, 'wfnsym', None)
             mc1 = mc1.state_average_(self.weights, wfnsym)
         return mc1
 
+    def reset(self, mol=None):
+        casci.CASCI.reset(self, mol=mol)
+        self._max_stepsize = None
+
 scf.hf.RHF.CASSCF = scf.rohf.ROHF.CASSCF = lib.class_as_method(CASSCF)
 scf.uhf.UHF.CASSCF = None
 
 
 # to avoid calculating AO integrals
 def _fake_h_for_fast_casci(casscf, mo, eris):
     mc = copy.copy(casscf)
```

### Comparing `pyscf-2.2.1/pyscf/mcscf/mc1step_symm.py` & `pyscf-2.3.0/pyscf/mcscf/mc1step_symm.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,14 +34,15 @@
 
         assert (self.mol.symmetry)
         fcisolver = self.fcisolver
         if isinstance(fcisolver, fci.direct_spin0.FCISolver):
             self.fcisolver = fci.direct_spin0_symm.FCISolver(self.mol)
         else:
             self.fcisolver = fci.direct_spin1_symm.FCISolver(self.mol)
+        delattr(fcisolver, '_keys')
         self.fcisolver.__dict__.update(fcisolver.__dict__)
 
     @property
     def wfnsym(self):
         return self.fcisolver.wfnsym
     @wfnsym.setter
     def wfnsym(self, wfnsym):
```

### Comparing `pyscf-2.2.1/pyscf/mcscf/mc2step.py` & `pyscf-2.3.0/pyscf/mcscf/mc2step.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/mc_ao2mo.py` & `pyscf-2.3.0/pyscf/mcscf/mc_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/newton_casscf.py` & `pyscf-2.3.0/pyscf/mcscf/newton_casscf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/newton_casscf_symm.py` & `pyscf-2.3.0/pyscf/mcscf/newton_casscf_symm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/ucasci.py` & `pyscf-2.3.0/pyscf/mcscf/ucasci.py`

 * *Files 1% similar despite different names*

```diff
@@ -408,15 +408,15 @@
                     for c,ia,ib in res:
                         log.info('  %-20s %-30s %.12f', ia, ib, c)
         return dm1a, dm1b
 
     def spin_square(self, fcivec=None, mo_coeff=None, ovlp=None):
         return addons.spin_square(self, mo_coeff, fcivec, ovlp)
 
-    fix_spin_ = fix_spin = None
+    fix_spin_ = fix_spin = lib.invalid_method('fix_spin')
 
     @lib.with_doc(addons.sort_mo.__doc__)
     def sort_mo(self, caslst, mo_coeff=None, base=1):
         if mo_coeff is None: mo_coeff = self.mo_coeff
         return addons.sort_mo(self, mo_coeff, caslst, base)
 
     def make_rdm1s(self, mo_coeff=None, ci=None, ncas=None, nelecas=None,
```

### Comparing `pyscf-2.2.1/pyscf/mcscf/umc1step.py` & `pyscf-2.3.0/pyscf/mcscf/umc1step.py`

 * *Files 1% similar despite different names*

```diff
@@ -26,15 +26,15 @@
 import copy
 from functools import reduce
 import numpy
 import pyscf.gto
 import pyscf.scf
 from pyscf.lib import logger
 from pyscf.mcscf import ucasci
-from pyscf.mcscf.mc1step import expmat, rotate_orb_cc
+from pyscf.mcscf.mc1step import expmat, rotate_orb_cc, max_stepsize_scheduler, as_scanner
 from pyscf.mcscf import umc_ao2mo
 from pyscf.mcscf import chkfile
 from pyscf import __config__
 
 #FIXME:  when the number of core orbitals are different for alpha and beta,
 # the convergence are very unstable and slow
 
@@ -799,32 +799,29 @@
         return mo_a, mo_b
 
     def micro_cycle_scheduler(self, envs):
         #log_norm_ddm = numpy.log(envs['norm_ddm'])
         #return max(self.max_cycle_micro, int(self.max_cycle_micro-1-log_norm_ddm))
         return self.max_cycle_micro
 
-    def max_stepsize_scheduler(self, envs):
-        if self._max_stepsize is None:
-            self._max_stepsize = self.max_stepsize
-        if envs['de'] > self.conv_tol:  # Avoid total energy increasing
-            self._max_stepsize *= .5
-            logger.debug(self, 'set max_stepsize to %g', self._max_stepsize)
-        else:
-            self._max_stepsize = numpy.sqrt(self.max_stepsize*self.max_stepsize)
-        return self._max_stepsize
+    max_stepsize_scheduler=max_stepsize_scheduler
+    as_scanner=as_scanner
 
     @property
     def max_orb_stepsize(self):  # pragma: no cover
         return self.max_stepsize
     @max_orb_stepsize.setter
     def max_orb_stepsize(self, x):  # pragma: no cover
         sys.stderr.write('WARN: Attribute "max_orb_stepsize" was replaced by "max_stepsize"\n')
         self.max_stepsize = x
 
+    def reset(self, mol=None):
+        ucasci.UCASCI.reset(self, mol=mol)
+        self._max_stepsize = None
+
 CASSCF = UCASSCF
 
 
 # to avoid calculating AO integrals
 def _fake_h_for_fast_casci(casscf, mo, eris):
     mc = copy.copy(casscf)
     mc.mo_coeff = mo
```

### Comparing `pyscf-2.2.1/pyscf/mcscf/umc2step.py` & `pyscf-2.3.0/pyscf/mcscf/umc2step.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mcscf/umc_ao2mo.py` & `pyscf-2.3.0/pyscf/mcscf/umc_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/md/__init__.py` & `pyscf-2.3.0/pyscf/md/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/md/distributions.py` & `pyscf-2.3.0/pyscf/md/distributions.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/md/integrators.py` & `pyscf-2.3.0/pyscf/md/integrators.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mp/__init__.py` & `pyscf-2.3.0/pyscf/mp/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mp/dfgmp2.py` & `pyscf-2.3.0/pyscf/mp/dfgmp2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mp/dfmp2.py` & `pyscf-2.3.0/pyscf/mp/dfmp2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mp/dfmp2_native.py` & `pyscf-2.3.0/pyscf/mp/dfmp2_native.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mp/dfump2_native.py` & `pyscf-2.3.0/pyscf/mp/dfump2_native.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mp/gmp2.py` & `pyscf-2.3.0/pyscf/mp/gmp2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mp/mp2.py` & `pyscf-2.3.0/pyscf/mp/mp2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mp/mp2f12_slow.py` & `pyscf-2.3.0/pyscf/mp/mp2f12_slow.py`

 * *Files 1% similar despite different names*

```diff
@@ -39,15 +39,15 @@
 
 # The cabs space, the complimentary space to the OBS.
 def find_cabs(mol, auxmol, lindep=1e-8):
     cabs_mol = gto.conc_mol(mol, auxmol)
     nao = mol.nao_nr()
     s = cabs_mol.intor_symmetric('int1e_ovlp')
 
-    ls12 = scipy.linalg.solve(s[:nao,:nao], s[:nao,nao:], sym_pos=True)
+    ls12 = scipy.linalg.solve(s[:nao,:nao], s[:nao,nao:], assume_a='pos')
     s[nao:,nao:] -= s[nao:,:nao].dot(ls12)
     w, v = scipy.linalg.eigh(s[nao:,nao:])
     c2 = v[:,w>lindep]/numpy.sqrt(w[w>lindep])
     c1 = ls12.dot(c2)
     return cabs_mol, numpy.vstack((-c1,c2))
 
 def trans(eri, mos):
```

### Comparing `pyscf-2.2.1/pyscf/mp/ump2.py` & `pyscf-2.3.0/pyscf/mp/ump2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mrpt/__init__.py` & `pyscf-2.3.0/pyscf/mrpt/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/mrpt/nevpt2.py` & `pyscf-2.3.0/pyscf/mrpt/nevpt2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/__init__.py` & `pyscf-2.3.0/pyscf/pbc/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/adc/__init__.py` & `pyscf-2.3.0/pyscf/pbc/adc/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/adc/dfadc.py` & `pyscf-2.3.0/pyscf/pbc/adc/dfadc.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/adc/kadc_ao2mo.py` & `pyscf-2.3.0/pyscf/pbc/adc/kadc_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/adc/kadc_rhf.py` & `pyscf-2.3.0/pyscf/pbc/adc/kadc_rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/adc/kadc_rhf_amplitudes.py` & `pyscf-2.3.0/pyscf/pbc/adc/kadc_rhf_amplitudes.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/adc/kadc_rhf_ea.py` & `pyscf-2.3.0/pyscf/pbc/adc/kadc_rhf_ea.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/adc/kadc_rhf_ip.py` & `pyscf-2.3.0/pyscf/pbc/adc/kadc_rhf_ip.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/ao2mo/__init__.py` & `pyscf-2.3.0/pyscf/pbc/ao2mo/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/ao2mo/eris.py` & `pyscf-2.3.0/pyscf/pbc/ao2mo/eris.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/__init__.py` & `pyscf-2.3.0/pyscf/pbc/cc/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/ccsd.py` & `pyscf-2.3.0/pyscf/pbc/cc/ccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_ghf.py` & `pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_ghf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_rhf.py` & `pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_rhf_ea.py` & `pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_rhf_ea.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_rhf_ip.py` & `pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_rhf_ip.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/eom_kccsd_uhf.py` & `pyscf-2.3.0/pyscf/pbc/cc/eom_kccsd_uhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kccsd.py` & `pyscf-2.3.0/pyscf/pbc/cc/kccsd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kccsd_rhf.py` & `pyscf-2.3.0/pyscf/pbc/cc/kccsd_rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kccsd_rhf_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/cc/kccsd_rhf_ksymm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kccsd_t.py` & `pyscf-2.3.0/pyscf/pbc/cc/kccsd_t.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kccsd_t_rhf.py` & `pyscf-2.3.0/pyscf/pbc/cc/kccsd_t_rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kccsd_t_rhf_slow.py` & `pyscf-2.3.0/pyscf/pbc/cc/kccsd_t_rhf_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kccsd_uhf.py` & `pyscf-2.3.0/pyscf/pbc/cc/kccsd_uhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kintermediates.py` & `pyscf-2.3.0/pyscf/pbc/cc/kintermediates.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kintermediates_rhf.py` & `pyscf-2.3.0/pyscf/pbc/cc/kintermediates_rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kintermediates_rhf_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/cc/kintermediates_rhf_ksymm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kintermediates_uhf.py` & `pyscf-2.3.0/pyscf/pbc/cc/kintermediates_uhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/cc/kuccsd_rdm.py` & `pyscf-2.3.0/pyscf/pbc/cc/kuccsd_rdm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/ci/__init__.py` & `pyscf-2.3.0/pyscf/pbc/ci/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/ci/cisd.py` & `pyscf-2.3.0/pyscf/pbc/ci/cisd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/ci/kcis_rhf.py` & `pyscf-2.3.0/pyscf/pbc/ci/kcis_rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/df/__init__.py` & `pyscf-2.3.0/pyscf/pbc/df/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/df/aft.py` & `pyscf-2.3.0/pyscf/pbc/tools/pbc.py`

 * *Files 22% similar despite different names*

```diff
@@ -8,581 +8,698 @@
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-#
-# Author: Qiming Sun <osirpt.sun@gmail.com>
-#
-
-'''Density expansion on plane waves'''
-
 
+import warnings
 import copy
-import contextlib
-import numpy
+import numpy as np
+import scipy.linalg
 from pyscf import lib
-from pyscf import gto
 from pyscf.lib import logger
-from pyscf.pbc import tools
-from pyscf.pbc.gto import pseudo, estimate_ke_cutoff, error_for_ke_cutoff
-from pyscf.pbc import gto as pbcgto
-from pyscf.pbc.df import ft_ao
-from pyscf.pbc.lib.kpts_helper import is_zero, gamma_point
-from pyscf.pbc.df import aft_jk
-from pyscf.pbc.df import aft_ao2mo
-from pyscf.pbc.df.incore import _IntNucBuilder, _compensate_nuccell
-from pyscf.pbc.tools import k2gamma
-from pyscf.pbc.tools import pbc as pbctools
+from pyscf.gto import ATM_SLOTS, BAS_SLOTS, ATOM_OF, PTR_COORD
+from pyscf.pbc.lib.kpts_helper import get_kconserv, get_kconserv3  # noqa
 from pyscf import __config__
 
+FFT_ENGINE = getattr(__config__, 'pbc_tools_pbc_fft_engine', 'BLAS')
+
+def _fftn_blas(f, mesh):
+    Gx = np.fft.fftfreq(mesh[0])
+    Gy = np.fft.fftfreq(mesh[1])
+    Gz = np.fft.fftfreq(mesh[2])
+    expRGx = np.exp(np.einsum('x,k->xk', -2j*np.pi*np.arange(mesh[0]), Gx))
+    expRGy = np.exp(np.einsum('x,k->xk', -2j*np.pi*np.arange(mesh[1]), Gy))
+    expRGz = np.exp(np.einsum('x,k->xk', -2j*np.pi*np.arange(mesh[2]), Gz))
+    out = np.empty(f.shape, dtype=np.complex128)
+    buf = np.empty(mesh, dtype=np.complex128)
+    for i, fi in enumerate(f):
+        buf[:] = fi.reshape(mesh)
+        g = lib.dot(buf.reshape(mesh[0],-1).T, expRGx, c=out[i].reshape(-1,mesh[0]))
+        g = lib.dot(g.reshape(mesh[1],-1).T, expRGy, c=buf.reshape(-1,mesh[1]))
+        g = lib.dot(g.reshape(mesh[2],-1).T, expRGz, c=out[i].reshape(-1,mesh[2]))
+    return out.reshape(-1, *mesh)
+
+def _ifftn_blas(g, mesh):
+    Gx = np.fft.fftfreq(mesh[0])
+    Gy = np.fft.fftfreq(mesh[1])
+    Gz = np.fft.fftfreq(mesh[2])
+    expRGx = np.exp(np.einsum('x,k->xk', 2j*np.pi*np.arange(mesh[0]), Gx))
+    expRGy = np.exp(np.einsum('x,k->xk', 2j*np.pi*np.arange(mesh[1]), Gy))
+    expRGz = np.exp(np.einsum('x,k->xk', 2j*np.pi*np.arange(mesh[2]), Gz))
+    out = np.empty(g.shape, dtype=np.complex128)
+    buf = np.empty(mesh, dtype=np.complex128)
+    for i, gi in enumerate(g):
+        buf[:] = gi.reshape(mesh)
+        f = lib.dot(buf.reshape(mesh[0],-1).T, expRGx, 1./mesh[0], c=out[i].reshape(-1,mesh[0]))
+        f = lib.dot(f.reshape(mesh[1],-1).T, expRGy, 1./mesh[1], c=buf.reshape(-1,mesh[1]))
+        f = lib.dot(f.reshape(mesh[2],-1).T, expRGz, 1./mesh[2], c=out[i].reshape(-1,mesh[2]))
+    return out.reshape(-1, *mesh)
+
+if FFT_ENGINE == 'FFTW':
+    # pyfftw is slower than np.fft in most cases
+    try:
+        import pyfftw
+        pyfftw.interfaces.cache.enable()
+        nproc = lib.num_threads()
+        def _fftn_wrapper(a):
+            return pyfftw.interfaces.numpy_fft.fftn(a, axes=(1,2,3), threads=nproc)
+        def _ifftn_wrapper(a):
+            return pyfftw.interfaces.numpy_fft.ifftn(a, axes=(1,2,3), threads=nproc)
+    except ImportError:
+        def _fftn_wrapper(a):
+            return np.fft.fftn(a, axes=(1,2,3))
+        def _ifftn_wrapper(a):
+            return np.fft.ifftn(a, axes=(1,2,3))
+
+elif FFT_ENGINE == 'NUMPY':
+    def _fftn_wrapper(a):
+        return np.fft.fftn(a, axes=(1,2,3))
+    def _ifftn_wrapper(a):
+        return np.fft.ifftn(a, axes=(1,2,3))
+
+elif FFT_ENGINE == 'NUMPY+BLAS':
+    _EXCLUDE = [17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,
+                83, 89, 97,101,103,107,109,113,127,131,137,139,149,151,157,163,
+                167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,
+                257,263,269,271,277,281,283,293]
+    _EXCLUDE = set(_EXCLUDE + [n*2 for n in _EXCLUDE] + [n*3 for n in _EXCLUDE])
+    def _fftn_wrapper(a):
+        mesh = a.shape[1:]
+        if mesh[0] in _EXCLUDE and mesh[1] in _EXCLUDE and mesh[2] in _EXCLUDE:
+            return _fftn_blas(a, mesh)
+        else:
+            return np.fft.fftn(a, axes=(1,2,3))
+    def _ifftn_wrapper(a):
+        mesh = a.shape[1:]
+        if mesh[0] in _EXCLUDE and mesh[1] in _EXCLUDE and mesh[2] in _EXCLUDE:
+            return _ifftn_blas(a, mesh)
+        else:
+            return np.fft.ifftn(a, axes=(1,2,3))
+
+#?elif:  # 'FFTW+BLAS'
+else:  # 'BLAS'
+    def _fftn_wrapper(a):
+        mesh = a.shape[1:]
+        return _fftn_blas(a, mesh)
+    def _ifftn_wrapper(a):
+        mesh = a.shape[1:]
+        return _ifftn_blas(a, mesh)
+
+
+def fft(f, mesh):
+    '''Perform the 3D FFT from real (R) to reciprocal (G) space.
+
+    After FFT, (u, v, w) -> (j, k, l).
+    (jkl) is in the index order of Gv.
+
+    FFT normalization factor is 1., as in MH and in `numpy.fft`.
+
+    Args:
+        f : (nx*ny*nz,) ndarray
+            The function to be FFT'd, flattened to a 1D array corresponding
+            to the index order of :func:`cartesian_prod`.
+        mesh : (3,) ndarray of ints (= nx,ny,nz)
+            The number G-vectors along each direction.
+
+    Returns:
+        (nx*ny*nz,) ndarray
+            The FFT 1D array in same index order as Gv (natural order of
+            numpy.fft).
 
-CUTOFF = getattr(__config__, 'pbc_df_aft_estimate_eta_cutoff', 1e-12)
-ETA_MIN = getattr(__config__, 'pbc_df_aft_estimate_eta_min', 0.2)
-OMEGA_MIN = getattr(__config__, 'pbc_df_aft_estimate_omega_min', 0.3)
-PRECISION = getattr(__config__, 'pbc_df_aft_estimate_eta_precision', 1e-8)
-KE_SCALING = getattr(__config__, 'pbc_df_aft_ke_cutoff_scaling', 0.75)
-
-def estimate_eta_min(cell, cutoff=CUTOFF):
-    '''Given rcut the boundary of repeated images of the cell, estimates the
-    minimal exponent of the smooth compensated gaussian model charge, requiring
-    that at boundary, density ~ 4pi rmax^2 exp(-eta/2*rmax^2) < cutoff
-    '''
-    lmax = min(numpy.max(cell._bas[:,gto.ANG_OF]), 4)
-    # If lmax=3 (r^5 for radial part), this expression guarantees at least up
-    # to f shell the convergence at boundary
-    rcut = cell.rcut
-    eta = max(numpy.log(4*numpy.pi*rcut**(lmax+2)/cutoff)/rcut**2, ETA_MIN)
-    return eta
-
-estimate_eta = estimate_eta_min
-
-def estimate_eta_for_ke_cutoff(cell, ke_cutoff, precision=PRECISION):
-    '''Given ke_cutoff, the upper bound of eta to produce the required
-    precision in AFTDF Coulomb integrals.
-    '''
-    # search eta for interaction between GTO(eta) and point charge at the same
-    # location so that
-    # \sum_{k^2/2 > ke_cutoff} weight*4*pi/k^2 GTO(eta, k) < precision
-    # GTO(eta, k) = Fourier transform of Gaussian e^{-eta r^2}
-
-    lmax = numpy.max(cell._bas[:,gto.ANG_OF])
-    kmax = (ke_cutoff*2)**.5
-    # The interaction between two s-type density distributions should be
-    # enough for the error estimation.  Put lmax here to increate Ecut for
-    # slightly better accuracy
-    log_rest = numpy.log(precision / (32*numpy.pi**2 * kmax**max(0, lmax-1)))
-    log_eta = -1
-    eta = kmax**2/4 / (-log_eta - log_rest)
-    return eta
-
-def estimate_ke_cutoff_for_eta(cell, eta, precision=PRECISION):
-    '''Given eta, the lower bound of ke_cutoff to produce the required
-    precision in AFTDF Coulomb integrals.
-    '''
-    # estimate ke_cutoff for interaction between GTO(eta) and point charge at
-    # the same location so that
-    # \sum_{k^2/2 > ke_cutoff} weight*4*pi/k^2 GTO(eta, k) < precision
-    # \sum_{k^2/2 > ke_cutoff} weight*4*pi/k^2 GTO(eta, k)
-    # ~ \int_kmax^infty 4*pi/k^2 GTO(eta,k) dk^3
-    # = (4*pi)^2 *2*eta/kmax^{n-1} e^{-kmax^2/4eta} + ... < precision
-
-    # The magic number 0.2 comes from AFTDF.__init__ and GDF.__init__
-    # eta = max(eta, ETA_MIN)
-
-    log_k0 = 3 + numpy.log(eta) / 2
-    log_rest = numpy.log(precision / (32*numpy.pi**2*eta))
-    # The interaction between two s-type density distributions should be
-    # enough for the error estimation.  Put lmax here to increate Ecut for
-    # slightly better accuracy
-    lmax = numpy.max(cell._bas[:,gto.ANG_OF])
-    Ecut = 2*eta * (log_k0*max(0, lmax-1) - log_rest)
-    Ecut = max(Ecut, .5)
-    return Ecut
-
-def estimate_omega_min(cell, cutoff=CUTOFF):
-    '''Given cell.rcut the boundary of repeated images of the cell, estimates
-    the minimal omega for the attenuated Coulomb interactions, requiring that at
-    boundary the Coulomb potential of a point charge < cutoff
-    '''
-    # erfc(z) = 2/\sqrt(pi) int_z^infty exp(-t^2) dt < exp(-z^2)/(z\sqrt(pi))
-    # erfc(omega*rcut)/rcut < cutoff
-    # ~ exp(-(omega*rcut)**2) / (omega*rcut**2*pi**.5) < cutoff
-    rcut = cell.rcut
-    omega = OMEGA_MIN
-    omega = max((-numpy.log(cutoff * rcut**2 * omega))**.5 / rcut, OMEGA_MIN)
-    return omega
-
-estimate_omega = estimate_omega_min
-
-# \sum_{k^2/2 > ke_cutoff} weight*4*pi/k^2 exp(-k^2/(4 omega^2)) rho(k) < precision
-# ~ 16 pi^2 int_cutoff^infty exp(-k^2/(4*omega^2)) dk
-# = 16 pi^{5/2} omega erfc(sqrt(ke_cutoff/(2*omega^2)))
-# ~ 16 pi^2 exp(-ke_cutoff/(2*omega^2)))
-def estimate_ke_cutoff_for_omega(cell, omega, precision=None):
-    '''Energy cutoff to converge attenuated Coulomb in moment space
     '''
-    if precision is None:
-        precision = cell.precision
-    precision *= 1e-2
-    lmax = numpy.max(cell._bas[:,gto.ANG_OF])
-    ke_cutoff = -2*omega**2 * numpy.log(precision / (16*numpy.pi**2))
-    ke_cutoff = -2*omega**2 * numpy.log(precision / (16*numpy.pi**2*(ke_cutoff*2)**(.5*lmax)))
-    return ke_cutoff
+    if f.size == 0:
+        return np.zeros_like(f)
+
+    f3d = f.reshape(-1, *mesh)
+    assert (f3d.shape[0] == 1 or f[0].size == f3d[0].size)
+    g3d = _fftn_wrapper(f3d)
+    ngrids = np.prod(mesh)
+    if f.ndim == 1 or (f.ndim == 3 and f.size == ngrids):
+        return g3d.ravel()
+    else:
+        return g3d.reshape(-1, ngrids)
+
+def ifft(g, mesh):
+    '''Perform the 3D inverse FFT from reciprocal (G) space to real (R) space.
+
+    Inverse FFT normalization factor is 1./N, same as in `numpy.fft` but
+    **different** from MH (they use 1.).
+
+    Args:
+        g : (nx*ny*nz,) ndarray
+            The function to be inverse FFT'd, flattened to a 1D array
+            corresponding to the index order of `span3`.
+        mesh : (3,) ndarray of ints (= nx,ny,nz)
+            The number G-vectors along each direction.
+
+    Returns:
+        (nx*ny*nz,) ndarray
+            The inverse FFT 1D array in same index order as Gv (natural order
+            of numpy.fft).
 
-def estimate_omega_for_ke_cutoff(cell, ke_cutoff, precision=None):
-    '''The minimal omega in attenuated Coulombl given energy cutoff
     '''
-    if precision is None:
-        precision = cell.precision
-    # esitimation based on \int dk 4pi/k^2 exp(-k^2/4omega) sometimes is not
-    # enough to converge the 2-electron integrals. A penalty term here is to
-    # reduce the error in integrals
-    precision *= 1e-2
-    # Consider l>0 basis here to increate Ecut for slightly better accuracy
-    lmax = numpy.max(cell._bas[:,gto.ANG_OF])
-    kmax = (ke_cutoff*2)**.5
-    log_rest = numpy.log(precision / (16*numpy.pi**2 * kmax**lmax))
-    omega = (-.5 * ke_cutoff / log_rest)**.5
-    return omega
-
-def get_pp_loc_part1(mydf, kpts=None):
-    if kpts is None:
-        kpts_lst = numpy.zeros((1,3))
+    if g.size == 0:
+        return np.zeros_like(g)
+
+    g3d = g.reshape(-1, *mesh)
+    assert (g3d.shape[0] == 1 or g[0].size == g3d[0].size)
+    f3d = _ifftn_wrapper(g3d)
+    ngrids = np.prod(mesh)
+    if g.ndim == 1 or (g.ndim == 3 and g.size == ngrids):
+        return f3d.ravel()
     else:
-        kpts_lst = numpy.reshape(kpts, (-1,3))
+        return f3d.reshape(-1, ngrids)
 
-    if mydf.eta != 0:
-        dfbuilder = _IntNucBuilder(mydf.cell, kpts_lst)
-        vj = dfbuilder.get_pp_loc_part1()
-        if kpts is None or numpy.shape(kpts) == (3,):
-            vj = vj[0]
-        return numpy.asarray(vj)
-
-    log = logger.Logger(mydf.stdout, mydf.verbose)
-    t0 = t1 = (logger.process_clock(), logger.perf_counter())
-
-    cell = mydf.cell
-    mesh = numpy.asarray(mydf.mesh)
-    nkpts = len(kpts_lst)
-    nao = cell.nao_nr()
-    nao_pair = nao * (nao+1) // 2
-
-    kpt_allow = numpy.zeros(3)
-    if cell.dimension > 0:
-        ke_guess = estimate_ke_cutoff(cell, cell.precision)
-        mesh_guess = tools.cutoff_to_mesh(cell.lattice_vectors(), ke_guess)
-        if numpy.any(mesh[:cell.dimension] < mesh_guess[:cell.dimension]*.8):
-            logger.warn(mydf, 'mesh %s is not enough for AFTDF.get_nuc function '
-                        'to get integral accuracy %g.\nRecommended mesh is %s.',
-                        mesh, cell.precision, mesh_guess)
-    log.debug1('aft.get_pp_loc_part1 mesh = %s', mesh)
-    Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
-
-    vpplocG = pseudo.pp_int.get_gth_vlocG_part1(cell, Gv)
-    vpplocG = -numpy.einsum('ij,ij->j', cell.get_SI(Gv), vpplocG)
-
-    vpplocG *= kws
-    vG = vpplocG
-    vj = numpy.zeros((nkpts,nao_pair), dtype=numpy.complex128)
-
-    max_memory = max(2000, mydf.max_memory-lib.current_memory()[0])
-    for aoaoks, p0, p1 in mydf.ft_loop(mesh, kpt_allow, kpts_lst,
-                                       max_memory=max_memory, aosym='s2'):
-        for k, aoao in enumerate(aoaoks):
-            # rho_ij(G) nuc(-G) / G^2
-            # = [Re(rho_ij(G)) + Im(rho_ij(G))*1j] [Re(nuc(G)) - Im(nuc(G))*1j] / G^2
-            if gamma_point(kpts_lst[k]):
-                vj[k] += numpy.einsum('k,kx->x', vG[p0:p1].real, aoao.real)
-                vj[k] += numpy.einsum('k,kx->x', vG[p0:p1].imag, aoao.imag)
-            else:
-                vj[k] += numpy.einsum('k,kx->x', vG[p0:p1].conj(), aoao)
-        t1 = log.timer_debug1('contracting Vnuc [%s:%s]'%(p0, p1), *t1)
-    log.timer_debug1('contracting Vnuc', *t0)
-
-    vj_kpts = []
-    for k, kpt in enumerate(kpts_lst):
-        if gamma_point(kpt):
-            vj_kpts.append(lib.unpack_tril(vj[k].real))
-        else:
-            vj_kpts.append(lib.unpack_tril(vj[k]))
 
-    if kpts is None or numpy.shape(kpts) == (3,):
-        vj_kpts = vj_kpts[0]
-    return numpy.asarray(vj_kpts)
-
-def _int_nuc_vloc(mydf, nuccell, kpts, intor='int3c2e', aosym='s2', comp=1):
-    '''Vnuc - Vloc'''
-    dfbuilder = _IntNucBuilder(mydf.cell, kpts)
-    return dfbuilder._int_nuc_vloc(nuccell, intor, aosym)
-
-def get_pp(mydf, kpts=None):
-    '''Get the periodic pseudotential nuc-el AO matrix, with G=0 removed.
-    '''
-    t0 = (logger.process_clock(), logger.perf_counter())
-    dfbuilder = _IntNucBuilder(mydf.cell, kpts)
-    vpp = dfbuilder.get_pp(mydf.mesh)
-    if kpts is None or numpy.shape(kpts) == (3,):
-        vpp = vpp[0]
-    logger.timer(mydf, 'get_pp', *t0)
-    return vpp
-
-def get_nuc(mydf, kpts=None):
-    t0 = (logger.process_clock(), logger.perf_counter())
-    dfbuilder = _IntNucBuilder(mydf.cell, kpts)
-    vj = dfbuilder.get_nuc(mydf.mesh)
-    if kpts is None or numpy.shape(kpts) == (3,):
-        vj = vj[0]
-    logger.timer(mydf, 'get_nuc', *t0)
-    return vj
-
-def weighted_coulG(mydf, kpt=numpy.zeros(3), exx=False, mesh=None, omega=None):
-    '''Weighted regular Coulomb kernel, applying cell.omega by default'''
-    cell = mydf.cell
+def fftk(f, mesh, expmikr):
+    r'''Perform the 3D FFT of a real-space function which is (periodic*e^{ikr}).
+
+    fk(k+G) = \sum_r fk(r) e^{-i(k+G)r} = \sum_r [f(k)e^{-ikr}] e^{-iGr}
+    '''
+    return fft(f*expmikr, mesh)
+
+
+def ifftk(g, mesh, expikr):
+    r'''Perform the 3D inverse FFT of f(k+G) into a function which is (periodic*e^{ikr}).
+
+    fk(r) = (1/Ng) \sum_G fk(k+G) e^{i(k+G)r} = (1/Ng) \sum_G [fk(k+G)e^{iGr}] e^{ikr}
+    '''
+    return ifft(g, mesh) * expikr
+
+
+def get_coulG(cell, k=np.zeros(3), exx=False, mf=None, mesh=None, Gv=None,
+              wrap_around=True, omega=None, **kwargs):
+    '''Calculate the Coulomb kernel for all G-vectors, handling G=0 and exchange.
+
+    Args:
+        k : (3,) ndarray
+            k-point
+        exx : bool or str
+            Whether this is an exchange matrix element.
+        mf : instance of :class:`SCF`
+
+    Returns:
+        coulG : (ngrids,) ndarray
+            The Coulomb kernel.
+        mesh : (3,) ndarray of ints (= nx,ny,nz)
+            The number G-vectors along each direction.
+        omega : float
+            Enable Coulomb kernel erf(|omega|*r12)/r12 if omega > 0
+            and erfc(|omega|*r12)/r12 if omega < 0.
+            Note this parameter is slightly different to setting cell.omega
+            for the treatment of exxdiv (at G0).  cell.omega affects Ewald
+            probe charge at G0. It is used mostly by RSH functionals for
+            the long-range part of HF exchange. This parameter is used by
+            range-separated JK builder and range-separated DF (and other
+            range-separated integral methods) which require Ewald probe charge
+            to be computed with regular Coulomb interaction (1/r12).
+    '''
+    exxdiv = exx
+    if isinstance(exx, str):
+        exxdiv = exx
+    elif exx and mf is not None:
+        exxdiv = mf.exxdiv
+
     if mesh is None:
-        mesh = mydf.mesh
-    if omega is None:
-        omega = cell.omega
-    Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
-    coulG = tools.get_coulG(cell, kpt, exx, mydf, mesh, Gv, omega=omega)
-    coulG *= kws
+        mesh = cell.mesh
+    if 'gs' in kwargs:
+        warnings.warn('cell.gs is deprecated.  It is replaced by cell.mesh,'
+                      'the number of PWs (=2*gs+1) along each direction.')
+        mesh = [2*n+1 for n in kwargs['gs']]
+    if Gv is None:
+        Gv = cell.get_Gv(mesh)
+
+    if abs(k).sum() > 1e-9:
+        kG = k + Gv
+    else:
+        kG = Gv
+
+    equal2boundary = np.zeros(Gv.shape[0], dtype=bool)
+    if wrap_around and abs(k).sum() > 1e-9:
+        # Here we 'wrap around' the high frequency k+G vectors into their lower
+        # frequency counterparts.  Important if you want the gamma point and k-point
+        # answers to agree
+        b = cell.reciprocal_vectors()
+        box_edge = np.einsum('i,ij->ij', np.asarray(mesh)//2+0.5, b)
+        assert (all(np.linalg.solve(box_edge.T, k).round(9).astype(int)==0))
+        reduced_coords = np.linalg.solve(box_edge.T, kG.T).T.round(9)
+        on_edge = reduced_coords.astype(int)
+        if cell.dimension >= 1:
+            equal2boundary |= reduced_coords[:,0] == 1
+            equal2boundary |= reduced_coords[:,0] ==-1
+            kG[on_edge[:,0]== 1] -= 2 * box_edge[0]
+            kG[on_edge[:,0]==-1] += 2 * box_edge[0]
+        if cell.dimension >= 2:
+            equal2boundary |= reduced_coords[:,1] == 1
+            equal2boundary |= reduced_coords[:,1] ==-1
+            kG[on_edge[:,1]== 1] -= 2 * box_edge[1]
+            kG[on_edge[:,1]==-1] += 2 * box_edge[1]
+        if cell.dimension == 3:
+            equal2boundary |= reduced_coords[:,2] == 1
+            equal2boundary |= reduced_coords[:,2] ==-1
+            kG[on_edge[:,2]== 1] -= 2 * box_edge[2]
+            kG[on_edge[:,2]==-1] += 2 * box_edge[2]
+
+    absG2 = np.einsum('gi,gi->g', kG, kG)
+
+    if getattr(mf, 'kpts', None) is not None:
+        kpts = mf.kpts
+    else:
+        kpts = k.reshape(1,3)
+    Nk = len(kpts)
+
+    if exxdiv == 'vcut_sph':  # PRB 77 193110
+        Rc = (3*Nk*cell.vol/(4*np.pi))**(1./3)
+        with np.errstate(divide='ignore',invalid='ignore'):
+            coulG = 4*np.pi/absG2*(1.0 - np.cos(np.sqrt(absG2)*Rc))
+        coulG[absG2==0] = 4*np.pi*0.5*Rc**2
+
+        if cell.dimension < 3:
+            raise NotImplementedError
+
+    elif exxdiv == 'vcut_ws':  # PRB 87, 165122
+        assert (cell.dimension == 3)
+        if not getattr(mf, '_ws_exx', None):
+            mf._ws_exx = precompute_exx(cell, kpts)
+        exx_alpha = mf._ws_exx['alpha']
+        exx_kcell = mf._ws_exx['kcell']
+        exx_q = mf._ws_exx['q']
+        exx_vq = mf._ws_exx['vq']
+
+        with np.errstate(divide='ignore',invalid='ignore'):
+            coulG = 4*np.pi/absG2*(1.0 - np.exp(-absG2/(4*exx_alpha**2)))
+        coulG[absG2==0] = np.pi / exx_alpha**2
+        # Index k+Gv into the precomputed vq and add on
+        gxyz = np.dot(kG, exx_kcell.lattice_vectors().T)/(2*np.pi)
+        gxyz = gxyz.round(decimals=6).astype(int)
+        mesh = np.asarray(exx_kcell.mesh)
+        gxyz = (gxyz + mesh)%mesh
+        qidx = (gxyz[:,0]*mesh[1] + gxyz[:,1])*mesh[2] + gxyz[:,2]
+        #qidx = [np.linalg.norm(exx_q-kGi,axis=1).argmin() for kGi in kG]
+        maxqv = abs(exx_q).max(axis=0)
+        is_lt_maxqv = (abs(kG) <= maxqv).all(axis=1)
+        coulG = coulG.astype(exx_vq.dtype)
+        coulG[is_lt_maxqv] += exx_vq[qidx[is_lt_maxqv]]
+
+        if cell.dimension < 3:
+            raise NotImplementedError
+
+    else:
+        # Ewald probe charge method to get the leading term of the finite size
+        # error in exchange integrals
+
+        G0_idx = np.where(absG2==0)[0]
+        if cell.dimension != 2 or cell.low_dim_ft_type == 'inf_vacuum':
+            with np.errstate(divide='ignore'):
+                coulG = 4*np.pi/absG2
+                coulG[G0_idx] = 0
+
+        elif cell.dimension == 2:
+            # The following 2D analytical fourier transform is taken from:
+            # R. Sundararaman and T. Arias PRB 87, 2013
+            b = cell.reciprocal_vectors()
+            Ld2 = np.pi/np.linalg.norm(b[2])
+            Gz = kG[:,2]
+            Gp = np.linalg.norm(kG[:,:2], axis=1)
+            weights = 1. - np.cos(Gz*Ld2) * np.exp(-Gp*Ld2)
+            with np.errstate(divide='ignore', invalid='ignore'):
+                coulG = weights*4*np.pi/absG2
+            if len(G0_idx) > 0:
+                coulG[G0_idx] = -2*np.pi*Ld2**2 #-pi*L_z^2/2
+
+        elif cell.dimension == 1:
+            logger.warn(cell, 'No method for PBC dimension 1, dim-type %s.'
+                        '  cell.low_dim_ft_type="inf_vacuum"  should be set.',
+                        cell.low_dim_ft_type)
+            raise NotImplementedError
+
+            # Carlo A. Rozzi, PRB 73, 205119 (2006)
+            a = cell.lattice_vectors()
+            # Rc is the cylindrical radius
+            Rc = np.sqrt(cell.vol / np.linalg.norm(a[0])) / 2
+            Gx = abs(kG[:,0])
+            Gp = np.linalg.norm(kG[:,1:], axis=1)
+            with np.errstate(divide='ignore', invalid='ignore'):
+                weights = 1 + Gp*Rc * scipy.special.j1(Gp*Rc) * scipy.special.k0(Gx*Rc)
+                weights -= Gx*Rc * scipy.special.j0(Gp*Rc) * scipy.special.k1(Gx*Rc)
+                coulG = 4*np.pi/absG2 * weights
+                # TODO: numerical integation
+                # coulG[Gx==0] = -4*np.pi * (dr * r * scipy.special.j0(Gp*r) * np.log(r)).sum()
+            if len(G0_idx) > 0:
+                coulG[G0_idx] = -np.pi*Rc**2 * (2*np.log(Rc) - 1)
+
+        # The divergent part of periodic summation of (ii|ii) integrals in
+        # Coulomb integrals were cancelled out by electron-nucleus
+        # interaction. The periodic part of (ii|ii) in exchange cannot be
+        # cancelled out by Coulomb integrals. Its leading term is calculated
+        # using Ewald probe charge (the function madelung below)
+        if cell.dimension > 0 and exxdiv == 'ewald' and len(G0_idx) > 0:
+            coulG[G0_idx] += Nk*cell.vol*madelung(cell, kpts)
+
+    coulG[equal2boundary] = 0
+
+    # Scale the coulG kernel for attenuated Coulomb integrals.
+    # * omega is used by RangeSeparatedJKBuilder which requires ewald probe charge
+    # being evaluated with regular Coulomb interaction (1/r12).
+    # * cell.omega, which affects the ewald probe charge, is often set by
+    # DFT-RSH functionals to build long-range HF-exchange for erf(omega*r12)/r12
+    if omega is not None:
+        if omega > 0:
+            # long range part
+            coulG *= np.exp(-.25/omega**2 * absG2)
+        elif omega < 0:
+            # short range part
+            coulG *= (1 - np.exp(-.25/omega**2 * absG2))
+    elif cell.omega > 0:
+        coulG *= np.exp(-.25/cell.omega**2 * absG2)
+    elif cell.omega < 0:
+        raise NotImplementedError
+
     return coulG
 
+def precompute_exx(cell, kpts):
+    from pyscf.pbc import gto as pbcgto
+    from pyscf.pbc.dft import gen_grid
+    log = lib.logger.Logger(cell.stdout, cell.verbose)
+    log.debug("# Precomputing Wigner-Seitz EXX kernel")
+    Nk = get_monkhorst_pack_size(cell, kpts)
+    log.debug("# Nk = %s", Nk)
+
+    kcell = pbcgto.Cell()
+    kcell.atom = 'H 0. 0. 0.'
+    kcell.spin = 1
+    kcell.unit = 'B'
+    kcell.verbose = 0
+    kcell.a = cell.lattice_vectors() * Nk
+    Lc = 1.0/lib.norm(np.linalg.inv(kcell.a), axis=0)
+    log.debug("# Lc = %s", Lc)
+    Rin = Lc.min() / 2.0
+    log.debug("# Rin = %s", Rin)
+    # ASE:
+    alpha = 5./Rin # sqrt(-ln eps) / Rc, eps ~ 10^{-11}
+    log.info("WS alpha = %s", alpha)
+    kcell.mesh = np.array([4*int(L*alpha*3.0) for L in Lc])  # ~ [120,120,120]
+    # QE:
+    #alpha = 3./Rin * np.sqrt(0.5)
+    #kcell.mesh = (4*alpha*np.linalg.norm(kcell.a,axis=1)).astype(int)
+    log.debug("# kcell.mesh FFT = %s", kcell.mesh)
+    rs = kcell.get_uniform_grids(wrap_around=False)
+    kngs = len(rs)
+    log.debug("# kcell kngs = %d", kngs)
+    corners_coord = lib.cartesian_prod(([0, 1], [0, 1], [0, 1]))
+    corners = np.dot(corners_coord, kcell.a)
+    #vR = np.empty(kngs)
+    #for i, rv in enumerate(rs):
+    #    # Minimum image convention to corners of kcell parallelepiped
+    #    r = lib.norm(rv-corners, axis=1).min()
+    #    if np.isclose(r, 0.):
+    #        vR[i] = 2*alpha / np.sqrt(np.pi)
+    #    else:
+    #        vR[i] = scipy.special.erf(alpha*r) / r
+    r = np.min([lib.norm(rs-c, axis=1) for c in corners], axis=0)
+    vR = scipy.special.erf(alpha*r) / (r+1e-200)
+    vR[r<1e-9] = 2*alpha / np.sqrt(np.pi)
+    vG = (kcell.vol/kngs) * fft(vR, kcell.mesh)
+
+    if abs(vG.imag).max() > 1e-6:
+        # vG should be real in regular lattice. If imaginary part is observed,
+        # this probably means a ws cell was built from a unconventional
+        # lattice. The SR potential erfc(alpha*r) for the charge in the center
+        # of ws cell decays to the region out of ws cell. The Ewald-sum based
+        # on the minimum image convention cannot be used to build the kernel
+        # Eq (12) of PRB 87, 165122
+        raise RuntimeError('Unconventional lattice was found')
+
+    ws_exx = {'alpha': alpha,
+              'kcell': kcell,
+              'q'    : kcell.Gv,
+              'vq'   : vG.real.copy()}
+    log.debug("# Finished precomputing")
+    return ws_exx
+
+
+def madelung(cell, kpts):
+    Nk = get_monkhorst_pack_size(cell, kpts)
+    ecell = copy.copy(cell)
+    ecell._atm = np.array([[1, cell._env.size, 0, 0, 0, 0]])
+    ecell._env = np.append(cell._env, [0., 0., 0.])
+    ecell.unit = 'B'
+    #ecell.verbose = 0
+    ecell.a = a = np.einsum('xi,x->xi', cell.lattice_vectors(), Nk)
 
-class AFTDFMixin:
+    if cell.omega == 0:
+        return -2*ecell.ewald()
 
-    weighted_coulG = weighted_coulG
-    _int_nuc_vloc = _int_nuc_vloc
-    get_nuc = get_nuc
-    get_pp = get_pp
-
-    def pw_loop(self, mesh=None, kpti_kptj=None, q=None, shls_slice=None,
-                max_memory=2000, aosym='s1', blksize=None,
-                intor='GTO_ft_ovlp', comp=1, bvk_kmesh=None):
-        '''
-        Fourier transform iterator for AO pair
-        '''
-        cell = self.cell
-        if mesh is None:
-            mesh = self.mesh
-        if kpti_kptj is None:
-            kpti = kptj = numpy.zeros(3)
-        else:
-            kpti, kptj = kpti_kptj
-        if q is None:
-            q = kptj - kpti
-
-        ao_loc = cell.ao_loc_nr()
-        Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
-        gxyz = lib.cartesian_prod([numpy.arange(len(x)) for x in Gvbase])
-        ngrids = gxyz.shape[0]
-
-        if shls_slice is None:
-            shls_slice = (0, cell.nbas, 0, cell.nbas)
-        if aosym == 's2':
-            assert (shls_slice[2] == 0)
-            i0 = ao_loc[shls_slice[0]]
-            i1 = ao_loc[shls_slice[1]]
-            nij = i1*(i1+1)//2 - i0*(i0+1)//2
-        else:
-            ni = ao_loc[shls_slice[1]] - ao_loc[shls_slice[0]]
-            nj = ao_loc[shls_slice[3]] - ao_loc[shls_slice[2]]
-            nij = ni*nj
-
-        if blksize is None:
-            blksize = min(max(64, int(max_memory*1e6*.75/(nij*16*comp))), 16384)
-            sublk = int(blksize//4)
-        else:
-            sublk = blksize
-        buf = numpy.empty(nij*blksize*comp, dtype=numpy.complex128)
-        pqkRbuf = numpy.empty(nij*sublk*comp)
-        pqkIbuf = numpy.empty(nij*sublk*comp)
-
-        if bvk_kmesh is None:
-            bvk_kmesh = k2gamma.kpts_to_kmesh(cell, [kpti, kptj])
-        supmol_ft = ft_ao._ExtendedMole.from_cell(cell, bvk_kmesh).strip_basis()
-        ft_kern = supmol_ft.gen_ft_kernel(aosym, intor=intor, comp=comp)
-
-        for p0, p1 in self.prange(0, ngrids, blksize):
-            aoaoR, aoaoI = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, q,
-                                   kptj.reshape(1, 3), shls_slice, out=buf)
-            aoaoR = aoaoR.reshape(comp,p1-p0,nij)
-            aoaoI = aoaoI.reshape(comp,p1-p0,nij)
-
-            for i0, i1 in lib.prange(0, p1-p0, sublk):
-                nG = i1 - i0
-                if comp == 1:
-                    pqkR = numpy.ndarray((nij,nG), buffer=pqkRbuf)
-                    pqkI = numpy.ndarray((nij,nG), buffer=pqkIbuf)
-                    pqkR[:] = aoaoR[0,i0:i1].T
-                    pqkI[:] = aoaoI[0,i0:i1].T
-                else:
-                    pqkR = numpy.ndarray((comp,nij,nG), buffer=pqkRbuf)
-                    pqkI = numpy.ndarray((comp,nij,nG), buffer=pqkIbuf)
-                    pqkR[:] = aoaoR[:,i0:i1].transpose(0,2,1)
-                    pqkI[:] = aoaoI[:,i0:i1].transpose(0,2,1)
-                yield (pqkR, pqkI, p0+i0, p0+i1)
-
-    def ft_loop(self, mesh=None, q=numpy.zeros(3), kpts=None, shls_slice=None,
-                max_memory=4000, aosym='s1', intor='GTO_ft_ovlp', comp=1,
-                bvk_kmesh=None):
-        '''
-        Fourier transform iterator for all kpti which satisfy
-            2pi*N = (kpts - kpti - q)*a,  N = -1, 0, 1
-        '''
-        cell = self.cell
-        if mesh is None:
-            mesh = self.mesh
-        if kpts is None:
-            assert (is_zero(q))
-            kpts = self.kpts
-        kpts = numpy.asarray(kpts)
-        nkpts = len(kpts)
-
-        ao_loc = cell.ao_loc_nr()
-        Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
-        gxyz = lib.cartesian_prod([numpy.arange(len(x)) for x in Gvbase])
-        ngrids = gxyz.shape[0]
-
-        if shls_slice is None:
-            shls_slice = (0, cell.nbas, 0, cell.nbas)
-        if aosym == 's2':
-            assert (shls_slice[2] == 0)
-            i0 = ao_loc[shls_slice[0]]
-            i1 = ao_loc[shls_slice[1]]
-            nij = i1*(i1+1)//2 - i0*(i0+1)//2
-        else:
-            ni = ao_loc[shls_slice[1]] - ao_loc[shls_slice[0]]
-            nj = ao_loc[shls_slice[3]] - ao_loc[shls_slice[2]]
-            nij = ni*nj
-
-        if bvk_kmesh is None:
-            bvk_kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
-        # ke_cutoff = pbctools.mesh_to_cutoff(cell.lattice_vectors(), mesh)
-        # rs_cell = ft_ao._RangeSeparatedCell.from_cell(cell, ke_cutoff, ft_ao.RCUT_THRESHOLD)
-        supmol_ft = ft_ao._ExtendedMole.from_cell(cell, bvk_kmesh).strip_basis()
-        ft_kern = supmol_ft.gen_ft_kernel(aosym, intor=intor, comp=comp,
-                                          return_complex=True)
-
-        blksize = max(16, int(max_memory*.9e6/(nij*nkpts*16*comp)))
-        blksize = min(blksize, ngrids, 16384)
-        buf = numpy.empty(nkpts*nij*blksize*comp, dtype=numpy.complex128)
-
-        for p0, p1 in self.prange(0, ngrids, blksize):
-            dat = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, q, kpts, shls_slice, out=buf)
-            yield dat, p0, p1
-
-    @contextlib.contextmanager
-    def range_coulomb(self, omega):
-        '''Creates a temporary density fitting object for RSH-DF integrals.
-        In this context, only LR or SR integrals for mol and auxmol are computed.
-        '''
-        key = '%.6f' % omega
-        if key in self._rsh_df:
-            rsh_df = self._rsh_df[key]
-        else:
-            rsh_df = self._rsh_df[key] = copy.copy(self).reset()
-            logger.info(self, 'Create RSH-DF object %s for omega=%s', rsh_df, omega)
+    else:
+        # cell.ewald function does not use the Coulomb kernel function
+        # get_coulG. When computing the nuclear interactions with attenuated
+        # Coulomb operator, the Ewald summation technique is not needed
+        # because the Coulomb kernel 4pi/G^2*exp(-G^2/4/omega**2) decays
+        # quickly.
+        precision = cell.precision
+        omega = cell.omega
+        Ecut = 10.
+        Ecut = np.log(16*np.pi**2/(2*omega**2*(2*Ecut)**.5) / precision + 1.) * 2*omega**2
+        Ecut = np.log(16*np.pi**2/(2*omega**2*(2*Ecut)**.5) / precision + 1.) * 2*omega**2
+        mesh = cutoff_to_mesh(a, Ecut)
+        Gv, Gvbase, weights = ecell.get_Gv_weights(mesh)
+        wcoulG = get_coulG(ecell, Gv=Gv) * weights
+        SI = ecell.get_SI(mesh=mesh)
+        ZSI = SI[0]
+        return 2*omega/np.pi**0.5-np.einsum('i,i,i->', ZSI.conj(), ZSI, wcoulG).real
+
+
+def get_monkhorst_pack_size(cell, kpts, tol=1e-5):
+    kpts = np.reshape(kpts, (-1,3))
+    min_tol = tol
+    assert kpts.shape[0] < 1/min_tol
+    if kpts.shape[0] == 1:
+        Nk = np.array([1,1,1])
+    else:
+        tol = max(10**(-int(-np.log10(1/kpts.shape[0]))-2), min_tol)
+        skpts = cell.get_scaled_kpts(kpts)
+        Nk = np.array([np.count_nonzero(abs(ski[1:]-ski[:-1]) > tol) + 1
+                       for ski in np.sort(skpts.T)])
+    return Nk
 
-        cell = self.cell
-        auxcell = getattr(self, 'auxcell', None)
 
-        cell_omega = cell.omega
-        cell.omega = omega
-        auxcell_omega = None
-        if auxcell is not None:
-            auxcell_omega = auxcell.omega
-            auxcell.omega = omega
-
-        assert rsh_df.cell.omega == omega
-        if getattr(rsh_df, 'auxcell', None) is not None:
-            assert rsh_df.auxcell.omega == omega
-
-        try:
-            yield rsh_df
-        finally:
-            cell.omega = cell_omega
-            if auxcell_omega is not None:
-                auxcell.omega = auxcell_omega
-
-
-class AFTDF(lib.StreamObject, AFTDFMixin):
-    '''Density expansion on plane waves
-    '''
-    def __init__(self, cell, kpts=numpy.zeros((1,3))):
-        self.cell = cell
-        self.stdout = cell.stdout
-        self.verbose = cell.verbose
-        self.max_memory = cell.max_memory
-        self.mesh = cell.mesh
-# For nuclear attraction integrals using Ewald-like technique.
-# Set to 0 to switch off Ewald tech and use the regular reciprocal space
-# method (solving Poisson equation of nuclear charges in reciprocal space).
-        if cell.dimension == 0:
-            self.eta = 0.2
-        else:
-            ke_cutoff = tools.mesh_to_cutoff(cell.lattice_vectors(), self.mesh)
-            ke_cutoff = ke_cutoff[:cell.dimension].min()
-            self.eta = max(estimate_eta_for_ke_cutoff(cell, ke_cutoff, cell.precision),
-                           estimate_eta(cell, cell.precision))
-        self.kpts = kpts
-
-        # to mimic molecular DF object
-        self.blockdim = getattr(__config__, 'pbc_df_df_DF_blockdim', 240)
-
-        # The following attributes are not input options.
-        self._rsh_df = {}  # Range separated Coulomb DF objects
-        self._keys = set(self.__dict__.keys())
-
-    def dump_flags(self, verbose=None):
-        logger.info(self, '\n')
-        logger.info(self, '******** %s ********', self.__class__)
-        logger.info(self, 'mesh = %s (%d PWs)', self.mesh, numpy.prod(self.mesh))
-        logger.info(self, 'eta = %s', self.eta)
-        logger.info(self, 'len(kpts) = %d', len(self.kpts))
-        logger.debug1(self, '    kpts = %s', self.kpts)
-        return self
-
-    def reset(self, cell=None):
-        if cell is not None:
-            self.cell = cell
-        self._rsh_df = {}
-        return self
-
-    def check_sanity(self):
-        lib.StreamObject.check_sanity(self)
-        cell = self.cell
-        if not cell.has_ecp():
-            logger.warn(self, 'AFTDF integrals are found in all-electron '
-                        'calculation.  It often causes huge error.\n'
-                        'Recommended methods are DF or MDF. In SCF calculation, '
-                        'they can be initialized as\n'
-                        '        mf = mf.density_fit()\nor\n'
-                        '        mf = mf.mix_density_fit()')
-
-        if cell.dimension > 0:
-            if cell.ke_cutoff is None:
-                ke_cutoff = tools.mesh_to_cutoff(cell.lattice_vectors(), self.mesh)
-                ke_cutoff = ke_cutoff[:cell.dimension].min()
-            else:
-                ke_cutoff = numpy.min(cell.ke_cutoff)
-            ke_guess = estimate_ke_cutoff(cell, cell.precision)
-            mesh_guess = tools.cutoff_to_mesh(cell.lattice_vectors(), ke_guess)
-            if ke_cutoff < ke_guess * KE_SCALING:
-                logger.warn(self, 'ke_cutoff/mesh (%g / %s) is not enough for AFTDF '
-                            'to get integral accuracy %g.\nCoulomb integral error '
-                            'is ~ %.2g Eh.\nRecommended ke_cutoff/mesh are %g / %s.',
-                            ke_cutoff, self.mesh, cell.precision,
-                            error_for_ke_cutoff(cell, ke_cutoff), ke_guess, mesh_guess)
+def get_lattice_Ls(cell, nimgs=None, rcut=None, dimension=None, discard=True):
+    '''Get the (Cartesian, unitful) lattice translation vectors for nearby images.
+    The translation vectors can be used for the lattice summation.
+
+    Kwargs:
+        discard:
+            Drop less important Ls based on AO values on grid
+    '''
+    if dimension is None:
+        # For atoms near the boundary of the cell, it is necessary (even in low-
+        # dimensional systems) to include lattice translations in all 3 dimensions.
+        if cell.dimension < 2 or cell.low_dim_ft_type == 'inf_vacuum':
+            dimension = cell.dimension
         else:
-            mesh_guess = numpy.copy(self.mesh)
+            dimension = 3
+    if rcut is None:
+        rcut = cell.rcut
+
+    if dimension == 0 or rcut <= 0:
+        return np.zeros((1, 3))
+
+    a = cell.lattice_vectors()
+
+    scaled_atom_coords = np.linalg.solve(a.T, cell.atom_coords().T).T
+    atom_boundary_max = scaled_atom_coords[:,:dimension].max(axis=0)
+    atom_boundary_min = scaled_atom_coords[:,:dimension].min(axis=0)
+    if (np.any(atom_boundary_max > 1) or np.any(atom_boundary_min < -1)):
+        atom_boundary_max[atom_boundary_max > 1] = 1
+        atom_boundary_min[atom_boundary_min <-1] = -1
+    ovlp_penalty = atom_boundary_max - atom_boundary_min
+    dR = ovlp_penalty.dot(a[:dimension])
+    dR_basis = np.diag(dR)
+
+    # Search the minimal x,y,z requiring |x*a[0]+y*a[1]+z*a[2]+dR|^2 > rcut^2
+    # Ls boundary should be derived by decomposing (a, Rij) for each atom-pair.
+    # For reasons unclear, the so-obtained Ls boundary seems not large enough.
+    # The upper-bound of the Ls boundary is generated by find_boundary function.
+    def find_boundary(a):
+        aR = np.vstack([a, dR_basis])
+        r = np.linalg.qr(aR.T)[1]
+        ub = (rcut + abs(r[2,3:]).sum()) / abs(r[2,2])
+        return ub
+
+    xb = find_boundary(a[[1,2,0]])
+    if dimension > 1:
+        yb = find_boundary(a[[2,0,1]])
+    else:
+        yb = 0
+    if dimension > 2:
+        zb = find_boundary(a)
+    else:
+        zb = 0
+    bounds = np.ceil([xb, yb, zb]).astype(int)
+    Ts = lib.cartesian_prod((np.arange(-bounds[0], bounds[0]+1),
+                             np.arange(-bounds[1], bounds[1]+1),
+                             np.arange(-bounds[2], bounds[2]+1)))
+    Ls = np.dot(Ts[:,:dimension], a[:dimension])
+
+    ovlp_penalty += 1e-200  # avoid /0
+    Ts_scaled = (Ts[:,:dimension] + 1e-200) / ovlp_penalty
+    ovlp_penalty_fac = 1. / abs(Ts_scaled).min(axis=1)
+    Ls_mask = np.linalg.norm(Ls, axis=1) * (1-ovlp_penalty_fac) < rcut
+    Ls = Ls[Ls_mask]
+    return np.asarray(Ls, order='C')
+
+
+def super_cell(cell, ncopy, wrap_around=False):
+    '''Create an ncopy[0] x ncopy[1] x ncopy[2] supercell of the input cell
+    Note this function differs from :fun:`cell_plus_imgs` that cell_plus_imgs
+    creates images in both +/- direction.
+
+    Args:
+        cell : instance of :class:`Cell`
+        ncopy : (3,) array
+        wrap_around : bool
+            Put the original cell centered on the super cell. It has the
+            effects corresponding to the parameter wrap_around of
+            cell.make_kpts.
 
-        if cell.dimension < 3:
-            err = numpy.exp(-0.436392335*min(self.mesh[cell.dimension:]) - 2.99944305)
-            err *= cell.nelectron
-            meshz = pbcgto.cell._mesh_inf_vaccum(cell)
-            mesh_guess[cell.dimension:] = int(meshz)
-            if err > cell.precision*10:
-                logger.warn(self, 'mesh %s of AFTDF may not be enough to get '
-                            'integral accuracy %g for %dD PBC system.\n'
-                            'Coulomb integral error is ~ %.2g Eh.\n'
-                            'Recommended mesh is %s.',
-                            self.mesh, cell.precision, cell.dimension, err, mesh_guess)
-            if any(x/meshz > 1.1 for x in cell.mesh[cell.dimension:]):
-                meshz = pbcgto.cell._mesh_inf_vaccum(cell)
-                logger.warn(self, 'setting mesh %s of AFTDF too high in non-periodic direction '
-                            '(=%s) can result in an unnecessarily slow calculation.\n'
-                            'For coulomb integral error of ~ %.2g Eh in %dD PBC, \n'
-                            'a recommended mesh for non-periodic direction is %s.',
-                            self.mesh, self.mesh[cell.dimension:], cell.precision,
-                            cell.dimension, mesh_guess[cell.dimension:])
-        return self
-
-    def build(self):
-        return self.check_sanity()
-
-    # Note: Special exxdiv by default should not be used for an arbitrary
-    # input density matrix. When the df object was used with the molecular
-    # post-HF code, get_jk was often called with an incomplete DM (e.g. the
-    # core DM in CASCI). An SCF level exxdiv treatment is inadequate for
-    # post-HF methods.
-    def get_jk(self, dm, hermi=1, kpts=None, kpts_band=None,
-               with_j=True, with_k=True, omega=None, exxdiv=None):
-        if omega is not None:  # J/K for RSH functionals
-            with self.range_coulomb(omega) as rsh_df:
-                return rsh_df.get_jk(dm, hermi, kpts, kpts_band, with_j, with_k,
-                                     omega=None, exxdiv=exxdiv)
-
-        if kpts is None:
-            if numpy.all(self.kpts == 0):
-                # Gamma-point calculation by default
-                kpts = numpy.zeros(3)
-            else:
-                kpts = self.kpts
-        kpts = numpy.asarray(kpts)
-
-        if kpts.shape == (3,):
-            return aft_jk.get_jk(self, dm, hermi, kpts, kpts_band, with_j,
-                                  with_k, exxdiv)
-
-        vj = vk = None
-        if with_k:
-            vk = aft_jk.get_k_kpts(self, dm, hermi, kpts, kpts_band, exxdiv)
-        if with_j:
-            vj = aft_jk.get_j_kpts(self, dm, hermi, kpts, kpts_band)
-        return vj, vk
-
-    get_eri = get_ao_eri = aft_ao2mo.get_eri
-    ao2mo = get_mo_eri = aft_ao2mo.general
-    ao2mo_7d = aft_ao2mo.ao2mo_7d
-    get_ao_pairs_G = get_ao_pairs = aft_ao2mo.get_ao_pairs_G
-    get_mo_pairs_G = get_mo_pairs = aft_ao2mo.get_mo_pairs_G
-
-    def update_mf(self, mf):
-        mf = copy.copy(mf)
-        mf.with_df = self
-        return mf
-
-    def prange(self, start, stop, step):
-        '''This is a hook for MPI parallelization. DO NOT use it out of the
-        scope of AFTDF/GDF/MDF.
-        '''
-        return lib.prange(start, stop, step)
-
-################################################################################
-# With this function to mimic the molecular DF.loop function, the pbc gamma
-# point DF object can be used in the molecular code
-    def loop(self, blksize=None):
-        cell = self.cell
-        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
-            raise RuntimeError('ERIs of PBC-2D systems are not positive '
-                               'definite. Current API only supports postive '
-                               'definite ERIs.')
-
-        if blksize is None:
-            blksize = self.blockdim
-        # coulG of 1D and 2D has negative elements.
-        coulG = self.weighted_coulG()
-        Lpq = None
-        for pqkR, pqkI, p0, p1 in self.pw_loop(aosym='s2', blksize=blksize):
-            vG = numpy.sqrt(coulG[p0:p1])
-            pqkR *= vG
-            pqkI *= vG
-            Lpq = lib.transpose(pqkR, out=Lpq)
-            yield Lpq
-            Lpq = lib.transpose(pqkI, out=Lpq)
-            yield Lpq
-
-    def get_naoaux(self):
-        mesh = numpy.asarray(self.mesh)
-        ngrids = numpy.prod(mesh)
-        return ngrids * 2
-
-def _sub_df_jk_(dfobj, dm, hermi=1, kpts=None, kpts_band=None,
-                with_j=True, with_k=True, omega=None, exxdiv=None):
-    with dfobj.range_coulomb(omega) as rsh_df:
-        return rsh_df.get_jk(dm, hermi, kpts, kpts_band, with_j, with_k,
-                             omega=None, exxdiv=exxdiv)
+    Returns:
+        supcell : instance of :class:`Cell`
+    '''
+    a = cell.lattice_vectors()
+    #:supcell.atom = []
+    #:for Lx in range(ncopy[0]):
+    #:    for Ly in range(ncopy[1]):
+    #:        for Lz in range(ncopy[2]):
+    #:            # Using cell._atom guarantees coord is in Bohr
+    #:            for atom, coord in cell._atom:
+    #:                L = np.dot([Lx, Ly, Lz], a)
+    #:                supcell.atom.append([atom, coord + L])
+    xs = np.arange(ncopy[0])
+    ys = np.arange(ncopy[1])
+    zs = np.arange(ncopy[2])
+    if wrap_around:
+        xs[(ncopy[0]+1)//2:] -= ncopy[0]
+        ys[(ncopy[1]+1)//2:] -= ncopy[1]
+        zs[(ncopy[2]+1)//2:] -= ncopy[2]
+    Ts = lib.cartesian_prod((xs, ys, zs))
+    Ls = np.dot(Ts, a)
+    supcell = copy.copy(cell)
+    supcell.a = np.einsum('i,ij->ij', ncopy, a)
+    mesh = np.asarray(ncopy) * np.asarray(cell.mesh)
+    supcell.mesh = (mesh // 2) * 2 + 1
+    return _build_supcell_(supcell, cell, Ls)
+
+
+def cell_plus_imgs(cell, nimgs):
+    '''Create a supercell via nimgs[i] in each +/- direction, as in get_lattice_Ls().
+    Note this function differs from :fun:`super_cell` that super_cell only
+    stacks the images in + direction.
+
+    Args:
+        cell : instance of :class:`Cell`
+        nimgs : (3,) array
+
+    Returns:
+        supcell : instance of :class:`Cell`
+    '''
+    a = cell.lattice_vectors()
+    Ts = lib.cartesian_prod((np.arange(-nimgs[0], nimgs[0]+1),
+                             np.arange(-nimgs[1], nimgs[1]+1),
+                             np.arange(-nimgs[2], nimgs[2]+1)))
+    Ls = np.dot(Ts, a)
+    supcell = copy.copy(cell)
+    supcell.a = np.einsum('i,ij->ij', nimgs, a)
+    supcell.mesh = np.array([(nimgs[0]*2+1)*cell.mesh[0],
+                             (nimgs[1]*2+1)*cell.mesh[1],
+                             (nimgs[2]*2+1)*cell.mesh[2]])
+    return _build_supcell_(supcell, cell, Ls)
+
+def _build_supcell_(supcell, cell, Ls):
+    '''
+    Construct supcell ._env directly without calling supcell.build() method.
+    This reserves the basis contraction coefficients defined in cell
+    '''
+    nimgs = len(Ls)
+    symbs = [atom[0] for atom in cell._atom] * nimgs
+    coords = Ls.reshape(-1,1,3) + cell.atom_coords()
+    coords = coords.reshape(-1,3)
+    x, y, z = coords.T
+    supcell.atom = supcell._atom = list(zip(symbs, zip(x, y, z)))
+    supcell.unit = 'B'
+
+    # Do not call supcell.build() to initialize supcell since it may normalize
+    # the basis contraction coefficients
+
+    # preserves environments defined in cell._env (e.g. omega, gauge origin)
+    _env = np.append(cell._env, coords.ravel())
+    _atm = np.repeat(cell._atm[None,:,:], nimgs, axis=0)
+    _atm = _atm.reshape(-1, ATM_SLOTS)
+    # Point to the corrdinates appended to _env
+    _atm[:,PTR_COORD] = cell._env.size + np.arange(nimgs * cell.natm) * 3
+
+    _bas = np.repeat(cell._bas[None,:,:], nimgs, axis=0)
+    # For atom pointers in each image, shift natm*image_id
+    _bas[:,:,ATOM_OF] += np.arange(nimgs)[:,None] * cell.natm
+
+    supcell._atm = np.asarray(_atm, dtype=np.int32)
+    supcell._bas = np.asarray(_bas.reshape(-1, BAS_SLOTS), dtype=np.int32)
+    supcell._env = _env
+    return supcell
+
+
+def cutoff_to_mesh(a, cutoff):
+    r'''
+    Convert KE cutoff to FFT-mesh
+
+        uses KE = k^2 / 2, where k_max ~ \pi / grid_spacing
+
+    Args:
+        a : (3,3) ndarray
+            The real-space cell lattice vectors. Each row represents a
+            lattice vector.
+        cutoff : float
+            KE energy cutoff in a.u.
+
+    Returns:
+        mesh : (3,) array
+    '''
+    # Search the minimal x,y,z requiring |x*b[0]+y*b[1]+z*b[2]|^2 > 2 * cutoff
+    b = 2 * np.pi * np.linalg.inv(a.T)
+    rx = np.linalg.qr(b[[1,2,0]].T)[1][2,2]
+    ry = np.linalg.qr(b[[2,0,1]].T)[1][2,2]
+    rz = np.linalg.qr(b.T)[1][2,2]
+
+    Gmax = (2*cutoff)**.5 / np.abs([rx, ry, rz])
+    mesh = np.ceil(Gmax).astype(int) * 2 + 1
+    return mesh
 
-del(CUTOFF, PRECISION)
+def mesh_to_cutoff(a, mesh):
+    '''
+    Convert #grid points to KE cutoff
+    '''
+    # Search the minimal x,y,z requiring |x*b[0]+y*b[1]+z*b[2]|^2 > 2 * cutoff
+    b = 2 * np.pi * np.linalg.inv(a.T)
+    rx = np.linalg.qr(b[[1,2,0]].T)[1][2,2]
+    ry = np.linalg.qr(b[[2,0,1]].T)[1][2,2]
+    rz = np.linalg.qr(b.T)[1][2,2]
+
+    gs = (np.asarray(mesh) - 1) // 2
+    Gmax = gs * np.array([rx, ry, rz])
+    ke_cutoff = Gmax**2 / 2
+    return ke_cutoff
+
+def cutoff_to_gs(a, cutoff):
+    '''Deprecated.  Replaced by function cutoff_to_mesh.'''
+    return [n//2 for n in cutoff_to_mesh(a, cutoff)]
+
+def gs_to_cutoff(a, gs):
+    '''Deprecated.  Replaced by function mesh_to_cutoff.'''
+    return mesh_to_cutoff(a, [2*n+1 for n in gs])
+
+def round_to_cell0(r, tol=1e-6):
+    '''Round scaled coordinates to reference unit cell
+    '''
+    from pyscf.pbc.lib import kpts_helper
+    return kpts_helper.round_to_fbz(r, wrap_around=False, tol=tol)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/aft_ao2mo.py` & `pyscf-2.3.0/pyscf/pbc/df/aft_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/df/df.py` & `pyscf-2.3.0/pyscf/pbc/df/df.py`

 * *Files 2% similar despite different names*

```diff
@@ -42,39 +42,40 @@
 from pyscf import lib
 from pyscf import gto
 from pyscf.lib import logger
 from pyscf.df import addons
 from pyscf.df.outcore import _guess_shell_ranges
 from pyscf.pbc.gto.cell import _estimate_rcut
 from pyscf.pbc import tools
+from pyscf.pbc.df import incore
 from pyscf.pbc.df import outcore
 from pyscf.pbc.df import ft_ao
 from pyscf.pbc.df import aft
 from pyscf.pbc.df import df_jk
 from pyscf.pbc.df import df_ao2mo
-from pyscf.pbc.df.aft import estimate_eta, get_nuc
+from pyscf.pbc.df.aft import estimate_eta, _check_kpts
 from pyscf.pbc.df.df_jk import zdotCN
 from pyscf.pbc.lib.kpts_helper import (is_zero, gamma_point, member, unique,
                                        KPT_DIFF_TOL)
-from pyscf.pbc.df.gdf_builder import libpbc, _CCGDFBuilder, _guess_eta
-from pyscf.pbc.df.rsdf_builder import _RSGDFBuilder
+from pyscf.pbc.df.gdf_builder import libpbc, _CCGDFBuilder, _CCNucBuilder
+from pyscf.pbc.df.rsdf_builder import _RSGDFBuilder, _RSNucBuilder
 from pyscf import __config__
 
 LINEAR_DEP_THR = getattr(__config__, 'pbc_df_df_DF_lindep', 1e-9)
 LONGRANGE_AFT_TURNOVER_THRESHOLD = 2.5
 
 
 def make_modrho_basis(cell, auxbasis=None, drop_eta=None):
     r'''Generate a cell object using the density fitting auxbasis as
     the basis set. The normalization coeffcients of the auxiliary cell are
     different to the regular (square-norm) convention. To simplify the
     compensated charge algorithm, they are normalized against
     \int (r^l e^{-ar^2} r^2 dr
     '''
-    auxcell = addons.make_auxmol(cell, auxbasis)
+    auxcell = incore.make_auxcell(cell, auxbasis)
 
 # Note libcint library will multiply the norm of the integration over spheric
 # part sqrt(4pi) to the basis.
     half_sph_norm = numpy.sqrt(.25/numpy.pi)
     steep_shls = []
     ndrop = 0
     rcut = []
@@ -100,15 +101,15 @@
 # \int (r^l e^{-ar^2} * Y_{lm}) (r^l Y_{lm}) r^2 dr d\Omega
             int1 = gto.gaussian_int(l*2+2, es)
             s = numpy.einsum('pi,p->i', cs, int1)
 # The auxiliary basis normalization factor is not a must for density expansion.
 # half_sph_norm here to normalize the monopole (charge).  This convention can
 # simplify the formulism of \int \bar{\rho}, see function auxbar.
             cs = numpy.einsum('pi,i->pi', cs, half_sph_norm/s)
-            _env[ptr:ptr+np*nc] = cs.T.reshape(-1)
+            _env[ptr:ptr+np*nc] = cs.T.ravel()
 
             steep_shls.append(ib)
 
             r = _estimate_rcut(es, l, abs(cs).max(axis=1), cell.precision)
             rcut.append(r.max())
 
     auxcell._env = _env
@@ -180,15 +181,14 @@
             self._cderi = None
 
     def reset(self, cell=None):
         if cell is not None:
             self.cell = cell
         self.auxcell = None
         self._cderi = None
-        self._cderi_to_save = tempfile.NamedTemporaryFile(dir=lib.param.TMPDIR)
         self._rsh_df = {}
         return self
 
     @property
     def gs(self):
         return [n//2 for n in self.mesh]
     @gs.setter
@@ -220,17 +220,14 @@
         log.info('len(kpts) = %d', len(self.kpts))
         log.debug1('    kpts = %s', self.kpts)
         if self.kpts_band is not None:
             log.info('len(kpts_band) = %d', len(self.kpts_band))
             log.debug1('    kpts_band = %s', self.kpts_band)
         return self
 
-    def check_sanity(self):
-        return lib.StreamObject.check_sanity(self)
-
     def build(self, j_only=None, with_j3c=True, kpts_band=None):
         if j_only is not None:
             self._j_only = j_only
         if self.kpts_band is not None:
             self.kpts_band = numpy.reshape(self.kpts_band, (-1,3))
         if kpts_band is not None:
             kpts_band = numpy.reshape(kpts_band, (-1,3))
@@ -241,15 +238,15 @@
 
         self.check_sanity()
         self.dump_flags()
 
         self.auxcell = make_modrho_basis(self.cell, self.auxbasis,
                                          self.exp_to_discard)
 
-        if with_j3c:
+        if with_j3c and self._cderi_to_save is not None:
             if isinstance(self._cderi_to_save, str):
                 cderi = self._cderi_to_save
             else:
                 cderi = self._cderi_to_save.name
             if isinstance(self._cderi, str):
                 if self._cderi == cderi and os.path.isfile(cderi):
                     logger.warn(self, 'File %s (specified by ._cderi) is '
@@ -282,15 +279,16 @@
             dfbuilder = _CCGDFBuilder(cell, auxcell, kpts_union)
             dfbuilder.eta = self.eta
         else:
             dfbuilder = _RSGDFBuilder(cell, auxcell, kpts_union)
         dfbuilder.mesh = self.mesh
         dfbuilder.linear_dep_threshold = self.linear_dep_threshold
         j_only = self._j_only or len(kpts_union) == 1
-        dfbuilder.make_j3c(cderi_file, j_only=j_only, dataname=self._dataname)
+        dfbuilder.make_j3c(cderi_file, j_only=j_only, dataname=self._dataname,
+                           kptij_lst=kptij_lst)
 
     def cderi_array(self, label=None):
         '''
         Returns CDERIArray object which provides numpy APIs to access cderi tensor.
         '''
         if label is None:
             label = self._dataname
@@ -328,15 +326,15 @@
             blksize = max(16, min(int(blksize), self.blockdim))
             logger.debug3(self, 'max_memory %d MB, blksize %d', max_memory, blksize)
 
         def load(aux_slice):
             b0, b1 = aux_slice
             naux = b1 - b0
             if is_real:
-                LpqR = numpy.asarray(j3c[b0:b1])
+                LpqR = numpy.asarray(j3c[b0:b1].real)
                 if compact and LpqR.shape[1] == nao**2:
                     LpqR = lib.pack_tril(LpqR.reshape(naux,nao,nao))
                 elif unpack and LpqR.shape[1] != nao**2:
                     LpqR = lib.unpack_tril(LpqR).reshape(naux,nao**2)
                 LpqI = numpy.zeros_like(LpqR)
             else:
                 Lpq = numpy.asarray(j3c[b0:b1])
@@ -363,17 +361,43 @@
             with _load3c(self._cderi, self._dataname+'-', kpti_kptj,
                          ignore_key_error=True) as j3c:
                 slices = lib.prange(0, j3c.shape[0], blksize)
                 for LpqR, LpqI in lib.map_with_prefetch(load, slices):
                     yield LpqR, LpqI, -1
                     LpqR = LpqI = None
 
-    _int_nuc_vloc = aft._int_nuc_vloc
-    get_nuc = aft.get_nuc  # noqa: F811
-    get_pp = aft.get_pp
+    def get_pp(self, kpts=None):
+        '''Get the periodic pseudotential nuc-el AO matrix, with G=0 removed.
+        '''
+        cell = self.cell
+        kpts, is_single_kpt = _check_kpts(self, kpts)
+        if self._prefer_ccdf or cell.omega > 0:
+            # For long-range integrals _CCGDFBuilder is the only option
+            dfbuilder = _CCNucBuilder(cell, kpts).build()
+        else:
+            dfbuilder = _RSNucBuilder(cell, kpts).build()
+        vpp = dfbuilder.get_pp()
+        if is_single_kpt:
+            vpp = vpp[0]
+        return vpp
+
+    def get_nuc(self, kpts=None):
+        '''Get the periodic nuc-el AO matrix, with G=0 removed.
+        '''
+        cell = self.cell
+        kpts, is_single_kpt = _check_kpts(self, kpts)
+        if self._prefer_ccdf or cell.omega > 0:
+            # For long-range integrals _CCGDFBuilder is the only option
+            dfbuilder = _CCNucBuilder(cell, kpts).build()
+        else:
+            dfbuilder = _RSNucBuilder(cell, kpts).build()
+        nuc = dfbuilder.get_nuc()
+        if is_single_kpt:
+            nuc = nuc[0]
+        return nuc
 
     # Note: Special exxdiv by default should not be used for an arbitrary
     # input density matrix. When the df object was used with the molecular
     # post-HF code, get_jk was often called with an incomplete DM (e.g. the
     # core DM in CASCI). An SCF level exxdiv treatment is inadequate for
     # post-HF methods.
     def get_jk(self, dm, hermi=1, kpts=None, kpts_band=None,
@@ -389,31 +413,24 @@
             # * The sparse mesh is not appropriate for low dimensional systems
             #   with infinity vacuum since the ERI may require large mesh to
             #   sample density in vacuum.
             if (omega < LONGRANGE_AFT_TURNOVER_THRESHOLD and
                 cell.dimension >= 2 and cell.low_dim_ft_type != 'inf_vacuum'):
                 mydf = aft.AFTDF(cell, self.kpts)
                 ke_cutoff = aft.estimate_ke_cutoff_for_omega(cell, omega)
-                mydf.mesh = tools.cutoff_to_mesh(cell.lattice_vectors(), ke_cutoff)
+                mydf.mesh = cell.cutoff_to_mesh(ke_cutoff)
             else:
                 mydf = self
             with mydf.range_coulomb(omega) as rsh_df:
                 return rsh_df.get_jk(dm, hermi, kpts, kpts_band, with_j, with_k,
                                      omega=None, exxdiv=exxdiv)
 
-        if kpts is None:
-            if numpy.all(self.kpts == 0):
-                # Gamma-point calculation by default
-                kpts = numpy.zeros(3)
-            else:
-                kpts = self.kpts
-        kpts = numpy.asarray(kpts)
-
-        if kpts.shape == (3,):
-            return df_jk.get_jk(self, dm, hermi, kpts, kpts_band, with_j,
+        kpts, is_single_kpt = _check_kpts(self, kpts)
+        if is_single_kpt:
+            return df_jk.get_jk(self, dm, hermi, kpts[0], kpts_band, with_j,
                                 with_k, exxdiv)
 
         vj = vk = None
         if with_k:
             vk = df_jk.get_k_kpts(self, dm, hermi, kpts, kpts_band, exxdiv)
         if with_j:
             vj = df_jk.get_j_kpts(self, dm, hermi, kpts, kpts_band)
@@ -459,31 +476,47 @@
 
     def get_naoaux(self):
         '''The dimension of auxiliary basis at gamma point'''
 # determine naoaux with self._cderi, because DF object may be used as CD
 # object when self._cderi is provided.
         if self._cderi is None:
             self.build()
+
+        cell = self.cell
+        if isinstance(self._cderi, numpy.ndarray):
+            # self._cderi is likely offered by user. Ensure
+            # cderi.shape = (nkpts,naux,nao_pair)
+            nao = cell.nao
+            if self._cderi.shape[-1] == nao:
+                assert self._cderi.ndim == 4
+                naux = self._cderi.shape[1]
+            elif self._cderi.shape[-1] in (nao**2, nao*(nao+1)//2):
+                assert self._cderi.ndim == 3
+                naux = self._cderi.shape[1]
+            else:
+                raise RuntimeError('cderi shape')
+            return naux
+
         # self._cderi['j3c/k_id/seg_id']
-        with addons.load(self._cderi, f'{self._dataname}/0') as feri:
-            if isinstance(feri, h5py.Group):
-                naux = feri['0'].shape[0]
+        with h5py.File(self._cderi, 'r') as feri:
+            key = next(iter(feri[self._dataname].keys()))
+            dat = feri[f'{self._dataname}/{key}']
+            if isinstance(dat, h5py.Group):
+                naux = dat['0'].shape[0]
             else:
-                naux = feri.shape[0]
+                naux = dat.shape[0]
 
-        cell = self.cell
-        if (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum' and
-            not isinstance(self._cderi, numpy.ndarray)):
-            with h5py.File(self._cderi, 'r') as feri:
-                if f'{self._dataname}-/0' in feri:
-                    dat = feri[f'{self._dataname}-/0']
-                    if isinstance(dat, h5py.Group):
-                        naux += dat['0'].shape[0]
-                    else:
-                        naux += dat.shape[0]
+            if (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum' and
+                f'{self._dataname}-' in feri):
+                key = next(iter(feri[f'{self._dataname}-'].keys()))
+                dat = feri[f'{self._dataname}-/{key}']
+                if isinstance(dat, h5py.Group):
+                    naux += dat['0'].shape[0]
+                else:
+                    naux += dat.shape[0]
         return naux
 
 DF = GDF
 
 class CDERIArray:
     '''
     Provide numpy APIs to access cderi tensor. This object can be viewed as an
@@ -511,24 +544,28 @@
         aosym = data_group['aosym'][()]
         if isinstance(aosym, bytes):
             aosym = aosym.decode()
         self.aosym = aosym
         self.j3c = data_group[label]
         self.kpts = data_group['kpts'][:]
         self.nkpts = self.kpts.shape[0]
-        nao_pair = sum(dat.shape[1] for dat in self.j3c['0'].values())
+        self.naux = 0
+        nao_pair = 0
+        for dat in self.j3c.values():
+            nao_pair = sum(x.shape[1] for x in dat.values())
+            self.naux = dat['0'].shape[0]
+            break
         if self.aosym == 's1':
             nao = int(nao_pair ** .5)
             assert nao ** 2 == nao_pair
             self.nao = nao
         elif self.aosym == 's2':
             self.nao = int((nao_pair * 2)**.5)
         else:
             raise NotImplementedError
-        self.naux = self.j3c['0/0'].shape[0]
 
     def __del__(self):
         if not self._data_is_h5obj:
             self.data_group.close()
 
     def __enter__(self):
         return self
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/df_ao2mo.py` & `pyscf-2.3.0/pyscf/pbc/df/df_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/df/df_jk.py` & `pyscf-2.3.0/pyscf/pbc/df/df_jk.py`

 * *Files 1% similar despite different names*

```diff
@@ -74,15 +74,15 @@
     log = logger.Logger(mydf.stdout, mydf.verbose)
     t0 = (logger.process_clock(), logger.perf_counter())
     if mydf._cderi is None or not mydf.has_kpts(kpts_band):
         if mydf._cderi is not None:
             log.warn('DF integrals for band k-points were not found %s. '
                      'DF integrals will be rebuilt to include band k-points.',
                      mydf._cderi)
-        mydf.build(kpts_band=kpts_band)
+        mydf.build(j_only=True, kpts_band=kpts_band)
         t0 = log.timer_debug1('Init get_j_kpts', *t0)
 
     dm_kpts = lib.asarray(dm_kpts, order='C')
     dms = _format_dms(dm_kpts, kpts)
     nset, nkpts, nao = dms.shape[:3]
     if mydf.auxcell is None:
         # If mydf._cderi is the file that generated from another calculation,
@@ -117,20 +117,26 @@
                 rhoI[:,p0:p1] += sign * numpy.einsum('Lp,xp->xL', LpqI, dmsR[:,k])
             LpqR = LpqI = None
     t1 = log.timer_debug1('get_j pass 1', *t1)
 
     weight = 1./nkpts
     rhoR *= weight
     rhoI *= weight
-    vjR = numpy.zeros((nset,nband,nao_pair))
-    vjI = numpy.zeros((nset,nband,nao_pair))
+    if hermi == 0:
+        aos2symm = False
+        vjR = numpy.zeros((nset,nband,nao**2))
+        vjI = numpy.zeros((nset,nband,nao**2))
+    else:
+        aos2symm = True
+        vjR = numpy.zeros((nset,nband,nao_pair))
+        vjI = numpy.zeros((nset,nband,nao_pair))
     for k, kpt in enumerate(kpts_band):
         kptii = numpy.asarray((kpt,kpt))
         p1 = 0
-        for LpqR, LpqI, sign in mydf.sr_loop(kptii, max_memory, True):
+        for LpqR, LpqI, sign in mydf.sr_loop(kptii, max_memory, aos2symm):
             p0, p1 = p1, p1+LpqR.shape[0]
             #:Lpq = (LpqR + LpqI*1j)#.reshape(-1,nao,nao)
             #:vjR[:,k] += numpy.dot(rho[:,p0:p1], Lpq).real
             #:vjI[:,k] += numpy.dot(rho[:,p0:p1], Lpq).imag
             vjR[:,k] += numpy.dot(rhoR[:,p0:p1], LpqR)
             if not j_real:
                 vjI[:,k] += numpy.dot(rhoI[:,p0:p1], LpqR)
@@ -140,15 +146,16 @@
             LpqR = LpqI = None
     t1 = log.timer_debug1('get_j pass 2', *t1)
 
     if j_real:
         vj_kpts = vjR
     else:
         vj_kpts = vjR + vjI*1j
-    vj_kpts = lib.unpack_tril(vj_kpts.reshape(-1,nao_pair))
+    if aos2symm:
+        vj_kpts = lib.unpack_tril(vj_kpts.reshape(-1,nao_pair))
     vj_kpts = vj_kpts.reshape(nset,nband,nao,nao)
 
     log.timer('get_j', *t0)
 
     return _format_jks(vj_kpts, dm_kpts, input_band, kpts)
 
 
@@ -551,34 +558,34 @@
 # Single k-point
 #
 ##################################################
 
 def get_jk(mydf, dm, hermi=1, kpt=numpy.zeros(3),
            kpts_band=None, with_j=True, with_k=True, exxdiv=None):
     '''JK for given k-point'''
+    log = logger.Logger(mydf.stdout, mydf.verbose)
+    t0 = (logger.process_clock(), logger.perf_counter())
+    if mydf._cderi is None or not mydf.has_kpts(kpts_band):
+        if mydf._cderi is not None:
+            log.warn('DF integrals for band k-points were not found %s. '
+                     'DF integrals will be rebuilt to include band k-points.',
+                     mydf._cderi)
+        mydf.build(j_only=not with_k, kpts_band=kpts_band)
+        t0 = log.timer_debug1('Init get_jk', *t0)
+
     vj = vk = None
     if kpts_band is not None and abs(kpt-kpts_band).sum() > 1e-9:
         kpt = numpy.reshape(kpt, (1,3))
         if with_k:
             vk = get_k_kpts(mydf, dm, hermi, kpt, kpts_band, exxdiv)
         if with_j:
             vj = get_j_kpts(mydf, dm, hermi, kpt, kpts_band)
         return vj, vk
 
     cell = mydf.cell
-    log = logger.Logger(mydf.stdout, mydf.verbose)
-    t0 = (logger.process_clock(), logger.perf_counter())
-    if mydf._cderi is None or not mydf.has_kpts(kpts_band):
-        if mydf._cderi is not None:
-            log.warn('DF integrals for band k-points were not found %s. '
-                     'DF integrals will be rebuilt to include band k-points.',
-                     mydf._cderi)
-        mydf.build(kpts_band=kpts_band)
-        t0 = log.timer_debug1('Init get_jk', *t0)
-
     dm = numpy.asarray(dm, order='C')
     dms = _format_dms(dm, [kpt])
     nset, _, nao = dms.shape[:3]
     dms = dms.reshape(nset,nao,nao)
     j_real = gamma_point(kpt)
     kptii = numpy.asarray((kpt,kpt))
     dmsR = dms.real.reshape(nset,nao,nao)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/fft.py` & `pyscf-2.3.0/pyscf/pbc/df/fft.py`

 * *Files 14% similar despite different names*

```diff
@@ -17,75 +17,72 @@
 #
 
 '''Density expansion on plane waves'''
 
 import copy
 import numpy
 from pyscf import lib
+from pyscf import gto
 from pyscf.lib import logger
 from pyscf.pbc import tools
-from pyscf.pbc.gto import pseudo, estimate_ke_cutoff, error_for_ke_cutoff
+from pyscf.pbc import gto as pbcgto
+from pyscf.pbc.gto import pseudo, error_for_ke_cutoff, estimate_ke_cutoff
 from pyscf.pbc.df import ft_ao
 from pyscf.pbc.df import fft_ao2mo
+from pyscf.pbc.df import fft_jk
 from pyscf.pbc.df import aft
-from pyscf.pbc.lib.kpts_helper import gamma_point
+from pyscf.pbc.df.aft import _check_kpts
+from pyscf.pbc.lib.kpts_helper import is_zero
 from pyscf import __config__
 
 KE_SCALING = getattr(__config__, 'pbc_df_aft_ke_cutoff_scaling', 0.75)
 
 
 def get_nuc(mydf, kpts=None):
-    if kpts is None:
-        kpts_lst = numpy.zeros((1,3))
-    else:
-        kpts_lst = numpy.reshape(kpts, (-1,3))
-
+    from pyscf.pbc.dft import gen_grid
+    kpts, is_single_kpt = _check_kpts(mydf, kpts)
     cell = mydf.cell
     mesh = mydf.mesh
     charge = -cell.atom_charges()
     Gv = cell.get_Gv(mesh)
-    SI = cell.get_SI(Gv)
+    SI = cell.get_SI(mesh=mesh)
     rhoG = numpy.dot(charge, SI)
 
     coulG = tools.get_coulG(cell, mesh=mesh, Gv=Gv)
     vneG = rhoG * coulG
     vneR = tools.ifft(vneG, mesh).real
 
-    vne = [0] * len(kpts_lst)
-    for ao_ks_etc, p0, p1 in mydf.aoR_loop(mydf.grids, kpts_lst):
+    vne = [0] * len(kpts)
+    for ao_ks_etc, p0, p1 in mydf.aoR_loop(mydf.grids, kpts):
         ao_ks = ao_ks_etc[0]
         for k, ao in enumerate(ao_ks):
             vne[k] += lib.dot(ao.T.conj()*vneR[p0:p1], ao)
         ao = ao_ks = None
 
-    if kpts is None or numpy.shape(kpts) == (3,):
+    if is_single_kpt:
         vne = vne[0]
     return numpy.asarray(vne)
 
 def get_pp(mydf, kpts=None):
     '''Get the periodic pseudotential nuc-el AO matrix, with G=0 removed.
     '''
-    from pyscf import gto
+    from pyscf.pbc.dft import gen_grid
+    kpts, is_single_kpt = _check_kpts(mydf, kpts)
     cell = mydf.cell
-    if kpts is None:
-        kpts_lst = numpy.zeros((1,3))
-    else:
-        kpts_lst = numpy.reshape(kpts, (-1,3))
-
     mesh = mydf.mesh
     Gv = cell.get_Gv(mesh)
-    SI = cell.get_SI(Gv)
+    SI = cell.get_SI(mesh=mesh)
     vpplocG = pseudo.get_vlocG(cell, Gv)
     vpplocG = -numpy.einsum('ij,ij->j', SI, vpplocG)
     ngrids = len(vpplocG)
 
     # vpploc evaluated in real-space
     vpplocR = tools.ifft(vpplocG, mesh).real
-    vpp = [0] * len(kpts_lst)
-    for ao_ks_etc, p0, p1 in mydf.aoR_loop(mydf.grids, kpts_lst):
+    vpp = [0] * len(kpts)
+    for ao_ks_etc, p0, p1 in mydf.aoR_loop(mydf.grids, kpts):
         ao_ks = ao_ks_etc[0]
         for k, ao in enumerate(ao_ks):
             vpp[k] += lib.dot(ao.T.conj()*vpplocR[p0:p1], ao)
         ao = ao_ks = None
 
     # vppnonloc evaluated in reciprocal space
     fakemol = gto.Mole()
@@ -140,22 +137,22 @@
                         p0, p1 = p1, p1+nl*(l*2+1)
                         hl = numpy.asarray(hl)
                         SPG_lm_aoG = SPG_lm_aoGs[p0:p1].reshape(nl,l*2+1,-1)
                         tmp = numpy.einsum('ij,jmp->imp', hl, SPG_lm_aoG)
                         vppnl += numpy.einsum('imp,imq->pq', SPG_lm_aoG.conj(), tmp)
         return vppnl * (1./cell.vol)
 
-    for k, kpt in enumerate(kpts_lst):
+    for k, kpt in enumerate(kpts):
         vppnl = vppnl_by_k(kpt)
-        if gamma_point(kpt):
+        if is_zero(kpt):
             vpp[k] = vpp[k].real + vppnl.real
         else:
             vpp[k] += vppnl
 
-    if kpts is None or numpy.shape(kpts) == (3,):
+    if is_single_kpt:
         vpp = vpp[0]
     return numpy.asarray(vpp)
 
 
 class FFTDF(lib.StreamObject):
     '''Density expansion on plane waves
     '''
@@ -164,15 +161,22 @@
         from pyscf.pbc.dft import numint
         self.cell = cell
         self.stdout = cell.stdout
         self.verbose = cell.verbose
         self.max_memory = cell.max_memory
 
         self.kpts = kpts
+
         self.grids = gen_grid.UniformGrids(cell)
+        # FFT from real space density distributes error to every rho_ij(G) than
+        # the one with largest Gaussian exponent. Therefore the error for FFT-ERI
+        # ~ Nele * error[rho(Ecut)] while in AFT the error is ~ error[rho(Ecut)]^2.
+        # This is a first order error, same to the error estimation for nuclear
+        # attraction.
+        self.mesh = cell.mesh
 
         # to mimic molecular DF object
         self.blockdim = getattr(__config__, 'pbc_df_df_DF_blockdim', 240)
 
         # The following attributes are not input options.
         # self.exxdiv has no effects. It was set in the get_k_kpts function to
         # mimic the KRHF/KUHF object in the call to tools.get_coulG.
@@ -221,15 +225,15 @@
 
         if cell.ke_cutoff is None:
             ke_cutoff = tools.mesh_to_cutoff(cell.lattice_vectors(), self.mesh).min()
         else:
             ke_cutoff = numpy.min(cell.ke_cutoff)
         ke_guess = estimate_ke_cutoff(cell, cell.precision)
         if ke_cutoff < ke_guess * KE_SCALING:
-            mesh_guess = tools.cutoff_to_mesh(cell.lattice_vectors(), ke_guess)
+            mesh_guess = cell.cutoff_to_mesh(ke_guess)
             logger.warn(self, 'ke_cutoff/mesh (%g / %s) is not enough for FFTDF '
                         'to get integral accuracy %g.\nCoulomb integral error '
                         'is ~ %.2g Eh.\nRecommended ke_cutoff/mesh are %g / %s.',
                         ke_cutoff, self.mesh, cell.precision,
                         error_for_ke_cutoff(cell, ke_cutoff), ke_guess, mesh_guess)
         return self
 
@@ -264,79 +268,47 @@
             p0, p1 = p1, p1 + coords.shape[0]
             yield ao_k1_etc, p0, p1
 
     get_pp = get_pp
     get_nuc = get_nuc
 
     def get_jk_e1(self, dm, kpts=None, kpts_band=None, exxdiv=None):
-        from pyscf.pbc.df import fft_jk
-        if kpts is None:
-            if numpy.all(self.kpts == 0): # Gamma-point J/K by default
-                kpts = numpy.zeros(3)
-            else:
-                kpts = self.kpts
-        else:
-            kpts = numpy.asarray(kpts)
-
+        kpts = _check_kpts(self, kpts)[0]
         vj = fft_jk.get_j_e1_kpts(self, dm, kpts, kpts_band)
         vk = fft_jk.get_k_e1_kpts(self, dm, kpts, kpts_band, exxdiv)
         return vj, vk
 
     def get_j_e1(self, dm, kpts=None, kpts_band=None):
-        from pyscf.pbc.df import fft_jk
-        if kpts is None:
-            if numpy.all(self.kpts == 0): # Gamma-point J/K by default
-                kpts = numpy.zeros(3)
-            else:
-                kpts = self.kpts
-        else:
-            kpts = numpy.asarray(kpts)
-
+        kpts = _check_kpts(self, kpts)[0]
         vj = fft_jk.get_j_e1_kpts(self, dm, kpts, kpts_band)
         return vj
 
     def get_k_e1(self, dm, kpts=None, kpts_band=None, exxdiv=None):
-        from pyscf.pbc.df import fft_jk
-        if kpts is None:
-            if numpy.all(self.kpts == 0): # Gamma-point J/K by default
-                kpts = numpy.zeros(3)
-            else:
-                kpts = self.kpts
-        else:
-            kpts = numpy.asarray(kpts)
-
+        kpts = _check_kpts(self, kpts)[0]
         vk = fft_jk.get_k_e1_kpts(self, dm, kpts, kpts_band, exxdiv)
         return vk
 
     # Note: Special exxdiv by default should not be used for an arbitrary
     # input density matrix. When the df object was used with the molecular
     # post-HF code, get_jk was often called with an incomplete DM (e.g. the
     # core DM in CASCI). An SCF level exxdiv treatment is inadequate for
     # post-HF methods.
     def get_jk(self, dm, hermi=1, kpts=None, kpts_band=None,
                with_j=True, with_k=True, omega=None, exxdiv=None):
-        from pyscf.pbc.df import fft_jk
         if omega is not None:  # J/K for RSH functionals
             with self.range_coulomb(omega) as rsh_df:
                 return rsh_df.get_jk(dm, hermi, kpts, kpts_band, with_j, with_k,
                                      omega=None, exxdiv=exxdiv)
 
-        if kpts is None:
-            if numpy.all(self.kpts == 0): # Gamma-point J/K by default
-                kpts = numpy.zeros(3)
-            else:
-                kpts = self.kpts
-        else:
-            kpts = numpy.asarray(kpts)
-
-        vj = vk = None
-        if kpts.shape == (3,):
-            vj, vk = fft_jk.get_jk(self, dm, hermi, kpts, kpts_band,
+        kpts, is_single_kpt = _check_kpts(self, kpts)
+        if is_single_kpt:
+            vj, vk = fft_jk.get_jk(self, dm, hermi, kpts[0], kpts_band,
                                    with_j, with_k, exxdiv)
         else:
+            vj = vk = None
             if with_k:
                 vk = fft_jk.get_k_kpts(self, dm, hermi, kpts, kpts_band, exxdiv)
             if with_j:
                 vj = fft_jk.get_j_kpts(self, dm, hermi, kpts, kpts_band)
         return vj, vk
 
     get_eri = get_ao_eri = fft_ao2mo.get_eri
@@ -376,25 +348,7 @@
 
     def get_naoaux(self):
         mesh = numpy.asarray(self.mesh)
         ngrids = numpy.prod(mesh)
         return ngrids * 2
 
     range_coulomb = aft.AFTDF.range_coulomb
-
-
-if __name__ == '__main__':
-    from pyscf.pbc import gto as pbcgto
-    cell = pbcgto.Cell()
-    cell.verbose = 0
-    cell.atom = 'C 0 0 0; C 1 1 1; C 0 2 2; C 2 0 2'
-    cell.a = numpy.diag([4, 4, 4])
-    cell.basis = 'gth-szv'
-    cell.pseudo = 'gth-pade'
-    cell.mesh = [20]*3
-    cell.build()
-    k = numpy.ones(3)*.25
-    df = FFTDF(cell)
-    v1 = get_pp(df, k)
-    print(lib.finger(v1) - (1.8428463642697195-0.10478381725330854j))
-    v1 = get_nuc(df, k)
-    print(lib.finger(v1) - (2.3454744614944714-0.12528407127454744j))
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/fft_ao2mo.py` & `pyscf-2.3.0/pyscf/pbc/df/fft_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/df/fft_jk.py` & `pyscf-2.3.0/pyscf/pbc/df/fft_jk.py`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 
 import numpy as np
 from pyscf import lib
 from pyscf.lib import logger
 from pyscf.pbc import tools
 from pyscf.pbc.df.df_jk import _format_dms, _format_kpts_band, _format_jks
 from pyscf.pbc.df.df_jk import _ewald_exxdiv_for_G0
-from pyscf.pbc.lib.kpts_helper import is_zero, gamma_point
+from pyscf.pbc.lib.kpts_helper import is_zero
 
 
 def get_j_kpts(mydf, dm_kpts, hermi=1, kpts=np.zeros((1,3)), kpts_band=None):
     '''Get the Coulomb (J) AO matrix at sampled k-points.
 
     Args:
         dm_kpts : (nkpts, nao, nao) ndarray or a list of (nkpts,nao,nao) ndarray
@@ -56,15 +56,15 @@
     dm_kpts = lib.asarray(dm_kpts, order='C')
     dms = _format_dms(dm_kpts, kpts)
     nset, nkpts, nao = dms.shape[:3]
 
     coulG = tools.get_coulG(cell, mesh=mesh)
     ngrids = len(coulG)
 
-    if hermi == 1 or gamma_point(kpts):
+    if hermi == 1 or is_zero(kpts):
         vR = rhoR = np.zeros((nset,ngrids))
         for ao_ks_etc, p0, p1 in mydf.aoR_loop(mydf.grids, kpts):
             ao_ks, mask = ao_ks_etc[0], ao_ks_etc[2]
             for i in range(nset):
                 rhoR[i,p0:p1] += make_rho(i, ao_ks, mask, 'LDA').real
             ao = ao_ks = None
 
@@ -88,15 +88,15 @@
             vG = coulG * rhoG
             vR[i] = tools.ifft(vG, mesh)
 
     kpts_band, input_band = _format_kpts_band(kpts_band, kpts), kpts_band
     nband = len(kpts_band)
     weight = cell.vol / ngrids
     vR *= weight
-    if gamma_point(kpts_band):
+    if is_zero(kpts_band):
         vj_kpts = np.zeros((nset,nband,nao,nao))
     else:
         vj_kpts = np.zeros((nset,nband,nao,nao), dtype=np.complex128)
 
     for ao_ks_etc, p0, p1 in mydf.aoR_loop(mydf.grids, kpts_band):
         ao_ks, mask = ao_ks_etc[0], ao_ks_etc[2]
         for i in range(nset):
@@ -120,15 +120,15 @@
     dm_kpts = lib.asarray(dm_kpts, order='C')
     dms = _format_dms(dm_kpts, kpts)
     nset, nkpts, nao = dms.shape[:3]
 
     coulG = tools.get_coulG(cell, mesh=mesh)
     ngrids = len(coulG)
 
-    if gamma_point(kpts):
+    if is_zero(kpts):
         vR = rhoR = np.zeros((nset,ngrids))
         for ao_ks_etc, p0, p1 in mydf.aoR_loop(mydf.grids, kpts):
             ao_ks, mask = ao_ks_etc[0], ao_ks_etc[2]
             for i in range(nset):
                 rhoR[i,p0:p1] += make_rho(i, ao_ks, mask, 'LDA').real
             ao = ao_ks = None
 
@@ -152,15 +152,15 @@
             vG = coulG * rhoG
             vR[i] = tools.ifft(vG, mesh)
 
     kpts_band, input_band = _format_kpts_band(kpts_band, kpts), kpts_band
     nband = len(kpts_band)
     weight = cell.vol / ngrids
     vR *= weight
-    if gamma_point(kpts_band):
+    if is_zero(kpts_band):
         vj_kpts = np.zeros((3,nset,nband,nao,nao))
     else:
         vj_kpts = np.zeros((3,nset,nband,nao,nao), dtype=np.complex128)
 
     for ao_ks_etc, p0, p1 in mydf.aoR_loop(mydf.grids, kpts_band, deriv=1):
         ao_ks, mask = ao_ks_etc[0], ao_ks_etc[2]
         for i in range(nset):
@@ -215,15 +215,15 @@
     nset, nkpts, nao = dms.shape[:3]
 
     weight = 1./nkpts * (cell.vol/ngrids)
 
     kpts_band, input_band = _format_kpts_band(kpts_band, kpts), kpts_band
     nband = len(kpts_band)
 
-    if gamma_point(kpts_band) and gamma_point(kpts):
+    if is_zero(kpts_band) and is_zero(kpts):
         vk_kpts = np.zeros((nset,nband,nao,nao), dtype=dms.dtype)
     else:
         vk_kpts = np.zeros((nset,nband,nao,nao), dtype=np.complex128)
 
     coords = mydf.grids.coords
     ao2_kpts = [np.asarray(ao.T, order='C')
                 for ao in mydf._numint.eval_ao(cell, coords, kpts=kpts)]
@@ -323,15 +323,15 @@
     nset, nkpts, nao = dms.shape[:3]
 
     weight = 1./nkpts * (cell.vol/ngrids)
 
     kpts_band, input_band = _format_kpts_band(kpts_band, kpts), kpts_band
     nband = len(kpts_band)
 
-    if gamma_point(kpts_band) and gamma_point(kpts):
+    if is_zero(kpts_band) and is_zero(kpts):
         vk_kpts = np.zeros((3,nset,nband,nao,nao), dtype=dms.dtype)
     else:
         vk_kpts = np.zeros((3,nset,nband,nao,nao), dtype=np.complex128)
 
     coords = mydf.grids.coords
 
     if input_band is None:
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/ft_ao.py` & `pyscf-2.3.0/pyscf/pbc/df/ft_ao.py`

 * *Files 13% similar despite different names*

```diff
@@ -29,21 +29,18 @@
 from pyscf.pbc import gto as pbcgto
 from pyscf.gto.ft_ao import ft_ao as mol_ft_ao
 from pyscf.pbc.tools import k2gamma
 from pyscf.pbc.tools import pbc as pbctools
 from pyscf.pbc.lib.kpts_helper import is_zero, gamma_point
 from pyscf import __config__
 
-RCUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_rcut_threshold', 2.0)
+RCUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_rcut_threshold', 1.0)
 # kecut=10 can rougly converge GTO with alpha=0.5
 KECUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_kecut_threshold', 10.0)
 
-# cutoff penalty due to lattice summation
-LATTICE_SUM_PENALTY = 1e-2
-
 STEEP_BASIS = 0
 LOCAL_BASIS = 1
 SMOOTH_BASIS = 2
 
 libpbc = lib.load_library('libpbc')
 
 #
@@ -74,20 +71,22 @@
 
     The return array holds the AO pair
     corresponding to the kpoints given by kptjs
     '''
     log = logger.new_logger(cell)
     kptjs = np.asarray(kptjs, order='C').reshape(-1,3)
 
-    rs_cell = _RangeSeparatedCell.from_cell(cell, KECUT_THRESHOLD, RCUT_THRESHOLD, log)
+    rs_cell = _RangeSeparatedCell.from_cell(cell, KECUT_THRESHOLD,
+                                            RCUT_THRESHOLD, log)
     if bvk_kmesh is None:
         bvk_kmesh = k2gamma.kpts_to_kmesh(cell, kptjs)
         log.debug2('Set bvk_kmesh = %s', bvk_kmesh)
-    supmol = _ExtendedMole.from_cell(rs_cell, bvk_kmesh, verbose=log)
-    supmol = supmol.strip_basis()
+    rcut = estimate_rcut(rs_cell)
+    supmol = ExtendedMole.from_cell(rs_cell, bvk_kmesh, rcut.max(), log)
+    supmol = supmol.strip_basis(rcut)
 
     ft_kern = supmol.gen_ft_kernel(aosym, intor=intor, comp=comp,
                                    return_complex=True, verbose=log)
 
     return ft_kern(Gv, gxyz, Gvbase, q, kptjs, shls_slice)
 
 
@@ -98,15 +97,15 @@
         return mol_ft_ao(mol, Gv, shls_slice, b, gxyz, Gvbase, verbose)
     else:
         kG = Gv + kpt
         return mol_ft_ao(mol, kG, shls_slice, None, None, None, verbose)
 
 
 def gen_ft_kernel(supmol, aosym='s1', intor='GTO_ft_ovlp', comp=1,
-                  return_complex=False, verbose=None):
+                  return_complex=False, kpts=None, verbose=None):
     r'''
     Generate the analytical fourier transform kernel for AO products
 
     \sum_T exp(-i k_j * T) \int exp(-i(G+q)r) i(r) j(r-T) dr^3
     '''
     log = logger.new_logger(supmol)
     cput0 = logger.process_clock(), logger.perf_counter()
@@ -120,40 +119,56 @@
 
     ovlp_mask = supmol.get_ovlp_mask()
     bvk_ovlp_mask = lib.condense('np.any', ovlp_mask, rs_cell.sh_loc, supmol.sh_loc)
     cell0_ovlp_mask = bvk_ovlp_mask.reshape(nbasp, bvk_ncells, nbasp).any(axis=1)
     ovlp_mask = ovlp_mask.astype(np.int8)
     cell0_ovlp_mask = cell0_ovlp_mask.astype(np.int8)
 
-    # A map to assign each basis of supmol._bas the index in
-    # [bvk_cell-id, bas-id, image-id]
-    bas_map = np.where(supmol.bas_mask.ravel())[0].astype(np.int32)
+    if kpts is not None:
+        expLk = np.exp(1j*np.dot(supmol.bvkmesh_Ls, kpts.T))
+        expLkR = np.asarray(expLk.real, order='C')
+        expLkI = np.asarray(expLk.imag, order='C')
+        _expLk = (expLkR, expLkI)
+    else:
+        _expLk = None
 
     b = rs_cell.reciprocal_vectors()
+    if abs(b-np.diag(b.diagonal())).sum() < 1e-8:
+        _eval_gz = 'GTO_Gv_orth'
+    else:
+        _eval_gz = 'GTO_Gv_nonorth'
+    drv = libpbc.PBC_ft_bvk_drv
+    cintor = getattr(libpbc, rs_cell._add_suffix(intor))
 
     log.timer_debug1('ft_ao kernel initialization', *cput0)
 
     # TODO: use Gv = b * gxyz + q in c code
     # TODO: add zfill
-    def ft_kernel(Gv, gxyz=None, Gvbase=None, q=np.zeros(3), kptjs=np.zeros((1, 3)),
+    def ft_kernel(Gv, gxyz=None, Gvbase=None, q=np.zeros(3), kptjs=None,
                   shls_slice=None, aosym=aosym, out=None):
         '''
         Analytical FT for orbital products. The output tensor has the shape [nGv, nao, nao]
         '''
         cput0 = logger.process_clock(), logger.perf_counter()
-        q = np.reshape(q, 3)
-        kptjs = np.asarray(kptjs, order='C').reshape(-1,3)
-        nkpts = len(kptjs)
-
-        expLk = np.exp(1j*np.dot(supmol.bvkmesh_Ls, kptjs.T))
-        expLkR = np.asarray(expLk.real, order='C')
-        expLkI = np.asarray(expLk.imag, order='C')
-        expLk = None
+        assert q.ndim == 1
+        if kptjs is None:
+            if _expLk is None:
+                expLkR = np.ones((nimgs,1))
+                expLkI = np.zeros((nimgs,1))
+            else:
+                expLkR, expLkI = _expLk
+        else:
+            kptjs = np.asarray(kptjs, order='C').reshape(-1,3)
+            expLk = np.exp(1j*np.dot(supmol.bvkmesh_Ls, kptjs.T))
+            expLkR = np.asarray(expLk.real, order='C')
+            expLkI = np.asarray(expLk.imag, order='C')
+            expLk = None
 
-        GvT = np.asarray(Gv.T, order='C') + q.reshape(-1,1)
+        nkpts = expLkR.shape[1]
+        GvT = np.asarray(Gv.T + q[:,None], order='C')
         nGv = GvT.shape[1]
 
         if shls_slice is None:
             shls_slice = (0, nbasp, 0, nbasp)
         ni = cell0_ao_loc[shls_slice[1]] - cell0_ao_loc[shls_slice[0]]
         nj = cell0_ao_loc[shls_slice[3]] - cell0_ao_loc[shls_slice[2]]
         shape = (nkpts, comp, ni, nj, nGv)
@@ -167,62 +182,58 @@
             # hermi operation needs to reorder axis-0.  It is inefficient.
         elif aosym == 's2':
             i0 = cell0_ao_loc[shls_slice[0]]
             i1 = cell0_ao_loc[shls_slice[1]]
             nij = i1*(i1+1)//2 - i0*(i0+1)//2
             shape = (nkpts, comp, nij, nGv)
 
-        if gxyz is None or b is None or Gvbase is None or (abs(q).sum() > 1e-9):
+        if gxyz is None or Gvbase is None or (abs(q).sum() > 1e-9):
             p_gxyzT = lib.c_null_ptr()
             p_mesh = (ctypes.c_int*3)(0,0,0)
             p_b = (ctypes.c_double*1)(0)
             eval_gz = 'GTO_Gv_general'
         else:
-            if abs(b-np.diag(b.diagonal())).sum() < 1e-8:
-                eval_gz = 'GTO_Gv_orth'
-            else:
-                eval_gz = 'GTO_Gv_nonorth'
+            eval_gz = _eval_gz
             gxyzT = np.asarray(gxyz.T, order='C', dtype=np.int32)
             p_gxyzT = gxyzT.ctypes.data_as(ctypes.c_void_p)
             bqGv = np.hstack((b.ravel(), q) + Gvbase)
             p_b = bqGv.ctypes.data_as(ctypes.c_void_p)
             p_mesh = (ctypes.c_int*3)(*[len(x) for x in Gvbase])
 
-        drv = libpbc.PBC_ft_bvk_drv
-        cintor = getattr(libpbc, rs_cell._add_suffix(intor))
         eval_gz = getattr(libpbc, eval_gz)
         if nkpts == 1:
             fill = getattr(libpbc, 'PBC_ft_bvk_nk1'+aosym)
         else:
             fill = getattr(libpbc, 'PBC_ft_bvk_k'+aosym)
 
         if return_complex:
             fsort = getattr(libpbc, 'PBC_ft_zsort_' + aosym)
             out = np.ndarray(shape, dtype=np.complex128, buffer=out)
         else:
             fsort = getattr(libpbc, 'PBC_ft_dsort_' + aosym)
             out = np.ndarray((2,) + shape, buffer=out)
-        drv(cintor, eval_gz, fill, fsort,
-            out.ctypes.data_as(ctypes.c_void_p),
-            expLkR.ctypes.data_as(ctypes.c_void_p),
-            expLkI.ctypes.data_as(ctypes.c_void_p),
-            ctypes.c_int(bvk_ncells), ctypes.c_int(nimgs),
-            ctypes.c_int(nkpts), ctypes.c_int(nbasp), ctypes.c_int(comp),
-            supmol.sh_loc.ctypes.data_as(ctypes.c_void_p),
-            cell0_ao_loc.ctypes.data_as(ctypes.c_void_p),
-            (ctypes.c_int*4)(*shls_slice),
-            ovlp_mask.ctypes.data_as(ctypes.c_void_p),
-            cell0_ovlp_mask.ctypes.data_as(ctypes.c_void_p),
-            bas_map.ctypes.data_as(ctypes.c_void_p),
-            GvT.ctypes.data_as(ctypes.c_void_p), p_b, p_gxyzT, p_mesh, ctypes.c_int(nGv),
-            supmol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.natm),
-            supmol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.nbas),
-            supmol._env.ctypes.data_as(ctypes.c_void_p))
 
-        log.timer_debug1(f'ft_ao intor {intor}', *cput0)
+        if nGv > 0:
+            drv(cintor, eval_gz, fill, fsort,
+                out.ctypes.data_as(ctypes.c_void_p),
+                expLkR.ctypes.data_as(ctypes.c_void_p),
+                expLkI.ctypes.data_as(ctypes.c_void_p),
+                ctypes.c_int(bvk_ncells), ctypes.c_int(nimgs),
+                ctypes.c_int(nkpts), ctypes.c_int(nbasp), ctypes.c_int(comp),
+                supmol.seg_loc.ctypes.data_as(ctypes.c_void_p),
+                supmol.seg2sh.ctypes.data_as(ctypes.c_void_p),
+                cell0_ao_loc.ctypes.data_as(ctypes.c_void_p),
+                (ctypes.c_int*4)(*shls_slice),
+                ovlp_mask.ctypes.data_as(ctypes.c_void_p),
+                cell0_ovlp_mask.ctypes.data_as(ctypes.c_void_p),
+                GvT.ctypes.data_as(ctypes.c_void_p), p_b, p_gxyzT, p_mesh, ctypes.c_int(nGv),
+                supmol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.natm),
+                supmol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.nbas),
+                supmol._env.ctypes.data_as(ctypes.c_void_p))
+            log.timer_debug1(f'ft_ao intor {intor}', *cput0)
 
         if return_complex:
             if aosym == 's1hermi':
                 for i in range(1, ni):
                     out[:,:,:i,i] = out[:,:,i,:i]
             out = np.rollaxis(out, -1, 2)
             if comp == 1:
@@ -231,47 +242,52 @@
         else:
             if aosym == 's1hermi':
                 for i in range(1, ni):
                     out[:,:,:,:i,i] = out[:,:,:,i,:i]
             out = np.rollaxis(out, -1, 3)
             if comp == 1:
                 out = out[:,:,0]
-            outR = out[0]
-            outI = out[1]
-            return outR, outI
+            return out
 
     return ft_kernel
 
 
 class _RangeSeparatedCell(pbcgto.Cell):
     '''Cell with partially de-contracted basis'''
     def __init__(self):
         # ref_cell is the original cell of which the basis to be de-contracted
         self.ref_cell = None
         # For each de-contracted basis, the shell Id in the original cell
         self.bas_map = None
         # Type of each de-contracted basis
         self.bas_type = None
-        # For each shell in the original cell, the first basis in the rs-cell.
-        # sh_loc indicates how the rs-cell basis can be aggregated to restore
-        # the contracted basis in the original cell
+        # Each shell in the original cell can have several segments in the rs-cell.
+        # sh_loc indicates the shell Id in rs-cell for each shell in cell.
         self.sh_loc = None
 
     @classmethod
-    def from_cell(cls, cell, ke_cut_threshold=KECUT_THRESHOLD,
-                  rcut_threshold=None, verbose=None):
-        from pyscf.pbc.dft.multigrid import _primitive_gto_cutoff
-        log = logger.new_logger(cell, verbose)
+    def from_cell(cls, cell, ke_cut_threshold=None, rcut_threshold=None,
+                  in_rsjk=False, verbose=None):
+        from pyscf.pbc.df import aft
+        rs_cell = cls()
+        rs_cell.__dict__.update(cell.__dict__)
+        rs_cell.ref_cell = cell
+
         if ke_cut_threshold is None:
-            ke_cut_threshold = KECUT_THRESHOLD
+            rs_cell.bas_map = np.arange(cell.nbas, dtype=np.int32)
+            rs_cell.bas_type = np.empty(cell.nbas, dtype=np.int32)
+            rs_cell.bas_type[:] = LOCAL_BASIS
+            rs_cell.sh_loc = np.arange(cell.nbas + 1, dtype=np.int32)
+            return rs_cell
+
+        log = logger.new_logger(cell, verbose)
         if not isinstance(ke_cut_threshold, float):
             ke_cut_threshold = np.min(ke_cut_threshold)
 
-        # rcut and energy cutoff for eash shell
-        rcuts, kecuts = _primitive_gto_cutoff(cell, cell.precision)
+        precision = cell.precision
 
         # preserves all environments defined in cell (e.g. omega, gauge origin)
         _env = cell._env.copy()
         decontracted_bas = []
         bas_type = []
         # For each basis of rs_cell, bas_map gives the basis in cell
         bas_map = []
@@ -283,32 +299,52 @@
             new_bas[gto.PTR_EXP] += e_offset
             new_bas[gto.PTR_COEFF] += e_offset * new_bas[gto.NCTR_OF]
             new_bas[gto.NPRIM_OF] = nprim
             decontracted_bas.append(new_bas)
             bas_type.append(btype)
             bas_map.append(orig_id)
 
-        # Split shells based on rcut
         for ib, orig_bas in enumerate(cell._bas):
             nprim = orig_bas[gto.NPRIM_OF]
             nctr = orig_bas[gto.NCTR_OF]
-            ke = kecuts[ib]
+            l = orig_bas[gto.ANG_OF]
+            es = cell.bas_exp(ib)
+            # Sort exponents because integral screening of rsjk method relies on
+            # the dscending order in exponents
+            es_idx = es.argsort()[::-1]
+            es = es[es_idx]
+            cs = cell._libcint_ctr_coeff(ib)[es_idx]
+            abs_cs = abs(cs).max(axis=1)
+
+            # aft._estimate_ke_cutoff is accurate for 4c2e integrals
+            # For other integrals such as nuclear attraction.
+            # aft._estimate_ke_cutoff may put some primitive GTOs of large es
+            # and small cs in the group SMOOTH_BASIS.  These GTOs requires a
+            # large ke_cutoff (mesh) in _RSNucBuilder or _CCNucBuilder.
+            if in_rsjk:
+                ke = aft._estimate_ke_cutoff(es, l, abs_cs, precision)
+            else:
+                ke = pbcgto.cell._estimate_ke_cutoff(es, l, abs_cs, precision)
 
             smooth_mask = ke < ke_cut_threshold
             if rcut_threshold is None:
                 local_mask = ~smooth_mask
                 steep_mask = np.zeros_like(local_mask)
+                rcut = None
             else:
-                steep_mask = (~smooth_mask) & (rcuts[ib] < rcut_threshold)
+                norm_ang = ((2*l+1)/(4*np.pi))**.5
+                fac = 2*np.pi*abs_cs/cell.vol * norm_ang/es / precision
+                rcut = cell.rcut
+                rcut = (np.log(fac * rcut**(l+1) + 1.) / es)**.5
+                rcut = (np.log(fac * rcut**(l+1) + 1.) / es)**.5
+                steep_mask = (~smooth_mask) & (rcut < rcut_threshold)
                 local_mask = (~steep_mask) & (~smooth_mask)
 
             pexp = orig_bas[gto.PTR_EXP]
             pcoeff = orig_bas[gto.PTR_COEFF]
-            es = cell.bas_exp(ib)
-            cs = cell._libcint_ctr_coeff(ib)
 
             c_steep = cs[steep_mask]
             c_local = cs[local_mask]
             c_smooth = cs[smooth_mask]
             _env[pcoeff:pcoeff+nprim*nctr] = np.hstack([
                 c_steep.T.ravel(),
                 c_local.T.ravel(),
@@ -316,15 +352,15 @@
             ])
             _env[pexp:pexp+nprim] = np.hstack([
                 es[steep_mask],
                 es[local_mask],
                 es[smooth_mask],
             ])
             if log.verbose >= logger.DEBUG2:
-                log.debug2('bas %d rcuts %s  kecuts %s', ib, rcuts[ib], ke)
+                log.debug2('bas %d rcut %s  kecut %s', ib, rcut, ke)
                 log.debug2('steep %s, %s', np.where(steep_mask)[0], es[steep_mask])
                 log.debug2('local %s, %s', np.where(local_mask)[0], es[local_mask])
                 log.debug2('smooth %s, %s', np.where(smooth_mask)[0], es[smooth_mask])
 
             nprim_steep = c_steep.shape[0]
             nprim_local = c_local.shape[0]
             nprim_smooth = c_smooth.shape[0]
@@ -336,27 +372,25 @@
 
             if nprim_smooth > 0:
                 _append_to_decontracted_bas(ib, nprim_steep+nprim_local,
                                             nprim_smooth, SMOOTH_BASIS)
 
             bas_loc.append(len(decontracted_bas))
 
-        rs_cell = cls()
-        rs_cell.__dict__.update(cell.__dict__)
-        rs_cell.ref_cell = cell
         rs_cell._bas = np.asarray(decontracted_bas, dtype=np.int32, order='C')
         # rs_cell._bas might be of size (0, BAS_SLOTS)
         rs_cell._bas = rs_cell._bas.reshape(-1, gto.BAS_SLOTS)
         rs_cell._env = _env
         rs_cell.bas_map = np.asarray(bas_map, dtype=np.int32)
         rs_cell.bas_type = np.asarray(bas_type, dtype=np.int32)
         rs_cell.sh_loc = np.asarray(bas_loc, dtype=np.int32)
         rs_cell.ke_cutoff = ke_cut_threshold
         if log.verbose >= logger.DEBUG:
             bas_type = rs_cell.bas_type
+            log.debug('rs_cell.nbas %d nao %d', rs_cell.nbas, rs_cell.nao)
             log.debug1('No. steep_bas in rs_cell %d', np.count_nonzero(bas_type == STEEP_BASIS))
             log.debug1('No. local_bas in rs_cell %d', np.count_nonzero(bas_type == LOCAL_BASIS))
             log.debug('No. smooth_bas in rs_cell %d', np.count_nonzero(bas_type == SMOOTH_BASIS))
             map_bas = rs_cell._reverse_bas_map(rs_cell.bas_map)
             log.debug2('bas_map from cell to rs_cell %s', map_bas)
             assert np.array_equiv(map_bas, bas_loc)
         log.debug2('%s.bas_type %s', cls, rs_cell.bas_type)
@@ -373,57 +407,61 @@
         return np.append(map_bas, len(bas_map)).astype(np.int32)
 
     def smooth_basis_cell(self):
         '''Construct a cell with only the smooth part of the AO basis'''
         cell_d = self.view(pbcgto.Cell)
         mask = self.bas_type == SMOOTH_BASIS
         cell_d._bas = self._bas[mask]
-        precision = self.precision
-        cell_d.rcut = pbcgto.estimate_rcut(cell_d, precision=precision)
+        segs = np.zeros(self.ref_cell.nbas)
+        segs[self.bas_map[mask]] = 1
+        cell_d.sh_loc = np.append(0, np.cumsum(segs)).astype(np.int32)
+        logger.debug1(self, 'cell_d.nbas %d', cell_d.nbas)
+        if cell_d.nbas == 0:
+            return cell_d
 
-        # Update mesh
-        ke_cutoff = pbcgto.estimate_ke_cutoff(cell_d, precision)
-        mesh = pbctools.cutoff_to_mesh(cell_d.lattice_vectors(), ke_cutoff)
-        if (cell_d.dimension < 2 or
-            (cell_d.dimension == 2 and cell_d.low_dim_ft_type == 'inf_vacuum')):
-            mesh[cell_d.dimension:] = pbcgto.cell._mesh_inf_vaccum(cell_d)
+        cell_d.ke_cutoff = ke_cutoff = pbcgto.estimate_ke_cutoff(cell_d)
+        cell_d.mesh = cell_d.cutoff_to_mesh(ke_cutoff)
         logger.debug1(self, 'cell_d rcut %g ke_cutoff %g, mesh %s',
-                      cell_d.rcut, ke_cutoff, mesh)
-        cell_d.mesh = mesh
+                      cell_d.rcut, ke_cutoff, cell_d.mesh)
         return cell_d
 
     def compact_basis_cell(self):
         '''Construct a cell with only the smooth part of the AO basis'''
         cell_c = copy.copy(self)
         mask = self.bas_type != SMOOTH_BASIS
         cell_c._bas = self._bas[mask]
         cell_c.bas_map = cell_c.bas_map[mask]
         cell_c.bas_type = cell_c.bas_type[mask]
-        cell_c.sh_loc = None
+        segs = self.sh_loc[1:] - self.sh_loc[:-1]
+        segs[self.bas_map[~mask]] -= 1
+        cell_c.sh_loc = np.append(0, np.cumsum(segs)).astype(np.int32)
         cell_c.rcut = pbcgto.estimate_rcut(cell_c, self.precision)
         return cell_c
 
     def merge_diffused_block(self, aosym='s1'):
         '''For AO pair that are evaluated in blocks with using the basis
         partitioning self.compact_basis_cell() and self.smooth_basis_cell(),
-        merge the DD block into the CC, CD, DC blocks (D ~ compact basis,
+        merge the DD block into the CC, CD, DC blocks (C ~ compact basis,
         D ~ diffused basis)
         '''
         ao_loc = self.ref_cell.ao_loc
         smooth_bas_idx = self.bas_map[self.bas_type == SMOOTH_BASIS]
         smooth_ao_idx = self.get_ao_indices(smooth_bas_idx, ao_loc)
         nao = ao_loc[-1]
         naod = smooth_ao_idx.size
         drv = getattr(libpbc, f'PBCnr3c_fuse_dd_{aosym}')
 
-        def merge(j3c, j3c_dd, shls_slice):
+        def merge(j3c, j3c_dd, shls_slice=None):
             if j3c_dd.size == 0:
                 return j3c
             # The AO index in the original cell
-            slice_in_cell = ao_loc[list(shls_slice[:4])]
+            if shls_slice is None:
+                slice_in_cell = (0, nao, 0, nao)
+            else:
+                slice_in_cell = ao_loc[list(shls_slice[:4])]
             # Then search the corresponding index in the diffused block
             slice_in_cell_d = np.searchsorted(smooth_ao_idx, slice_in_cell)
 
             # j3c_dd may be an h5 object. Load j3c_dd to memory
             d0, d1 = slice_in_cell_d[:2]
             j3c_dd = np.asarray(j3c_dd[d0:d1], order='C')
             naux = j3c_dd.shape[-1]
@@ -520,153 +558,225 @@
 
         pcell.bas_map = np.arange(pcell.nbas, dtype=np.int32)
         pcell.sh_loc = np.append(np.arange(pcell.nbas), pcell.nbas).astype(np.int32)
         logger.debug3(pcell, 'decontracted cell bas_type %s', pcell.bas_type)
         logger.debug3(pcell, 'decontracted cell sh_loc %s', pcell.sh_loc)
         return pcell, ctr_coeff
 
-class _ExtendedMole(gto.Mole):
+class ExtendedMole(gto.Mole):
     '''An extended Mole object to mimic periodicity'''
     def __init__(self):
         # The cell which used to generate the supmole
         self.rs_cell: _RangeSeparatedCell = None
         self.bvk_kmesh = None
         self.Ls = None
         self.bvkmesh_Ls = None
-        # For each shell in the bvk cell, the first basis in the supmole.
-        # sh_loc indicates the boundary of the batches in supmol. These batches
-        # can be aggregated to restore the original contracted basis in the bvk-cell
-        self.sh_loc = None
+        # seg_loc maps the shell Id in bvk cell to shell Id in bvk rs-cell.
+        # seg2sh maps the shell Id in bvk rs-cell to the shell Id in supmol.
+        # Lattice sum range for each bvk cell shell can be obtained
+        # (seg2sh[n+1] - seg2sh[n])
+        self.seg_loc = None
+        self.seg2sh = None
         # whether the basis bas_mask[bvk-cell-id, basis-id, image-id] is
         # needed to reproduce the periodicity
         self.bas_mask = None
         self.precision = None
 
+    @property
+    def sh_loc(self):
+        # A map for shell in bvk cell to shell Id in supmol
+        return self.seg2sh[self.seg_loc]
+
+    @property
+    def bas_map(self):
+        # A map to assign each basis of supmol._bas the index in
+        # [bvk_cell-id, bas-id, image-id]
+        return np.where(self.bas_mask.ravel())[0].astype(np.int32)
+
     @classmethod
     def from_cell(cls, cell, kmesh, rcut=None, verbose=None):
         if rcut is None: rcut = cell.rcut
         log = logger.new_logger(cell, verbose)
 
         if not isinstance(cell, _RangeSeparatedCell):
-            rs_cell = cell.view(_RangeSeparatedCell)
-            rs_cell.ref_cell = cell
-            rs_cell.bas_map = np.arange(cell.nbas, dtype=np.int32)
-            rs_cell.bas_type = np.empty(cell.nbas, dtype=np.int32)
-            rs_cell.bas_type[:] = LOCAL_BASIS
-            rs_cell.sh_loc = np.append(np.arange(cell.nbas), cell.nbas).astype(np.int32)
-            cell = rs_cell
+            cell = _RangeSeparatedCell.from_cell(cell)
 
         bvkcell = pbctools.super_cell(cell, kmesh, wrap_around=True)
         Ls = bvkcell.get_lattice_Ls(rcut=rcut)
         Ls = Ls[np.linalg.norm(Ls, axis=1).argsort()]
         bvkmesh_Ls = k2gamma.translation_vectors_for_kmesh(cell, kmesh, True)
         LKs = Ls[:,None,:] + bvkmesh_Ls
         nimgs, bvk_ncells = LKs.shape[:2]
-        log.debug1('Generate supmol with nimgs = %d bvk_ncells = %d',
-                   nimgs, bvk_ncells)
+        log.debug1('Generate supmol with rcut = %g nimgs = %d bvk_ncells = %d',
+                   rcut, nimgs, bvk_ncells)
 
         supmol = cls()
         supmol.__dict__.update(cell.__dict__)
         supmol = pbctools._build_supcell_(supmol, cell, LKs.reshape(nimgs*bvk_ncells, 3))
         supmol.rs_cell = cell
         supmol.bvk_kmesh = kmesh
         supmol.Ls = Ls
         supmol.bvkmesh_Ls = bvkmesh_Ls
         bas_mask = np.ones((bvk_ncells, cell.nbas, nimgs), dtype=bool)
-        supmol.sh_loc = supmol.bas_mask_to_sh_loc(cell, bas_mask, verbose)
+        supmol.seg_loc, supmol.seg2sh = supmol.bas_mask_to_segment(cell, bas_mask, verbose)
         supmol.bas_mask = bas_mask
-        supmol.precision = cell.precision * LATTICE_SUM_PENALTY
+        supmol.precision = cell.precision
+        supmol._env[gto.PTR_EXPCUTOFF] = -np.log(cell.precision*1e-4)
 
         _bas_reordered = supmol._bas.reshape(
             nimgs, bvk_ncells, cell.nbas, gto.BAS_SLOTS).transpose(1,2,0,3)
         supmol._bas = np.asarray(_bas_reordered.reshape(-1, gto.BAS_SLOTS),
                                  dtype=np.int32, order='C')
         return supmol
 
-    def strip_basis(self, cutoff=None, inplace=True):
-        '''Remove remote basis if they do not contribute to the FT of basis product'''
-        ovlp_mask = self.get_ovlp_mask(cutoff).any(axis=0)
-        if inplace:
-            supmol = self
-        else:
-            supmol = copy.copy(self)
-        if ovlp_mask.size == supmol.bas_mask.size:
-            supmol.bas_mask = ovlp_mask.reshape(supmol.bas_mask.shape)
+    def strip_basis(self, rcut):
+        rs_cell = self.rs_cell
+        dim = rs_cell.dimension
+        if dim == 0:
+            return self
+        supmol_bas_coords = self.atom_coords()[self._bas[:,gto.ATOM_OF]]
+        rb = np.linalg.norm(supmol_bas_coords[:,:dim], axis=1)
+        a = rs_cell.lattice_vectors()
+
+        # filter _bas
+        nbas0 = self._bas.shape[0]
+        if rb.size == self.bas_mask.size:
+            dr = rb - np.linalg.norm(a[:dim])
+            dr = dr.reshape(self.bas_mask.shape)
+            self.bas_mask = bas_mask = dr < rcut[:,None]
+            self._bas = self._bas[bas_mask.ravel()]
         else:
-            supmol.bas_mask = supmol.bas_mask.copy()
-            supmol.bas_mask[supmol.bas_mask] = ovlp_mask
-        supmol._bas = supmol._bas[ovlp_mask]
-        supmol.sh_loc = supmol.bas_mask_to_sh_loc(supmol.rs_cell, supmol.bas_mask)
-        return supmol
+            dr = np.empty(self.bas_mask.shape)
+            dr[:] = 1e9
+            dr[self.bas_mask] = rb - np.linalg.norm(a[:dim])
+            bas_mask = dr < rcut[:,None]
+            self._bas = self._bas[bas_mask[self.bas_mask]]
+            self.bas_mask = bas_mask
+
+        # filter _atm
+        atm_ids = np.unique(self._bas[:,gto.ATOM_OF])
+        atm_mapping = np.zeros(self._atm.shape[0], dtype=np.int32)
+        atm_mapping[atm_ids] = np.arange(atm_ids.size)
+        self._atm = self._atm[atm_ids]
+        self._bas[:,gto.ATOM_OF] = atm_mapping[self._bas[:,gto.ATOM_OF]]
+
+        nbas1 = self._bas.shape[0]
+        logger.debug1(self, 'strip_basis %d to %d ', nbas0, nbas1)
+        self.seg_loc, self.seg2sh = self.bas_mask_to_segment(rs_cell, self.bas_mask)
+        return self
 
     def get_ovlp_mask(self, cutoff=None):
         '''integral screening mask for basis product between cell and supmol'''
-        if cutoff is None:
-            cutoff = self.precision
         rs_cell = self.rs_cell
         supmol = self
         # consider only the most diffused component of a basis
-        cell_exps = np.array([e.min() for e in rs_cell.bas_exps()])
+        cell_exps, cell_cs = pbcgto.cell._extract_pgto_params(rs_cell, 'min')
         cell_l = rs_cell._bas[:,gto.ANG_OF]
         cell_bas_coords = rs_cell.atom_coords()[rs_cell._bas[:,gto.ATOM_OF]]
 
-        supmol_exps = np.array([e.min() for e in supmol.bas_exps()])
+        if cutoff is None:
+            theta_ij = cell_exps.min() / 2
+            vol = rs_cell.vol
+            lattice_sum_factor = max(2*np.pi*rs_cell.rcut/(vol*theta_ij), 1)
+            cutoff = rs_cell.precision/lattice_sum_factor * .1
+            logger.debug(self, 'Set ft_ao cutoff to %g', cutoff)
+
+        supmol_exps, supmol_cs = pbcgto.cell._extract_pgto_params(supmol, 'min')
         supmol_bas_coords = supmol.atom_coords()[supmol._bas[:,gto.ATOM_OF]]
         supmol_l = supmol._bas[:,gto.ANG_OF]
 
-        # Removing the angular part of each basis and turning basis to s-type
-        # functions, ovlp is an estimation of the upper bound of radial part
-        # overlap integrals
         aij = cell_exps[:,None] + supmol_exps
-        a1 = cell_exps[:,None] * supmol_exps / aij
+        theta = cell_exps[:,None] * supmol_exps / aij
         dr = np.linalg.norm(cell_bas_coords[:,None,:] - supmol_bas_coords, axis=2)
-        # dri is the distance between the center of gaussian product to basis_i
-        # drj is the distance between the center of gaussian product to basis_j
-        dri = supmol_exps/aij * dr + 1
-        drj = cell_exps[:,None]/aij * dr + 1
-        ovlp = ((4 * a1 / aij)**.75 * np.exp(-a1*dr**2) *
-                dri**cell_l[:,None] * drj**supmol_l)
+
+        aij1 = 1./aij
+        aij2 = aij**-.5
+        dri = supmol_exps*aij1 * dr + aij2
+        drj = cell_exps[:,None]*aij1 * dr + aij2
+        norm_i = cell_cs * ((2*cell_l+1)/(4*np.pi))**.5
+        norm_j = supmol_cs * ((2*supmol_l+1)/(4*np.pi))**.5
+        fl = 2*np.pi/rs_cell.vol*dr/theta + 1.
+        ovlp = (np.pi**1.5 * norm_i[:,None]*norm_j * np.exp(-theta*dr**2) *
+                dri**cell_l[:,None] * drj**supmol_l * aij1**1.5 * fl)
         return ovlp > cutoff
 
     @staticmethod
-    def bas_mask_to_sh_loc(rs_cell, bas_mask, verbose=None):
+    def bas_mask_to_segment(rs_cell, bas_mask, verbose=None):
         '''
         bas_mask shape [bvk_ncells, nbas, nimgs]
         '''
         log = logger.new_logger(rs_cell, verbose)
         bvk_ncells, cell_rs_nbas, nimgs = bas_mask.shape
         images_count = np.count_nonzero(bas_mask, axis=2)
-        if log.verbose >= logger.DEBUG:
+
+        # seg_loc maps shell Id in bvk-cell to segment Id in supmol
+        # seg2sh maps the segment Id to shell Id of supmol
+        seg_loc = np.arange(bvk_ncells)[:,None] * cell_rs_nbas + rs_cell.sh_loc[:-1]
+        seg_loc = np.append(seg_loc.ravel(), bvk_ncells * cell_rs_nbas)
+        seg2sh = np.append(0, np.cumsum(images_count.ravel()))
+
+        if log.verbose > logger.DEBUG:
             steep_mask = rs_cell.bas_type == STEEP_BASIS
             local_mask = rs_cell.bas_type == LOCAL_BASIS
             diffused_mask = rs_cell.bas_type == SMOOTH_BASIS
             log.debug1('No. steep basis in sup-mol %d', images_count[:,steep_mask].sum())
             log.debug1('No. local basis in sup-mol %d', images_count[:,local_mask].sum())
             log.debug1('No. diffused basis in sup-mol %d', images_count[:,diffused_mask].sum())
-
-        cell0_sh_loc = rs_cell.sh_loc
-        cell_nbas = len(cell0_sh_loc) - 1
-        condensed_images_count = np.empty((bvk_ncells, cell_nbas), dtype=np.int32)
-        for ib, (i0, i1) in enumerate(zip(cell0_sh_loc[:-1], cell0_sh_loc[1:])):
-            condensed_images_count[:,ib] = images_count[:,i0:i1].sum(axis=1)
-
-        # sh_loc maps from shell Id in bvk-cell to shell Id of supmol
-        sh_loc = np.append(0, np.cumsum(condensed_images_count.ravel()))
-        log.debug3('sup-mol sh_loc %s', sh_loc)
-        # TODO: Some bases are completely inside the bvk-cell. Exclude them from
-        # lattice sum. ??
-        # sh_loc = np.append(0, np.cumsum(condensed_images_count[condensed_images_count != 0]))
-        return sh_loc.astype(np.int32)
+            log.debug3('sup-mol seg_loc %s', seg_loc)
+            log.debug3('sup-mol seg2sh %s', seg2sh)
+        return seg_loc.astype(np.int32), seg2sh.astype(np.int32)
 
     def bas_type_to_indices(self, type_code=SMOOTH_BASIS):
         '''Return the basis indices of required bas_type'''
         cell0_mask = self.rs_cell.bas_type == type_code
         if np.any(cell0_mask):
             # (bvk_ncells, rs_cell.nbas, nimgs)
             bas_type_mask = np.empty_like(self.bas_mask)
             bas_type_mask[:] = cell0_mask[None,:,None]
             bas_type_mask = bas_type_mask[self.bas_mask]
             return np.where(bas_type_mask)[0]
         else:
             return np.arange(0)
 
     gen_ft_kernel = gen_ft_kernel
+
+def estimate_rcut(cell, precision=None):
+    '''Estimate rcut for each basis based on Schwarz inequality
+    Q_ij ~ S_ij * (sqrt(2aij/pi) * aij**(lij*2) * (4*lij-1)!!)**.5
+    '''
+    if precision is None:
+        precision = cell.precision
+
+    if cell.nbas == 0:
+        return np.zeros(1)
+
+    # consider only the most diffused component of a basis
+    exps, cs = pbcgto.cell._extract_pgto_params(cell, 'min')
+    ls = cell._bas[:,gto.ANG_OF]
+
+    ai_idx = exps.argmin()
+    ai = exps[ai_idx]
+    li = ls[ai_idx]
+    ci = cs[ai_idx]
+    aj = exps
+    lj = ls
+    cj = cs
+    aij = ai + aj
+    lij = li + lj
+    norm_ang = ((2*li+1)*(2*lj+1))**.5/(4*np.pi)
+    c1 = ci * cj * norm_ang
+    theta = ai * aj / aij
+    aij1 = aij**-.5
+    fac = np.pi**1.5*c1 * aij1**(lij+3) * (2*aij/np.pi)**.25 * aij**lij
+    fac /= precision
+
+    r0 = cell.rcut
+    dri = aj*aij1 * r0 + 1.
+    drj = ai*aij1 * r0 + 1.
+    fl = 2*np.pi/cell.vol * r0/theta
+    r0 = (np.log(fac * dri**li * drj**lj * fl + 1.) / theta)**.5
+
+    dri = aj*aij1 * r0 + 1.
+    drj = ai*aij1 * r0 + 1.
+    fl = 2*np.pi/cell.vol * r0/theta
+    r0 = (np.log(fac * dri**li * drj**lj * fl + 1.) / theta)**.5
+    return r0
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/gdf_builder.py` & `pyscf-2.3.0/pyscf/pbc/df/gdf_builder.py`

 * *Files 23% similar despite different names*

```diff
@@ -32,43 +32,44 @@
 import scipy.linalg
 from pyscf import gto
 from pyscf import lib
 from pyscf.lib import logger, zdotNN, zdotCN, zdotNC
 from pyscf.df.outcore import _guess_shell_ranges
 from pyscf.pbc.tools import k2gamma
 from pyscf.pbc.tools import pbc as pbctools
-from pyscf.pbc.gto.cell import _estimate_rcut
+from pyscf.pbc import gto as pbcgto
 from pyscf.pbc.df import aft
 from pyscf.pbc.df import ft_ao
 from pyscf.pbc.df import rsdf_builder
-from pyscf.pbc.df.rsdf_builder import _round_off_to_odd_mesh
-from pyscf.pbc.df.incore import libpbc, _Int3cBuilder, _strip_basis
-from pyscf.pbc.lib.kpts_helper import (is_zero, unique_with_wrap_around,
-                                       group_by_conj_pairs)
+from pyscf.pbc.df.incore import libpbc, Int3cBuilder
+from pyscf.pbc.lib.kpts_helper import is_zero, kk_adapted_iter, KPT_DIFF_TOL
+from pyscf import __config__
 
+ETA_MIN = getattr(__config__, 'pbc_df_aft_estimate_eta_min', 0.1)
 
 class _CCGDFBuilder(rsdf_builder._RSGDFBuilder):
     '''
     Use the compensated-charge algorithm to build Gaussian density fitting 3-center tensor
     '''
     def __init__(self, cell, auxcell, kpts=np.zeros((1,3))):
         self.eta = None
         self.mesh = None
         self.fused_cell = None
         self.fuse: callable = None
         self.rs_fused_cell = None
+        self.supmol_ft = None
 
-        _Int3cBuilder.__init__(self, cell, auxcell, kpts)
+        Int3cBuilder.__init__(self, cell, auxcell, kpts)
 
     def has_long_range(self):
         '''Whether to add the long-range part computed with AFT integrals'''
-        return True
+        return self.cell.dimension > 0
 
     def reset(self, cell=None):
-        _Int3cBuilder.reset(self, cell)
+        Int3cBuilder.reset(self, cell)
         self.fused_cell = None
         self.fuse = None
 
     def dump_flags(self, verbose=None):
         logger.info(self, '\n')
         logger.info(self, '******** %s ********', self.__class__)
         logger.info(self, 'mesh = %s (%d PWs)', self.mesh, np.prod(self.mesh))
@@ -86,61 +87,81 @@
 
         self.bvk_kmesh = kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
         log.debug('kmesh for bvk-cell = %s', kmesh)
 
         if self.eta is None:
             self.eta, self.mesh, self.ke_cutoff = _guess_eta(auxcell, kpts, self.mesh)
         elif self.mesh is None:
-            self.ke_cutoff = aft.estimate_ke_cutoff_for_eta(cell, self.eta)
-            mesh = pbctools.cutoff_to_mesh(cell.lattice_vectors(), self.ke_cutoff)
-            self.mesh = _round_off_to_odd_mesh(mesh)
+            self.ke_cutoff = estimate_ke_cutoff_for_eta(cell, self.eta)
+            self.mesh = cell.cutoff_to_mesh(self.ke_cutoff)
         elif self.ke_cutoff is None:
             ke_cutoff = pbctools.mesh_to_cutoff(cell.lattice_vectors(), self.mesh)
             self.ke_cutoff = ke_cutoff.min()
 
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            self.mesh[2] = rsdf_builder._estimate_meshz(cell)
+        elif cell.dimension < 2:
+            self.mesh[cell.dimension:] = cell.mesh[cell.dimension:]
         self.mesh = cell.symmetrize_mesh(self.mesh)
 
         self.dump_flags()
 
-        self.fused_cell, self.fuse = fuse_auxcell(auxcell, self.eta)
+        exp_min = np.hstack(cell.bas_exps()).min()
+        lattice_sum_factor = max((2*cell.rcut)**3/cell.vol * 1/exp_min, 1)
+        cutoff = cell.precision / lattice_sum_factor * .1
+        self.direct_scf_tol = cutoff
+        log.debug('Set _CCGDFBuilder.direct_scf_tol to %g', cutoff)
 
+        self.fused_cell, self.fuse = fuse_auxcell(auxcell, self.eta)
         self.rs_cell = rs_cell = ft_ao._RangeSeparatedCell.from_cell(
             cell, self.ke_cutoff, rsdf_builder.RCUT_THRESHOLD, verbose=log)
-
-        supmol = ft_ao._ExtendedMole.from_cell(rs_cell, kmesh)
-        self.supmol = supmol = _strip_basis(supmol, self.eta)
-
-        log.timer_debug1('initializing supmol', *cpu0)
+        rcut = estimate_rcut(rs_cell, self.fused_cell, rs_cell.precision,
+                             self.exclude_dd_block)
+        rcut_max = rcut.max()
+        supmol = ft_ao.ExtendedMole.from_cell(rs_cell, kmesh, rcut_max, log)
+        supmol.exclude_dd_block = self.exclude_dd_block
+        self.supmol = supmol.strip_basis(rcut)
         log.debug('sup-mol nbas = %d cGTO = %d pGTO = %d',
                   supmol.nbas, supmol.nao, supmol.npgto_nr())
+
+        if self.has_long_range():
+            rcut = rsdf_builder.estimate_ft_rcut(rs_cell, cell.precision,
+                                                 self.exclude_dd_block)
+            supmol_ft = rsdf_builder._ExtendedMoleFT.from_cell(rs_cell, kmesh,
+                                                               rcut.max(), log)
+            supmol_ft.exclude_dd_block = self.exclude_dd_block
+            self.supmol_ft = supmol_ft.strip_basis(rcut)
+            log.debug('sup-mol-ft nbas = %d cGTO = %d pGTO = %d',
+                      supmol_ft.nbas, supmol_ft.nao, supmol_ft.npgto_nr())
+        log.timer_debug1('initializing supmol', *cpu0)
         return self
 
     weighted_coulG = aft.weighted_coulG
-    get_q_cond_aux = _Int3cBuilder.get_q_cond_aux
-    get_bas_map = _Int3cBuilder.get_bas_map
 
     def get_2c2e(self, uniq_kpts):
         fused_cell = self.fused_cell
         auxcell = self.auxcell
         naux = auxcell.nao
+        if auxcell.dimension == 0:
+            return [auxcell.intor('int2c2e', hermi=1)]
 
         # j2c ~ (-kpt_ji | kpt_ji)
         # Generally speaking, the int2c2e integrals with lattice sum applied on
         # |j> are not necessary hermitian because int2c2e cannot be made converged
         # with regular lattice sum unless the lattice sum vectors (from
         # cell.get_lattice_Ls) are symmetric. After adding the planewaves
         # contributions and fuse(fuse(j2c)), the output matrix is hermitian.
         j2c = list(fused_cell.pbc_intor('int2c2e', hermi=0, kpts=uniq_kpts))
 
         # 2c2e integrals the metric can easily cause errors in cderi tensor.
         # self.mesh may not be enough to produce required accuracy.
         # mesh = self.mesh
         precision = auxcell.precision**2
-        ke = aft.estimate_ke_cutoff_for_eta(auxcell, self.eta, precision)
-        mesh = pbctools.cutoff_to_mesh(auxcell.lattice_vectors(), ke)
+        ke = estimate_ke_cutoff_for_eta(auxcell, self.eta, precision)
+        mesh = auxcell.cutoff_to_mesh(ke)
         if auxcell.dimension < 2 or auxcell.low_dim_ft_type == 'inf_vacuum':
             mesh[auxcell.dimension:] = self.mesh[auxcell.dimension:]
         mesh = self.cell.symmetrize_mesh(mesh)
         logger.debug(self, 'Set 2c2e integrals precision %g, mesh %s', precision, mesh)
 
         Gv, Gvbase, kws = fused_cell.get_Gv_weights(mesh)
         b = fused_cell.reciprocal_vectors()
@@ -173,15 +194,15 @@
             # lattice sum is not big enough.
             j2c[k] = (j2c[k] + j2c[k].conj().T) * .5
             j2c[k] = self.fuse(self.fuse(j2c[k]), axis=1)
         return j2c
 
     def outcore_auxe2(self, cderi_file, intor='int3c2e', aosym='s2', comp=None,
                       j_only=False, dataname='j3c', shls_slice=None,
-                      fft_dd_block=None):
+                      fft_dd_block=None, kk_idx=None):
         r'''The 3-center integrals (ij|L) in real space with double lattice sum.
 
         Kwargs:
             shls_slice :
                 Indicate the shell slices in the primitive cell
         '''
         swapfile = tempfile.NamedTemporaryFile(dir=os.path.dirname(cderi_file))
@@ -202,22 +223,14 @@
             j_only = True
 
         intor, comp = gto.moleintor._get_intor_and_comp(cell._add_suffix(intor), comp)
 
         if fft_dd_block is None:
             fft_dd_block = self.exclude_dd_block
 
-        if fft_dd_block:
-            self._outcore_dd_block(fswap, intor, aosym, comp, j_only,
-                                   dataname, shls_slice)
-
-        # int3c2e for (cell, cell | fused_cell)
-        with lib.temporary_env(self, auxcell=self.fused_cell):
-            int3c = self.gen_int3c_kernel(intor, aosym, comp, j_only)
-
         if shls_slice is None:
             shls_slice = (0, cell.nbas, 0, cell.nbas, 0, fused_cell.nbas)
         assert shls_slice[4] == 0 and shls_slice[5] == fused_cell.nbas
 
         ao_loc = cell.ao_loc
         ish0, ish1, jsh0, jsh1, ksh0, ksh1 = shls_slice
         i0, i1, j0, j1 = ao_loc[list(shls_slice[:4])]
@@ -227,42 +240,55 @@
             nao_pair = i1*(i1+1)//2 - i0*(i0+1)//2
 
         if fft_dd_block and np.any(rs_cell.bas_type == ft_ao.SMOOTH_BASIS):
             merge_dd = rs_cell.merge_diffused_block(aosym)
         else:
             merge_dd = None
 
+        reindex_k = None
         # TODO: shape = (comp, nao_pair, naux)
         shape = (nao_pair, naux)
         if j_only or nkpts == 1:
-            for k in range(nkpts):
-                fswap.create_dataset(f'{dataname}R/{k*nkpts+k}', shape, 'f8')
-                # exclude imaginary part for gamma point
-                if not is_zero(kpts[k]):
-                    fswap.create_dataset(f'{dataname}I/{k*nkpts+k}', shape, 'f8')
             nkpts_ij = nkpts
-            kikj_idx = [k*nkpts+k for k in range(nkpts)]
+            ks = np.arange(nkpts, dtype=np.int32)
+            kikj_idx = ks * nkpts + ks
+            if kk_idx is not None:
+                # Ensure kk_idx is a subset of all possible ki-kj paris
+                assert np.all(np.isin(kk_idx, kikj_idx))
+                kikj_idx = kk_idx
+            reindex_k = kikj_idx // nkpts
         else:
-            for ki in range(nkpts):
-                for kj in range(nkpts):
-                    fswap.create_dataset(f'{dataname}R/{ki*nkpts+kj}', shape, 'f8')
-                    fswap.create_dataset(f'{dataname}I/{ki*nkpts+kj}', shape, 'f8')
-                # exclude imaginary part for gamma point
-                if is_zero(kpts[ki]):
-                    del fswap[f'{dataname}I/{ki*nkpts+ki}']
             nkpts_ij = nkpts * nkpts
-            kikj_idx = range(nkpts_ij)
-            if merge_dd:
-                uniq_kpts, uniq_index, uniq_inverse = unique_with_wrap_around(
-                    cell, (kpts[None,:,:] - kpts[:,None,:]).reshape(-1, 3))
-                kpt_ij_pairs = group_by_conj_pairs(cell, uniq_kpts)[0]
+            if kk_idx is None:
+                kikj_idx = np.arange(nkpts_ij, dtype=np.int32)
+            else:
+                kikj_idx = kk_idx
+            reindex_k = kikj_idx
+            if merge_dd and kk_idx is None:
+                kpt_ij_iters = list(kk_adapted_iter(cell, kpts))
+
+        for idx in kikj_idx:
+            fswap.create_dataset(f'{dataname}R/{idx}', shape, 'f8')
+            fswap.create_dataset(f'{dataname}I/{idx}', shape, 'f8')
+        # exclude imaginary part for gamma point
+        for k in np.where(abs(kpts).max(axis=1) < KPT_DIFF_TOL)[0]:
+            if f'{dataname}I/{k*nkpts+k}' in fswap:
+                del fswap[f'{dataname}I/{k*nkpts+k}']
 
         if naux == 0:
             return fswap
 
+        if fft_dd_block:
+            self._outcore_dd_block(fswap, intor, aosym, comp, j_only,
+                                   dataname, kk_idx=kk_idx)
+
+        # int3c2e for (cell, cell | fused_cell)
+        int3c = self.gen_int3c_kernel(intor, aosym, comp, j_only,
+                                      reindex_k=reindex_k, auxcell=self.fused_cell)
+
         mem_now = lib.current_memory()[0]
         log.debug2('memory = %s', mem_now)
         max_memory = max(2000, self.max_memory-mem_now)
 
         # split the 3-center tensor (nkpts_ij, i, j, aux) along shell i.
         # plus 1 to ensure the intermediates in libpbc do not overflow
         buflen = min(max(int(max_memory*.9e6/16/naux/(nkpts_ij+1)), 1), nao_pair)
@@ -285,79 +311,99 @@
             log.debug2('      step [%d/%d], shell range [%d:%d], len(buf) = %d',
                        istep+1, nsteps, sh_start, sh_end, nrow)
             cpu0 = log.timer_debug1(f'outcore_auxe2 [{istep+1}/{nsteps}]', *cpu0)
 
             outR = list(outR)
             if outI is not None:
                 outI = list(outI)
-            for k, kk_idx in enumerate(kikj_idx):
+            for k, idx in enumerate(kikj_idx):
                 outR[k] = self.fuse(outR[k], axis=1)
-                if f'{dataname}I/{kk_idx}' in fswap:
+                if f'{dataname}I/{idx}' in fswap and outI[k] is not None:
                     outI[k] = self.fuse(outI[k], axis=1)
 
             shls_slice = (sh_start, sh_end, 0, cell.nbas)
             row0, row1 = row1, row1 + nrow
             if merge_dd is not None:
                 if gamma_point_only:
                     merge_dd(outR[0], fswap[f'{dataname}R-dd/0'], shls_slice)
                 elif j_only or nkpts == 1:
-                    for k in range(nkpts):
-                        merge_dd(outR[k], fswap[f'{dataname}R-dd/{k*nkpts+k}'], shls_slice)
-                        merge_dd(outI[k], fswap[f'{dataname}I-dd/{k*nkpts+k}'], shls_slice)
-                else:
-                    for k, k_conj in kpt_ij_pairs:
-                        kpt_ij_idx = np.where(uniq_inverse == k)[0]
-                        if k_conj is None or k == k_conj:
+                    for k, idx in enumerate(kikj_idx):
+                        merge_dd(outR[k], fswap[f'{dataname}R-dd/{idx}'], shls_slice)
+                        merge_dd(outI[k], fswap[f'{dataname}I-dd/{idx}'], shls_slice)
+                elif kk_idx is None:
+                    for _, ki_idx, kj_idx, self_conj in kpt_ij_iters:
+                        kpt_ij_idx = ki_idx * nkpts + kj_idx
+                        if self_conj:
                             for ij_idx in kpt_ij_idx:
                                 merge_dd(outR[ij_idx], fswap[f'{dataname}R-dd/{ij_idx}'], shls_slice)
                                 merge_dd(outI[ij_idx], fswap[f'{dataname}I-dd/{ij_idx}'], shls_slice)
                         else:
-                            ki_lst = kpt_ij_idx // nkpts
-                            kj_lst = kpt_ij_idx % nkpts
-                            kpt_ji_idx = kj_lst * nkpts + ki_lst
+                            kpt_ji_idx = kj_idx * nkpts + ki_idx
                             for ij_idx, ji_idx in zip(kpt_ij_idx, kpt_ji_idx):
                                 j3cR_dd = np.asarray(fswap[f'{dataname}R-dd/{ij_idx}'])
                                 merge_dd(outR[ij_idx], j3cR_dd, shls_slice)
                                 merge_dd(outR[ji_idx], j3cR_dd.transpose(1,0,2), shls_slice)
                                 j3cI_dd = np.asarray(fswap[f'{dataname}I-dd/{ij_idx}'])
                                 merge_dd(outI[ij_idx], j3cI_dd, shls_slice)
                                 merge_dd(outI[ji_idx],-j3cI_dd.transpose(1,0,2), shls_slice)
-
-            for k, kk_idx in enumerate(kikj_idx):
-                fswap[f'{dataname}R/{kk_idx}'][row0:row1] = outR[k]
-                if f'{dataname}I/{kk_idx}' in fswap:
-                    fswap[f'{dataname}I/{kk_idx}'][row0:row1] = outI[k]
+                else:
+                    for k, idx in enumerate(kikj_idx):
+                        merge_dd(outR[k], fswap[f'{dataname}R-dd/{idx}'], shls_slice)
+                        merge_dd(outI[k], fswap[f'{dataname}I-dd/{idx}'], shls_slice)
+
+            for k, idx in enumerate(kikj_idx):
+                fswap[f'{dataname}R/{idx}'][row0:row1] = outR[k]
+                if f'{dataname}I/{idx}' in fswap:
+                    fswap[f'{dataname}I/{idx}'][row0:row1] = outI[k]
             outR = outI = None
         return fswap
 
     def weighted_ft_ao(self, kpt):
         '''exp(-i*(G + k) dot r) * Coulomb_kernel for the basis of model charge'''
+        cell = self.cell
         fused_cell = self.fused_cell
         mesh = self.mesh
         Gv, Gvbase, kws = fused_cell.get_Gv_weights(mesh)
         b = fused_cell.reciprocal_vectors()
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
-        shls_slice = (self.auxcell.nbas, fused_cell.nbas)
-        auxG = ft_ao.ft_ao(fused_cell, Gv, shls_slice, b, gxyz, Gvbase, kpt).T
 
-        auxG *= self.weighted_coulG(kpt, False, mesh)
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            auxG = ft_ao.ft_ao(fused_cell, Gv, None, b, gxyz, Gvbase, kpt).T
+            naux = self.auxcell.nao
+            coulG = self.weighted_coulG(kpt, False, mesh)
+            with lib.temporary_env(cell, dimension=3):
+                coulG_full = self.weighted_coulG(kpt, False, mesh)
+            # For compensated basis, add_ft_j3c will remove its full Coulomb
+            # interactions
+            auxG[naux:] *= coulG_full
+            # For auxbasis, in truncated Coulomb treatments, coulG_full - coulG
+            # gives the trunc-Coul completion (interactions beyond truncation
+            # length). add_ft_j3c function will remove this part
+            auxG[:naux] *= coulG_full - coulG
+        else:
+            # FT for the compensated charge basis only
+            shls_slice = (self.auxcell.nbas, fused_cell.nbas)
+            auxG = ft_ao.ft_ao(fused_cell, Gv, shls_slice, b, gxyz, Gvbase, kpt).T
+            auxG *= self.weighted_coulG(kpt, False, mesh)
         Gaux = lib.transpose(auxG)
         GauxR = np.asarray(Gaux.real, order='C')
         GauxI = np.asarray(Gaux.imag, order='C')
         return GauxR, GauxI
 
     def gen_j3c_loader(self, h5group, kpt, kpt_ij_idx, aosym):
         cell = self.cell
         naux = self.auxcell.nao
         nauxc = self.fused_cell.nao
 
         # vbar is the interaction between the background charge
         # and the auxiliary basis.  0D, 1D, 2D do not have vbar.
         vbar = None
-        if cell.dimension == 3 and is_zero(kpt):
+        if (is_zero(kpt) and
+            (cell.dimension == 3 or
+             (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum'))):
             if self.exclude_dd_block:
                 rs_cell = self.rs_cell
                 ovlp = rs_cell.pbc_intor('int1e_ovlp', hermi=1, kpts=self.kpts)
                 smooth_ao_idx = rs_cell.get_ao_type() == ft_ao.SMOOTH_BASIS
                 for s in ovlp:
                     s[smooth_ao_idx[:,None] & smooth_ao_idx] = 0
                 recontract_2d = rs_cell.recontract(dim=2)
@@ -399,30 +445,41 @@
                 j3cR.append(vR)
                 j3cI.append(vI)
             return j3cR, j3cI
 
         return load_j3c
 
     def add_ft_j3c(self, j3c, Gpq, Gaux, p0, p1):
+        cell = self.cell
         j3cR, j3cI = j3c
         GchgR = Gaux[0][p0:p1]
         GchgI = Gaux[1][p0:p1]
-        naux = j3cR[0].shape[0] - GchgR.shape[1]
         nG = p1 - p0
-        for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
-            GpqR = GpqR.reshape(nG, -1)
-            GpqI = GpqI.reshape(nG, -1)
-            # \sum_G coulG * ints(ij * exp(-i G * r)) * ints(P * exp(i G * r))
-            # = \sum_G FT(ij, G) conj(FT(aux, G)) , where aux
-            # functions |P> are assumed to be real
-            lib.ddot(GchgR.T, GpqR, -1, j3cR[k][naux:], 1)
-            lib.ddot(GchgI.T, GpqI, -1, j3cR[k][naux:], 1)
-            if j3cI[k] is not None:
-                lib.ddot(GchgR.T, GpqI, -1, j3cI[k][naux:], 1)
-                lib.ddot(GchgI.T, GpqR,  1, j3cI[k][naux:], 1)
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
+                GpqR = GpqR.reshape(nG, -1)
+                GpqI = GpqI.reshape(nG, -1)
+                lib.ddot(GchgR.T, GpqR, -1, j3cR[k], 1)
+                lib.ddot(GchgI.T, GpqI, -1, j3cR[k], 1)
+                if j3cI[k] is not None:
+                    lib.ddot(GchgR.T, GpqI, -1, j3cI[k], 1)
+                    lib.ddot(GchgI.T, GpqR,  1, j3cI[k], 1)
+        else:
+            naux = j3cR[0].shape[0] - GchgR.shape[1]
+            for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
+                GpqR = GpqR.reshape(nG, -1)
+                GpqI = GpqI.reshape(nG, -1)
+                # \sum_G coulG * ints(ij * exp(-i G * r)) * ints(P * exp(i G * r))
+                # = \sum_G FT(ij, G) conj(FT(aux, G)) , where aux
+                # functions |P> are assumed to be real
+                lib.ddot(GchgR.T, GpqR, -1, j3cR[k][naux:], 1)
+                lib.ddot(GchgI.T, GpqI, -1, j3cR[k][naux:], 1)
+                if j3cI[k] is not None:
+                    lib.ddot(GchgR.T, GpqI, -1, j3cI[k][naux:], 1)
+                    lib.ddot(GchgI.T, GpqR,  1, j3cI[k][naux:], 1)
 
     def solve_cderi(self, cd_j2c, j3cR, j3cI):
         j2c, j2c_negative, j2ctag = cd_j2c
         if j3cI is None:
             j3c = self.fuse(j3cR)
         else:
             j3c = self.fuse(j3cR + j3cI * 1j)
@@ -433,28 +490,261 @@
         else:
             cderi = lib.dot(j2c, j3c)
             if j2c_negative is not None:
                 # for low-dimension systems
                 cderi_negative = lib.dot(j2c_negative, j3c)
         return cderi, cderi_negative
 
+
+class _CCNucBuilder(_CCGDFBuilder):
+
+    exclude_dd_block = True
+
+    def __init__(self, cell, kpts=np.zeros((1,3))):
+        self.mesh = None
+        self.fused_cell = None
+        self.modchg_cell = None
+        self.auxcell = self.rs_auxcell = None
+        Int3cBuilder.__init__(self, cell, self.auxcell, kpts)
+
+    def dump_flags(self, verbose=None):
+        logger.info(self, '\n')
+        logger.info(self, '******** %s ********', self.__class__)
+        logger.info(self, 'mesh = %s (%d PWs)', self.mesh, np.prod(self.mesh))
+        logger.info(self, 'ke_cutoff = %s', self.ke_cutoff)
+        logger.info(self, 'eta = %s', self.eta)
+        logger.info(self, 'j2c_eig_always = %s', self.j2c_eig_always)
+        return self
+
+    def build(self, eta=None):
+        cpu0 = logger.process_clock(), logger.perf_counter()
+        log = logger.new_logger(self)
+        cell = self.cell
+        kpts = self.kpts
+        nkpts = len(kpts)
+
+        self.bvk_kmesh = kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
+        log.debug('kmesh for bvk-cell = %s', kmesh)
+
+        if cell.dimension == 0:
+            self.eta, self.mesh, self.ke_cutoff = _guess_eta(cell, kpts, self.mesh)
+        else:
+            if eta is None:
+                eta = max(.5/(.5+nkpts**(1./9)), ETA_MIN)
+            ke_cutoff = estimate_ke_cutoff_for_eta(cell, eta)
+            self.mesh = cell.cutoff_to_mesh(ke_cutoff)
+            self.ke_cutoff = min(pbctools.mesh_to_cutoff(
+                cell.lattice_vectors(), self.mesh)[:cell.dimension])
+            self.eta = estimate_eta_for_ke_cutoff(cell, self.ke_cutoff)
+            if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+                self.mesh[2] = rsdf_builder._estimate_meshz(cell)
+            elif cell.dimension < 2:
+                self.mesh[cell.dimension:] = cell.mesh[cell.dimension:]
+            self.mesh = cell.symmetrize_mesh(self.mesh)
+
+        self.dump_flags()
+
+        self.modchg_cell = _compensate_nuccell(cell, self.eta)
+        self.rs_cell = rs_cell = ft_ao._RangeSeparatedCell.from_cell(
+            cell, self.ke_cutoff, rsdf_builder.RCUT_THRESHOLD, verbose=log)
+        rcut = estimate_rcut(rs_cell, self.modchg_cell,
+                             exclude_dd_block=self.exclude_dd_block)
+        rcut_max = rcut.max()
+        supmol = ft_ao.ExtendedMole.from_cell(rs_cell, kmesh, rcut_max, log)
+        supmol.exclude_dd_block = self.exclude_dd_block
+        self.supmol = supmol.strip_basis(rcut)
+        log.debug('sup-mol nbas = %d cGTO = %d pGTO = %d',
+                  supmol.nbas, supmol.nao, supmol.npgto_nr())
+
+        exp_min = np.hstack(cell.bas_exps()).min()
+        lattice_sum_factor = max((2*cell.rcut)**3/cell.vol * 1/exp_min, 1)
+        cutoff = cell.precision / lattice_sum_factor * .1
+        self.direct_scf_tol = cutoff / cell.atom_charges().max()
+        log.debug('Set _CCNucBuilder.direct_scf_tol to %g', cutoff)
+
+        rcut = rsdf_builder.estimate_ft_rcut(rs_cell, cell.precision,
+                                             self.exclude_dd_block)
+        supmol_ft = rsdf_builder._ExtendedMoleFT.from_cell(rs_cell, kmesh,
+                                                           rcut.max(), log)
+        supmol_ft.exclude_dd_block = self.exclude_dd_block
+        self.supmol_ft = supmol_ft.strip_basis(rcut)
+        log.debug('sup-mol-ft nbas = %d cGTO = %d pGTO = %d',
+                  supmol_ft.nbas, supmol_ft.nao, supmol_ft.npgto_nr())
+        log.timer_debug1('initializing supmol', *cpu0)
+        return self
+
+    def _int_nuc_vloc(self, fakenuc, intor='int3c2e', aosym='s2', comp=None,
+                      supmol=None):
+        '''Vnuc - Vloc.
+        '''
+        logger.debug2(self, 'Real space integrals %s for Vnuc - Vloc', intor)
+
+        cell = self.cell
+        kpts = self.kpts
+        nkpts = len(kpts)
+
+        charge = -cell.atom_charges()
+        if cell.dimension > 0:
+            mod_cell = self.modchg_cell
+            fakenuc = copy.copy(fakenuc)
+            fakenuc._atm, fakenuc._bas, fakenuc._env = \
+                    gto.conc_env(mod_cell._atm, mod_cell._bas, mod_cell._env,
+                                 fakenuc._atm, fakenuc._bas, fakenuc._env)
+            charge = np.append(-charge, charge)
+
+        int3c = self.gen_int3c_kernel(intor, aosym, comp=comp, j_only=True,
+                                      auxcell=fakenuc, supmol=supmol)
+        bufR, bufI = int3c()
+
+        if is_zero(kpts):
+            mat = np.einsum('k...z,z->k...', bufR, charge)
+        else:
+            mat = (np.einsum('k...z,z->k...', bufR, charge) +
+                   np.einsum('k...z,z->k...', bufI, charge) * 1j)
+
+        # vbar is the interaction between the background charge
+        # and the compensating function.  0D, 1D, 2D do not have vbar.
+        if ((intor in ('int3c2e', 'int3c2e_sph', 'int3c2e_cart')) and
+            (cell.dimension == 3 or
+             (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum'))):
+            logger.debug2(self, 'G=0 part for %s', intor)
+
+            # Note only need to remove the G=0 for mod_cell. when fakenuc is
+            # constructed for pseudo potentail, don't remove its G=0 contribution
+            charge = -cell.atom_charges()
+            nucbar = (charge / np.hstack(mod_cell.bas_exps())).sum()
+            nucbar *= np.pi/cell.vol
+            if self.exclude_dd_block:
+                rs_cell = self.rs_cell
+                ovlp = rs_cell.pbc_intor('int1e_ovlp', hermi=1, kpts=kpts)
+                smooth_ao_idx = rs_cell.get_ao_type() == ft_ao.SMOOTH_BASIS
+                for s in ovlp:
+                    s[smooth_ao_idx[:,None] & smooth_ao_idx] = 0
+                recontract_2d = rs_cell.recontract(dim=2)
+                ovlp = [recontract_2d(s) for s in ovlp]
+            else:
+                ovlp = cell.pbc_intor('int1e_ovlp', 1, lib.HERMITIAN, kpts)
+
+            for k in range(nkpts):
+                if aosym == 's1':
+                    mat[k] -= nucbar * ovlp[k].ravel()
+                else:
+                    mat[k] -= nucbar * lib.pack_tril(ovlp[k])
+        return mat
+
+    _int_dd_block = rsdf_builder._int_dd_block
+
+    def get_pp_loc_part1(self, mesh=None, with_pseudo=True):
+        log = logger.Logger(self.stdout, self.verbose)
+        t0 = t1 = (logger.process_clock(), logger.perf_counter())
+        if self.rs_cell is None:
+            self.build()
+        cell = self.cell
+        kpts = self.kpts
+        nkpts = len(kpts)
+        nao = cell.nao_nr()
+        aosym = 's2'
+        nao_pair = nao * (nao+1) // 2
+        mesh = self.mesh
+
+        fakenuc = aft._fake_nuc(cell, with_pseudo=with_pseudo)
+        vj = self._int_nuc_vloc(fakenuc)
+        if cell.dimension == 0:
+            return lib.unpack_tril(vj)
+
+        if self.exclude_dd_block:
+            cell_d = self.rs_cell.smooth_basis_cell()
+            if cell_d.nao > 0 and fakenuc.natm > 0:
+                merge_dd = self.rs_cell.merge_diffused_block(aosym)
+                if is_zero(kpts):
+                    vj_dd = self._int_dd_block(fakenuc)
+                    merge_dd(vj, vj_dd)
+                else:
+                    vj_ddR, vj_ddI = self._int_dd_block(fakenuc)
+                    for k in range(nkpts):
+                        outR = vj[k].real.copy()
+                        outI = vj[k].imag.copy()
+                        merge_dd(outR, vj_ddR[k])
+                        merge_dd(outI, vj_ddI[k])
+                        vj[k] = outR + outI * 1j
+        t0 = t1 = log.timer_debug1('vnuc pass1: analytic int', *t0)
+
+        kpt_allow = np.zeros(3)
+        Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
+        b = cell.reciprocal_vectors()
+        gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
+        charges = -cell.atom_charges()
+
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            coulG = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv)
+            with lib.temporary_env(cell, dimension=3):
+                coulG_full = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv)
+            aoaux = ft_ao.ft_ao(self.modchg_cell, Gv, None, b, gxyz, Gvbase)
+            vG = np.einsum('i,xi,x->x', charges, aoaux, coulG_full * kws)
+            aoaux = ft_ao.ft_ao(fakenuc, Gv, None, b, gxyz, Gvbase)
+            vG += np.einsum('i,xi,x->x', charges, aoaux, (coulG-coulG_full)*kws)
+        else:
+            aoaux = ft_ao.ft_ao(self.modchg_cell, Gv, None, b, gxyz, Gvbase)
+            coulG = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv)
+            vG = np.einsum('i,xi,x->x', charges, aoaux, coulG * kws)
+
+        ft_kern = self.supmol_ft.gen_ft_kernel(aosym, return_complex=False,
+                                               verbose=log)
+        ngrids = Gv.shape[0]
+        max_memory = max(2000, self.max_memory-lib.current_memory()[0])
+        Gblksize = max(16, int(max_memory*.8e6/16/(nao_pair*nkpts))//8*8)
+        Gblksize = min(Gblksize, ngrids, 200000)
+        vGR = vG.real
+        vGI = vG.imag
+        log.debug1('max_memory = %s  Gblksize = %s  ngrids = %s',
+                   max_memory, Gblksize, ngrids)
+
+        buf = np.empty((2, nkpts, Gblksize, nao_pair))
+        for p0, p1 in lib.prange(0, ngrids, Gblksize):
+            # shape of Gpq (nkpts, nGv, nao_pair)
+            Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, kpts, out=buf)
+            for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
+                # rho_ij(G) nuc(-G) / G^2
+                # = [Re(rho_ij(G)) + Im(rho_ij(G))*1j] [Re(nuc(G)) - Im(nuc(G))*1j] / G^2
+                vR = np.einsum('k,kx->x', vGR[p0:p1], GpqR)
+                vR+= np.einsum('k,kx->x', vGI[p0:p1], GpqI)
+                vj[k] += vR
+                if not is_zero(kpts[k]):
+                    vI = np.einsum('k,kx->x', vGR[p0:p1], GpqI)
+                    vI-= np.einsum('k,kx->x', vGI[p0:p1], GpqR)
+                    vj[k] += vI * 1j
+            t1 = log.timer_debug1('contracting Vnuc [%s:%s]'%(p0, p1), *t1)
+        log.timer_debug1('contracting Vnuc', *t0)
+
+        vj_kpts = []
+        for k, kpt in enumerate(kpts):
+            if is_zero(kpt):
+                vj_kpts.append(lib.unpack_tril(vj[k].real))
+            else:
+                vj_kpts.append(lib.unpack_tril(vj[k]))
+        return np.asarray(vj_kpts)
+
+    get_nuc = rsdf_builder.get_nuc
+    get_pp = rsdf_builder.get_pp
+
+
 def auxbar(fused_cell):
     r'''
     Potential average = \sum_L V_L*Lpq
 
     The coulomb energy is computed with chargeless density
     \int (rho-C) V,  C = (\int rho) / vol = Tr(gamma,S)/vol
     It is equivalent to removing the averaged potential from the short range V
     vs = vs - (\int V)/vol * S
     '''
     aux_loc = fused_cell.ao_loc_nr()
     naux = aux_loc[-1]
     vbar = np.zeros(naux)
-    # SR ERI does not have the contributions from backgound charge
-    if fused_cell.dimension != 3 or fused_cell.omega < 0:
+    # SR ERI should not have contributions from backgound charge
+    if fused_cell.dimension < 2 or fused_cell.omega < 0:
         return vbar
 
     half_sph_norm = .5/np.sqrt(np.pi)
     for i in range(fused_cell.nbas):
         l = fused_cell.bas_angular(i)
         if l == 0:
             es = fused_cell.bas_exp(i)
@@ -498,22 +788,27 @@
     chgcell._bas = np.asarray(chg_bas, dtype=np.int32).reshape(-1,gto.BAS_SLOTS)
     chgcell._env = np.hstack((auxcell._env, chg_env))
 
     # chgcell.rcut needs to ensure the model charges are well separated such
     # that the Coulomb interaction between the compensated auxiliary basis can
     # be calculated as 1/Rcut.
     # _estimate_rcut based on the integral overlap
-    chgcell.rcut = _estimate_rcut(smooth_eta, l_max, 1., auxcell.precision)
+    chgcell.rcut = pbcgto.cell._estimate_rcut(smooth_eta, l_max, 1., auxcell.precision)
 
     logger.debug1(auxcell, 'make compensating basis, num shells = %d, num cGTOs = %d',
                   chgcell.nbas, chgcell.nao_nr())
     logger.debug1(auxcell, 'chgcell.rcut %s', chgcell.rcut)
     return chgcell
 
 def fuse_auxcell(auxcell, eta):
+    if auxcell.dimension == 0:
+        def fuse(Lpq, axis=0):
+            return Lpq
+        return auxcell, fuse
+
     chgcell = make_modchg_basis(auxcell, eta)
     fused_cell = copy.copy(auxcell)
     fused_cell._atm, fused_cell._bas, fused_cell._env = \
             gto.conc_env(auxcell._atm, auxcell._bas, auxcell._env,
                          chgcell._atm, chgcell._bas, chgcell._env)
     fused_cell.rcut = max(auxcell.rcut, chgcell.rcut)
 
@@ -583,47 +878,184 @@
                 p0 = modchg_offset[ia,l]
                 if p0 >= 0:
                     nd = l * 2 + 1
                     for i0, i1 in lib.prange(aux_loc[i], aux_loc[i+1], nd):
                         Lpq[i0:i1] -= chgLpq[p0:p0+nd]
             if axis == 1 and Lpq.ndim == 2:
                 Lpq = lib.transpose(Lpq)
-            return Lpq
+            return np.asarray(Lpq, order='A')
     return fused_cell, fuse
 
 def _guess_eta(cell, kpts=None, mesh=None):
     '''Search for optimal eta and mesh'''
     if cell.dimension == 0:
         if mesh is None:
             mesh = cell.mesh
         ke_cutoff = pbctools.mesh_to_cutoff(cell.lattice_vectors(), mesh).min()
-        eta = aft.estimate_eta_for_ke_cutoff(cell, ke_cutoff, cell.precision)
+        eta = estimate_eta_for_ke_cutoff(cell, ke_cutoff, cell.precision)
         return eta, mesh, ke_cutoff
 
+    # eta_min = estimate_eta_min(cell, cell.precision*1e-2)
+    eta_min = ETA_MIN
+    ke_min = estimate_ke_cutoff_for_eta(cell, eta_min, cell.precision)
     a = cell.lattice_vectors()
-    eta_min = aft.estimate_eta(cell, cell.precision*1e-2)
-    ke_min = aft.estimate_ke_cutoff_for_eta(cell, eta_min, cell.precision)
-    mesh_min = _round_off_to_odd_mesh(pbctools.cutoff_to_mesh(a, ke_min))
 
     if mesh is None:
-        nimgs = (8 * cell.rcut**3 / cell.vol) ** (cell.dimension / 3)
         nkpts = len(kpts)
-        nao = cell.nao
-        mesh = (nimgs**2*nao / (nkpts**.5*nimgs**.5 * 1e2 + nkpts**2*nao))**(1./3) + 2
-        mesh = int(min((1e8/nao)**(1./3), mesh))
-        mesh = np.max([mesh_min, [mesh] * 3], axis=0)
-        ke_cutoff = pbctools.mesh_to_cutoff(a, mesh-1)
-        ke_cutoff = ke_cutoff[:cell.dimension].min()
-        if cell.dimension < 2 or cell.low_dim_ft_type == 'inf_vacuum':
-            mesh[cell.dimension:] = cell.mesh[cell.dimension:]
-        elif cell.dimension == 2:
-            mesh = pbctools.cutoff_to_mesh(a, ke_cutoff)
-        mesh = _round_off_to_odd_mesh(mesh)
+        ke_cutoff = 30. * nkpts**(-1./3)
+        ke_cutoff = max(ke_cutoff, ke_min)
+        mesh = cell.cutoff_to_mesh(ke_cutoff)
     else:
+        mesh = np.asarray(mesh)
+        mesh_min = cell.cutoff_to_mesh(ke_min)
         if np.any(mesh[:cell.dimension] < mesh_min[:cell.dimension]):
             logger.warn(cell, 'mesh %s is not enough to converge to the required '
                         'integral precision %g.\nRecommended mesh is %s.',
                         mesh, cell.precision, mesh_min)
-        ke_cutoff = pbctools.mesh_to_cutoff(cell.lattice_vectors(), np.asarray(mesh)-1)
-        ke_cutoff = ke_cutoff[:cell.dimension].min()
-    eta = aft.estimate_eta_for_ke_cutoff(cell, ke_cutoff, cell.precision)
+    ke_cutoff = min(pbctools.mesh_to_cutoff(a, mesh)[:cell.dimension])
+    eta = estimate_eta_for_ke_cutoff(cell, ke_cutoff, cell.precision)
     return eta, mesh, ke_cutoff
+
+def _compensate_nuccell(cell, eta):
+    '''A cell of the compensated Gaussian charges for nucleus'''
+    modchg_cell = copy.copy(cell)
+    half_sph_norm = .5/np.sqrt(np.pi)
+    norm = half_sph_norm/gto.gaussian_int(2, eta)
+    chg_env = [eta, norm]
+    ptr_eta = cell._env.size
+    ptr_norm = ptr_eta + 1
+    chg_bas = [[ia, 0, 1, 1, 0, ptr_eta, ptr_norm, 0] for ia in range(cell.natm)]
+    modchg_cell._atm = cell._atm
+    modchg_cell._bas = np.asarray(chg_bas, dtype=np.int32)
+    modchg_cell._env = np.hstack((cell._env, chg_env))
+    return modchg_cell
+
+def estimate_rcut(rs_cell, auxcell, precision=None, exclude_dd_block=False):
+    '''Estimate rcut for 3c2e integrals'''
+    if precision is None:
+        precision = rs_cell.precision
+
+    if rs_cell.nbas == 0 or auxcell.nbas == 0:
+        return np.zeros(1)
+
+    cell_exps, cs = pbcgto.cell._extract_pgto_params(rs_cell, 'min')
+    ls = rs_cell._bas[:,gto.ANG_OF]
+
+    aux_exps = np.array([e.min() for e in auxcell.bas_exps()])
+    ai_idx = cell_exps.argmin()
+    ak_idx = aux_exps.argmin()
+    ai = cell_exps[ai_idx]
+    aj = cell_exps
+    ak = aux_exps[ak_idx]
+    li = rs_cell._bas[ai_idx,gto.ANG_OF]
+    lj = ls
+    lk = auxcell._bas[ak_idx,gto.ANG_OF]
+
+    ci = cs[ai_idx]
+    cj = cs
+    # Note ck normalizes the auxiliary basis \int \chi_k dr to 1
+    ck = 1./(4*np.pi) / gto.gaussian_int(lk+2, ak)
+
+    aij = ai + aj
+    lij = li + lj
+    l3 = lij + lk
+    theta = 1./(1./aij + 1./ak)
+    norm_ang = ((2*li+1)*(2*lj+1))**.5/(4*np.pi)
+    c1 = ci * cj * ck * norm_ang
+    sfac = aij*aj/(aij*aj + ai*theta)
+    fl = 2
+    fac = 2**li*np.pi**2.5*c1 * theta**(l3-.5)
+    fac *= 2*np.pi/rs_cell.vol/theta
+    fac /= aij**(li+1.5) * ak**(lk+1.5) * aj**lj
+    fac *= fl / precision
+
+    r0 = rs_cell.rcut
+    r0 = (np.log(fac * r0 * (sfac*r0)**(l3-1) + 1.) / (sfac*theta))**.5
+    r0 = (np.log(fac * r0 * (sfac*r0)**(l3-1) + 1.) / (sfac*theta))**.5
+    rcut = r0
+
+    if exclude_dd_block:
+        compact_mask = rs_cell.bas_type != ft_ao.SMOOTH_BASIS
+        compact_idx = np.where(compact_mask)[0]
+        if 0 < compact_idx.size < rs_cell.nbas:
+            compact_idx = compact_idx[cell_exps[compact_idx].argmin()]
+            smooth_mask = ~compact_mask
+            ai = cell_exps[compact_idx]
+            li = ls[compact_idx]
+            ci = cs[compact_idx]
+            aj = cell_exps[smooth_mask]
+            lj = ls[smooth_mask]
+            cj = cs[smooth_mask]
+
+            aij = ai + aj
+            lij = li + lj
+            l3 = lij + lk
+            theta = 1./(1./aij + 1./ak)
+            norm_ang = ((2*li+1)*(2*lj+1))**.5/(4*np.pi)
+            c1 = ci * cj * ck * norm_ang
+            sfac = aij*aj/(aij*aj + ai*theta)
+            fl = 2
+            fac = 2**li*np.pi**2.5*c1 * theta**(l3-.5)
+            fac *= 2*np.pi/rs_cell.vol/theta
+            fac /= aij**(li+1.5) * ak**(lk+1.5) * aj**lj
+            fac *= fl / precision
+
+            r0 = rs_cell.rcut
+            r0 = (np.log(fac * r0 * (sfac*r0)**(l3-1) + 1.) / (sfac*theta))**.5
+            r0 = (np.log(fac * r0 * (sfac*r0)**(l3-1) + 1.) / (sfac*theta))**.5
+            rcut[smooth_mask] = r0
+    return rcut
+
+def estimate_eta_min(cell, precision=None):
+    '''Given rcut the boundary of repeated images of the cell, estimates the
+    minimal exponent of the smooth compensated gaussian model charge, requiring
+    that at boundary, density ~ 4pi rmax^2 exp(-eta/2*rmax^2) < precision
+    '''
+    if precision is None:
+        precision = cell.precision
+    lmax = min(np.max(cell._bas[:,gto.ANG_OF]), 4)
+    # If lmax=3 (r^5 for radial part), this expression guarantees at least up
+    # to f shell the convergence at boundary
+    rcut = cell.rcut
+    eta = max(np.log(4*np.pi*rcut**(lmax+2)/precision)/rcut**2, ETA_MIN)
+    return eta
+
+def estimate_eta_for_ke_cutoff(cell, ke_cutoff, precision=None):
+    '''Given ke_cutoff, the upper bound of eta to produce the required
+    precision in AFTDF Coulomb integrals.
+    '''
+    if precision is None:
+        precision = cell.precision
+    ai = np.hstack(cell.bas_exps()).max()
+    aij = ai * 2
+    ci = gto.gto_norm(0, ai)
+    norm_ang = (4*np.pi)**-1.5
+    c1 = ci**2 * norm_ang
+    fac = 64*np.pi**5*c1 * (aij*ke_cutoff*2)**-.5 / precision
+
+    eta = 4.
+    eta = 1./(np.log(fac * eta**-1.5)*2 / ke_cutoff - 1./aij)
+    if eta < 0:
+        eta = 4.
+    else:
+        eta = min(4., eta)
+    return eta
+
+def estimate_ke_cutoff_for_eta(cell, eta, precision=None):
+    '''Given eta, the lower bound of ke_cutoff to produce the required
+    precision in AFTDF Coulomb integrals.
+    '''
+    if precision is None:
+        precision = cell.precision
+    ai = np.hstack(cell.bas_exps()).max()
+    aij = ai * 2
+    ci = gto.gto_norm(0, ai)
+    ck = gto.gto_norm(0, eta)
+    theta = 1./(1./aij + 1./eta)
+    Norm_ang = (4*np.pi)**-1.5
+    fac = 32*np.pi**5 * ci**2*ck*Norm_ang * (2*aij) / (aij*eta)**1.5
+    fac /= precision
+
+    Ecut = 20.
+    Ecut = np.log(fac * (Ecut*2)**(-.5)) * 2*theta
+    Ecut = np.log(fac * (Ecut*2)**(-.5)) * 2*theta
+    return Ecut
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/incore.py` & `pyscf-2.3.0/pyscf/pbc/df/aft.py`

 * *Files 23% similar despite different names*

```diff
@@ -12,710 +12,717 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
 # Author: Qiming Sun <osirpt.sun@gmail.com>
 #
 
-import ctypes
+'''Density expansion on plane waves'''
+
+
 import copy
+import contextlib
 import numpy as np
 from pyscf import lib
 from pyscf import gto
 from pyscf.lib import logger
-import pyscf.df
-from pyscf.scf import _vhf
-from pyscf.pbc.df import ft_ao
-from pyscf.pbc.gto import estimate_rcut
+from pyscf.pbc import tools
+from pyscf.pbc.gto import pseudo, error_for_ke_cutoff
+from pyscf.pbc import gto as pbcgto
 from pyscf.pbc.gto.pseudo import pp_int
-from pyscf.pbc.lib.kpts_helper import is_zero, unique
+from pyscf.pbc.lib.kpts_helper import is_zero, gamma_point
+from pyscf.pbc.df import ft_ao
+from pyscf.pbc.df import aft_jk
+from pyscf.pbc.df import aft_ao2mo
+from pyscf.pbc.df.incore import Int3cBuilder
 from pyscf.pbc.tools import k2gamma
 from pyscf.pbc.tools import pbc as pbctools
 from pyscf import __config__
 
-RCUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_rcut_threshold', 2.5)
-KECUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_kecut_threshold', 10.0)
 
-libpbc = lib.load_library('libpbc')
+KE_SCALING = getattr(__config__, 'pbc_df_aft_ke_cutoff_scaling', 0.75)
+RCUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_rcut_threshold', 2.0)
 
-def make_auxmol(cell, auxbasis=None):
+def estimate_eta_min(cell, cutoff=None):
+    '''Given rcut the boundary of repeated images of the cell, estimates the
+    minimal exponent of the smooth compensated gaussian model charge, requiring
+    that at boundary, density ~ 4pi rmax^2 exp(-eta/2*rmax^2) < cutoff
     '''
-    See pyscf.df.addons.make_auxmol
+    from pyscf.pbc.df.gdf_builder import estimate_eta_min
+    logger.warn(cell, 'Function deprecated. '
+                'Call pbc.df.gdf_builder.estimate_eta_min instead.')
+    return estimate_eta_min(cell, cutoff)
+
+estimate_eta = estimate_eta_min
+
+def estimate_eta_for_ke_cutoff(cell, ke_cutoff, precision=None):
+    '''Given ke_cutoff, the upper bound of eta to produce the required
+    precision in AFTDF Coulomb integrals.
     '''
-    auxcell = pyscf.df.addons.make_auxmol(cell, auxbasis)
-    auxcell.rcut = estimate_rcut(auxcell, cell.precision)
-    return auxcell
-
-make_auxcell = make_auxmol
+    from pyscf.pbc.df.gdf_builder import estimate_eta_for_ke_cutoff
+    logger.warn(cell, 'Function deprecated. '
+                'Call pbc.df.gdf_builder.estimate_eta_for_ke_cutoff instead.')
+    return estimate_eta_for_ke_cutoff(cell, ke_cutoff, precision)
+
+def estimate_ke_cutoff_for_eta(cell, eta, precision=None):
+    '''Given eta, the lower bound of ke_cutoff to produce the required
+    precision in AFTDF Coulomb integrals.
+    '''
+    from pyscf.pbc.df.gdf_builder import estimate_ke_cutoff_for_eta
+    logger.warn(cell, 'Function deprecated. '
+                'Call pbc.df.gdf_builder.estimate_ke_cutoff_for_eta instead.')
+    return estimate_ke_cutoff_for_eta(cell, eta, precision)
+
+def estimate_omega_min(cell, cutoff=None):
+    '''Given cell.rcut the boundary of repeated images of the cell, estimates
+    the minimal omega for the attenuated Coulomb interactions, requiring that at
+    boundary the Coulomb potential of a point charge < cutoff
+    '''
+    from pyscf.pbc.df.rsdf_builder import estimate_omega_min
+    logger.warn(cell, 'Function deprecated. '
+                'Call pbc.df.rsdf_builder.estimate_omega_min instead.')
+    return estimate_omega_min(cell, cutoff)
 
-def format_aux_basis(cell, auxbasis='weigend+etb'):
-    '''For backward compatibility'''
-    return make_auxmol(cell, auxbasis)
+estimate_omega = estimate_omega_min
 
-def aux_e2(cell, auxcell_or_auxbasis, intor='int3c2e', aosym='s1', comp=None,
-           kptij_lst=np.zeros((1,2,3)), shls_slice=None, **kwargs):
-    r'''3-center AO integrals (ij|L) with double lattice sum:
-    \sum_{lm} (i[l]j[m]|L[0]), where L is the auxiliary basis.
+def estimate_ke_cutoff_for_omega(cell, omega, precision=None):
+    '''Energy cutoff for AFTDF to converge attenuated Coulomb in moment space
+    '''
+    from pyscf.pbc.df.rsdf_builder import estimate_ke_cutoff_for_omega
+    logger.warn(cell, 'Function deprecated. '
+                'Call pbc.df.rsdf_builder.estimate_ke_cutoff_for_omega instead.')
+    return estimate_ke_cutoff_for_omega(cell, omega, precision)
 
-    Returns:
-        (nao_pair, naux) array
+def estimate_omega_for_ke_cutoff(cell, ke_cutoff, precision=None):
+    '''The minimal omega in attenuated Coulombl given energy cutoff
     '''
-    if isinstance(auxcell_or_auxbasis, gto.Mole):
-        auxcell = auxcell_or_auxbasis
+    from pyscf.pbc.df.rsdf_builder import estimate_omega_for_ke_cutoff
+    logger.warn(cell, 'Function deprecated. '
+                'Call pbc.df.rsdf_builder.estimate_omega_for_ke_cutoff instead.')
+    return estimate_omega_for_ke_cutoff(cell, ke_cutoff, precision)
+
+
+def _get_pp_loc_part1(mydf, kpts=None, with_pseudo=True):
+    kpts, is_single_kpt = _check_kpts(mydf, kpts)
+    log = logger.Logger(mydf.stdout, mydf.verbose)
+    t0 = t1 = (logger.process_clock(), logger.perf_counter())
+    cell = mydf.cell
+    mesh = np.asarray(mydf.mesh)
+    nkpts = len(kpts)
+    nao = cell.nao_nr()
+    nao_pair = nao * (nao+1) // 2
+
+    kpt_allow = np.zeros(3)
+    if cell.dimension > 0:
+        ke_guess = estimate_ke_cutoff(cell, cell.precision)
+        mesh_guess = cell.cutoff_to_mesh(ke_guess)
+        if np.any(mesh < mesh_guess*KE_SCALING):
+            logger.warn(mydf, 'mesh %s is not enough for AFTDF.get_nuc function '
+                        'to get integral accuracy %g.\nRecommended mesh is %s.',
+                        mesh, cell.precision, mesh_guess)
+    log.debug1('aft.get_pp_loc_part1 mesh = %s', mesh)
+    Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
+
+    if with_pseudo:
+        vpplocG = pp_int.get_gth_vlocG_part1(cell, Gv)
+        vpplocG = -np.einsum('ij,ij->j', cell.get_SI(Gv), vpplocG)
     else:
-        auxcell = make_auxcell(cell, auxcell_or_auxbasis)
+        fakenuc = _fake_nuc(cell, with_pseudo=with_pseudo)
+        aoaux = ft_ao.ft_ao(fakenuc, Gv)
+        charges = cell.atom_charges()
+        coulG = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv)
+        vpplocG = np.einsum('i,xi,x->x', -charges, aoaux, coulG)
 
-# For some unkown reasons, the pre-decontracted basis 'is slower than
-## Slighly decontract basis. The decontracted basis has better locality.
-## The locality can be used in the lattice sum to reduce cost.
-#    if shls_slice is None and cell.nao_nr() < 200:
-#        cell, contr_coeff = pbcgto.cell._split_basis(cell)
-#    else:
-#        contr_coeff = None
-
-    int3c = wrap_int3c(cell, auxcell, intor, aosym, comp, kptij_lst, **kwargs)
-    out = int3c(shls_slice)
-
-#    if contr_coeff is not None:
-#        if aosym == 's2':
-#            tmp = out.reshape(nkptij,comp,ni,ni,naux)
-#            idx, idy = np.tril_indices(ni)
-#            tmp[:,:,idy,idx] = out.conj()
-#            tmp[:,:,idx,idy] = out
-#            out, tmp = tmp, None
-#            out = lib.einsum('kcpql,pi->kciql', out, contr_coeff)
-#            out = lib.einsum('kciql,qj->kcijl', out, contr_coeff)
-#            idx, idy = np.tril_indices(contr_coeff.shape[1])
-#            out = out[:,:,idx,idy]
-#        else:
-#            out = out.reshape(nkptij,comp,ni,nj,naux)
-#            out = lib.einsum('kcpql,pi->kciql', out, contr_coeff)
-#            out = lib.einsum('kciql,qj->kcijl', out, contr_coeff)
-#            out = out.reshape(nkptij,comp,-1,naux)
-
-    if len(kptij_lst) == 1:
-        out = out[0]
-    return out
-
-def wrap_int3c(cell, auxcell, intor='int3c2e', aosym='s1', comp=1,
-               kptij_lst=np.zeros((1,2,3)), cintopt=None, pbcopt=None):
-    '''Generate a 3-center integral kernel which can be called repeatedly in
-    the incore or outcore driver. The kernel function has a simple function
-    signature f(shls_slice)
-    '''
-    kpti = kptij_lst[:,0]
-    kptj = kptij_lst[:,1]
-    j_only = is_zero(kpti - kptj)
-    if j_only:
-        kpts = kpti
-        nkpts = len(kpts)
-        kptij_idx = np.arange(nkpts)
+    vpplocG *= kws
+    vGR = vpplocG.real
+    vGI = vpplocG.imag
+
+    vjR = np.zeros((nkpts, nao_pair))
+    vjI = np.zeros((nkpts, nao_pair))
+    max_memory = max(2000, mydf.max_memory-lib.current_memory()[0])
+    for Gpq, p0, p1 in mydf.ft_loop(mesh, kpt_allow, kpts, aosym='s2',
+                                    max_memory=max_memory, return_complex=False):
+        # shape of Gpq (nkpts, nGv, nao_pair)
+        for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
+            # rho_ij(G) nuc(-G) / G^2
+            # = [Re(rho_ij(G)) + Im(rho_ij(G))*1j] [Re(nuc(G)) - Im(nuc(G))*1j] / G^2
+            vjR[k] += np.einsum('k,kx->x', vGR[p0:p1], GpqR)
+            vjR[k] += np.einsum('k,kx->x', vGI[p0:p1], GpqI)
+            if not is_zero(kpts[k]):
+                vjI[k] += np.einsum('k,kx->x', vGR[p0:p1], GpqI)
+                vjI[k] -= np.einsum('k,kx->x', vGI[p0:p1], GpqR)
+        t1 = log.timer_debug1('contracting Vnuc [%s:%s]'%(p0, p1), *t1)
+    log.timer_debug1('contracting Vnuc', *t0)
+
+    vj_kpts = []
+    for k, kpt in enumerate(kpts):
+        if is_zero(kpt):
+            vj_kpts.append(lib.unpack_tril(vjR[k]))
+        else:
+            vj_kpts.append(lib.unpack_tril(vjR[k]+vjI[k]*1j))
+    if is_single_kpt:
+        vj_kpts = vj_kpts[0]
+    return np.asarray(vj_kpts)
+
+def _check_kpts(mydf, kpts):
+    '''Check if the argument kpts is a single k-point'''
+    if kpts is None:
+        kpts = np.asarray(mydf.kpts)
+        # mydf.kpts is initialized to np.zeros((1,3)). Here is only a guess
+        # based on the value of mydf.kpts.
+        is_single_kpt = kpts.ndim == 1 or is_zero(kpts)
     else:
-        kpts, _, kptij_idx = unique(np.vstack([kpti,kptj]))
-        wherei = kptij_idx[:len(kpti)]
-        wherej = kptij_idx[len(kpti):]
-        nkpts = len(kpts)
-        kptij_idx = wherei * nkpts + wherej
-    dfbuilder = _Int3cBuilder(cell, auxcell, kpts).build()
-    # Reduce the size of supmol based on the 3-center overlaps. Otherwise the
-    # dfbuilder.supmol oftens two large for the calculations.
-    # TODO: strip supmol basis based on the intor type.
-    eta = np.hstack(auxcell.bas_exps()).min()
-    dfbuilder.supmol = _strip_basis(dfbuilder.supmol, eta)
-    int3c = dfbuilder.gen_int3c_kernel(intor, aosym, comp, j_only,
-                                       kptij_idx, return_complex=True)
-    return int3c
+        kpts = np.asarray(kpts)
+        is_single_kpt = kpts.ndim == 1
+    kpts = kpts.reshape(-1,3)
+    return kpts, is_single_kpt
+
+def _int_nuc_vloc(mydf, nuccell, kpts, intor='int3c2e', aosym='s2', comp=1):
+    '''Vnuc - Vloc'''
+    raise DeprecationWarning
+
+def get_pp(mydf, kpts=None):
+    '''Get the periodic pseudotential nuc-el AO matrix, with G=0 removed.
+
+    Kwargs:
+        mesh: custom mesh grids. By default mesh is determined by the
+        function _guess_eta from module pbc.df.gdf_builder.
+    '''
+    t0 = (logger.process_clock(), logger.perf_counter())
+    kpts, is_single_kpt = _check_kpts(mydf, kpts)
+    cell = mydf.cell
+    vpp = _get_pp_loc_part1(mydf, kpts, with_pseudo=True)
+    t1 = logger.timer_debug1(mydf, 'get_pp_loc_part1', *t0)
+    pp2builder = _IntPPBuilder(cell, kpts)
+    vpp += pp2builder.get_pp_loc_part2()
+    t1 = logger.timer_debug1(mydf, 'get_pp_loc_part2', *t1)
+    vpp += pp_int.get_pp_nl(cell, kpts)
+    t1 = logger.timer_debug1(mydf, 'get_pp_nl', *t1)
+    if is_single_kpt:
+        vpp = vpp[0]
+    logger.timer(mydf, 'get_pp', *t0)
+    return vpp
 
 
-def fill_2c2e(cell, auxcell_or_auxbasis, intor='int2c2e', hermi=0, kpt=np.zeros(3)):
-    '''2-center 2-electron AO integrals (L|ij), where L is the auxiliary basis.
-    '''
-    if isinstance(auxcell_or_auxbasis, gto.Mole):
-        auxcell = auxcell_or_auxbasis
-    else:
-        auxcell = make_auxcell(cell, auxcell_or_auxbasis)
+def get_nuc(mydf, kpts=None):
+    '''Get the periodic nuc-el AO matrix, with G=0 removed.
 
-    if hermi != 0:
-        hermi = pyscf.lib.HERMITIAN
-# pbcopt use the value of AO-pair to prescreening PBC integrals in the lattice
-# summation.  Pass NULL pointer to pbcopt to prevent the prescreening
-    return auxcell.pbc_intor(intor, 1, hermi, kpt, pbcopt=lib.c_null_ptr())
+    Kwargs:
+        function _guess_eta from module pbc.df.gdf_builder.
+    '''
+    t0 = (logger.process_clock(), logger.perf_counter())
+    nuc = _get_pp_loc_part1(mydf, kpts, with_pseudo=False)
+    logger.timer(mydf, 'get_nuc', *t0)
+    return nuc
+
+
+def weighted_coulG(mydf, kpt=np.zeros(3), exx=False, mesh=None, omega=None):
+    '''Weighted regular Coulomb kernel, applying cell.omega by default'''
+    cell = mydf.cell
+    if mesh is None:
+        mesh = mydf.mesh
+    if omega is None:
+        omega = cell.omega
+    Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
+    coulG = tools.get_coulG(cell, kpt, exx, mydf, mesh, Gv, omega=omega)
+    coulG *= kws
+    return coulG
 
 
-class _Int3cBuilder(lib.StreamObject):
-    '''helper functions to compute 3-center integral tensor with double-lattice sum
+def _fake_nuc(cell, with_pseudo=True):
+    '''A fake cell with steep gaussians to mimic nuclear density
     '''
-    def __init__(self, cell, auxcell, kpts=None):
-        self.cell = cell
-        self.auxcell = auxcell
-        self.stdout = cell.stdout
-        self.verbose = cell.verbose
-        self.max_memory = cell.max_memory
-        if kpts is None:
-            self.kpts = np.zeros((1, 3))
+    fakenuc = copy.copy(cell)
+    fakenuc._atm = cell._atm.copy()
+    fakenuc._atm[:,gto.PTR_COORD] = np.arange(gto.PTR_ENV_START,
+                                              gto.PTR_ENV_START+cell.natm*3,3)
+    _bas = []
+    _env = [0]*gto.PTR_ENV_START + [cell.atom_coords().ravel()]
+    ptr = gto.PTR_ENV_START + cell.natm * 3
+    half_sph_norm = .5/np.sqrt(np.pi)
+    for ia in range(cell.natm):
+        symb = cell.atom_symbol(ia)
+        if with_pseudo and symb in cell._pseudo:
+            pp = cell._pseudo[symb]
+            rloc, nexp, cexp = pp[1:3+1]
+            eta = .5 / rloc**2
         else:
-            self.kpts = np.reshape(kpts, (-1, 3))
+            eta = 1e16
+        norm = half_sph_norm/gto.gaussian_int(2, eta)
+        _env.extend([eta, norm])
+        _bas.append([ia, 0, 1, 1, 0, ptr, ptr+1, 0])
+        ptr += 2
+    fakenuc._bas = np.asarray(_bas, dtype=np.int32)
+    fakenuc._env = np.asarray(np.hstack(_env), dtype=np.double)
+    fakenuc.rcut = 0.1
+    return fakenuc
 
-        self.rs_cell = None
-        # mesh to generate Born-von Karman supercell
-        self.bvk_kmesh = None
-        self.supmol = None
-        self.ke_cutoff = None
 
-        self._keys = set(self.__dict__.keys())
+def _estimate_ke_cutoff(alpha, l, c, precision, omega=0):
+    '''Energy cutoff estimation for 4-center Coulomb repulsion integrals'''
+    norm_ang = ((2*l+1)/(4*np.pi))**2
+    fac = 8*np.pi**5 * c**4*norm_ang / (2*alpha)**(4*l+2) / precision
+    Ecut = 20.
+    if omega <= 0:
+        Ecut = np.log(fac * (Ecut*.5)**(2*l-.5) + 1.) * 2*alpha
+        Ecut = np.log(fac * (Ecut*.5)**(2*l-.5) + 1.) * 2*alpha
+    else:
+        theta = 1./(1./(2*alpha) + 1./(2*omega**2))
+        Ecut = np.log(fac * (Ecut*.5)**(2*l-.5) + 1.) * theta
+        Ecut = np.log(fac * (Ecut*.5)**(2*l-.5) + 1.) * theta
+    return Ecut
+
+def estimate_ke_cutoff(cell, precision=None):
+    '''Energy cutoff estimation for 4-center Coulomb repulsion integrals'''
+    if cell.nbas == 0:
+        return 0.
+    if precision is None:
+        precision = cell.precision
+    exps, cs = pbcgto.cell._extract_pgto_params(cell, 'max')
+    ls = cell._bas[:,gto.ANG_OF]
+    cs = gto.gto_norm(ls, exps)
+    Ecut = _estimate_ke_cutoff(exps, ls, cs, precision)
+    return Ecut.max()
 
-    def reset(self, cell=None):
-        if cell is not None:
-            self.cell = cell
-        self.rs_cell = None
-        self.supmol = None
-        return self
+
+class _IntPPBuilder(Int3cBuilder):
+    '''3-center integral builder for pp loc part2 only
+    '''
+    def __init__(self, cell, kpts=np.zeros((1,3))):
+        # cache ovlp_mask which are reused for different types of intor
+        self._supmol = None
+        self._ovlp_mask = None
+        self._cell0_ovlp_mask = None
+        Int3cBuilder.__init__(self, cell, None, kpts)
+
+    def get_ovlp_mask(self, cutoff, supmol=None, cintopt=None):
+        if self._ovlp_mask is None or supmol is not self._supmol:
+            self._ovlp_mask, self._cell0_ovlp_mask = \
+                    Int3cBuilder.get_ovlp_mask(self, cutoff, supmol, cintopt)
+            self._supmol = supmol
+        return self._ovlp_mask, self._cell0_ovlp_mask
 
     def build(self):
+        pass
+
+    def get_pp_loc_part2(self):
         log = logger.new_logger(self)
         cell = self.cell
         kpts = self.kpts
+        nkpts = len(kpts)
 
         self.bvk_kmesh = kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
         log.debug('kmesh for bvk-cell = %s', kmesh)
 
         self.rs_cell = rs_cell = ft_ao._RangeSeparatedCell.from_cell(
             cell, self.ke_cutoff, RCUT_THRESHOLD, verbose=log)
 
-        supmol = ft_ao._ExtendedMole.from_cell(rs_cell, kmesh, cell.rcut,
-                                               verbose=log)
-        if self.auxcell is not None:
-            eta = np.hstack(self.auxcell.bas_exps()).min()
-            supmol = _strip_basis(supmol, eta)
-        self.supmol = supmol
+        intors = ('int3c2e', 'int3c1e', 'int3c1e_r2_origk',
+                  'int3c1e_r4_origk', 'int3c1e_r6_origk')
+        fake_cells = {}
+        for cn in range(1, 5):
+            fake_cell = pp_int.fake_cell_vloc(cell, cn)
+            if fake_cell.nbas > 0:
+                fake_cells[cn] = fake_cell
+
+        if not fake_cells:
+            if any(cell.atom_symbol(ia) in cell._pseudo for ia in range(cell.natm)):
+                pass
+            else:
+                lib.logger.warn(cell, 'cell.pseudo was specified but its elements %s '
+                                'were not found in the system.', cell._pseudo.keys())
+            vpploc = [0] * nkpts
+            return vpploc
+
+        rcut = self._estimate_rcut_3c1e(rs_cell, fake_cells)
+        supmol = ft_ao.ExtendedMole.from_cell(rs_cell, kmesh, rcut.max(), log)
+        self.supmol = supmol.strip_basis(rcut)
         log.debug('sup-mol nbas = %d cGTO = %d pGTO = %d',
                   supmol.nbas, supmol.nao, supmol.npgto_nr())
-        return self
 
-    def gen_int3c_kernel(self, intor='int3c2e', aosym='s2', comp=None,
-                         j_only=False, reindex_k=None, rs_auxcell=None,
-                         auxcell=None, supmol=None, return_complex=False):
-        '''Generate function to compute int3c2e with double lattice-sum
+        bufR = 0
+        bufI = 0
+        for cn, fake_cell in fake_cells.items():
+            int3c = self.gen_int3c_kernel(
+                intors[cn], 's2', comp=1, j_only=True, auxcell=fake_cell)
+            vR, vI = int3c()
+            bufR += np.einsum('...i->...', vR)
+            if vI is not None:
+                bufI += np.einsum('...i->...', vI)
 
-        rs_auxcell: range-separated auxcell for gdf/rsdf module
+        buf = (bufR + bufI * 1j).reshape(nkpts,-1)
+        vpploc = []
+        for k, kpt in enumerate(kpts):
+            v = lib.unpack_tril(buf[k])
+            if is_zero(kpt):  # gamma_point:
+                v = v.real
+            vpploc.append(v)
+        return vpploc
 
-        reindex_k: an index array to sort the order of k-points in output
+    def _estimate_rcut_3c1e(self, cell, fake_cells):
+        '''Estimate rcut for pp-loc part2 based on 3-center overlap integrals.
+        '''
+        precision = cell.precision
+        exps = np.array([e.min() for e in cell.bas_exps()])
+        if exps.size == 0:
+            return np.zeros(1)
+
+        ls = cell._bas[:,gto.ANG_OF]
+        cs = gto.gto_norm(ls, exps)
+        ai_idx = exps.argmin()
+        ai = exps[ai_idx]
+        li = cell._bas[ai_idx,gto.ANG_OF]
+        ci = cs[ai_idx]
+
+        r0 = cell.rcut  # initial guess
+        rcut = []
+        for lk, fake_cell in fake_cells.items():
+            nuc_exps = np.hstack(fake_cell.bas_exps())
+            ak_idx = nuc_exps.argmin()
+            ak = nuc_exps[ak_idx]
+            ck = abs(fake_cell._env[fake_cell._bas[ak_idx,gto.PTR_COEFF]])
+
+            aij = ai + exps
+            ajk = exps + ak
+            aijk = aij + ak
+            aijk1 = aijk**-.5
+            theta = 1./(1./aij + 1./ak)
+            norm_ang = ((2*li+1)*(2*ls+1))**.5/(4*np.pi)
+            c1 = ci * cs * ck * norm_ang
+            sfac = aij*exps/(aij*exps + ai*theta)
+            rfac = ak / (aij * ajk)
+            fl = 2
+            fac = 2**(li+1)*np.pi**2.5 * aijk1**3 * c1 / theta * fl / precision
+
+            r0 = (np.log(fac * r0 * (rfac*exps*r0+aijk1)**li *
+                         (rfac*ai*r0+aijk1)**ls + 1.) / (sfac*theta))**.5
+            r0 = (np.log(fac * r0 * (rfac*exps*r0+aijk1)**li *
+                         (rfac*ai*r0+aijk1)**ls + 1.) / (sfac*theta))**.5
+            rcut.append(r0)
+        return np.max(rcut, axis=0)
+
+
+class AFTDFMixin:
+
+    weighted_coulG = weighted_coulG
+    _int_nuc_vloc = _int_nuc_vloc
+
+    def pw_loop(self, mesh=None, kpti_kptj=None, q=None, shls_slice=None,
+                max_memory=2000, aosym='s1', blksize=None,
+                intor='GTO_ft_ovlp', comp=1, bvk_kmesh=None):
+        '''
+        Fourier transform iterator for AO pair
         '''
-        log = logger.new_logger(self)
-        cput0 = logger.process_clock(), logger.perf_counter()
-        if self.rs_cell is None:
-            self.build()
-        if auxcell is None:
-            auxcell = self.auxcell
-        if supmol is None:
-            supmol = self.supmol
         cell = self.cell
-        kpts = self.kpts
-        nkpts = len(kpts)
-        bvk_ncells, rs_nbas, nimgs = supmol.bas_mask.shape
-        intor, comp = gto.moleintor._get_intor_and_comp(cell._add_suffix(intor), comp)
-        nbasp = cell.nbas  # The number of shells in the primitive cell
-
-        # integral mask for supmol
-        log.debug1('int3c_kernel integral cutoff %g', supmol.precision)
-
-        def _conc_locs(cell_loc, auxcell_loc):
-            '''auxiliary basis was appended to regular AO basis when calling int3c2e
-            integrals. Composite loc combines locs from regular AO basis and auxiliary
-            basis accordingly.'''
-            comp_loc = np.append(cell_loc[:-1], cell_loc[-1] + auxcell_loc)
-            return np.asarray(comp_loc, dtype=np.int32)
-
-        if rs_auxcell is None:
-            atm, bas, env = gto.conc_env(supmol._atm, supmol._bas, supmol._env,
-                                         auxcell._atm, auxcell._bas, auxcell._env)
-            sh_loc = _conc_locs(supmol.sh_loc, np.arange(auxcell.nbas + 1))
-        else:
-            atm, bas, env = gto.conc_env(supmol._atm, supmol._bas, supmol._env,
-                                         rs_auxcell._atm, rs_auxcell._bas, rs_auxcell._env)
-            sh_loc = _conc_locs(supmol.sh_loc, rs_auxcell.sh_loc)
-
-        cell0_ao_loc = _conc_locs(cell.ao_loc, auxcell.ao_loc)
-
-        if 'ECP' in intor:
-            q_cond_aux = None
-            env[gto.AS_ECPBAS_OFFSET] = supmol.nbas + 1
-            cintopt = _vhf.make_cintopt(atm, bas, env, intor)
+        if mesh is None:
+            mesh = self.mesh
+        if kpti_kptj is None:
+            kpti = kptj = np.zeros(3)
         else:
-            q_cond_aux = self.get_q_cond_aux()
-            cintopt = _vhf.make_cintopt(supmol._atm, supmol._bas, supmol._env, intor)
+            kpti, kptj = kpti_kptj
+        if q is None:
+            q = kptj - kpti
 
-        ovlp_mask, cell0_ovlp_mask = self.get_ovlp_mask(supmol.precision, supmol, cintopt)
-        bas_map = self.get_bas_map(auxcell, supmol)
+        ao_loc = cell.ao_loc_nr()
+        Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
+        gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
+        ngrids = gxyz.shape[0]
 
-        # Estimate the buffer size required by PBCfill_nr3c functions
-        cache_size = max(_get_cache_size(cell, intor),
-                         _get_cache_size(auxcell, intor))
-        cell0_dims = cell0_ao_loc[1:] - cell0_ao_loc[:-1]
-        dijk = cell0_dims[:nbasp].max()**2 * cell0_dims[nbasp:].max() * comp
-
-        aosym = aosym[:2]
-        gamma_point_only = is_zero(kpts)
-        if gamma_point_only:
-            assert nkpts == 1
-            fill = f'PBCfill_nr3c_g{aosym}'
-            nkpts_ij = 1
-            cache_size += dijk
-        elif nkpts == 1:
-            fill = f'PBCfill_nr3c_nk1{aosym}'
-            nkpts_ij = 1
-            cache_size += dijk * 3
-        elif j_only:
-            fill = f'PBCfill_nr3c_k{aosym}'
-            # sort kpts then reindex_k in sort_k can be skipped
-            if reindex_k is not None:
-                kpts = kpts[reindex_k]
-                nkpts = len(kpts)
-            nkpts_ij = nkpts
-            cache_size = (dijk * bvk_ncells + dijk * nkpts * 2 +
-                          max(dijk * nkpts * 2, cache_size))
+        if shls_slice is None:
+            shls_slice = (0, cell.nbas, 0, cell.nbas)
+        if aosym == 's2':
+            assert (shls_slice[2] == 0)
+            i0 = ao_loc[shls_slice[0]]
+            i1 = ao_loc[shls_slice[1]]
+            nij = i1*(i1+1)//2 - i0*(i0+1)//2
         else:
-            fill = f'PBCfill_nr3c_kk{aosym}'
-            nkpts_ij = nkpts * nkpts
-            cache_size = (max(dijk * bvk_ncells**2 + cache_size, dijk * nkpts**2 * 2) +
-                          dijk * bvk_ncells * nkpts * 2)
-            if aosym == 's2' and reindex_k is not None:
-                kk_mask = np.zeros((nkpts*nkpts), dtype=bool)
-                kk_mask[reindex_k] = True
-                kk_mask = kk_mask.reshape(nkpts, nkpts)
-                if not np.all(kk_mask == kk_mask.T):
-                    log.warn('aosym=s2 not found in required kpts pairs')
-
-        expLk = np.exp(1j*np.dot(supmol.bvkmesh_Ls, kpts.T))
-        expLkR = np.asarray(expLk.real, order='C')
-        expLkI = np.asarray(expLk.imag, order='C')
-        expLk = None
-
-        if reindex_k is None:
-            reindex_k = np.arange(nkpts_ij, dtype=np.int32)
+            ni = ao_loc[shls_slice[1]] - ao_loc[shls_slice[0]]
+            nj = ao_loc[shls_slice[3]] - ao_loc[shls_slice[2]]
+            nij = ni*nj
+
+        if blksize is None:
+            blksize = min(max(64, int(max_memory*1e6*.75/(nij*16*comp))), 16384)
+            sublk = int(blksize//4)
         else:
-            reindex_k = np.asarray(reindex_k, dtype=np.int32)
-            nkpts_ij = reindex_k.size
-
-        drv = libpbc.PBCfill_nr3c_drv
-
-        # is_pbcintor controls whether to use memory efficient functions
-        # Only suppots int3c2e_sph, int3c2e_cart in current C library
-        is_pbcintor = intor in ('int3c2e_sph', 'int3c2e_cart')
-        if is_pbcintor and not intor.startswith('PBC'):
-            intor = 'PBC' + intor
-        log.debug1('is_pbcintor = %d, intor = %s', is_pbcintor, intor)
-
-        log.timer_debug1('int3c kernel initialization', *cput0)
-
-        def int3c(shls_slice=None, outR=None, outI=None):
-            cput0 = logger.process_clock(), logger.perf_counter()
-            if shls_slice is None:
-                shls_slice = [0, nbasp, 0, nbasp, nbasp, nbasp + auxcell.nbas]
-            else:
-                ksh0 = nbasp + shls_slice[4]
-                ksh1 = nbasp + shls_slice[5]
-                shls_slice = list(shls_slice[:4]) + [ksh0, ksh1]
-            i0, i1, j0, j1, k0, k1 = cell0_ao_loc[shls_slice]
-            if aosym == 's1':
-                nrow = (i1-i0)*(j1-j0)
-            else:
-                nrow = i1*(i1+1)//2 - i0*(i0+1)//2
-            if comp == 1:
-                shape = (nkpts_ij, nrow, k1-k0)
-            else:
-                shape = (nkpts_ij, comp, nrow, k1-k0)
-            # output has to be filled with zero first because certain integrals
-            # may be skipped by fill_ints driver
-            outR = np.ndarray(shape, buffer=outR)
-            outR[:] = 0
-            if gamma_point_only:
-                outI = np.zeros(0)
-            else:
-                outI = np.ndarray(shape, buffer=outI)
-                outI[:] = 0
-
-            if q_cond_aux is None:
-                q_cond_aux_ptr = lib.c_null_ptr()
-            else:
-                q_cond_aux_ptr = q_cond_aux.ctypes.data_as(ctypes.c_void_p)
-
-            drv(getattr(libpbc, intor), getattr(libpbc, fill),
-                ctypes.c_int(is_pbcintor),
-                outR.ctypes.data_as(ctypes.c_void_p),
-                outI.ctypes.data_as(ctypes.c_void_p),
-                expLkR.ctypes.data_as(ctypes.c_void_p),
-                expLkI.ctypes.data_as(ctypes.c_void_p),
-                reindex_k.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(nkpts_ij),
-                ctypes.c_int(bvk_ncells), ctypes.c_int(nimgs),
-                ctypes.c_int(nkpts), ctypes.c_int(nbasp), ctypes.c_int(comp),
-                sh_loc.ctypes.data_as(ctypes.c_void_p),
-                cell0_ao_loc.ctypes.data_as(ctypes.c_void_p),
-                (ctypes.c_int*6)(*shls_slice),
-                ovlp_mask.ctypes.data_as(ctypes.c_void_p),
-                cell0_ovlp_mask.ctypes.data_as(ctypes.c_void_p),
-                bas_map.ctypes.data_as(ctypes.c_void_p),
-                q_cond_aux_ptr, ctypes.c_double(supmol.precision),
-                cintopt, ctypes.c_int(cache_size),
-                atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.natm),
-                bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.nbas),
-                env.ctypes.data_as(ctypes.c_void_p))
-
-            log.timer_debug1(f'pbc integral {intor}', *cput0)
-            if return_complex:
-                if gamma_point_only:
-                    return outR
-                else:
-                    return outR + outI * 1j
-            else:
-                if gamma_point_only:
-                    return outR, None
+            sublk = blksize
+        buf = np.empty(nij*blksize*comp, dtype=np.complex128)
+        pqkRbuf = np.empty(nij*sublk*comp)
+        pqkIbuf = np.empty(nij*sublk*comp)
+
+        if bvk_kmesh is None:
+            bvk_kmesh = k2gamma.kpts_to_kmesh(cell, [kpti, kptj])
+        rcut = ft_ao.estimate_rcut(cell)
+        supmol = ft_ao.ExtendedMole.from_cell(cell, bvk_kmesh, rcut.max())
+        supmol = supmol.strip_basis(rcut)
+        ft_kern = supmol.gen_ft_kernel(aosym, intor=intor, comp=comp)
+
+        for p0, p1 in self.prange(0, ngrids, blksize):
+            aoaoR, aoaoI = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, q,
+                                   kptj.reshape(1, 3), shls_slice, out=buf)
+            aoaoR = aoaoR.reshape(comp,p1-p0,nij)
+            aoaoI = aoaoI.reshape(comp,p1-p0,nij)
+
+            for i0, i1 in lib.prange(0, p1-p0, sublk):
+                nG = i1 - i0
+                if comp == 1:
+                    pqkR = np.ndarray((nij,nG), buffer=pqkRbuf)
+                    pqkI = np.ndarray((nij,nG), buffer=pqkIbuf)
+                    pqkR[:] = aoaoR[0,i0:i1].T
+                    pqkI[:] = aoaoI[0,i0:i1].T
                 else:
-                    return outR, outI
-        return int3c
-
-    def get_q_cond_aux(self):
-        '''To compute Schwarz inequality for auxiliary basis'''
-        return None
-
-    def get_ovlp_mask(self, cutoff, supmol=None, cintopt=None):
-        '''integral screening mask between two sup-mols'''
-        if cutoff is None:
-            cutoff = self.cell.precision
-        if supmol is None:
-            supmol = self.supmol
-        bvk_ncells, rs_nbas, nimgs = supmol.bas_mask.shape
-        nbasp = self.cell.nbas  # The number of shells in the primitive cell
-        nbas = supmol.nbas
-        ovlp_mask = np.empty((nbas, nbas), dtype=np.int8)
-        libpbc.PBCsupmol_ovlp_mask(
-            ovlp_mask.ctypes.data_as(ctypes.c_void_p), ctypes.c_double(cutoff),
-            supmol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.natm),
-            supmol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.nbas),
-            supmol._env.ctypes.data_as(ctypes.c_void_p))
-
-        bvk_ovlp_mask = lib.condense('np.any', ovlp_mask, supmol.sh_loc)
-        cell0_ovlp_mask = bvk_ovlp_mask.reshape(
-            bvk_ncells, nbasp, bvk_ncells, nbasp).any(axis=2).any(axis=0)
-        ovlp_mask = ovlp_mask.astype(np.int8)
-        cell0_ovlp_mask = cell0_ovlp_mask.astype(np.int8)
-        return ovlp_mask, cell0_ovlp_mask
-
-    def get_bas_map(self, auxcell=None, supmol=None):
-        '''bas_map is to assign each basis of supmol._bas the index in
-        [bvk_cell-id, bas-id, image-id]
+                    pqkR = np.ndarray((comp,nij,nG), buffer=pqkRbuf)
+                    pqkI = np.ndarray((comp,nij,nG), buffer=pqkIbuf)
+                    pqkR[:] = aoaoR[:,i0:i1].transpose(0,2,1)
+                    pqkI[:] = aoaoI[:,i0:i1].transpose(0,2,1)
+                yield (pqkR, pqkI, p0+i0, p0+i1)
+
+    def ft_loop(self, mesh=None, q=np.zeros(3), kpts=None, shls_slice=None,
+                max_memory=4000, aosym='s1', intor='GTO_ft_ovlp', comp=1,
+                bvk_kmesh=None, return_complex=True):
         '''
-        # Append aux_mask to bas_map as a temporary solution for function
-        # _assemble3c in fill_ints.c
-        if auxcell is None:
-            auxcell = self.auxcell
-        if supmol is None:
-            supmol = self.supmol
-        aux_mask = np.ones(auxcell.nbas, dtype=np.int32)
-        bas_map = np.where(supmol.bas_mask.ravel())[0].astype(np.int32)
-        bas_map = np.asarray(np.append(bas_map, aux_mask), dtype=np.int32)
-        return bas_map
-
-
-libpbc.GTOmax_cache_size.restype = ctypes.c_int
-def _get_cache_size(cell, intor):
-    '''Cache size for libcint integrals. Cache size cannot be accurately
-    estimated in function PBC_ft_bvk_drv
-    '''
-    cache_size = libpbc.GTOmax_cache_size(
-        getattr(libpbc, intor), (ctypes.c_int*2)(0, cell.nbas), ctypes.c_int(1),
-        cell._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(cell.natm),
-        cell._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(cell.nbas),
-        cell._env.ctypes.data_as(ctypes.c_void_p))
-    return cache_size
-
-
-class _IntNucBuilder(_Int3cBuilder):
-    '''In this builder, ovlp_mask can be reused for different types of intor
-    '''
-    def __init__(self, cell, kpts=np.zeros((1,3))):
-        # cache ovlp_mask
-        self._supmol = None
-        self._ovlp_mask = None
-        self._cell0_ovlp_mask = None
-        _Int3cBuilder.__init__(self, cell, None, kpts)
-
-    def get_ovlp_mask(self, cutoff, supmol=None, cintopt=None):
-        if self._ovlp_mask is None or supmol is not self._supmol:
-            self._ovlp_mask, self._cell0_ovlp_mask = \
-                    _Int3cBuilder.get_ovlp_mask(self, cutoff, supmol, cintopt)
-            self._supmol = supmol
-        return self._ovlp_mask, self._cell0_ovlp_mask
-
-    def _int_nuc_vloc(self, nuccell, intor='int3c2e', aosym='s2', comp=None,
-                      with_pseudo=True, supmol=None):
-        '''Vnuc - Vloc. nuccell is the cell for model charges
+        Fourier transform iterator for all kpti which satisfy
+            2pi*N = (kpts - kpti - q)*a,  N = -1, 0, 1
         '''
-        logger.debug2(self, 'Real space integrals %s for Vnuc - Vloc', intor)
-
         cell = self.cell
-        kpts = self.kpts
+        if mesh is None:
+            mesh = self.mesh
+        if kpts is None:
+            assert (is_zero(q))
+            kpts = self.kpts
+        kpts = np.asarray(kpts)
         nkpts = len(kpts)
 
-        # Use the 3c2e code with steep s gaussians to mimic nuclear density
-        fakenuc = _fake_nuc(cell, with_pseudo=with_pseudo)
-        fakenuc._atm, fakenuc._bas, fakenuc._env = \
-                gto.conc_env(nuccell._atm, nuccell._bas, nuccell._env,
-                             fakenuc._atm, fakenuc._bas, fakenuc._env)
-
-        int3c = self.gen_int3c_kernel(intor, aosym, comp=comp, j_only=True,
-                                      auxcell=fakenuc, supmol=supmol)
-        bufR, bufI = int3c()
-
-        charge = cell.atom_charges()
-        charge = np.append(charge, -charge)  # (charge-of-nuccell, charge-of-fakenuc)
-        if is_zero(kpts):
-            mat = np.einsum('k...z,z->k...', bufR, charge)
-        else:
-            mat = (np.einsum('k...z,z->k...', bufR, charge) +
-                   np.einsum('k...z,z->k...', bufI, charge) * 1j)
+        ao_loc = cell.ao_loc_nr()
+        Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
+        gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
+        ngrids = gxyz.shape[0]
 
-        # vbar is the interaction between the background charge
-        # and the compensating function.  0D, 1D, 2D do not have vbar.
-        if cell.dimension == 3 and intor in ('int3c2e', 'int3c2e_sph',
-                                             'int3c2e_cart'):
-            logger.debug2(self, 'G=0 part for %s', intor)
-            charge = -cell.atom_charges()
-
-            nucbar = sum([z/nuccell.bas_exp(i)[0] for i,z in enumerate(charge)])
-            nucbar *= np.pi/cell.vol
-
-            ovlp = cell.pbc_intor('int1e_ovlp', 1, lib.HERMITIAN, kpts)
-            for k in range(nkpts):
-                if aosym == 's1':
-                    mat[k] -= nucbar * ovlp[k].ravel()
-                else:
-                    mat[k] -= nucbar * lib.pack_tril(ovlp[k])
-        return mat
+        if shls_slice is None:
+            shls_slice = (0, cell.nbas, 0, cell.nbas)
+        if aosym == 's2':
+            assert (shls_slice[2] == 0)
+            i0 = ao_loc[shls_slice[0]]
+            i1 = ao_loc[shls_slice[1]]
+            nij = i1*(i1+1)//2 - i0*(i0+1)//2
+        else:
+            ni = ao_loc[shls_slice[1]] - ao_loc[shls_slice[0]]
+            nj = ao_loc[shls_slice[3]] - ao_loc[shls_slice[2]]
+            nij = ni*nj
+
+        if bvk_kmesh is None:
+            bvk_kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
+        #TODO:
+        # ke_cutoff = pbctools.mesh_to_cutoff(cell.lattice_vectors(), mesh)
+        # rs_cell = ft_ao._RangeSeparatedCell.from_cell(cell, ke_cutoff, ft_ao.RCUT_THRESHOLD)
+        rcut = ft_ao.estimate_rcut(cell)
+        supmol = ft_ao.ExtendedMole.from_cell(cell, bvk_kmesh, rcut.max())
+        supmol = supmol.strip_basis(rcut)
+        ft_kern = supmol.gen_ft_kernel(aosym, intor=intor, comp=comp,
+                                       return_complex=return_complex)
+
+        blksize = max(16, int(max_memory*.9e6/(nij*nkpts*16*comp)))
+        blksize = min(blksize, ngrids, 16384)
+        buf = np.empty(nkpts*nij*blksize*comp, dtype=np.complex128)
+
+        for p0, p1 in self.prange(0, ngrids, blksize):
+            dat = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, q, kpts, shls_slice, out=buf)
+            yield dat, p0, p1
+
+    @contextlib.contextmanager
+    def range_coulomb(self, omega):
+        '''Creates a temporary density fitting object for RSH-DF integrals.
+        In this context, only LR or SR integrals for mol and auxmol are computed.
+        '''
+        key = '%.6f' % omega
+        if key in self._rsh_df:
+            rsh_df = self._rsh_df[key]
+        else:
+            rsh_df = self._rsh_df[key] = copy.copy(self).reset()
+            if hasattr(self, '_dataname'):
+                rsh_df._dataname = f'{self._dataname}/lr/{key}'
+            logger.info(self, 'Create RSH-DF object %s for omega=%s', rsh_df, omega)
 
-    def _get_nuc(self, mesh=None, with_pseudo=False):
-        from pyscf.pbc.df.gdf_builder import _guess_eta
-        log = logger.Logger(self.stdout, self.verbose)
-        t0 = t1 = (logger.process_clock(), logger.perf_counter())
         cell = self.cell
-        kpts = self.kpts
-        nkpts = len(kpts)
-        nao = cell.nao_nr()
-        aosym = 's2'
-        nao_pair = nao * (nao+1) // 2
-
-        kpt_allow = np.zeros(3)
-        eta, mesh, ke_cutoff = _guess_eta(cell, kpts, mesh)
-        log.debug1('get_nuc/get_pp_loc_part1 eta = %s mesh = %s', eta, mesh)
-
-        # Initialize self.supmol
-        if self.rs_cell is None:
-            self.build()
-        self.supmol = supmol = _strip_basis(self.supmol, eta)
-        log.debug('stripped supmol nbas = %d cGTO = %d pGTO = %d',
-                  supmol.nbas, supmol.nao, supmol.npgto_nr())
+        auxcell = getattr(self, 'auxcell', None)
 
-        modchg_cell = _compensate_nuccell(cell, eta)
-        vj = self._int_nuc_vloc(modchg_cell, with_pseudo=with_pseudo,
-                                supmol=supmol)
-        t0 = t1 = log.timer_debug1('vnuc pass1: analytic int', *t0)
+        cell_omega = cell.omega
+        cell.omega = omega
+        auxcell_omega = None
+        if auxcell is not None:
+            auxcell_omega = auxcell.omega
+            auxcell.omega = omega
+
+        assert rsh_df.cell.omega == omega
+        if getattr(rsh_df, 'auxcell', None) is not None:
+            assert rsh_df.auxcell.omega == omega
+
+        try:
+            yield rsh_df
+        finally:
+            cell.omega = cell_omega
+            if auxcell_omega is not None:
+                auxcell.omega = auxcell_omega
 
-        Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
-        coulG = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv) * kws
-        aoaux = ft_ao.ft_ao(modchg_cell, Gv)
-        charges = cell.atom_charges()
-        vG = np.einsum('i,xi->x', -charges, aoaux) * coulG
-
-        supmol_ft = ft_ao._ExtendedMole.from_cell(self.rs_cell, self.bvk_kmesh, verbose=log)
-        supmol_ft = supmol_ft.strip_basis()
-        ft_kern = supmol_ft.gen_ft_kernel(aosym, return_complex=False, verbose=log)
 
-        Gv, Gvbase, kws = modchg_cell.get_Gv_weights(mesh)
-        gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
-        ngrids = Gv.shape[0]
-        max_memory = max(2000, self.max_memory-lib.current_memory()[0])
-        Gblksize = max(16, int(max_memory*1e6/16/nao_pair/nkpts))
-        Gblksize = min(Gblksize, ngrids, 200000)
-        vGR = vG.real
-        vGI = vG.imag
-        log.debug1('max_memory = %s  Gblksize = %s  ngrids = %s',
-                   max_memory, Gblksize, ngrids)
-
-        buf = np.empty((2, nkpts, Gblksize, nao_pair))
-        for p0, p1 in lib.prange(0, ngrids, Gblksize):
-            # shape of Gpq (nkpts, nGv, nao_pair)
-            Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, kpts, out=buf)
-            for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
-                # rho_ij(G) nuc(-G) / G^2
-                # = [Re(rho_ij(G)) + Im(rho_ij(G))*1j] [Re(nuc(G)) - Im(nuc(G))*1j] / G^2
-                vR = np.einsum('k,kx->x', vGR[p0:p1], GpqR)
-                vR+= np.einsum('k,kx->x', vGI[p0:p1], GpqI)
-                vj[k] += vR
-                if not is_zero(kpts[k]):
-                    vI = np.einsum('k,kx->x', vGR[p0:p1], GpqI)
-                    vI-= np.einsum('k,kx->x', vGI[p0:p1], GpqR)
-                    vj[k] += vI * 1j
-            t1 = log.timer_debug1('contracting Vnuc [%s:%s]'%(p0, p1), *t1)
-        log.timer_debug1('contracting Vnuc', *t0)
+class AFTDF(lib.StreamObject, AFTDFMixin):
+    '''Density expansion on plane waves
+    '''
+    def __init__(self, cell, kpts=np.zeros((1,3))):
+        self.cell = cell
+        self.stdout = cell.stdout
+        self.verbose = cell.verbose
+        self.max_memory = cell.max_memory
+        self.mesh = cell.mesh
+        self.kpts = kpts
+        self.time_reversal_symmetry = True
 
-        vj_kpts = []
-        for k, kpt in enumerate(kpts):
-            if is_zero(kpt):
-                vj_kpts.append(lib.unpack_tril(vj[k].real))
-            else:
-                vj_kpts.append(lib.unpack_tril(vj[k]))
-        return np.asarray(vj_kpts)
+        # to mimic molecular DF object
+        self.blockdim = getattr(__config__, 'pbc_df_df_DF_blockdim', 240)
 
-    def get_nuc(self, mesh=None):
-        '''Get the periodic nuc-el AO matrix, with G=0 removed.
+        # The following attributes are not input options.
+        self._rsh_df = {}  # Range separated Coulomb DF objects
+        self._keys = set(self.__dict__.keys())
 
-        Kwargs:
-            mesh: custom mesh grids. By default mesh is determined by the
-            function _guess_eta from module pbc.df.gdf_builder.
-        '''
-        t0 = (logger.process_clock(), logger.perf_counter())
-        nuc = self._get_nuc(mesh, with_pseudo=False)
-        logger.timer(self, 'get_nuc', *t0)
-        return nuc
+    def dump_flags(self, verbose=None):
+        logger.info(self, '\n')
+        logger.info(self, '******** %s ********', self.__class__)
+        logger.info(self, 'mesh = %s (%d PWs)', self.mesh, np.prod(self.mesh))
+        logger.info(self, 'len(kpts) = %d', len(self.kpts))
+        logger.debug1(self, '    kpts = %s', self.kpts)
+        return self
 
-    def get_pp_loc_part1(self, mesh=None):
-        return self._get_nuc(mesh, with_pseudo=True)
+    def reset(self, cell=None):
+        if cell is not None:
+            self.cell = cell
+        self._rsh_df = {}
+        return self
 
-    def get_pp_loc_part2(self):
-        if self.rs_cell is None:
-            self.build()
+    def check_sanity(self):
+        lib.StreamObject.check_sanity(self)
         cell = self.cell
-        kpts = self.kpts
-        nkpts = len(kpts)
-        intors = ('int3c2e', 'int3c1e', 'int3c1e_r2_origk',
-                  'int3c1e_r4_origk', 'int3c1e_r6_origk')
-        fake_cells = [pp_int.fake_cell_vloc(cell, cn) for cn in range(1, 5)]
-
-        supmol = self.supmol
-        if supmol.nbas == supmol.bas_mask.size:  # supmol not stripped
-            eta = min([np.hstack(c.bas_exps()).min()
-                       for c in fake_cells if c.nbas > 0])
-            supmol = _strip_basis(supmol, eta, inplace=False)
-
-        bufR = 0
-        bufI = 0
-        for cn, fake_cell in enumerate(fake_cells, start=1):
-            if fake_cell.nbas > 0:
-                int3c = self.gen_int3c_kernel(intors[cn], 's2', comp=1, j_only=True,
-                                              auxcell=fake_cell, supmol=supmol)
-                vR, vI = int3c()
-                bufR += np.einsum('...i->...', vR)
-                if vI is not None:
-                    bufI += np.einsum('...i->...', vI)
-
-        if isinstance(bufR, int):
-            if any(cell.atom_symbol(ia) in cell._pseudo for ia in range(cell.natm)):
-                pass
+        if not cell.has_ecp():
+            logger.warn(self, 'AFTDF integrals are found in all-electron '
+                        'calculation.  It often causes huge error.\n'
+                        'Recommended methods are DF or MDF. In SCF calculation, '
+                        'they can be initialized as\n'
+                        '        mf = mf.density_fit()\nor\n'
+                        '        mf = mf.mix_density_fit()')
+
+        if cell.dimension > 0:
+            if cell.ke_cutoff is None:
+                ke_cutoff = tools.mesh_to_cutoff(cell.lattice_vectors(), self.mesh)
+                ke_cutoff = ke_cutoff[:cell.dimension].min()
             else:
-                lib.logger.warn(cell, 'cell.pseudo was specified but its elements %s '
-                                 'were not found in the system.', cell._pseudo.keys())
-            vpploc = [0] * nkpts
+                ke_cutoff = np.min(cell.ke_cutoff)
+            ke_guess = estimate_ke_cutoff(cell, cell.precision)
+            mesh_guess = cell.cutoff_to_mesh(ke_guess)
+            if ke_cutoff < ke_guess * KE_SCALING:
+                logger.warn(self, 'ke_cutoff/mesh (%g / %s) is not enough for AFTDF '
+                            'to get integral accuracy %g.\nCoulomb integral error '
+                            'is ~ %.2g Eh.\nRecommended ke_cutoff/mesh are %g / %s.',
+                            ke_cutoff, self.mesh, cell.precision,
+                            error_for_ke_cutoff(cell, ke_cutoff), ke_guess, mesh_guess)
         else:
-            buf = (bufR + bufI * 1j).reshape(nkpts,-1)
-            vpploc = []
-            for k, kpt in enumerate(kpts):
-                v = lib.unpack_tril(buf[k])
-                if abs(kpt).sum() < 1e-9:  # gamma_point:
-                    v = v.real
-                vpploc.append(v)
-        return vpploc
+            mesh_guess = np.copy(self.mesh)
 
-    def get_pp(self, mesh=None):
-        '''Get the periodic pseudotential nuc-el AO matrix, with G=0 removed.
+        if cell.dimension < 3:
+            err = np.exp(-0.436392335*min(self.mesh[cell.dimension:]) - 2.99944305)
+            err *= cell.nelectron
+            meshz = pbcgto.cell._mesh_inf_vaccum(cell)
+            mesh_guess[cell.dimension:] = int(meshz)
+            if err > cell.precision*10:
+                logger.warn(self, 'mesh %s of AFTDF may not be enough to get '
+                            'integral accuracy %g for %dD PBC system.\n'
+                            'Coulomb integral error is ~ %.2g Eh.\n'
+                            'Recommended mesh is %s.',
+                            self.mesh, cell.precision, cell.dimension, err, mesh_guess)
+            if any(x/meshz > 1.1 for x in cell.mesh[cell.dimension:]):
+                meshz = pbcgto.cell._mesh_inf_vaccum(cell)
+                logger.warn(self, 'setting mesh %s of AFTDF too high in non-periodic direction '
+                            '(=%s) can result in an unnecessarily slow calculation.\n'
+                            'For coulomb integral error of ~ %.2g Eh in %dD PBC, \n'
+                            'a recommended mesh for non-periodic direction is %s.',
+                            self.mesh, self.mesh[cell.dimension:], cell.precision,
+                            cell.dimension, mesh_guess[cell.dimension:])
+        return self
 
-        Kwargs:
-            mesh: custom mesh grids. By default mesh is determined by the
-            function _guess_eta from module pbc.df.gdf_builder.
-        '''
-        t0 = (logger.process_clock(), logger.perf_counter())
-        vloc1 = self.get_pp_loc_part1(mesh)
-        t1 = logger.timer_debug1(self, 'get_pp_loc_part1', *t0)
-        vloc2 = self.get_pp_loc_part2()
-        t1 = logger.timer_debug1(self, 'get_pp_loc_part2', *t1)
-        vpp = pp_int.get_pp_nl(self.cell, self.kpts)
-        nkpts = len(self.kpts)
-        for k in range(nkpts):
-            vpp[k] += vloc1[k] + vloc2[k]
-        t1 = logger.timer_debug1(self, 'get_pp_nl', *t1)
-        logger.timer(self, 'get_pp', *t0)
-        return vpp
+    def build(self):
+        return self.check_sanity()
 
-# Since the real-space lattice-sum for nuclear attraction is not implemented,
-# use the 3c2e code with steep gaussians to mimic nuclear density
-def _fake_nuc(cell, with_pseudo=True):
-    fakenuc = copy.copy(cell)
-    fakenuc._atm = cell._atm.copy()
-    fakenuc._atm[:,gto.PTR_COORD] = np.arange(gto.PTR_ENV_START,
-                                              gto.PTR_ENV_START+cell.natm*3,3)
-    _bas = []
-    _env = [0]*gto.PTR_ENV_START + [cell.atom_coords().ravel()]
-    ptr = gto.PTR_ENV_START + cell.natm * 3
-    half_sph_norm = .5/np.sqrt(np.pi)
-    for ia in range(cell.natm):
-        symb = cell.atom_symbol(ia)
-        if with_pseudo and symb in cell._pseudo:
-            pp = cell._pseudo[symb]
-            rloc, nexp, cexp = pp[1:3+1]
-            eta = .5 / rloc**2
-        else:
-            eta = 1e16
-        norm = half_sph_norm/gto.gaussian_int(2, eta)
-        _env.extend([eta, norm])
-        _bas.append([ia, 0, 1, 1, 0, ptr, ptr+1, 0])
-        ptr += 2
-    fakenuc._bas = np.asarray(_bas, dtype=np.int32)
-    fakenuc._env = np.asarray(np.hstack(_env), dtype=np.double)
-    fakenuc.rcut = cell.rcut
-    return fakenuc
+    get_nuc = get_nuc
+    get_pp = get_pp
 
-def _compensate_nuccell(cell, eta):
-    '''A cell of the compensated Gaussian charges for nucleus'''
-    modchg_cell = copy.copy(cell)
-    half_sph_norm = .5/np.sqrt(np.pi)
-    norm = half_sph_norm/gto.gaussian_int(2, eta)
-    chg_env = [eta, norm]
-    ptr_eta = cell._env.size
-    ptr_norm = ptr_eta + 1
-    chg_bas = [[ia, 0, 1, 1, 0, ptr_eta, ptr_norm, 0] for ia in range(cell.natm)]
-    modchg_cell._atm = cell._atm
-    modchg_cell._bas = np.asarray(chg_bas, dtype=np.int32)
-    modchg_cell._env = np.hstack((cell._env, chg_env))
-    return modchg_cell
-
-def _strip_basis(supmol, eta, cutoff=None, inplace=True):
-    rs_cell = supmol.rs_cell
-
-    supmol_exps = np.array([e.min() for e in supmol.bas_exps()])
-    supmol_bas_coords = supmol.atom_coords()[supmol._bas[:,gto.ATOM_OF]]
-
-    dim = rs_cell.dimension
-    if dim == 0:
-        bas_mask = np.ones(supmol.nbas, dtype=bool)
-    else:
-        if cutoff is None:
-            cutoff = supmol.precision
-        # estimation based on 3-center gaussian overlap integrals
-        # ejk = minimize (ai*aj*|ri-rj|^2+ai*eta*ri^2+aj*eta*rj^2)/(ai+aj+eta)
-        ajk = supmol_exps + eta
-        ejk = supmol_exps * eta / ajk
-        rb = np.linalg.norm(supmol_bas_coords[:,:dim], axis=1)
-        a = rs_cell.lattice_vectors()
-        dr = rb - np.linalg.norm(a[:dim])
-        dr[dr < 0] = 0
-        ovlp = ejk * dr**2
-        bas_mask = ovlp < -np.log(cutoff)
-
-    if not inplace:
-        supmol = copy.copy(supmol)
-    if bas_mask.size == supmol.bas_mask.size:
-        supmol.bas_mask = bas_mask.reshape(supmol.bas_mask.shape)
-    else:
-        supmol.bas_mask = supmol.bas_mask.copy()
-        supmol.bas_mask[supmol.bas_mask] = bas_mask
-    supmol._bas = supmol._bas[bas_mask]
-    supmol.sh_loc = supmol.bas_mask_to_sh_loc(rs_cell, supmol.bas_mask)
-    return supmol
+    # Note: Special exxdiv by default should not be used for an arbitrary
+    # input density matrix. When the df object was used with the molecular
+    # post-HF code, get_jk was often called with an incomplete DM (e.g. the
+    # core DM in CASCI). An SCF level exxdiv treatment is inadequate for
+    # post-HF methods.
+    def get_jk(self, dm, hermi=1, kpts=None, kpts_band=None,
+               with_j=True, with_k=True, omega=None, exxdiv=None):
+        if omega is not None:  # J/K for RSH functionals
+            with self.range_coulomb(omega) as rsh_df:
+                return rsh_df.get_jk(dm, hermi, kpts, kpts_band, with_j, with_k,
+                                     omega=None, exxdiv=exxdiv)
+
+        kpts, is_single_kpt = _check_kpts(self, kpts)
+        if is_single_kpt:
+            return aft_jk.get_jk(self, dm, hermi, kpts[0], kpts_band, with_j,
+                                  with_k, exxdiv)
+
+        vj = vk = None
+        if with_k:
+            vk = aft_jk.get_k_kpts(self, dm, hermi, kpts, kpts_band, exxdiv)
+        if with_j:
+            vj = aft_jk.get_j_kpts(self, dm, hermi, kpts, kpts_band)
+        return vj, vk
+
+    get_eri = get_ao_eri = aft_ao2mo.get_eri
+    ao2mo = get_mo_eri = aft_ao2mo.general
+    ao2mo_7d = aft_ao2mo.ao2mo_7d
+    get_ao_pairs_G = get_ao_pairs = aft_ao2mo.get_ao_pairs_G
+    get_mo_pairs_G = get_mo_pairs = aft_ao2mo.get_mo_pairs_G
+
+    def update_mf(self, mf):
+        mf = copy.copy(mf)
+        mf.with_df = self
+        return mf
+
+    def prange(self, start, stop, step):
+        '''This is a hook for MPI parallelization. DO NOT use it out of the
+        scope of AFTDF/GDF/MDF.
+        '''
+        return lib.prange(start, stop, step)
+
+################################################################################
+# With this function to mimic the molecular DF.loop function, the pbc gamma
+# point DF object can be used in the molecular code
+    def loop(self, blksize=None):
+        cell = self.cell
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            raise RuntimeError('ERIs of PBC-2D systems are not positive '
+                               'definite. Current API only supports postive '
+                               'definite ERIs.')
+
+        if blksize is None:
+            blksize = self.blockdim
+        # coulG of 1D and 2D has negative elements.
+        coulG = self.weighted_coulG()
+        Lpq = None
+        for pqkR, pqkI, p0, p1 in self.pw_loop(aosym='s2', blksize=blksize):
+            vG = np.sqrt(coulG[p0:p1])
+            pqkR *= vG
+            pqkI *= vG
+            Lpq = lib.transpose(pqkR, out=Lpq)
+            yield Lpq
+            Lpq = lib.transpose(pqkI, out=Lpq)
+            yield Lpq
+
+    def get_naoaux(self):
+        mesh = np.asarray(self.mesh)
+        ngrids = np.prod(mesh)
+        return ngrids * 2
+
+def _sub_df_jk_(dfobj, dm, hermi=1, kpts=None, kpts_band=None,
+                with_j=True, with_k=True, omega=None, exxdiv=None):
+    with dfobj.range_coulomb(omega) as rsh_df:
+        return rsh_df.get_jk(dm, hermi, kpts, kpts_band, with_j, with_k,
+                             omega=None, exxdiv=exxdiv)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/mdf.py` & `pyscf-2.3.0/pyscf/pbc/df/mdf.py`

 * *Files 3% similar despite different names*

```diff
@@ -18,31 +18,29 @@
 
 '''
 Gaussian and planewaves mixed density fitting
 Ref:
 J. Chem. Phys. 147, 164119 (2017)
 '''
 
-import os
-
 import tempfile
 import numpy as np
 import h5py
 import scipy.linalg
 from pyscf import lib
 from pyscf.lib import logger, zdotCN
 from pyscf.df.outcore import _guess_shell_ranges
 from pyscf.pbc import gto
-from pyscf.pbc.tools import pbc as pbctools
 from pyscf.pbc.df import outcore
 from pyscf.pbc.df import ft_ao
 from pyscf.pbc.df import df
 from pyscf.pbc.df import aft
+from pyscf.pbc.df.aft import _check_kpts
 from pyscf.pbc.df.gdf_builder import _CCGDFBuilder
-from pyscf.pbc.df.rsdf_builder import _RSGDFBuilder, _round_off_to_odd_mesh
+from pyscf.pbc.df.rsdf_builder import _RSGDFBuilder
 from pyscf.pbc.df.incore import libpbc, make_auxcell
 from pyscf.pbc.lib.kpts_helper import is_zero, member, unique
 from pyscf.pbc.df import mdf_jk
 from pyscf.pbc.df import mdf_ao2mo
 from pyscf.pbc.df.aft import _sub_df_jk_
 from pyscf import __config__
 
@@ -73,14 +71,17 @@
         # auxiliary set without affecting the accuracy of MDF. exp_to_discard
         # can be set to the value of self.eta
         self.exp_to_discard = None
 
         # tends to call _CCMDFBuilder if applicable
         self._prefer_ccdf = False
 
+        # TODO: More tests are needed
+        self.time_reversal_symmetry = False
+
         # The following attributes are not input options.
         self.exxdiv = None  # to mimic KRHF/KUHF object in function get_coulG
         self.auxcell = None
         self.blockdim = getattr(__config__, 'df_df_DF_blockdim', 240)
         self.linear_dep_threshold = df.LINEAR_DEP_THR
         self._j_only = False
 # If _cderi_to_save is specified, the 3C-integral tensor will be saved in this file.
@@ -121,19 +122,23 @@
             dfbuilder = _CCMDFBuilder(cell, auxcell, kpts_union)
         else:
             dfbuilder = _RSMDFBuilder(cell, auxcell, kpts_union)
             dfbuilder.eta = self.eta
         dfbuilder.mesh = self.mesh
         dfbuilder.linear_dep_threshold = self.linear_dep_threshold
         j_only = self._j_only or len(kpts_union) == 1
-        dfbuilder.make_j3c(cderi_file, j_only=j_only)
+        dfbuilder.make_j3c(cderi_file, j_only=j_only, dataname=self._dataname,
+                           kptij_lst=kptij_lst)
 
-        # mdf.mesh must be the same to the mesh used in generating cderi
+        # mdf.mesh must be the mesh to generate cderi
         self.mesh = dfbuilder.mesh
 
+    get_pp = df.GDF.get_pp
+    get_nuc = df.GDF.get_nuc
+
     # Note: Special exxdiv by default should not be used for an arbitrary
     # input density matrix. When the df object was used with the molecular
     # post-HF code, get_jk was often called with an incomplete DM (e.g. the
     # core DM in CASCI). An SCF level exxdiv treatment is inadequate for
     # post-HF methods.
     def get_jk(self, dm, hermi=1, kpts=None, kpts_band=None,
                with_j=True, with_k=True, omega=None, exxdiv=None):
@@ -148,31 +153,24 @@
             # * The sparse mesh is not appropriate for low dimensional systems
             #   with infinity vacuum since the ERI may require large mesh to
             #   sample density in vacuum.
             if (omega < df.LONGRANGE_AFT_TURNOVER_THRESHOLD and
                 cell.dimension >= 2 and cell.low_dim_ft_type != 'inf_vacuum'):
                 mydf = aft.AFTDF(cell, self.kpts)
                 ke_cutoff = aft.estimate_ke_cutoff_for_omega(cell, omega)
-                mydf.mesh = pbctools.cutoff_to_mesh(cell.lattice_vectors(), ke_cutoff)
+                mydf.mesh = cell.cutoff_to_mesh(ke_cutoff)
             else:
                 mydf = self
             with mydf.range_coulomb(omega) as rsh_df:
                 return rsh_df.get_jk(dm, hermi, kpts, kpts_band, with_j, with_k,
                                      omega=None, exxdiv=exxdiv)
 
-        if kpts is None:
-            if np.all(self.kpts == 0):
-                # Gamma-point calculation by default
-                kpts = np.zeros(3)
-            else:
-                kpts = self.kpts
-        kpts = np.asarray(kpts)
-
-        if kpts.shape == (3,):
-            return mdf_jk.get_jk(self, dm, hermi, kpts, kpts_band, with_j,
+        kpts, is_single_kpt = _check_kpts(self, kpts)
+        if is_single_kpt:
+            return mdf_jk.get_jk(self, dm, hermi, kpts[0], kpts_band, with_j,
                                  with_k, exxdiv)
 
         vj = vk = None
         if with_k:
             vk = mdf_jk.get_k_kpts(self, dm, hermi, kpts, kpts_band, exxdiv)
         if with_j:
             vj = mdf_jk.get_j_kpts(self, dm, hermi, kpts, kpts_band)
@@ -266,32 +264,32 @@
                     G0_idx = 0  # due to np.fft.fftfreq convention
                     G0_weight = kws[G0_idx] if isinstance(kws, np.ndarray) else kws
                     coulG_sr[G0_idx] += np.pi/omega**2 * G0_weight
 
                 for p0, p1 in lib.prange(0, ngrids, blksize):
                     auxG_sr = ft_ao.ft_ao(auxcell_c, Gv[p0:p1], None, b, gxyz[p0:p1], Gvbase, kpt).T
                     if is_zero(kpt):
-                        sr_j2c[k] -= lib.dot(auxG_sr.conj() * coulG_sr, auxG_sr.T).real
+                        sr_j2c[k] -= lib.dot(auxG_sr.conj() * coulG_sr[p0:p1], auxG_sr.T).real
                     else:
-                        sr_j2c[k] -= lib.dot(auxG_sr.conj() * coulG_sr, auxG_sr.T)
+                        sr_j2c[k] -= lib.dot(auxG_sr.conj() * coulG_sr[p0:p1], auxG_sr.T)
                     auxG_sr = None
 
                 j2c_k = recontract_2d(j2c_k, sr_j2c[k])
                 sr_j2c[k] = None
 
             j2c.append(j2c_k)
         return j2c
 
     def outcore_auxe2(self, cderi_file, intor='int3c2e', aosym='s2', comp=None,
                       j_only=False, dataname='j3c', shls_slice=None,
-                      fft_dd_block=False):
+                      fft_dd_block=False, kk_idx=None):
         # dd_block from real-space integrals will be cancelled by AFT part
         # anyway. It's safe to omit dd_block when computing real-space int3c2e
         return super().outcore_auxe2(cderi_file, intor, aosym, comp, j_only,
-                                     dataname, shls_slice, fft_dd_block)
+                                     dataname, shls_slice, fft_dd_block, kk_idx)
 
     def weighted_ft_ao(self, kpt):
         '''exp(-i*(G + k) dot r) * Coulomb_kernel'''
         rs_cell = self.rs_cell
         Gv, Gvbase, kws = rs_cell.get_Gv_weights(self.mesh)
         b = rs_cell.reciprocal_vectors()
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
@@ -363,17 +361,17 @@
                 auxG = None
             j2c[k] = j2c_k
         return j2c
 
 
     def outcore_auxe2(self, cderi_file, intor='int3c2e', aosym='s2', comp=None,
                       j_only=False, dataname='j3c', shls_slice=None,
-                      fft_dd_block=False):
+                      fft_dd_block=False, kk_idx=None):
         return super().outcore_auxe2(cderi_file, intor, aosym, comp, j_only,
-                                     dataname, shls_slice, fft_dd_block)
+                                     dataname, shls_slice, fft_dd_block, kk_idx)
 
     def weighted_ft_ao(self, kpt):
         fused_cell = self.fused_cell
         Gv, Gvbase, kws = fused_cell.get_Gv_weights(self.mesh)
         b = fused_cell.reciprocal_vectors()
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
         auxG = ft_ao.ft_ao(fused_cell, Gv, None, b, gxyz, Gvbase, kpt).T
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/mdf_ao2mo.py` & `pyscf-2.3.0/pyscf/pbc/df/mdf_ao2mo.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/df/mdf_jk.py` & `pyscf-2.3.0/pyscf/pbc/df/mdf_jk.py`

 * *Files 1% similar despite different names*

```diff
@@ -66,27 +66,27 @@
     mf = copy.copy(mf)
     mf.with_df = with_df
     mf._eri = None
     return mf
 
 
 def get_j_kpts(mydf, dm_kpts, hermi=1, kpts=numpy.zeros((1,3)), kpts_band=None):
-    vj_kpts = aft_jk.get_j_kpts(mydf, dm_kpts, hermi, kpts, kpts_band)
-    vj_kpts += df_jk.get_j_kpts(mydf, dm_kpts, hermi, kpts, kpts_band)
+    vj_kpts = df_jk.get_j_kpts(mydf, dm_kpts, hermi, kpts, kpts_band)
+    vj_kpts += aft_jk.get_j_kpts(mydf, dm_kpts, hermi, kpts, kpts_band)
     return vj_kpts
 
 
 def get_k_kpts(mydf, dm_kpts, hermi=1, kpts=numpy.zeros((1,3)), kpts_band=None,
                exxdiv=None):
     if exxdiv is not None and exxdiv != 'ewald':
         logger.warn(mydf, 'MDF does not support exxdiv %s. '
                     'exxdiv needs to be "ewald" or None', exxdiv)
         raise RuntimeError('GDF does not support exxdiv %s' % exxdiv)
-    vk_kpts = aft_jk.get_k_kpts(mydf, dm_kpts, hermi, kpts, kpts_band, exxdiv)
-    vk_kpts += df_jk.get_k_kpts(mydf, dm_kpts, hermi, kpts, kpts_band, None)
+    vk_kpts = df_jk.get_k_kpts(mydf, dm_kpts, hermi, kpts, kpts_band, None)
+    vk_kpts += aft_jk.get_k_kpts(mydf, dm_kpts, hermi, kpts, kpts_band, exxdiv)
     return vk_kpts
 
 
 ##################################################
 #
 # Single k-point
 #
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/outcore.py` & `pyscf-2.3.0/pyscf/pbc/df/outcore.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/df/rsdf.py` & `pyscf-2.3.0/pyscf/pbc/df/rsdf.py`

 * *Files 4% similar despite different names*

```diff
@@ -49,20 +49,19 @@
 from pyscf.lib import logger, zdotCN
 from pyscf.pbc.df.df import GDF
 from pyscf.pbc.df import aft, aft_jk
 from pyscf.pbc.df import ft_ao
 from pyscf.pbc.df import rsdf_helper
 from pyscf.pbc.df import rsdf_builder
 from pyscf.pbc.df import gdf_builder
-from pyscf.pbc.df.incore import _Int3cBuilder
+from pyscf.pbc.df.incore import Int3cBuilder
 from pyscf.df.outcore import _guess_shell_ranges
 from pyscf.pbc.tools import k2gamma
 from pyscf.pbc.lib.kpts_helper import (is_zero, member, unique,
-                                       unique_with_wrap_around,
-                                       group_by_conj_pairs, KPT_DIFF_TOL)
+                                       members_with_wrap_around)
 from pyscf.df.addons import make_auxmol
 
 
 def get_aux_chg(auxcell):
     r""" Compute charge of the auxiliary basis, \int_Omega dr chi_P(r)
 
     Returns:
@@ -285,15 +284,17 @@
 
         if self.kpts_band is None:
             kpts_union = self.kpts
         else:
             kpts_union = unique(np.vstack([self.kpts, self.kpts_band]))[0]
         dfbuilder = _RSGDFBuilder(cell, auxcell, kpts_union)
         dfbuilder.__dict__.update(self.__dict__)
-        dfbuilder.make_j3c(cderi_file, j_only=self._j_only, kptij_lst=kptij_lst)
+        j_only = self._j_only or len(kpts_union) == 1
+        dfbuilder.make_j3c(cderi_file, j_only=j_only, dataname=self._dataname,
+                           kptij_lst=kptij_lst)
 
     def build(self, j_only=None, with_j3c=True, kpts_band=None):
         # formatting k-points
         self._kpts_build(kpts_band=kpts_band)
 
         # build for range-separation hybrid
         self._rs_build()
@@ -319,16 +320,17 @@
             # Initialize omega to cell.omega for HF exchange of short range
             # int2e in RSH functionals
             self.omega = abs(cell.omega)
         else:
             self.omega = None
         self.ke_cutoff = None
         self.bvk_kmesh = None
+        self.supmol_ft = None
 
-        _Int3cBuilder.__init__(self, cell, auxcell, kpts)
+        Int3cBuilder.__init__(self, cell, auxcell, kpts)
 
         # set True to force calculating j2c^(-1/2) using eigenvalue
         # decomposition (ED); otherwise, Cholesky decomposition (CD) is used
         # first, and ED is called only if CD fails.
         self.j2c_eig_always = False
         self.linear_dep_threshold = rsdf_builder.LINEAR_DEP_THR
 
@@ -336,16 +338,25 @@
         log = logger.new_logger(self)
         cell = self.cell
         kpts = self.kpts
 
         self.bvk_kmesh = kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
         log.debug('kmesh for bvk-cell = %s', kmesh)
 
-        self.rs_cell = ft_ao._RangeSeparatedCell.from_cell(
+        self.rs_cell = rs_cell = ft_ao._RangeSeparatedCell.from_cell(
             cell, self.ke_cutoff, rsdf_builder.RCUT_THRESHOLD, verbose=log)
+
+        rcut = rsdf_builder.estimate_ft_rcut(rs_cell, cell.precision,
+                                             exclude_dd_block=False)
+        supmol_ft = rsdf_builder._ExtendedMoleFT.from_cell(rs_cell, kmesh,
+                                                           rcut.max(), log)
+        supmol_ft.exclude_dd_block = False
+        self.supmol_ft = supmol_ft.strip_basis(rcut)
+        log.debug('sup-mol-ft nbas = %d cGTO = %d pGTO = %d',
+                  supmol_ft.nbas, supmol_ft.nao, supmol_ft.npgto_nr())
         return self
 
     def get_2c2e(self, uniq_kpts):
         cell = self.cell
         auxcell = self.auxcell
         # compute j2c first as it informs the integral screening in computing j3c
         # short-range part of j2c ~ (-kpt_ji | kpt_ji)
@@ -429,38 +440,51 @@
         wcoulG_lr = self.weighted_coulG(kpt, mesh=mesh, omega=self.omega)
         auxG *= wcoulG_lr
         Gaux = lib.transpose(auxG)
         GauxR = np.asarray(Gaux.real, order='C')
         GauxI = np.asarray(Gaux.imag, order='C')
         return GauxR, GauxI
 
-    def gen_j3c_loader(self, h5group, kpt, kpt_ij_idx, ijlst_mapping, aosym,
-                       dataname='j3c'):
+    def gen_j3c_loader(self, h5group, kpt, kpt_ij_idx, ijlst_mapping, aosym):
         cell = self.cell
         kpts = self.kpts
         nkpts = len(self.kpts)
         vbar = None
         if is_zero(kpt) and cell.dimension == 3:
             qaux = get_aux_chg(self.auxcell)
             vbar = np.pi / self.omega**2 / cell.vol * qaux
             vbar_idx = np.where(vbar != 0)[0]
             ovlp = cell.pbc_intor('int1e_ovlp', hermi=1, kpts=kpts)
             if aosym == 's2':
                 ovlp = [lib.pack_tril(s) for s in ovlp]
             else:
                 ovlp = [s.ravel() for s in ovlp]
 
-        nsegs = len(h5group[f'{dataname}-junk/0'])
+        # TODO: Store rs_density_fit cderi tensor in v1 format for the moment.
+        # It should be changed to 'v2' format in the future.
+        if ijlst_mapping is None:
+            data_version = 'v2'
+        else:
+            data_version = 'v1'
+
+        if data_version == 'v1':
+            nsegs = len(h5group[f'j3c-junk/{ijlst_mapping[kpt_ij_idx[0]]}'])
+        else:
+            nsegs = len(h5group[f'j3c-junk/{kpt_ij_idx[0]}'])
 
         def load_j3c(col0, col1):
             j3cR = []
             j3cI = []
             for kk in kpt_ij_idx:
-                v = np.hstack([h5group[f'{dataname}-junk/{ijlst_mapping[kk]}/{i}'][0,col0:col1]
-                               for i in range(nsegs)])
+                if data_version == 'v1':
+                    v = np.hstack([h5group[f'j3c-junk/{ijlst_mapping[kk]}/{i}'][0,col0:col1]
+                                   for i in range(nsegs)])
+                else:
+                    v = np.hstack([h5group[f'j3c-junk/{kk}/{i}'][0,col0:col1]
+                                   for i in range(nsegs)])
                 vR = np.asarray(v.real, order='C')
                 kj = kk % nkpts
                 if is_zero(kpt) and is_zero(kpts[kj]):
                     vI = None
                 else:
                     vI = np.asarray(v.imag, order='C')
                 # vbar is the interaction between the background charge
@@ -493,72 +517,81 @@
         nao = cell.nao
         naux = self.auxcell.nao
 
         if shls_slice is not None:
             raise NotImplementedError
         ish0, ish1 = 0, cell.nbas
 
-        def members(kptis, kpts):
-            diff = abs(kptis[:,None,:] - kpts).max(axis=2)
-            return np.where(diff < KPT_DIFF_TOL)[1]
-
         # ijlst_mapping maps the [nkpts x nkpts] kpts-pair to kpts-pair in
         # kptij_lst. Value -1 in ijlst_mapping means the kpts-pair does not
         # exist in kptij_lst
         ijlst_mapping = np.empty(nkpts * nkpts, dtype=int)
         ijlst_mapping[:] = -1
         if kptij_lst is None:
             if j_only:
                 kpti_idx = np.arange(nkpts)
                 ijlst_mapping[kpti_idx * nkpts + kpti_idx] = kpti_idx
                 kptij_lst = np.concatenate([kpts[:,None,:], kpts[:,None,:]], axis=1)
+                kk_idx = kpti_idx * nkpts + kpti_idx
             else:
                 kpti_idx, kptj_idx = np.tril_indices(nkpts)
                 nkpts_pair = kpti_idx.size
                 ijlst_mapping[kpti_idx * nkpts + kptj_idx] = np.arange(nkpts_pair)
                 kptij_lst = np.concatenate([kpts[kpti_idx,None,:],
                                             kpts[kptj_idx,None,:]], axis=1)
+                kk_idx = kpti_idx * nkpts + kptj_idx
         else:
-            kpti_idx = members(kptij_lst[:,0], kpts)
-            kptj_idx = members(kptij_lst[:,1], kpts)
+            kpti_idx = members_with_wrap_around(cell, kptij_lst[:,0], kpts)
+            kptj_idx = members_with_wrap_around(cell, kptij_lst[:,1], kpts)
             ijlst_mapping[kpti_idx * nkpts + kptj_idx] = np.arange(len(kptij_lst))
+            kk_idx = kpti_idx * nkpts + kptj_idx
 
         fswap = self.outcore_auxe2(cderi_file, intor, aosym, comp,
-                                   kptij_lst, j_only, f'{dataname}-junk', shls_slice)
+                                   kptij_lst, j_only, 'j3c-junk', shls_slice)
         cpu1 = log.timer_debug1('3c2e', *cpu1)
 
-        supmol_ft = ft_ao._ExtendedMole.from_cell(self.rs_cell, self.bvk_kmesh, verbose=log)
-        supmol_ft = supmol_ft.strip_basis()
-        ft_kern = supmol_ft.gen_ft_kernel(aosym, return_complex=False, verbose=log)
+        ft_kern = self.supmol_ft.gen_ft_kernel(aosym, return_complex=False,
+                                               verbose=log)
 
         # recompute g0 and Gvectors for j3c
         mesh = self.mesh_compact
         Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
         ngrids = gxyz.shape[0]
 
         # Add (1) short-range G=0 (i.e., charge) part and (2) long-range part
         tspans = np.zeros((3,2))    # lr, j2c_inv, j2c_cntr
         tspannames = ["ftaop+pw", "j2c_inv", "j2c_cntr"]
         feri = h5py.File(cderi_file, 'w')
-        feri['j3c-kptij'] = kptij_lst
+
+        # TODO: Store rs_density_fit cderi tensor in v1 format for the moment.
+        # It should be changed to 'v2' format in the future.
+        data_version = 'v1'
+        if data_version == 'v1':
+            feri['j3c-kptij'] = kptij_lst
+        else:
+            feri['kpts'] = kpts
+            ijlst_mapping = None
         def make_cderi(kpt, kpt_ij_idx, j2c):
             log.debug1('make_cderi for %s', kpt)
-            input_kptij_idx = ijlst_mapping[kpt_ij_idx]
-            # filter kpt_ij_idx, keeps only the kpts-pair in kptij_lst
-            kpt_ij_idx = kpt_ij_idx[input_kptij_idx >= 0]
-            # input_kptij_idx saves the indices of remaining kpts-pair in kptij_lst
-            input_kptij_idx = input_kptij_idx[input_kptij_idx >= 0]
-            log.debug1('kpt_ij_idx = %s', kpt_ij_idx)
-            log.debug1('input_kptij_idx = %s', input_kptij_idx)
+            kptjs = kpts[kpt_ij_idx % nkpts]
+            nkptj = len(kptjs)
+            if data_version == 'v1':
+                input_kptij_idx = ijlst_mapping[kpt_ij_idx]
+                # filter kpt_ij_idx, keeps only the kpts-pair in kptij_lst
+                kpt_ij_idx = kpt_ij_idx[input_kptij_idx >= 0]
+                # input_kptij_idx saves the indices of remaining kpts-pair in kptij_lst
+                input_kptij_idx = input_kptij_idx[input_kptij_idx >= 0]
+                log.debug1('kpt_ij_idx = %s', kpt_ij_idx)
+                log.debug1('input_kptij_idx = %s', input_kptij_idx)
+            else:
+                input_kptij_idx = kpt_ij_idx
             if kpt_ij_idx.size == 0:
                 return
 
-            kptjs = kpts[kpt_ij_idx % nkpts]
-            nkptj = len(kptjs)
             Gaux = self.weighted_ft_ao(kpt)
 
             if is_zero(kpt):  # kpti == kptj
                 aosym = 's2'
                 nao_pair = nao*(nao+1)//2
             else:
                 aosym = 's1'
@@ -611,15 +644,16 @@
                     if cderi_negative is not None:
                         # for low-dimension systems
                         feri[f'{dataname}-/{idx}/{istep}'] = cderi_negative
                 j3cR = j3cI = j3c = cderi = None
                 tick_ = np.asarray((logger.process_clock(), logger.perf_counter()))
                 tspans[2] += tick_ - tock_
 
-        for kpt, kpt_ij_idx, cd_j2c in self.gen_uniq_kpts_groups(j_only, fswap):
+        for kpt, kpt_ij_idx, cd_j2c \
+                in self.gen_uniq_kpts_groups(j_only, fswap, kk_idx=kk_idx):
             make_cderi(kpt, kpt_ij_idx, cd_j2c)
 
         feri.close()
         # report time for aft part
         for tspan, tspanname in zip(tspans, tspannames):
             log.debug1("    CPU time for %s %9.2f sec, wall time %9.2f sec",
                        "%10s"%tspanname, *tspan)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/rsdf_builder.py` & `pyscf-2.3.0/pyscf/pbc/df/rsdf_builder.py`

 * *Files 13% similar despite different names*

```diff
@@ -24,40 +24,45 @@
 erf(omega*r12)/r12. It has to be computed with the gdf_builder module.
 
 Ref:
     Q. Sun, arXiv:2012.07929
 '''
 
 import os
+import copy
 import ctypes
+import warnings
 import tempfile
 import numpy as np
 import scipy.linalg
 import h5py
 from pyscf import gto
 from pyscf import lib
 from pyscf.lib import logger, zdotCN
 from pyscf.df.outcore import _guess_shell_ranges
 from pyscf.gto import ANG_OF
 from pyscf.pbc import gto as pbcgto
+from pyscf.pbc.gto import pseudo
 from pyscf.pbc.tools import pbc as pbctools
 from pyscf.pbc.tools import k2gamma
 from pyscf.pbc.df import aft
 from pyscf.pbc.df import ft_ao
-from pyscf.pbc.df.incore import libpbc, _Int3cBuilder
-from pyscf.pbc.lib.kpts_helper import (is_zero, member, unique_with_wrap_around,
-                                       group_by_conj_pairs)
+from pyscf.pbc.df.incore import libpbc, Int3cBuilder
+from pyscf.pbc.lib.kpts_helper import (is_zero, member, kk_adapted_iter,
+                                       members_with_wrap_around, KPT_DIFF_TOL)
 from pyscf import __config__
 
+OMEGA_MIN = 0.08
+INDEX_MIN = -10000
 LINEAR_DEP_THR = getattr(__config__, 'pbc_df_df_DF_lindep', 1e-9)
 # Threshold of steep bases and local bases
-RCUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_rcut_threshold', 2.0)
+RCUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_rcut_threshold', 1.0)
 
 
-class _RSGDFBuilder(_Int3cBuilder):
+class _RSGDFBuilder(Int3cBuilder):
     '''
     Use the range-separated algorithm to build Gaussian density fitting 3-center tensor
     '''
 
     # In real-space 3c2e integrals exclude smooth-smooth block (*|DD)
     fft_dd_block = True
     # In real-space 3c2e integrals exclude smooth auxiliary basis (D|**)
@@ -69,35 +74,45 @@
     # decomposition (ED); otherwise, Cholesky decomposition (CD) is used
     # first, and ED is called only if CD fails.
     j2c_eig_always = False
     linear_dep_threshold = LINEAR_DEP_THR
 
     def __init__(self, cell, auxcell, kpts=np.zeros((1,3))):
         self.mesh = None
-        if cell.omega != 0:
+        if cell.omega == 0:
+            self.omega = None
+        elif cell.omega < 0:
             # Initialize omega to cell.omega for HF exchange of short range
             # int2e in RSH functionals
-            self.omega = abs(cell.omega)
+            self.omega = -cell.omega
         else:
-            self.omega = None
+            raise RuntimeError('RSDF does not support LR integrals')
         self.rs_auxcell = None
+        self.supmol_ft = None
 
-        _Int3cBuilder.__init__(self, cell, auxcell, kpts)
+        Int3cBuilder.__init__(self, cell, auxcell, kpts)
 
     @property
     def exclude_dd_block(self):
         cell = self.cell
         return (self.fft_dd_block and
                 cell.dimension >= 2 and cell.low_dim_ft_type != 'inf_vacuum')
 
+    @exclude_dd_block.setter
+    def exclude_dd_block(self, x):
+        self.fft_dd_block = x
+        self.reset()
+
     def has_long_range(self):
         '''Whether to add the long-range part computed with AFT integrals'''
         # If self.exclude_d_aux is set, the block (D|**) will not be computed in
         # outcore_auxe2. It has to be computed by AFT code.
-        return self.omega is None or abs(self.cell.omega) < self.omega or self.exclude_d_aux
+        cell = self.cell
+        return (cell.dimension > 0 and
+                (self.omega is None or abs(cell.omega) < self.omega or self.exclude_d_aux))
 
     def dump_flags(self, verbose=None):
         logger.info(self, '\n')
         logger.info(self, '******** %s ********', self.__class__)
         logger.info(self, 'mesh = %s (%d PWs)', self.mesh, np.prod(self.mesh))
         logger.info(self, 'ke_cutoff = %s', self.ke_cutoff)
         logger.info(self, 'omega = %s', self.omega)
@@ -110,196 +125,95 @@
     def build(self, omega=None):
         cpu0 = logger.process_clock(), logger.perf_counter()
         log = logger.new_logger(self)
         cell = self.cell
         auxcell = self.auxcell
         kpts = self.kpts
 
-        if self.cell.dimension == 0:
-            log.warn('_RSGDFBuilder for cell.dimension=0 may have larger error '
-                     'than _CCGDFBuilder')
-
         self.bvk_kmesh = kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
         log.debug('kmesh for bvk-cell = %s', kmesh)
 
         if omega is not None:
             self.omega = omega
 
-        if self.omega is None:
+        if self.omega is None or self.omega == 0:
             # Search a proper range-separation parameter omega that can balance the
             # computational cost between the real space integrals and moment space
             # integrals
             self.omega, self.mesh, self.ke_cutoff = _guess_omega(auxcell, kpts, self.mesh)
         elif self.mesh is None:
-            self.ke_cutoff = aft.estimate_ke_cutoff_for_omega(cell, self.omega)
-            mesh = pbctools.cutoff_to_mesh(cell.lattice_vectors(), self.ke_cutoff)
-            self.mesh = _round_off_to_odd_mesh(mesh)
+            self.ke_cutoff = estimate_ke_cutoff_for_omega(cell, self.omega)
+            self.mesh = cell.cutoff_to_mesh(self.ke_cutoff)
         elif self.ke_cutoff is None:
             ke_cutoff = pbctools.mesh_to_cutoff(cell.lattice_vectors(), self.mesh)
             self.ke_cutoff = ke_cutoff[:cell.dimension].min()
 
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            self.mesh[2] = _estimate_meshz(cell)
+        elif cell.dimension < 2:
+            self.mesh[cell.dimension:] = cell.mesh[cell.dimension:]
         self.mesh = cell.symmetrize_mesh(self.mesh)
 
         self.dump_flags()
 
+        exp_min = np.hstack(cell.bas_exps()).min()
+        # For each basis i in (ij|, small integrals accumulated by the lattice
+        # sum for j are not negligible. (2*cell.rcut)**3/vol is roughly the
+        # number of basis i and 1./exp_min for the non-negligible basis j.
+        lattice_sum_factor = max((2*cell.rcut)**3/cell.vol * 1/exp_min, 1)
+        cutoff = cell.precision / lattice_sum_factor * .1
+        self.direct_scf_tol = cutoff
+        log.debug('Set _RSGDFBuilder.direct_scf_tol to %g', cutoff)
+
         self.rs_cell = rs_cell = ft_ao._RangeSeparatedCell.from_cell(
             cell, self.ke_cutoff, RCUT_THRESHOLD, verbose=log)
         self.rs_auxcell = rs_auxcell = ft_ao._RangeSeparatedCell.from_cell(
             auxcell, self.ke_cutoff, verbose=log)
 
-        # Estimate rcut to generate Ls. rcut (and the translation vectors Ls)
-        # here needs to cover all possible shells to converge int3c2e.
-        # cell.rcut cannot be used here because it only converge the GTOval.
-        smooth_bas_mask = rs_cell.bas_type == ft_ao.SMOOTH_BASIS
-        cell_exps = rs_cell.bas_exps()
-        aux_exps = rs_auxcell.bas_exps()
-        exps_d = [cell_exps[ib] for ib in range(rs_cell.nbas) if smooth_bas_mask[ib]]
-        exps_c = [cell_exps[ib] for ib in range(rs_cell.nbas) if not smooth_bas_mask[ib]]
-
-        if self.exclude_d_aux:
-            compact_aux_idx = np.where(rs_auxcell.bas_type != ft_ao.SMOOTH_BASIS)[0]
-            if len(compact_aux_idx) > 0:
-                exp_aux_min = np.hstack([aux_exps[ib] for ib in compact_aux_idx]).min()
-            else:
-                exp_aux_min = np.hstack(aux_exps).max()
-        else:
-            exp_aux_min = np.hstack(aux_exps).min()
-
-        if not exps_c: # Only smooth functions
-            rcut_sr = cell.rcut
-        else:
-            # Estimation with the assumption self.exclude_dd_block = True
-            # Is rcut enough if exclude_dd_block = False?
-            if not exps_d:  # Only compact functions
-                exp_d_min = exp_c_min = np.hstack(exps_c).min()
-                aij = exp_c_min * 2
-                eij = exp_c_min / 2
-            else:  # both smooth and compact functions exist
-                exp_d_min = np.hstack(exps_d).min()
-                exp_c_min = np.hstack(exps_c).min()
-                aij = exp_d_min + exp_c_min
-                eij = exp_d_min * exp_c_min / aij
-            theta = 1/(self.omega**-2 + 1./aij + 1./exp_aux_min)
-            fac = ((8*np.pi*exp_d_min*exp_c_min/(aij*exp_aux_min)**2)**.75
-                   / (theta * np.pi)**.5)
-            # x = rcut * x_ratio for the distance between compact function
-            # and smooth function (smooth function in the far end)
-            # fac*erfc(\sqrt(theta)|rcut - x|) for the asymptotic value of short-range eri
-            x_ratio = 1. / (exp_c_min/aij + exp_d_min/theta)
-            exp_fac = eij * x_ratio**2 + theta * (1 - exp_c_min/aij*x_ratio)**2
-
-            rcut_sr = cell.rcut  # initial guess
-            rcut_sr = ((-np.log(cell.precision
-                                * rcut_sr / (2*np.pi*fac)) / exp_fac)**.5
-                       + pbcgto.cell._rcut_penalty(cell))
-            log.debug1('exp_d_min = %g, exp_c_min = %g, exp_aux_min = %g, rcut_sr = %g',
-                       exp_d_min, exp_c_min, exp_aux_min, rcut_sr)
-
-        supmol = _ExtendedMoleSR.from_cell(rs_cell, kmesh, self.omega, rcut_sr, log)
-        self.supmol = _strip_basis(supmol, self.omega, exp_aux_min, self.exclude_dd_block)
-        log.timer_debug1('initializing supmol', *cpu0)
+        rcut_sr = estimate_rcut(rs_cell, rs_auxcell, self.omega, rs_cell.precision,
+                                self.exclude_dd_block,
+                                self.exclude_d_aux and cell.dimension > 0)
+        supmol = ft_ao.ExtendedMole.from_cell(rs_cell, kmesh, rcut_sr.max(), log)
+        supmol.omega = -self.omega
+        self.supmol = supmol.strip_basis(rcut_sr)
         log.debug('sup-mol nbas = %d cGTO = %d pGTO = %d',
                   supmol.nbas, supmol.nao, supmol.npgto_nr())
+
+        if self.has_long_range():
+            rcut = estimate_ft_rcut(rs_cell, cell.precision, self.exclude_dd_block)
+            supmol_ft = _ExtendedMoleFT.from_cell(rs_cell, kmesh, rcut.max(), log)
+            supmol_ft.exclude_dd_block = self.exclude_dd_block
+            self.supmol_ft = supmol_ft.strip_basis(rcut)
+            log.debug('sup-mol-ft nbas = %d cGTO = %d pGTO = %d',
+                      supmol_ft.nbas, supmol_ft.nao, supmol_ft.npgto_nr())
+        log.timer_debug1('initializing supmol', *cpu0)
         return self
 
     weighted_coulG = aft.weighted_coulG
 
     def weighted_coulG_LR(self, kpt=np.zeros(3), exx=False, mesh=None):
         # The long range part Coulomb kernel has to be computed as the
         # difference between coulG(cell.omega) - coulG(df.omega). It allows this
         # module to handle the SR- and regular integrals in the same framework
         return (self.weighted_coulG(kpt, exx, mesh) -
                 self.weighted_coulG_SR(kpt, exx, mesh))
 
     def weighted_coulG_SR(self, kpt=np.zeros(3), exx=False, mesh=None):
         return self.weighted_coulG(kpt, False, mesh, -self.omega)
 
-    def get_q_cond(self):
+    def get_q_cond(self, supmol=None):
         '''Integral screening condition max(sqrt((ij|ij))) inside the supmol'''
-        supmol = self.supmol
-        intor = 'int2e_sph'
-        cintopt = lib.c_null_ptr()
-        nbas = supmol.nbas
-        q_cond = np.empty((nbas, nbas))
-        with supmol.with_integral_screen(supmol.precision**2):
-            ao_loc = gto.moleintor.make_loc(supmol._bas, intor)
-            libpbc.CVHFset_int2e_q_cond(
-                getattr(libpbc, intor), cintopt,
-                q_cond.ctypes.data_as(ctypes.c_void_p),
-                ao_loc.ctypes.data_as(ctypes.c_void_p),
-                supmol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.natm),
-                supmol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.nbas),
-                supmol._env.ctypes.data_as(ctypes.c_void_p))
+        q_cond = Int3cBuilder.get_q_cond(self, supmol)
 
         # Remove d-d block in supmol q_cond
-        if self.exclude_dd_block:
+        if self.exclude_dd_block and self.cell.dimension > 0:
             smooth_idx = supmol.bas_type_to_indices(ft_ao.SMOOTH_BASIS)
-            q_cond[smooth_idx[:,None], smooth_idx] = 1e-200
+            q_cond[smooth_idx[:,None], smooth_idx] = INDEX_MIN
         return q_cond
 
-    def get_q_cond_aux(self, auxcell=None, supmol=None):
-        '''max(sqrt((k|ii))) between the auxcell and the supmol'''
-        if supmol is None:
-            supmol = self.supmol
-        auxcell_s = self.rs_auxcell.copy()
-        auxcell_s._bas[:,ANG_OF] = 0
-        intor = 'int3c2e_sph'
-        cintopt = lib.c_null_ptr()
-        nbas = supmol.nbas
-        q_cond_aux = np.empty((auxcell_s.nbas, nbas))
-        with supmol.with_integral_screen(supmol.precision**2):
-            atm, bas, env = gto.conc_env(supmol._atm, supmol._bas, supmol._env,
-                                         auxcell_s._atm, auxcell_s._bas, auxcell_s._env)
-            ao_loc = gto.moleintor.make_loc(bas, intor)
-            shls_slice = (0, supmol.nbas, supmol.nbas, len(bas))
-            libpbc.PBC_nr3c_q_cond(
-                getattr(libpbc, intor), cintopt,
-                q_cond_aux.ctypes.data_as(ctypes.c_void_p),
-                (ctypes.c_int * 4)(*shls_slice),
-                ao_loc.ctypes.data_as(ctypes.c_void_p),
-                atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.natm),
-                bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.nbas),
-                env.ctypes.data_as(ctypes.c_void_p))
-
-        if self.exclude_d_aux:
-            # Assign a very small value to q_cond_aux to avoid dividing 0 error
-            q_cond_aux[self.rs_auxcell.bas_type == ft_ao.SMOOTH_BASIS] = 1e-200
-        return q_cond_aux
-
-    def get_bas_map(self, auxcell=None, supmol=None):
-        '''bas_map is to assign each basis of supmol._bas the index in
-        [bvk_cell-id, bas-id, image-id]
-        '''
-        if supmol is None:
-            supmol = self.supmol
-        if self.exclude_d_aux:
-            # Use aux_mask to skip smooth auxiliary basis and handle them in AFT part.
-            aux_mask = (self.rs_auxcell.bas_type != ft_ao.SMOOTH_BASIS).astype(np.int32)
-        else:
-            aux_mask = np.ones(self.rs_auxcell.nbas, dtype=np.int32)
-
-        # Append aux_mask to bas_map as a temporary solution for function
-        # _assemble3c in fill_ints.c
-        bas_map = np.where(supmol.bas_mask.ravel())[0].astype(np.int32)
-        bas_map = np.asarray(np.append(bas_map, aux_mask), dtype=np.int32)
-        return bas_map
-
-    def get_ovlp_mask(self, cutoff, supmol=None, cintopt=None):
-        if supmol is None:
-            supmol = self.supmol
-        bvk_ncells, rs_nbas, nimgs = supmol.bas_mask.shape
-        nbasp = self.cell.nbas  # The number of shells in the primitive cell
-        ovlp_mask = self.get_q_cond() > cutoff
-        bvk_ovlp_mask = lib.condense('np.any', ovlp_mask, supmol.sh_loc)
-        cell0_ovlp_mask = bvk_ovlp_mask.reshape(
-            bvk_ncells, nbasp, bvk_ncells, nbasp).any(axis=2).any(axis=0)
-        ovlp_mask = ovlp_mask.astype(np.int8)
-        cell0_ovlp_mask = cell0_ovlp_mask.astype(np.int8)
-        return ovlp_mask, cell0_ovlp_mask
-
     def decompose_j2c(self, j2c):
         j2c = np.asarray(j2c)
         if self.j2c_eig_always:
             return self.eigenvalue_decomposed_metric(j2c)
         else:
             return self.cholesky_decomposed_metric(j2c)
 
@@ -312,48 +226,59 @@
             j2c, j2c_negative, j2ctag = self.eigenvalue_decomposed_metric(j2c)
         return j2c, j2c_negative, j2ctag
 
     def eigenvalue_decomposed_metric(self, j2c):
         cell = self.cell
         j2c_negative = None
         w, v = scipy.linalg.eigh(j2c)
+        mask = w > self.linear_dep_threshold
         logger.debug(self, 'cond = %.4g, drop %d bfns',
-                     w[-1]/w[0], np.count_nonzero(w<self.linear_dep_threshold))
-        v1 = v[:,w>self.linear_dep_threshold].conj().T
-        v1 /= np.sqrt(w[w>self.linear_dep_threshold]).reshape(-1,1)
+                     w[-1]/w[0], w.size-np.count_nonzero(mask))
+        v1 = v[:,mask].conj().T
+        v1 /= np.sqrt(w[mask, None])
         j2c = v1
         if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
             idx = np.where(w < -self.linear_dep_threshold)[0]
             if len(idx) > 0:
                 j2c_negative = (v[:,idx]/np.sqrt(-w[idx])).conj().T
         j2ctag = 'ED'
         return j2c, j2c_negative, j2ctag
 
     def get_2c2e(self, uniq_kpts):
         # j2c ~ (-kpt_ji | kpt_ji) => hermi=1
+        cell = self.cell
         auxcell = self.auxcell
+        if auxcell.dimension == 0:
+            return [auxcell.intor('int2c2e', hermi=1)]
+
         if not self.has_long_range():
             omega = auxcell.omega
-            with lib.temporary_env(auxcell):
-                j2c = auxcell.pbc_intor('int2c2e', hermi=1, kpts=uniq_kpts)
-            if auxcell.dimension == 3 and auxcell.low_dim_ft_type != 'inf_vacuum':
+            j2c = auxcell.pbc_intor('int2c2e', hermi=1, kpts=uniq_kpts)
+            if (auxcell.dimension >= 2 and omega != 0 and
+                auxcell.low_dim_ft_type != 'inf_vacuum'):
                 gamma_point_idx = member(np.zeros(3), uniq_kpts)
                 if len(gamma_point_idx) > 0:
                     # Add G=0 contribution
                     g0_fac = np.pi / omega**2 / auxcell.vol
                     aux_chg = _gaussian_int(auxcell)
                     j2c[gamma_point_idx[0]] -= g0_fac * aux_chg[:,None] * aux_chg
             return j2c
 
-        precision = auxcell.precision**2
+        precision = auxcell.precision**1.5
         omega = self.omega
         rs_auxcell = self.rs_auxcell
         auxcell_c = rs_auxcell.compact_basis_cell()
         if auxcell_c.nbas > 0:
-            rcut_sr = (-np.log(precision * auxcell_c.rcut**2 * omega))**.5 / omega
+            aux_exp = np.hstack(auxcell_c.bas_exps()).min()
+            if omega == 0:
+                theta = aux_exp / 2
+            else:
+                theta = 1./(2./aux_exp + omega**-2)
+            fac = 2*np.pi**3.5/auxcell.vol * aux_exp**-3 * theta**-1.5
+            rcut_sr = (np.log(fac / auxcell_c.rcut / precision + 1.) / theta)**.5
             auxcell_c.rcut = rcut_sr
             logger.debug1(self, 'auxcell_c  rcut_sr = %g', rcut_sr)
             with auxcell_c.with_short_range_coulomb(omega):
                 sr_j2c = list(auxcell_c.pbc_intor('int2c2e', hermi=1, kpts=uniq_kpts))
             recontract_1d = rs_auxcell.recontract()
 
             compact_bas_idx = np.where(rs_auxcell.bas_type != ft_ao.SMOOTH_BASIS)[0]
@@ -364,19 +289,21 @@
                 return lib.takebak_2d(j2c, j2c_cc, ao_map, ao_map, thread_safe=False)
         else:
             sr_j2c = None
 
         # 2c2e integrals the metric can easily cause errors in cderi tensor.
         # self.mesh may not be enough to produce required accuracy.
         # mesh = self.mesh
-        ke = aft.estimate_ke_cutoff_for_omega(auxcell, omega, precision)
-        mesh = pbctools.cutoff_to_mesh(auxcell.lattice_vectors(), ke)
-        if auxcell.dimension < 2 or auxcell.low_dim_ft_type == 'inf_vacuum':
-            mesh[auxcell.dimension:] = self.mesh[auxcell.dimension:]
-        mesh = self.cell.symmetrize_mesh(mesh)
+        ke = estimate_ke_cutoff_for_omega(auxcell, omega, precision)
+        mesh = auxcell.cutoff_to_mesh(ke)
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            mesh[2] = _estimate_meshz(auxcell)
+        elif cell.dimension < 2:
+            mesh[cell.dimension:] = cell.mesh[cell.dimension:]
+        mesh = cell.symmetrize_mesh(mesh)
         logger.debug(self, 'Set 2c2e integrals precision %g, mesh %s', precision, mesh)
 
         Gv, Gvbase, kws = auxcell.get_Gv_weights(mesh)
         b = auxcell.reciprocal_vectors()
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
         ngrids = Gv.shape[0]
         naux_rs = rs_auxcell.nao
@@ -390,31 +317,37 @@
             if is_zero(kpt):  # kpti == kptj
                 j2c_k = np.zeros((naux, naux))
             else:
                 j2c_k = np.zeros((naux, naux), dtype=np.complex128)
 
             if sr_j2c is None:
                 for p0, p1 in lib.prange(0, ngrids, blksize):
-                    auxG = ft_ao.ft_ao(auxcell, Gv[p0:p1], None, b, gxyz[p0:p1], Gvbase, kpt).T
+                    auxG = ft_ao.ft_ao(auxcell, Gv[p0:p1], None, b, gxyz[p0:p1],
+                                       Gvbase, kpt).T
                     if is_zero(kpt):  # kpti == kptj
                         j2c_k += lib.dot(auxG.conj() * coulG[p0:p1], auxG.T).real
                     else:
                         #j2cR, j2cI = zdotCN(LkR*coulG[p0:p1],
                         #                    LkI*coulG[p0:p1], LkR.T, LkI.T)
                         j2c_k += lib.dot(auxG.conj() * coulG[p0:p1], auxG.T)
                     auxG = None
             else:
                 # coulG_sr here to first remove the FT-SR-2c2e for compact basis
                 # from the analytical 2c2e integrals. The FT-SR-2c2e for compact
                 # basis is added back in j2c_k.
-                coulG_sr = self.weighted_coulG_SR(kpt, False, mesh)
-                if auxcell.dimension == 3 and is_zero(kpt):
-                    G0_idx = 0  # due to np.fft.fftfreq convention
-                    G0_weight = kws[G0_idx] if isinstance(kws, np.ndarray) else kws
-                    coulG_sr[G0_idx] += np.pi/omega**2 * G0_weight
+                if (cell.dimension == 3 or
+                    (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum')):
+                    with lib.temporary_env(cell, dimension=3):
+                        coulG_sr = self.weighted_coulG_SR(kpt, False, mesh)
+                    if omega != 0 and is_zero(kpt):
+                        G0_idx = 0  # due to np.fft.fftfreq convention
+                        coulG_SR_at_G0 = np.pi/omega**2 * kws
+                        coulG_sr[G0_idx] += coulG_SR_at_G0
+                else:
+                    coulG_sr = self.weighted_coulG_SR(kpt, False, mesh)
 
                 for p0, p1 in lib.prange(0, ngrids, blksize):
                     auxG = ft_ao.ft_ao(rs_auxcell, Gv[p0:p1], None, b, gxyz[p0:p1], Gvbase, kpt).T
                     auxG_sr = auxG[compact_ao_idx]
                     if is_zero(kpt):
                         sr_j2c[k] -= lib.dot(auxG_sr.conj() * coulG_sr[p0:p1], auxG_sr.T).real
                     else:
@@ -430,15 +363,15 @@
                 sr_j2c[k] = None
 
             j2c.append(j2c_k)
         return j2c
 
     def outcore_auxe2(self, cderi_file, intor='int3c2e', aosym='s2', comp=None,
                       j_only=False, dataname='j3c', shls_slice=None,
-                      fft_dd_block=None):
+                      fft_dd_block=None, kk_idx=None):
         r'''The SR part of 3-center integrals (ij|L) with double lattice sum.
 
         Kwargs:
             shls_slice :
                 Indicate the shell slices in the primitive cell
         '''
         # The ideal way to hold the temporary integrals is to store them in the
@@ -468,23 +401,18 @@
             j_only = True
 
         intor, comp = gto.moleintor._get_intor_and_comp(cell._add_suffix(intor), comp)
 
         if fft_dd_block is None:
             fft_dd_block = self.exclude_dd_block
 
-        if fft_dd_block:
-            self._outcore_dd_block(fswap, intor, aosym, comp, j_only,
-                                   dataname, shls_slice)
-
-        # int3c may be the regular int3c2e, LR-int3c2e or SR-int3c2e, depending
-        # on how self.supmol is initialized
-        int3c = self.gen_int3c_kernel(intor, aosym, comp, j_only,
-                                      rs_auxcell=self.rs_auxcell)
-
+        if self.exclude_d_aux and cell.dimension > 0:
+            rs_auxcell = self.rs_auxcell.compact_basis_cell()
+        else:
+            rs_auxcell = self.rs_auxcell
         if shls_slice is None:
             shls_slice = (0, cell.nbas, 0, cell.nbas, 0, auxcell.nbas)
 
         ao_loc = cell.ao_loc
         aux_loc = auxcell.ao_loc_nr(auxcell.cart or 'ssc' in intor)
         ish0, ish1, jsh0, jsh1, ksh0, ksh1 = shls_slice
         i0, i1, j0, j1 = ao_loc[list(shls_slice[:4])]
@@ -496,42 +424,57 @@
         naux = k1 - k0
 
         if fft_dd_block and np.any(rs_cell.bas_type == ft_ao.SMOOTH_BASIS):
             merge_dd = rs_cell.merge_diffused_block(aosym)
         else:
             merge_dd = None
 
+        reindex_k = None
         # TODO: shape = (comp, nao_pair, naux)
         shape = (nao_pair, naux)
         if j_only or nkpts == 1:
-            for k in range(nkpts):
-                fswap.create_dataset(f'{dataname}R/{k*nkpts+k}', shape, 'f8')
-                # exclude imaginary part for gamma point
-                if not is_zero(kpts[k]):
-                    fswap.create_dataset(f'{dataname}I/{k*nkpts+k}', shape, 'f8')
             nkpts_ij = nkpts
-            kikj_idx = [k*nkpts+k for k in range(nkpts)]
+            ks = np.arange(nkpts, dtype=np.int32)
+            kikj_idx = ks * nkpts + ks
+            if kk_idx is not None:
+                # Ensure kk_idx is a subset of all possible ki-kj paris
+                assert np.all(np.isin(kk_idx, kikj_idx))
+                kikj_idx = kk_idx
+            reindex_k = kikj_idx // nkpts
         else:
-            for ki in range(nkpts):
-                for kj in range(nkpts):
-                    fswap.create_dataset(f'{dataname}R/{ki*nkpts+kj}', shape, 'f8')
-                    fswap.create_dataset(f'{dataname}I/{ki*nkpts+kj}', shape, 'f8')
-                # exclude imaginary part for gamma point
-                if is_zero(kpts[ki]):
-                    del fswap[f'{dataname}I/{ki*nkpts+ki}']
             nkpts_ij = nkpts * nkpts
-            kikj_idx = range(nkpts_ij)
-            if merge_dd:
-                uniq_kpts, uniq_index, uniq_inverse = unique_with_wrap_around(
-                    cell, (kpts[None,:,:] - kpts[:,None,:]).reshape(-1, 3))
-                kpt_ij_pairs = group_by_conj_pairs(cell, uniq_kpts)[0]
+            if kk_idx is None:
+                kikj_idx = np.arange(nkpts_ij, dtype=np.int32)
+            else:
+                kikj_idx = kk_idx
+            reindex_k = kikj_idx
+            if merge_dd and kk_idx is None:
+                kpt_ij_iters = list(kk_adapted_iter(cell, kpts))
+
+        for idx in kikj_idx:
+            fswap.create_dataset(f'{dataname}R/{idx}', shape, 'f8')
+            fswap.create_dataset(f'{dataname}I/{idx}', shape, 'f8')
+        # exclude imaginary part for gamma point
+        for k in np.where(abs(kpts).max(axis=1) < KPT_DIFF_TOL)[0]:
+            if f'{dataname}I/{k*nkpts+k}' in fswap:
+                del fswap[f'{dataname}I/{k*nkpts+k}']
 
         if naux == 0:
             return fswap
 
+        if fft_dd_block:
+            self._outcore_dd_block(fswap, intor, aosym, comp, j_only,
+                                   dataname, kk_idx=kk_idx)
+
+        # int3c may be the regular int3c2e, LR-int3c2e or SR-int3c2e, depending
+        # on how self.supmol is initialized
+        # TODO: call gen_int3c_kernel(reindex_k=kikj_idx) for a subset of kpts
+        int3c = self.gen_int3c_kernel(intor, aosym, comp, j_only,
+                                      reindex_k=reindex_k, rs_auxcell=rs_auxcell)
+
         mem_now = lib.current_memory()[0]
         log.debug2('memory = %s', mem_now)
         max_memory = max(2000, self.max_memory-mem_now)
 
         # split the 3-center tensor (nkpts_ij, i, j, aux) along shell i.
         # plus 1 to ensure the intermediates in libpbc do not overflow
         buflen = min(max(int(max_memory*.9e6/16/naux/(nkpts_ij+1)), 1), nao_pair)
@@ -559,46 +502,49 @@
 
             shls_slice = (sh_start, sh_end, 0, cell.nbas)
             row0, row1 = row1, row1 + nrow
             if merge_dd is not None:
                 if gamma_point_only:
                     merge_dd(outR[0], fswap[f'{dataname}R-dd/0'], shls_slice)
                 elif j_only or nkpts == 1:
-                    for k in range(nkpts):
-                        merge_dd(outR[k], fswap[f'{dataname}R-dd/{k*nkpts+k}'], shls_slice)
-                        merge_dd(outI[k], fswap[f'{dataname}I-dd/{k*nkpts+k}'], shls_slice)
-                else:
-                    for k, k_conj in kpt_ij_pairs:
-                        kpt_ij_idx = np.where(uniq_inverse == k)[0]
-                        if k_conj is None or k == k_conj:
+                    for k, idx in enumerate(kikj_idx):
+                        merge_dd(outR[k], fswap[f'{dataname}R-dd/{idx}'], shls_slice)
+                        merge_dd(outI[k], fswap[f'{dataname}I-dd/{idx}'], shls_slice)
+                elif kk_idx is None:
+                    for _, ki_idx, kj_idx, self_conj in kpt_ij_iters:
+                        kpt_ij_idx = ki_idx * nkpts + kj_idx
+                        if self_conj:
                             for ij_idx in kpt_ij_idx:
                                 merge_dd(outR[ij_idx], fswap[f'{dataname}R-dd/{ij_idx}'], shls_slice)
                                 merge_dd(outI[ij_idx], fswap[f'{dataname}I-dd/{ij_idx}'], shls_slice)
                         else:
-                            ki_lst = kpt_ij_idx // nkpts
-                            kj_lst = kpt_ij_idx % nkpts
-                            kpt_ji_idx = kj_lst * nkpts + ki_lst
+                            kpt_ji_idx = kj_idx * nkpts + ki_idx
                             for ij_idx, ji_idx in zip(kpt_ij_idx, kpt_ji_idx):
                                 j3cR_dd = np.asarray(fswap[f'{dataname}R-dd/{ij_idx}'])
                                 merge_dd(outR[ij_idx], j3cR_dd, shls_slice)
                                 merge_dd(outR[ji_idx], j3cR_dd.transpose(1,0,2), shls_slice)
                                 j3cI_dd = np.asarray(fswap[f'{dataname}I-dd/{ij_idx}'])
                                 merge_dd(outI[ij_idx], j3cI_dd, shls_slice)
                                 merge_dd(outI[ji_idx],-j3cI_dd.transpose(1,0,2), shls_slice)
-
-            for k, kk_idx in enumerate(kikj_idx):
-                fswap[f'{dataname}R/{kk_idx}'][row0:row1] = outR[k]
-                if f'{dataname}I/{kk_idx}' in fswap:
-                    fswap[f'{dataname}I/{kk_idx}'][row0:row1] = outI[k]
+                else:
+                    for k, idx in enumerate(kikj_idx):
+                        merge_dd(outR[k], fswap[f'{dataname}R-dd/{idx}'], shls_slice)
+                        merge_dd(outI[k], fswap[f'{dataname}I-dd/{idx}'], shls_slice)
+
+            for k, idx in enumerate(kikj_idx):
+                fswap[f'{dataname}R/{idx}'][row0:row1] = outR[k]
+                if f'{dataname}I/{idx}' in fswap:
+                    fswap[f'{dataname}I/{idx}'][row0:row1] = outI[k]
             outR = outI = None
         bufR = bufI = None
         return fswap
 
     def _outcore_dd_block(self, h5group, intor='int3c2e', aosym='s2', comp=None,
-                          j_only=False, dataname='j3c', shls_slice=None):
+                          j_only=False, dataname='j3c', shls_slice=None,
+                          kk_idx=None):
         '''
         The block of smooth AO basis in i and j of (ij|L) with full Coulomb kernel
         '''
         if intor not in ('int3c2e', 'int3c2e_sph', 'int3c2e_cart'):
             raise NotImplementedError
 
         if shls_slice is not None:
@@ -617,15 +563,15 @@
             return
 
         mesh = cell_d.mesh
         aoR_ks, aoI_ks = _eval_gto(cell_d, mesh, kpts)
         coords = cell_d.get_uniform_grids(mesh)
 
         # TODO check if max_memory is enough
-        Gv, Gvbase, kws = auxcell.get_Gv_weights(mesh)
+        Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
         b = cell_d.reciprocal_vectors()
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
         ngrids = Gv.shape[0]
 
         def get_Vaux(kpt):
             # int3c2e = fft(ao.conj()*ao*exp(-1j*coords.dot(kpt))) * coulG *
             #           (cell.vol/ngrids) * fft(aux*exp(-1j*coords.dot(-kpt)))
@@ -650,39 +596,39 @@
             # Reuse auxG to reduce memory footprint
             Vaux = auxG
             for p0, p1 in lib.prange(0, naux, blksize):
                 Vaux[p0:p1] = pbctools.ifft(auxG[p0:p1], mesh)
             Vaux *= np.exp(-1j * coords.dot(kpt))
             return Vaux
 
-        def join_R(ki, kj):
-            #:aopair = np.einsum('ig,jg->ijg', aoR_ks[ki], aoR_ks[kj])
-            #:aopair+= np.einsum('ig,jg->ijg', aoI_ks[ki], aoI_ks[kj])
-            aopair = np.empty((nao**2, ngrids))
-            libpbc.PBC_zjoinR_CN_s1(
-                aopair.ctypes.data_as(ctypes.c_void_p),
-                aoR_ks[ki].ctypes.data_as(ctypes.c_void_p),
-                aoI_ks[ki].ctypes.data_as(ctypes.c_void_p),
-                aoR_ks[kj].ctypes.data_as(ctypes.c_void_p),
-                aoI_ks[kj].ctypes.data_as(ctypes.c_void_p),
-                ctypes.c_int(nao), ctypes.c_int(nao), ctypes.c_int(ngrids))
-            return aopair
-
-        def join_I(ki, kj):
-            #:aopair = np.einsum('ig,jg->ijg', aoR_ks[ki], aoI_ks[kj])
-            #:aopair-= np.einsum('ig,jg->ijg', aoI_ks[ki], aoR_ks[kj])
-            aopair = np.empty((nao**2, ngrids))
-            libpbc.PBC_zjoinI_CN_s1(
-                aopair.ctypes.data_as(ctypes.c_void_p),
-                aoR_ks[ki].ctypes.data_as(ctypes.c_void_p),
-                aoI_ks[ki].ctypes.data_as(ctypes.c_void_p),
-                aoR_ks[kj].ctypes.data_as(ctypes.c_void_p),
-                aoI_ks[kj].ctypes.data_as(ctypes.c_void_p),
-                ctypes.c_int(nao), ctypes.c_int(nao), ctypes.c_int(ngrids))
-            return aopair
+        #:def join_R(ki, kj):
+        #:    #:aopair = np.einsum('ig,jg->ijg', aoR_ks[ki], aoR_ks[kj])
+        #:    #:aopair+= np.einsum('ig,jg->ijg', aoI_ks[ki], aoI_ks[kj])
+        #:    aopair = np.empty((nao**2, ngrids))
+        #:    libpbc.PBC_zjoinR_CN_s1(
+        #:        aopair.ctypes.data_as(ctypes.c_void_p),
+        #:        aoR_ks[ki].ctypes.data_as(ctypes.c_void_p),
+        #:        aoI_ks[ki].ctypes.data_as(ctypes.c_void_p),
+        #:        aoR_ks[kj].ctypes.data_as(ctypes.c_void_p),
+        #:        aoI_ks[kj].ctypes.data_as(ctypes.c_void_p),
+        #:        ctypes.c_int(nao), ctypes.c_int(nao), ctypes.c_int(ngrids))
+        #:    return aopair
+
+        #:def join_I(ki, kj):
+        #:    #:aopair = np.einsum('ig,jg->ijg', aoR_ks[ki], aoI_ks[kj])
+        #:    #:aopair-= np.einsum('ig,jg->ijg', aoI_ks[ki], aoR_ks[kj])
+        #:    aopair = np.empty((nao**2, ngrids))
+        #:    libpbc.PBC_zjoinI_CN_s1(
+        #:        aopair.ctypes.data_as(ctypes.c_void_p),
+        #:        aoR_ks[ki].ctypes.data_as(ctypes.c_void_p),
+        #:        aoI_ks[ki].ctypes.data_as(ctypes.c_void_p),
+        #:        aoR_ks[kj].ctypes.data_as(ctypes.c_void_p),
+        #:        aoI_ks[kj].ctypes.data_as(ctypes.c_void_p),
+        #:        ctypes.c_int(nao), ctypes.c_int(nao), ctypes.c_int(ngrids))
+        #:    return aopair
 
         gamma_point_only = is_zero(kpts)
         if j_only or nkpts == 1:
             Vaux = np.asarray(get_Vaux(np.zeros(3)).real, order='C')
             if gamma_point_only:
                 #:aopair = np.einsum('ig,jg->ijg', aoR_ks[0], aoR_ks[0])
                 aopair = np.empty((nao**2, ngrids))
@@ -695,43 +641,41 @@
                 h5group[f'{dataname}R-dd/0'] = j3c.reshape(nao, nao, naux)
                 aopair = j3c = None
 
             else:
                 #:for k in range(nkpts):
                 #:    h5group[f'{dataname}R-dd/{k*nkpts+k}'] = lib.ddot(join_R(k, k), Vaux.T)
                 #:    h5group[f'{dataname}I-dd/{k*nkpts+k}'] = lib.ddot(join_I(k, k), Vaux.T)
-                k_idx = np.arange(nkpts, dtype=np.int32)
-                kpt_ij_idx = k_idx * nkpts + k_idx
+                if kk_idx is None:
+                    ks = np.arange(nkpts, dtype=np.int32)
+                    kpt_ij_idx = ks * nkpts + ks
+                else:
+                    kpt_ij_idx = np.asarray(kk_idx, dtype=np.int32)
                 j3cR = np.empty((nkpts, nao, nao, naux))
                 j3cI = np.empty((nkpts, nao, nao, naux))
                 libpbc.PBC_kzdot_CNN_s1(j3cR.ctypes.data_as(ctypes.c_void_p),
                                         j3cI.ctypes.data_as(ctypes.c_void_p),
                                         aoR_ks.ctypes.data_as(ctypes.c_void_p),
                                         aoI_ks.ctypes.data_as(ctypes.c_void_p),
                                         Vaux.ctypes.data_as(ctypes.c_void_p), lib.c_null_ptr(),
                                         kpt_ij_idx.ctypes.data_as(ctypes.c_void_p),
                                         ctypes.c_int(nao), ctypes.c_int(nao),
                                         ctypes.c_int(naux), ctypes.c_int(ngrids),
                                         ctypes.c_int(nkpts), ctypes.c_int(nkpts))
-                for k, kk_idx in enumerate(kpt_ij_idx):
-                    h5group[f'{dataname}R-dd/{kk_idx}'] = j3cR[k]
-                    h5group[f'{dataname}I-dd/{kk_idx}'] = j3cI[k]
+                for k, idx in enumerate(kpt_ij_idx):
+                    h5group[f'{dataname}R-dd/{idx}'] = j3cR[k]
+                    h5group[f'{dataname}I-dd/{idx}'] = j3cI[k]
 
         else:
-            uniq_kpts, uniq_index, uniq_inverse = unique_with_wrap_around(
-                cell, (kpts[None,:,:] - kpts[:,None,:]).reshape(-1, 3))
-            scaled_uniq_kpts = cell_d.get_scaled_kpts(uniq_kpts).round(5)
-            log.debug('Num uniq kpts %d', len(uniq_kpts))
-            log.debug2('Scaled unique kpts %s', scaled_uniq_kpts)
-            for k, k_conj in group_by_conj_pairs(cell, uniq_kpts)[0]:
-                # Find ki's and kj's that satisfy k_aux = kj - ki
-                kpt_ij_idx = np.asarray(np.where(uniq_inverse == k)[0], dtype=np.int32)
+            enable_t_rev_sym = kk_idx is None
+            for kpt, ki_idx, kj_idx, self_conj \
+                    in kk_adapted_iter(cell, kpts, kk_idx, enable_t_rev_sym):
+                kpt_ij_idx = np.asarray(ki_idx * nkpts + kj_idx, dtype=np.int32)
                 nkptij = len(kpt_ij_idx)
-
-                Vaux = get_Vaux(uniq_kpts[k])
+                Vaux = get_Vaux(kpt)
                 VauxR = np.asarray(Vaux.real, order='C')
                 VauxI = np.asarray(Vaux.imag, order='C')
                 Vaux = None
                 #:for kk_idx in kpt_ij_idx:
                 #:    ki = kk_idx // nkpts
                 #:    kj = kk_idx % nkpts
                 #:    aopair = join_R(ki, kj, exp(-i*k dot r))
@@ -748,30 +692,36 @@
                                         aoI_ks.ctypes.data_as(ctypes.c_void_p),
                                         VauxR.ctypes.data_as(ctypes.c_void_p),
                                         VauxI.ctypes.data_as(ctypes.c_void_p),
                                         kpt_ij_idx.ctypes.data_as(ctypes.c_void_p),
                                         ctypes.c_int(nao), ctypes.c_int(nao),
                                         ctypes.c_int(naux), ctypes.c_int(ngrids),
                                         ctypes.c_int(nkptij), ctypes.c_int(nkpts))
-                for k, kk_idx in enumerate(kpt_ij_idx):
-                    h5group[f'{dataname}R-dd/{kk_idx}'] = j3cR[k]
-                    h5group[f'{dataname}I-dd/{kk_idx}'] = j3cI[k]
+                for k, idx in enumerate(kpt_ij_idx):
+                    h5group[f'{dataname}R-dd/{idx}'] = j3cR[k]
+                    h5group[f'{dataname}I-dd/{idx}'] = j3cI[k]
                 j3cR = j3cI = VauxR = VauxI = None
 
     def weighted_ft_ao(self, kpt):
         '''exp(-i*(G + k) dot r) * Coulomb_kernel'''
+        cell = self.cell
         rs_cell = self.rs_cell
         Gv, Gvbase, kws = rs_cell.get_Gv_weights(self.mesh)
         b = rs_cell.reciprocal_vectors()
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
         coulG = self.weighted_coulG(kpt, False, self.mesh)
-        coulG_LR = coulG - self.weighted_coulG_SR(kpt, False, self.mesh)
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            with lib.temporary_env(cell, dimension=3):
+                coulG_SR = self.weighted_coulG_SR(kpt, False, self.mesh)
+        else:
+            coulG_SR = self.weighted_coulG_SR(kpt, False, self.mesh)
+        coulG_LR = coulG - coulG_SR
 
         shls_slice = None
-        if self.exclude_d_aux:
+        if self.exclude_d_aux and rs_cell.dimension > 0:
             # The smooth basis in auxcell was excluded in outcore_auxe2.
             # Full Coulomb kernel needs to be applied for the smooth basis
             rs_auxcell = self.rs_auxcell
             smooth_aux_mask = rs_auxcell.get_ao_type() == ft_ao.SMOOTH_BASIS
             auxG = ft_ao.ft_ao(rs_auxcell, Gv, shls_slice, b, gxyz, Gvbase, kpt).T
             auxG[smooth_aux_mask] *= coulG
             auxG[~smooth_aux_mask] *= coulG_LR
@@ -787,16 +737,18 @@
 
     def gen_j3c_loader(self, h5group, kpt, kpt_ij_idx, aosym):
         cell = self.cell
         naux = self.auxcell.nao
         vbar = None
         # Explicitly add the G0 contributions here because FT will not be
         # applied to the j3c integrals for short range integrals.
-        if cell.dimension == 3 and is_zero(kpt):
-            if self.exclude_d_aux:
+        if (is_zero(kpt) and self.omega != 0 and
+            (cell.dimension == 3 or
+             (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum'))):
+            if self.exclude_d_aux and cell.dimension > 0:
                 rs_auxcell = self.rs_auxcell
                 aux_chg = _gaussian_int(rs_auxcell)
                 smooth_ao_idx = rs_auxcell.get_ao_type() == ft_ao.SMOOTH_BASIS
                 aux_chg[smooth_ao_idx] = 0
                 aux_chg = rs_auxcell.recontract_1d(aux_chg[:,None]).ravel()
             else:
                 aux_chg = _gaussian_int(self.auxcell)
@@ -874,78 +826,75 @@
         else:
             cderi = lib.dot(j2c, j3c)
             if j2c_negative is not None:
                 # for low-dimension systems
                 cderi_negative = lib.dot(j2c_negative, j3c)
         return cderi, cderi_negative
 
-    def gen_uniq_kpts_groups(self, j_only, h5swap):
+    def gen_uniq_kpts_groups(self, j_only, h5swap, kk_idx=None):
         '''Group (kpti,kptj) pairs
         '''
         cpu1 = (logger.process_clock(), logger.perf_counter())
         log = logger.new_logger(self)
         cell = self.cell
         kpts = self.kpts
         nkpts = len(kpts)
         if j_only or nkpts == 1:
             uniq_kpts = np.zeros((1,3))
             j2c = self.get_2c2e(uniq_kpts)[0]
             cpu1 = log.timer('int2c2e', *cpu1)
             cd_j2c = self.decompose_j2c(j2c)
             j2c = None
-            ki = np.arange(nkpts)
-            kpt_ii_idx = ki * nkpts + ki
+            if kk_idx is None:
+                ki = np.arange(nkpts, dtype=np.int32)
+                kpt_ii_idx = ki * nkpts + ki
+            else:
+                kpt_ii_idx = np.asarray(kk_idx, dtype=np.int32)
             yield uniq_kpts[0], kpt_ii_idx, cd_j2c
 
         else:
-            uniq_kpts, uniq_index, uniq_inverse = unique_with_wrap_around(
-                cell, (kpts[None,:,:] - kpts[:,None,:]).reshape(-1, 3))
-            scaled_uniq_kpts = cell.get_scaled_kpts(uniq_kpts).round(5)
-            log.debug('Num uniq kpts %d', len(uniq_kpts))
-            log.debug2('scaled unique kpts %s', scaled_uniq_kpts)
-
-            kpts_idx_pairs = group_by_conj_pairs(cell, uniq_kpts)[0]
-            j2c_uniq_kpts = uniq_kpts[[k for k, _ in kpts_idx_pairs]]
+            enable_t_rev_sym = kk_idx is None
+            kpt_ij_iters = list(kk_adapted_iter(cell, kpts, kk_idx, enable_t_rev_sym))
+            j2c_uniq_kpts = np.asarray([s[0] for s in kpt_ij_iters])
             for k, j2c in enumerate(self.get_2c2e(j2c_uniq_kpts)):
                 h5swap[f'j2c/{k}'] = j2c
                 j2c = None
             cpu1 = log.timer('int2c2e', *cpu1)
 
-            for j2c_idx, (k, k_conj) in enumerate(kpts_idx_pairs):
+            for j2c_idx, (kpt, ki_idx, kj_idx, self_conj) \
+                    in enumerate(kpt_ij_iters):
                 # Find ki's and kj's that satisfy k_aux = kj - ki
-                log.debug1('Cholesky decomposition for j2c at kpt %s %s',
-                           k, scaled_uniq_kpts[k])
+                log.debug1('Cholesky decomposition for j2c %d', j2c_idx)
                 j2c = h5swap[f'j2c/{j2c_idx}']
-                if k == k_conj:
+                if self_conj:
                     # DF metric for self-conjugated k-point should be real
                     j2c = np.asarray(j2c).real
                 cd_j2c = self.decompose_j2c(j2c)
                 j2c = None
-                kpt_ij_idx = np.where(uniq_inverse == k)[0]
-                yield uniq_kpts[k], kpt_ij_idx, cd_j2c
 
-                if k_conj is None or k == k_conj:
+                kpt_ij_idx = ki_idx * nkpts + kj_idx
+                yield kpt, kpt_ij_idx, cd_j2c
+
+                if self_conj or not enable_t_rev_sym:
                     continue
 
                 # Swap ki, kj for the conjugated case
-                log.debug1('Cholesky decomposition for the conjugated kpt %s %s',
-                           k_conj, scaled_uniq_kpts[k_conj])
-                kpt_ji_idx = np.where(uniq_inverse == k_conj)[0]
+                kpt_ji_idx = kj_idx * nkpts + ki_idx
                 # If self.mesh is not enough to converge compensated charge or
                 # SR-coulG, the conj symmetry between j2c[k] and j2c[k_conj]
                 # (j2c[k] == conj(j2c[k_conj]) may not be strictly held.
                 # Decomposing j2c[k] and j2c[k_conj] may lead to different
                 # dimension in cderi tensor. Certain df_ao2mo requires
                 # contraction for cderi of k and cderi of k_conj. By using the
                 # conj(j2c[k]) and -uniq_kpts[k] (instead of j2c[k_conj] and
                 # uniq_kpts[k_conj]), conj-symmetry in j2c is imposed.
-                yield -uniq_kpts[k], kpt_ji_idx, _conj_j2c(cd_j2c)
+                yield -kpt, kpt_ji_idx, _conj_j2c(cd_j2c)
 
     def make_j3c(self, cderi_file, intor='int3c2e', aosym='s2', comp=None,
-                 j_only=False, dataname='j3c', shls_slice=None):
+                 j_only=False, dataname='j3c', shls_slice=None, kptij_lst=None):
         if self.rs_cell is None:
             self.build()
         log = logger.new_logger(self)
         cpu0 = logger.process_clock(), logger.perf_counter()
 
         cell = self.cell
         kpts = self.kpts
@@ -953,32 +902,44 @@
         nao = cell.nao
         naux = self.auxcell.nao
         if shls_slice is None:
             ish0, ish1 = 0, cell.nbas
         else:
             ish0, ish1 = shls_slice[:2]
 
+        if kptij_lst is not None:
+            if aosym == 's2':
+                warnings.warn('rsdf_builder does not support aosym="s2" for '
+                              'custom kptij_lst')
+                aosym = 's1'
+            ki_idx = members_with_wrap_around(cell, kptij_lst[:,0], kpts)
+            kj_idx = members_with_wrap_around(cell, kptij_lst[:,1], kpts)
+            if ki_idx.size != len(kptij_lst) or kj_idx.size != len(kptij_lst):
+                msg = f'some k-points in kptij_lst are not found in {self}.kpts'
+                raise RuntimeError(msg)
+            kk_idx = ki_idx * nkpts + kj_idx
+        else:
+            kk_idx = None
+
         fswap = self.outcore_auxe2(cderi_file, intor, aosym, comp, j_only,
-                                   dataname, shls_slice)
+                                   'j3c', shls_slice, kk_idx=kk_idx)
         cpu1 = log.timer('pass1: real space int3c2e', *cpu0)
 
         feri = h5py.File(cderi_file, 'w')
         feri['kpts'] = kpts
         feri['aosym'] = aosym
 
         if aosym == 's2':
             nao_pair = nao*(nao+1)//2
         else:
             nao_pair = nao**2
 
         if self.has_long_range():
-            supmol_ft = _ExtendedMoleFT.from_cell(self.rs_cell, self.bvk_kmesh, verbose=log)
-            supmol_ft.exclude_dd_block = self.exclude_dd_block
-            supmol_ft = supmol_ft.strip_basis()
-            ft_kern = supmol_ft.gen_ft_kernel(aosym, return_complex=False, verbose=log)
+            ft_kern = self.supmol_ft.gen_ft_kernel(aosym, return_complex=False,
+                                                   verbose=log)
 
         Gv, Gvbase, kws = cell.get_Gv_weights(self.mesh)
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
         ngrids = Gv.shape[0]
 
         def make_cderi(kpt, kpt_ij_idx, j2c):
             log.debug1('make_cderi for %s', kpt)
@@ -995,15 +956,15 @@
             buflen = min(max(int(max_memory*.3e6/16/naux/(nkptj+1)), 1), nao_pair)
             sh_ranges = _guess_shell_ranges(cell, buflen, aosym, start=ish0, stop=ish1)
             buflen = max([x[2] for x in sh_ranges])
             # * 2 for the buffer used in preload
             max_memory -= buflen * naux * (nkptj+1) * 16e-6 * 2
 
             # +1 for a pqkbuf
-            Gblksize = max(16, int(max_memory*1e6/16/buflen/(nkptj+1)))
+            Gblksize = max(16, int(max_memory*1e6/16/buflen/(nkptj+1))//8*8)
             Gblksize = min(Gblksize, ngrids, 200000)
 
             load = self.gen_j3c_loader(fswap, kpt, kpt_ij_idx, aosym)
 
             cols = [sh_range[2] for sh_range in sh_ranges]
             locs = np.append(0, np.cumsum(cols))
             # buf for ft_aopair
@@ -1022,120 +983,332 @@
                         # shape of Gpq (nkpts, nGv, ni, nj)
                         Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt,
                                       kptjs, shls_slice, out=buf)
                         self.add_ft_j3c(j3c, Gpq, Gaux, p0, p1)
                         Gpq = None
 
                 j3cR, j3cI = j3c
-                for k, kk_idx in enumerate(kpt_ij_idx):
+                for k, idx in enumerate(kpt_ij_idx):
                     cderi, cderi_negative = self.solve_cderi(j2c, j3cR[k], j3cI[k])
-                    feri[f'{dataname}/{kk_idx}/{istep}'] = cderi
+                    feri[f'{dataname}/{idx}/{istep}'] = cderi
                     if cderi_negative is not None:
                         # for low-dimension systems
-                        feri[f'{dataname}-/{kk_idx}/{istep}'] = cderi_negative
+                        feri[f'{dataname}-/{idx}/{istep}'] = cderi_negative
                 j3cR = j3cI = j3c = cderi = None
 
-        for kpt, kpt_ij_idx, cd_j2c in self.gen_uniq_kpts_groups(j_only, fswap):
+        for kpt, kpt_ij_idx, cd_j2c \
+                in self.gen_uniq_kpts_groups(j_only, fswap, kk_idx=kk_idx):
             make_cderi(kpt, kpt_ij_idx, cd_j2c)
 
         feri.close()
         cpu1 = log.timer('pass2: AFT int3c2e', *cpu1)
         return self
 
 
-def _strip_basis(supmol, omega, exp_aux_min=None, exclude_dd_block=False):
-    '''Remove redundant remote basis'''
-    rs_cell = supmol.rs_cell
-    bas_mask = supmol.bas_mask
-    compact_bas_mask = rs_cell.bas_type != ft_ao.SMOOTH_BASIS
-    exps = np.array([e.min() for e in rs_cell.bas_exps()])
-    exps_c = exps[compact_bas_mask]
-    if exps_c.size > 0:
-        exp_min = exps.min()
-        # compact_aux_idx = np.where(rs_auxcell.bas_type != ft_ao.SMOOTH_BASIS)[0]
-        # exp_aux_min = min([rs_auxcell.bas_exp(ib).min() for ib in compact_aux_idx])
-        # Is the exact exp_aux_min needed here?
-        if exp_aux_min is None:
-            exp_aux_min = exp_min
-        aij = exp_min + exps_c
-        eij = exp_min * exps_c / aij
-        theta = 1./(omega**-2 + 1./aij + 1./exp_aux_min)
-        LKs = supmol.Ls[:,None,:] + supmol.bvkmesh_Ls
-
-        # For basis on the boundary of a cell, boundary_penalty can adjust
-        # the LKs to get proper distance between basis
-        shifts = lib.cartesian_prod([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]])
-        a_off_bond = rs_cell.lattice_vectors() - 1.
-        boundary_penalty = np.einsum('te,ex->tx', shifts, a_off_bond)
-        rLK = np.linalg.norm(LKs + boundary_penalty[:,None,None], axis=-1).min(axis=0)
-        rLK[rLK < 1e-2] = 1e-2  # avoid singularity in upper_bounds
-        rr = rLK ** 2
-
-        # x = rcut * x_ratio for the distance between compact function
-        # and smooth function (compact function in the far end)
-        # fac*erfc(\sqrt(theta)|rcut - x|) for the asymptotic value of short-range eri
-        x_ratio = 1. / (exp_min/aij + exps_c/theta)
-        exp_fac = eij * x_ratio**2 + theta * (1 - exp_min/aij*x_ratio)**2
-        fac = ((8*np.pi*exp_min*exps_c/(aij*exp_aux_min)**2)**.75
-               / (theta * np.pi)**.5)
-        # upper_bounds are the maximum values int3c2e can reach for each
-        # basis in each repeated image. shape (bas_id, image_id, bvk_cell_id)
-        upper_bounds = np.einsum('i,lk,ilk->kil', fac, 2*np.pi/rr,
-                                 np.exp(-exp_fac[:,None,None]*rr))
-        # The cutoff here is most critical parameter that impacts the
-        # accuracy of DF integrals
-        bas_mask[:,compact_bas_mask] = upper_bounds > supmol.precision
-
-        # determine rcut boundary for diffused functions
-        exps_d = exps[~compact_bas_mask]
-        if exps_d.size > 0:
-            if exclude_dd_block:
-                # Just needs to estimate the upper bounds of (C,D|aux)
-                # otherwise, we need exp_min = exp_d_min for the (D,D|aux)
-                # upper bound estimation
-                exp_min = exps_c.min()
-            aij = exp_min + exps_d
-            eij = exp_min * exps_d / aij
-            theta = 1./(omega**-2 + 1./aij + 1./exp_aux_min)
-
-            x_ratio = 1. / (exps_d/aij + exp_min/theta)
-            exp_fac = eij * x_ratio**2 + theta * (1 - exps_d/aij*x_ratio)**2
-            fac = ((8*np.pi*exps_d*exp_min/(aij*exp_aux_min)**2)**.75
-                   / (theta * np.pi)**.5)
-            # upper_bounds are the maximum values int3c2e can reach for each
-            # basis in each repeated image. shape (bas_id, image_id, bvk_cell_id)
-            upper_bounds = np.einsum('i,lk,ilk->kil', fac, 2*np.pi/rr,
-                                     np.exp(-exp_fac[:,None,None]*rr))
-            bas_mask[:,~compact_bas_mask] = upper_bounds > supmol.precision
-
-        bas_mask[0,:,0] = True
-
-    nbas0 = supmol._bas.shape[0]
-    supmol._bas = np.asarray(supmol._bas[bas_mask.ravel()], dtype=np.int32, order='C')
-    nbas1 = supmol._bas.shape[0]
-    logger.debug1(supmol, 'strip_basis %d to %d ', nbas0, nbas1)
-    supmol.sh_loc = supmol.bas_mask_to_sh_loc(rs_cell, bas_mask)
-    supmol.bas_mask = bas_mask
-    return supmol
-
-class _ExtendedMoleSR(ft_ao._ExtendedMole):
-    '''Extended Mole for short-range ERIs without dd-blocks'''
-
-    @classmethod
-    def from_cell(cls, cell, kmesh, omega, rcut=None, verbose=None):
-        supmol = super(_ExtendedMoleSR, cls).from_cell(cell, kmesh, rcut, verbose)
-        supmol.omega = -omega
-        return supmol
+def get_nuc(nuc_builder):
+    '''Get the periodic nuc-el AO matrix, with G=0 removed.
+    '''
+    t0 = (logger.process_clock(), logger.perf_counter())
+    nuc = nuc_builder.get_pp_loc_part1(with_pseudo=False)
+    logger.timer(nuc_builder, 'get_nuc', *t0)
+    return nuc
+
+def get_pp(nuc_builder):
+    '''get the periodic pseudotential nuc-el ao matrix, with g=0 removed.
+
+    kwargs:
+        mesh: custom mesh grids. by default mesh is determined by the
+        function _guess_eta from module pbc.df.gdf_builder.
+    '''
+    t0 = (logger.process_clock(), logger.perf_counter())
+    cell = nuc_builder.cell
+    vpp = nuc_builder.get_pp_loc_part1()
+    t1 = logger.timer_debug1(nuc_builder, 'get_pp_loc_part1', *t0)
+    pp2builder = aft._IntPPBuilder(cell, nuc_builder.kpts)
+    vpp += pp2builder.get_pp_loc_part2()
+    t1 = logger.timer_debug1(nuc_builder, 'get_pp_loc_part2', *t1)
+    vpp += pseudo.pp_int.get_pp_nl(cell, nuc_builder.kpts)
+    t1 = logger.timer_debug1(nuc_builder, 'get_pp_nl', *t1)
+    logger.timer(nuc_builder, 'get_pp', *t0)
+    return vpp
+
+def _int_dd_block(dfbuilder, fakenuc, intor='int3c2e', comp=None):
+    '''
+    The block of smooth AO basis in i and j of (ij|L) with full Coulomb kernel
+    '''
+    if intor not in ('int3c2e', 'int3c2e_sph', 'int3c2e_cart'):
+        raise NotImplementedError
+
+    t0 = (logger.process_clock(), logger.perf_counter())
+    cell = dfbuilder.cell
+    cell_d = dfbuilder.rs_cell.smooth_basis_cell()
+    nao = cell_d.nao
+    kpts = dfbuilder.kpts
+    nkpts = kpts.shape[0]
+    if nao == 0 or fakenuc.natm == 0:
+        if is_zero(kpts):
+            return np.zeros((nao,nao,1))
+        else:
+            return np.zeros((2,nkpts,nao,nao,1))
+
+    mesh = cell_d.mesh
+    Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
+    b = cell_d.reciprocal_vectors()
+    gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
+
+    kpt_allow = np.zeros(3)
+    charges = -cell.atom_charges()
+    #:rhoG = np.dot(charges, SI)
+    aoaux = ft_ao.ft_ao(fakenuc, Gv, None, b, gxyz, Gvbase)
+    rhoG = np.einsum('i,xi->x', charges, aoaux)
+    coulG = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv)
+    vG = rhoG * coulG
+    if (cell.dimension == 3 or
+        (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum')):
+        vG[0] -= charges.dot(np.pi/np.hstack(fakenuc.bas_exps()))
+
+    vR = pbctools.ifft(vG, mesh).real
+
+    coords = cell_d.get_uniform_grids(mesh)
+    if is_zero(kpts):
+        ao_ks = cell_d.pbc_eval_gto('GTOval', coords)
+        j3c = lib.dot(ao_ks.T * vR, ao_ks).reshape(nao,nao,1)
+
+    else:
+        ao_ks = cell_d.pbc_eval_gto('GTOval', coords, kpts=kpts)
+        j3cR = np.empty((nkpts, nao, nao))
+        j3cI = np.empty((nkpts, nao, nao))
+        for k in range(nkpts):
+            v = lib.dot(ao_ks[k].conj().T * vR, ao_ks[k])
+            j3cR[k] = v.real
+            j3cI[k] = v.imag
+        j3c = j3cR.reshape(nkpts,nao,nao,1), j3cI.reshape(nkpts,nao,nao,1)
+    t0 = logger.timer_debug1(dfbuilder, 'FFT smooth basis', *t0)
+    return j3c
+
+
+class _RSNucBuilder(_RSGDFBuilder):
+
+    exclude_dd_block = True
+    exclude_d_aux = False
+
+    def __init__(self, cell, kpts=np.zeros((1,3))):
+        self.mesh = None
+        self.omega = None
+        self.auxcell = self.rs_auxcell = None
+        Int3cBuilder.__init__(self, cell, self.auxcell, kpts)
 
-class _ExtendedMoleFT(ft_ao._ExtendedMole):
+    def build(self, omega=None):
+        cpu0 = logger.process_clock(), logger.perf_counter()
+        log = logger.new_logger(self)
+        cell = self.cell
+        fakenuc = aft._fake_nuc(cell, with_pseudo=True)
+        kpts = self.kpts
+        nkpts = len(kpts)
+
+        self.bvk_kmesh = kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
+        log.debug('kmesh for bvk-cell = %s', kmesh)
+
+        if cell.dimension == 0:
+            self.omega, self.mesh, self.ke_cutoff = _guess_omega(cell, kpts, self.mesh)
+        else:
+            if omega is None:
+                omega = 1./(1.+nkpts**(1./9))
+            ke_cutoff = estimate_ke_cutoff_for_omega(cell, omega)
+            self.mesh = cell.cutoff_to_mesh(ke_cutoff)
+            self.ke_cutoff = min(pbctools.mesh_to_cutoff(
+                cell.lattice_vectors(), self.mesh)[:cell.dimension])
+            self.omega = estimate_omega_for_ke_cutoff(cell, self.ke_cutoff)
+            if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+                self.mesh[2] = _estimate_meshz(cell)
+            elif cell.dimension < 2:
+                self.mesh[cell.dimension:] = cell.mesh[cell.dimension:]
+            self.mesh = cell.symmetrize_mesh(self.mesh)
+
+        self.dump_flags()
+
+        exp_min = np.hstack(cell.bas_exps()).min()
+        # For each basis i in (ij|, small integrals accumulated by the lattice
+        # sum for j are not negligible.
+        lattice_sum_factor = max((2*cell.rcut)**3/cell.vol * 1/exp_min, 1)
+        cutoff = cell.precision / lattice_sum_factor * .1
+        self.direct_scf_tol = cutoff / cell.atom_charges().max()
+        log.debug('Set _RSNucBuilder.direct_scf_tol to %g', cutoff)
+
+        self.rs_cell = rs_cell = ft_ao._RangeSeparatedCell.from_cell(
+            cell, self.ke_cutoff, RCUT_THRESHOLD, verbose=log)
+        rcut_sr = estimate_rcut(rs_cell, fakenuc, self.omega,
+                                rs_cell.precision, self.exclude_dd_block)
+        supmol = ft_ao.ExtendedMole.from_cell(rs_cell, kmesh, rcut_sr.max(), log)
+        supmol.omega = -self.omega
+        self.supmol = supmol.strip_basis(rcut_sr)
+        log.debug('sup-mol nbas = %d cGTO = %d pGTO = %d',
+                  supmol.nbas, supmol.nao, supmol.npgto_nr())
+
+        rcut = estimate_ft_rcut(rs_cell, cell.precision, self.exclude_dd_block)
+        supmol_ft = _ExtendedMoleFT.from_cell(rs_cell, kmesh, rcut.max(), log)
+        supmol_ft.exclude_dd_block = self.exclude_dd_block
+        self.supmol_ft = supmol_ft.strip_basis(rcut)
+        log.debug('sup-mol-ft nbas = %d cGTO = %d pGTO = %d',
+                  supmol_ft.nbas, supmol_ft.nao, supmol_ft.npgto_nr())
+        log.timer_debug1('initializing supmol', *cpu0)
+        return self
+
+    def _int_nuc_vloc(self, fakenuc, intor='int3c2e', aosym='s2', comp=None):
+        '''SR-Vnuc
+        '''
+        logger.debug2(self, 'Real space integrals %s for SR-Vnuc', intor)
+
+        cell = self.cell
+        kpts = self.kpts
+        nkpts = len(kpts)
+
+        int3c = self.gen_int3c_kernel(intor, aosym, comp=comp, j_only=True,
+                                      auxcell=fakenuc)
+        bufR, bufI = int3c()
+
+        charge = -cell.atom_charges()
+        if is_zero(kpts):
+            mat = np.einsum('k...z,z->k...', bufR, charge)
+        else:
+            mat = (np.einsum('k...z,z->k...', bufR, charge) +
+                   np.einsum('k...z,z->k...', bufI, charge) * 1j)
+
+        # G = 0 contributions to SR integrals
+        if (self.omega != 0 and
+            (intor in ('int3c2e', 'int3c2e_sph', 'int3c2e_cart')) and
+            (cell.dimension == 3 or
+             (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum'))):
+            logger.debug2(self, 'G=0 part for %s', intor)
+            nucbar = np.pi / self.omega**2 / cell.vol * charge.sum()
+            if self.exclude_dd_block:
+                rs_cell = self.rs_cell
+                ovlp = rs_cell.pbc_intor('int1e_ovlp', hermi=1, kpts=kpts)
+                smooth_ao_idx = rs_cell.get_ao_type() == ft_ao.SMOOTH_BASIS
+                for s in ovlp:
+                    s[smooth_ao_idx[:,None] & smooth_ao_idx] = 0
+                recontract_2d = rs_cell.recontract(dim=2)
+                ovlp = [recontract_2d(s) for s in ovlp]
+            else:
+                ovlp = cell.pbc_intor('int1e_ovlp', 1, lib.HERMITIAN, kpts)
+
+            for k in range(nkpts):
+                if aosym == 's1':
+                    mat[k] -= nucbar * ovlp[k].ravel()
+                else:
+                    mat[k] -= nucbar * lib.pack_tril(ovlp[k])
+        return mat
+
+    _int_dd_block = _int_dd_block
+
+    def get_pp_loc_part1(self, mesh=None, with_pseudo=True):
+        log = logger.Logger(self.stdout, self.verbose)
+        t0 = t1 = (logger.process_clock(), logger.perf_counter())
+        if self.rs_cell is None:
+            self.build()
+        cell = self.cell
+        kpts = self.kpts
+        nkpts = len(kpts)
+        nao = cell.nao_nr()
+        aosym = 's2'
+        nao_pair = nao * (nao+1) // 2
+        mesh = self.mesh
+
+        fakenuc = aft._fake_nuc(cell, with_pseudo=with_pseudo)
+        vj = self._int_nuc_vloc(fakenuc)
+        if cell.dimension == 0:
+            return lib.unpack_tril(vj)
+
+        if self.exclude_dd_block:
+            cell_d = self.rs_cell.smooth_basis_cell()
+            if cell_d.nao > 0 and fakenuc.natm > 0:
+                merge_dd = self.rs_cell.merge_diffused_block(aosym)
+                if is_zero(kpts):
+                    vj_dd = self._int_dd_block(fakenuc)
+                    merge_dd(vj, vj_dd)
+                else:
+                    vj_ddR, vj_ddI = self._int_dd_block(fakenuc)
+                    for k in range(nkpts):
+                        outR = vj[k].real.copy()
+                        outI = vj[k].imag.copy()
+                        merge_dd(outR, vj_ddR[k])
+                        merge_dd(outI, vj_ddI[k])
+                        vj[k] = outR + outI * 1j
+        t0 = t1 = log.timer_debug1('vnuc pass1: analytic int', *t0)
+
+        kpt_allow = np.zeros(3)
+        Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
+        gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
+        b = cell.reciprocal_vectors()
+        aoaux = ft_ao.ft_ao(fakenuc, Gv, None, b, gxyz, Gvbase)
+        charges = -cell.atom_charges()
+
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            coulG = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv)
+            with lib.temporary_env(cell, dimension=3):
+                coulG_SR = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv,
+                                              omega=-self.omega)
+            coulG_LR = coulG - coulG_SR
+        else:
+            coulG_LR = pbctools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv,
+                                          omega=self.omega)
+        wcoulG = coulG_LR * kws
+        vG = np.einsum('i,xi,x->x', charges, aoaux, wcoulG)
+
+        # contributions due to pseudo.pp_int.get_gth_vlocG_part1
+        if (cell.dimension == 3 or
+            (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum')):
+            G0_idx = 0
+            exps = np.hstack(fakenuc.bas_exps())
+            vG[G0_idx] -= charges.dot(np.pi/exps) * kws
+
+        ft_kern = self.supmol_ft.gen_ft_kernel(aosym, return_complex=False,
+                                               kpts=kpts, verbose=log)
+        ngrids = Gv.shape[0]
+        max_memory = max(2000, self.max_memory-lib.current_memory()[0])
+        Gblksize = max(16, int(max_memory*.8e6/16/(nao_pair*nkpts))//8*8)
+        Gblksize = min(Gblksize, ngrids, 200000)
+        vGR = vG.real
+        vGI = vG.imag
+        log.debug1('max_memory = %s  Gblksize = %s  ngrids = %s',
+                   max_memory, Gblksize, ngrids)
+
+        buf = np.empty((2, nkpts, Gblksize, nao_pair))
+        for p0, p1 in lib.prange(0, ngrids, Gblksize):
+            # shape of Gpq (nkpts, nGv, nao_pair)
+            Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, out=buf)
+            for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
+                # rho_ij(G) nuc(-G) / G^2
+                # = [Re(rho_ij(G)) + Im(rho_ij(G))*1j] [Re(nuc(G)) - Im(nuc(G))*1j] / G^2
+                vR = np.einsum('k,kx->x', vGR[p0:p1], GpqR)
+                vR+= np.einsum('k,kx->x', vGI[p0:p1], GpqI)
+                vj[k] += vR
+                if not is_zero(kpts[k]):
+                    vI = np.einsum('k,kx->x', vGR[p0:p1], GpqI)
+                    vI-= np.einsum('k,kx->x', vGI[p0:p1], GpqR)
+                    vj[k].imag += vI
+            t1 = log.timer_debug1('contracting Vnuc [%s:%s]'%(p0, p1), *t1)
+        log.timer_debug1('contracting Vnuc', *t0)
+
+        vj_kpts = []
+        for k, kpt in enumerate(kpts):
+            if is_zero(kpt):
+                vj_kpts.append(lib.unpack_tril(vj[k].real))
+            else:
+                vj_kpts.append(lib.unpack_tril(vj[k]))
+        return np.asarray(vj_kpts)
+
+    get_pp = get_pp
+    get_nuc = get_nuc
+
+
+class _ExtendedMoleFT(ft_ao.ExtendedMole):
     '''Extended Mole for Fourier Transform without dd-blocks'''
 
-    def __init__(self):
-        self.exclude_dd_block = True
-        ft_ao._ExtendedMole.__init__(self)
+    exclude_dd_block = False
 
     def get_ovlp_mask(self, cutoff=None):
         '''integral screening mask for basis product between cell and supmol.
         The diffused-diffused basis block are removed
         '''
         ovlp_mask = super().get_ovlp_mask(cutoff)
         if self.exclude_dd_block:
@@ -1147,51 +1320,51 @@
 
 # ngrids ~= 8*naux = prod(mesh)
 def _guess_omega(cell, kpts, mesh=None):
     if cell.dimension == 0:
         if mesh is None:
             mesh = cell.mesh
         ke_cutoff = pbctools.mesh_to_cutoff(cell.lattice_vectors(), mesh).min()
-        omega = aft.estimate_omega_for_ke_cutoff(cell, ke_cutoff, cell.precision)
-        return omega, mesh, ke_cutoff
+        return 0, mesh, ke_cutoff
 
-    a = cell.lattice_vectors()
     # requiring Coulomb potential < cell.precision at rcut is often not
     # enough to truncate the interaction.
-    omega_min = aft.estimate_omega(cell, cell.precision*1e-2)
-    ke_min = aft.estimate_ke_cutoff_for_omega(cell, omega_min, cell.precision)
-    mesh_min = _round_off_to_odd_mesh(pbctools.cutoff_to_mesh(a, ke_min))
+    # omega_min = estimate_omega_min(cell, cell.precision*1e-2)
+    omega_min = OMEGA_MIN
+    ke_min = estimate_ke_cutoff_for_omega(cell, omega_min, cell.precision)
+    a = cell.lattice_vectors()
 
     if mesh is None:
-        nao = cell.npgto_nr()
         nkpts = len(kpts)
-        # FIXME: balance the two workloads
-        # int3c2e integrals ~ nao*(cell.rcut**3/cell.vol*nao)**2
-        # ft_ao integrals ~ nkpts*nao*(cell.rcut**3/cell.vol*nao)*mesh**3
-        nimgs = (8 * cell.rcut**3 / cell.vol) ** (cell.dimension / 3)
-        mesh = (nimgs**2*nao / (nkpts**.5*nimgs**.5 * 1e2 + nkpts**2*nao))**(1./3) + 2
-        mesh = int(min((1e8/nao)**(1./3), mesh))
-        mesh = np.max([mesh_min, [mesh] * 3], axis=0)
-        ke_cutoff = pbctools.mesh_to_cutoff(a, mesh-1)
-        ke_cutoff = ke_cutoff[:cell.dimension].min()
-        if cell.dimension < 2 or cell.low_dim_ft_type == 'inf_vacuum':
-            mesh[cell.dimension:] = cell.mesh[cell.dimension:]
-        elif cell.dimension == 2:
-            mesh = pbctools.cutoff_to_mesh(a, ke_cutoff)
-        mesh = _round_off_to_odd_mesh(mesh)
+        ke_cutoff = 20. * nkpts**(-1./3)
+        ke_cutoff = max(ke_cutoff, ke_min)
+        mesh = cell.cutoff_to_mesh(ke_cutoff)
     else:
+        mesh = np.asarray(mesh)
+        mesh_min = cell.cutoff_to_mesh(ke_min)
         if np.any(mesh[:cell.dimension] < mesh_min[:cell.dimension]):
             logger.warn(cell, 'mesh %s is not enough to converge to the required '
                         'integral precision %g.\nRecommended mesh is %s.',
                         mesh, cell.precision, mesh_min)
-        ke_cutoff = pbctools.mesh_to_cutoff(a, np.asarray(mesh)-1)
-        ke_cutoff = ke_cutoff[:cell.dimension].min()
-    omega = aft.estimate_omega_for_ke_cutoff(cell, ke_cutoff, cell.precision)
+    ke_cutoff = min(pbctools.mesh_to_cutoff(a, mesh)[:cell.dimension])
+    omega = estimate_omega_for_ke_cutoff(cell, ke_cutoff, cell.precision)
     return omega, mesh, ke_cutoff
 
+def _estimate_meshz(cell, precision=None):
+    '''For 2D with truncated Coulomb, estimate the necessary mesh size
+    that can converge the Gaussian function to the required precision.
+    '''
+    if precision is None:
+        precision = cell.precision
+    e = np.hstack(cell.bas_exps()).max()
+    ke_cut = -np.log(precision) * 2 * e
+    meshz = cell.cutoff_to_mesh(ke_cut)[2]
+    logger.debug2(cell, '_estimate_meshz %d', meshz)
+    return max(meshz, cell.mesh[2])
+
 def _eval_gto(cell, mesh, kpts):
     coords = cell.get_uniform_grids(mesh)
     nkpts = len(kpts)
     nao = cell.nao
     ngrids = len(coords)
 
     ao_ks = cell.pbc_eval_gto('GTOval', coords, kpts=kpts)
@@ -1218,8 +1391,212 @@
     # Round off mesh to the nearest odd numbers.
     # Odd number of grids is preferred because even number of grids may break
     # the conjugation symmetry between the k-points k and -k.
     # When building the DF integral tensor in function _make_j3c, the symmetry
     # between k and -k is used (function conj_j2c) to overcome the error
     # caused by auxiliary basis linear dependency. More detalis of this
     # problem can be found in function _make_j3c.
-    return (np.asarray(mesh) // 2) * 2 + 1
+    if isinstance(mesh, (int, np.integer)):
+        return (mesh // 2) * 2 + 1
+    else:
+        return (np.asarray(mesh) // 2) * 2 + 1
+
+def estimate_rcut(rs_cell, rs_auxcell, omega, precision=None,
+                  exclude_dd_block=False, exclude_d_aux=False):
+    '''Estimate rcut for 3c2e SR-integrals'''
+    if precision is None:
+        precision = rs_cell.precision
+
+    if rs_cell.nbas == 0 or rs_auxcell.nbas == 0:
+        return np.zeros(1)
+
+    if omega == 0:
+        # No SR integrals in int3c2e if omega=0
+        assert rs_cell.dimension == 0
+        return np.zeros(1)
+
+    cell_exps, cs = pbcgto.cell._extract_pgto_params(rs_cell, 'min')
+    ls = rs_cell._bas[:,gto.ANG_OF]
+
+    aux_exps = np.array([e.min() for e in rs_auxcell.bas_exps()])
+    aux_min_idx = aux_exps.argmin()
+    if exclude_d_aux:
+        compact_aux_idx = np.where(rs_auxcell.bas_type != ft_ao.SMOOTH_BASIS)[0]
+        if compact_aux_idx.size > 0:
+            aux_min_idx = compact_aux_idx[aux_exps[compact_aux_idx].argmin()]
+    ak = aux_exps[aux_min_idx]
+    lk = rs_auxcell._bas[aux_min_idx,gto.ANG_OF]
+
+    ai_idx = cell_exps.argmin()
+    ai = cell_exps[ai_idx]
+    aj = cell_exps
+    li = rs_cell._bas[ai_idx,gto.ANG_OF]
+    lj = ls
+
+    ci = cs[ai_idx]
+    cj = cs
+    # Note ck normalizes the auxiliary basis \int \chi_k dr to 1
+    ck = 1./(4*np.pi) / gto.gaussian_int(lk+2, ak)
+
+    aij = ai + aj
+    lij = li + lj
+    l3 = lij + lk
+    theta = 1./(omega**-2 + 1./aij + 1./ak)
+    norm_ang = ((2*li+1)*(2*lj+1))**.5/(4*np.pi)
+    c1 = ci * cj * ck * norm_ang
+    sfac = aij*aj/(aij*aj + ai*theta)
+    fl = 2
+    fac = 2**li*np.pi**2.5*c1 * theta**(l3-.5)
+    fac *= 2*np.pi/rs_cell.vol/theta
+    fac /= aij**(li+1.5) * ak**(lk+1.5) * aj**lj
+    fac *= fl / precision
+
+    r0 = rs_cell.rcut  # initial guess
+    r0 = (np.log(fac * r0 * (sfac*r0)**(l3-1) + 1.) / (sfac*theta))**.5
+    r0 = (np.log(fac * r0 * (sfac*r0)**(l3-1) + 1.) / (sfac*theta))**.5
+    rcut = r0
+
+    if exclude_dd_block:
+        compact_mask = rs_cell.bas_type != ft_ao.SMOOTH_BASIS
+        compact_idx = np.where(compact_mask)[0]
+        if 0 < compact_idx.size < rs_cell.nbas:
+            compact_idx = compact_idx[cell_exps[compact_idx].argmin()]
+            smooth_mask = ~compact_mask
+            ai = cell_exps[compact_idx]
+            li = ls[compact_idx]
+            ci = cs[compact_idx]
+            aj = cell_exps[smooth_mask]
+            lj = ls[smooth_mask]
+            cj = cs[smooth_mask]
+
+            aij = ai + aj
+            lij = li + lj
+            l3 = lij + lk
+            theta = 1./(omega**-2 + 1./aij + 1./ak)
+            norm_ang = ((2*li+1)*(2*lj+1))**.5/(4*np.pi)
+            c1 = ci * cj * ck * norm_ang
+            sfac = aij*aj/(aij*aj + ai*theta)
+            fl = 2
+            fac = 2**li*np.pi**2.5*c1 * theta**(l3-.5)
+            fac *= 2*np.pi/rs_cell.vol/theta
+            fac /= aij**(li+1.5) * ak**(lk+1.5) * aj**lj
+            fac *= fl / precision
+
+            r0 = rs_cell.rcut
+            r0 = (np.log(fac * r0 * (sfac*r0)**(l3-1) + 1.) / (sfac*theta))**.5
+            r0 = (np.log(fac * r0 * (sfac*r0)**(l3-1) + 1.) / (sfac*theta))**.5
+            rcut[smooth_mask] = r0
+    return rcut
+
+def estimate_ft_rcut(rs_cell, precision=None, exclude_dd_block=False):
+    '''Remove less important basis based on Schwarz inequality
+    Q_ij ~ S_ij * (sqrt(2aij/pi) * aij**(lij*2) * (4*lij-1)!!)**.5
+    '''
+    if precision is None:
+        precision = rs_cell.precision
+
+    # consider only the most diffused component of a basis
+    exps, cs = pbcgto.cell._extract_pgto_params(rs_cell, 'min')
+    ls = rs_cell._bas[:,gto.ANG_OF]
+    ai_idx = exps.argmin()
+    ai = exps[ai_idx]
+    li = ls[ai_idx]
+    ci = cs[ai_idx]
+    aj = exps
+    lj = ls
+    cj = cs
+    aij = ai + aj
+    lij = li + lj
+    norm_ang = ((2*li+1)*(2*lj+1))**.5/(4*np.pi)
+    c1 = ci * cj * norm_ang
+    theta = ai * aj / aij
+    aij1 = aij**-.5
+    fac = np.pi**1.5*c1 * aij1**(lij+3) * (2*aij/np.pi)**.25 * aij**lij
+    fac /= precision
+
+    r0 = rs_cell.rcut
+    dri = aj*aij1 * r0 + 1.
+    drj = ai*aij1 * r0 + 1.
+    fl = 2*np.pi*r0/theta + 1.
+    r0 = (np.log(fac * dri**li * drj**lj * fl + 1.) / theta)**.5
+
+    dri = aj*aij1 * r0 + 1.
+    drj = ai*aij1 * r0 + 1.
+    fl = 2*np.pi/rs_cell.vol*r0/theta
+    r0 = (np.log(fac * dri**li * drj**lj * fl + 1.) / theta)**.5
+    rcut = r0
+
+    if exclude_dd_block:
+        compact_mask = rs_cell.bas_type != ft_ao.SMOOTH_BASIS
+        compact_idx = np.where(compact_mask)[0]
+        if 0 < compact_idx.size < rs_cell.nbas:
+            compact_idx = compact_idx[exps[compact_idx].argmin()]
+            smooth_mask = ~compact_mask
+            ai = exps[compact_idx]
+            li = ls[compact_idx]
+            ci = cs[compact_idx]
+            aj = exps[smooth_mask]
+            lj = ls[smooth_mask]
+            cj = cs[smooth_mask]
+            aij = ai + aj
+            lij = li + lj
+            norm_ang = ((2*li+1)*(2*lj+1))**.5/(4*np.pi)
+            c1 = ci * cj * norm_ang
+            theta = ai * aj / aij
+            aij1 = aij**-.5
+            fac = np.pi**1.5*c1 * aij1**(lij+3) * (2*aij/np.pi)**.25 * aij**lij
+            fac /= precision
+
+            r0 = rs_cell.rcut
+            dri = aj*aij1 * r0 + 1.
+            drj = ai*aij1 * r0 + 1.
+            fl = 2*np.pi/rs_cell.vol*r0/theta
+            r0 = (np.log(fac * dri**li * drj**lj * fl + 1.) / theta)**.5
+
+            dri = aj*aij1 * r0 + 1.
+            drj = ai*aij1 * r0 + 1.
+            fl = 2*np.pi*r0/theta + 1.
+            r0 = (np.log(fac * dri**li * drj**lj * fl + 1.) / theta)**.5
+            rcut[smooth_mask] = r0
+    return rcut
+
+def estimate_omega_min(cell, precision=None):
+    '''Given cell.rcut the boundary of repeated images of the cell, estimates
+    the minimal omega for the attenuated Coulomb interactions, requiring that at
+    boundary the Coulomb potential of a point charge < cutoff
+    '''
+    if precision is None:
+        precision = cell.precision
+    # erfc(z) = 2/\sqrt(pi) int_z^infty exp(-t^2) dt < exp(-z^2)/(z\sqrt(pi))
+    # erfc(omega*rcut)/rcut < cutoff
+    # ~ exp(-(omega*rcut)**2) / (omega*rcut**2*pi**.5) < cutoff
+    rcut = cell.rcut
+    omega = OMEGA_MIN
+    omega = max((-np.log(precision * rcut**2 * omega))**.5 / rcut, OMEGA_MIN)
+    return omega
+
+def estimate_ke_cutoff_for_omega(cell, omega, precision=None):
+    '''Energy cutoff for AFTDF to converge attenuated Coulomb in moment space
+    '''
+    if precision is None:
+        precision = cell.precision
+    exps, cs = pbcgto.cell._extract_pgto_params(cell, 'max')
+    ls = cell._bas[:,gto.ANG_OF]
+    cs = gto.gto_norm(ls, exps)
+    Ecut = aft._estimate_ke_cutoff(exps, ls, cs, precision, omega)
+    return Ecut.max()
+
+def estimate_omega_for_ke_cutoff(cell, ke_cutoff, precision=None):
+    '''The minimal omega in attenuated Coulombl given energy cutoff
+    '''
+    if precision is None:
+        precision = cell.precision
+    # esitimation based on \int dk 4pi/k^2 exp(-k^2/4omega) sometimes is not
+    # enough to converge the 2-electron integrals. A penalty term here is to
+    # reduce the error in integrals
+    precision *= 1e-2
+    # Consider l>0 basis here to increate Ecut for slightly better accuracy
+    lmax = np.max(cell._bas[:,gto.ANG_OF])
+    kmax = (ke_cutoff*2)**.5
+    log_rest = np.log(precision / (16*np.pi**2 * kmax**lmax))
+    omega = (-.5 * ke_cutoff / log_rest)**.5
+    return omega
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/rsdf_helper.py` & `pyscf-2.3.0/pyscf/pbc/df/rsdf_helper.py`

 * *Files 1% similar despite different names*

```diff
@@ -22,24 +22,38 @@
 import numpy as np
 from scipy.special import gamma, gammaincc, comb
 
 from pyscf import lib
 from pyscf.lib import logger
 from pyscf.lib.parameters import BOHR
 from pyscf import gto as mol_gto
-from pyscf.pbc.df.gdf_builder import _round_off_to_odd_mesh
+from pyscf.pbc.df.rsdf_builder import _round_off_to_odd_mesh
 from pyscf.pbc.df.incore import libpbc, make_auxcell
 from pyscf.pbc.lib.kpts_helper import is_zero, gamma_point, unique, KPT_DIFF_TOL
 from pyscf.pbc.tools import pbc as pbctools
 from pyscf.scf import _vhf
 from pyscf.pbc.tools import k2gamma
 
 
 """ General helper functions
 """
+class MoleNoBasSort(mol_gto.mole.Mole):
+    def build(self, **kwargs):
+        mol_gto.mole.Mole.build(self, **kwargs)
+
+        # sort self._bas
+        _bas = []
+        for iatm in range(self.natm):
+            atm = self.atom_symbol(iatm)
+            basin = self._basis[atm]
+            bas_ls = [b[0] for b in basin]
+            ls_uniq, ls_inv = np.unique(bas_ls, return_inverse=True)
+            order = np.argsort(np.concatenate([np.where(ls_inv==l)[0] for l in ls_uniq]))
+            _bas.append( self._bas[np.where(self._bas[:,0] == iatm)[0][order]] )
+        self._bas = np.vstack(_bas).astype(np.int32)
 def _remove_exp_basis_(bold, amin, amax):
     bnew = []
     for b in bold:
         l = b[0]
         ecs = np.array(b[1:])
         if ecs.ndim == 1:
             ecs = np.array([ecs])
@@ -381,31 +395,31 @@
                 cs = ecs[:,jmax+1]
                 bas_new = [bas[0]] + [(e,c) for e,c in zip(es,cs)]
             bas_lst_new.append(bas_new)
         return bas_lst_new
     if keep1ctr:
         bas_lst = get1ctr(bas_lst)
     if dijs_lst is None:
-        mol = mol_gto.Mole()
-        mol.build(False, False, atom="H 0 0 0", basis=bas_lst, spin=None)
+        mol = MoleNoBasSort()
+        mol.build(dump_input=False, parse_arg=False, atom="H 0 0 0", basis=bas_lst, spin=None)
         nbas = mol.nbas
         intor = "int2c2e"
         Qs = np.zeros(nbas)
         for k in range(nbas):
             shls_slice = (k,k+1,k,k+1)
             I = _fintor_sreri(mol, intor, shls_slice, omega, safe)
             Qs[k] = _get_norm( I )**0.5
     else:
         def compute1_(mol, dij, intor, shls_slice, omega, safe):
             mol._env[mol._atm[1,mol_gto.PTR_COORD]] = dij
             return _get_norm(
                         _fintor_sreri(mol, intor, shls_slice, omega, safe)
                     )**0.5
-        mol = mol_gto.Mole()
-        mol.build(False, False, atom="H 0 0 0; H 0 0 0", basis=bas_lst, spin=None)
+        mol = MoleNoBasSort()
+        mol.build(dump_input=False, parse_arg=False, atom="H 0 0 0", basis=bas_lst, spin=None)
         nbas = mol.nbas//2
         n2 = nbas*(nbas+1)//2
         if len(dijs_lst) != n2:
             raise RuntimeError("dijs_lst has wrong len (expecting %d; got %d)" % (n2, len(dijs_lst)))
         intor = "int2e"
         Qs = [None] * n2
         ij = 0
@@ -424,16 +438,16 @@
     between each unique shell pair to drop below "precision". The Schwartz
     Q is define:
         Q = 2-norm[ (ab|ab) ]^(1/2)
 
     Return:
         1d array of length nbas*(nbas+1)//2 with nbas=len(bas_lst).
     """
-    mol = mol_gto.Mole()
-    mol.build(False, False, atom="H 0 0 0; H 0 0 0", basis=bas_lst)
+    mol = MoleNoBasSort()
+    mol.build(dump_input=False, parse_arg=False, atom="H 0 0 0; H 0 0 0", basis=bas_lst)
     nbas = len(bas_lst)
     n2 = nbas*(nbas+1)//2
 
     es = np.array([mol.bas_exp(i).min() for i in range(nbas)])
     etas = 1/(1/es[:,None] + 1/es)
 
     intor = "int2e"
@@ -660,23 +674,23 @@
     where i and j shls are separated by d specified by "dijs_lst".
     """
 
     if isinstance(bas_lst_or_mol, mol_gto.mole.Mole):
         mol = bas_lst_or_mol
     else:
         bas_lst = bas_lst_or_mol
-        mol = mol_gto.Mole()
-        mol.build(False, False, atom="H 0 0 0", basis=bas_lst, spin=None)
+        mol = MoleNoBasSort()
+        mol.build(dump_input=False, parse_arg=False, atom="H 0 0 0", basis=bas_lst, spin=None)
 
     if isinstance(auxbas_lst_or_auxmol, mol_gto.mole.Mole):
         auxmol = auxbas_lst_or_auxmol
     else:
         auxbas_lst = auxbas_lst_or_auxmol
-        auxmol = mol_gto.Mole()
-        auxmol.build(False, False, atom="H 0 0 0", basis=auxbas_lst, spin=None)
+        auxmol = MoleNoBasSort()
+        auxmol.build(dump_input=False, parse_arg=False, atom="H 0 0 0", basis=auxbas_lst, spin=None)
 
     nbas = mol.nbas
 
     ij = 0
     Rcuts = []
     for i in range(nbas):
         for j in range(i+1):
```

### Comparing `pyscf-2.2.1/pyscf/pbc/df/rsdf_jk.py` & `pyscf-2.3.0/pyscf/pbc/df/rsdf_jk.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/__init__.py` & `pyscf-2.3.0/pyscf/pbc/dft/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/cdft.py` & `pyscf-2.3.0/pyscf/pbc/dft/cdft.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/gen_grid.py` & `pyscf-2.3.0/pyscf/pbc/dft/gen_grid.py`

 * *Files 5% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 # Author: Qiming Sun <osirpt.sun@gmail.com>
 #
 
 import ctypes
 import numpy as np
 from pyscf import lib
 from pyscf.lib import logger
+from pyscf.pbc.gto import eval_gto as pbc_eval_gto
 from pyscf import dft
 from pyscf.pbc.gto.cell import get_uniform_grids, gen_uniform_grids
 from pyscf.dft.gen_grid import (sg1_prune, nwchem_prune, treutler_prune,
                                 stratmann, original_becke, gen_atomic_grids,
                                 BLKSIZE, NBINS, CUTOFF)
 
 libpbc = lib.load_library('libpbc')
@@ -40,21 +41,17 @@
     natm = ctypes.c_int(cell._atm.shape[0])
     nbas = ctypes.c_int(cell.nbas)
     ngrids = len(coords)
     if shls_slice is None:
         shls_slice = (0, cell.nbas)
     assert (shls_slice == (0, cell.nbas))
 
-    # For atoms near the boundary of the cell, it is necessary (even in low-
-    # dimensional systems) to include lattice translations in all 3 dimensions.
-    if cell.dimension < 2 or cell.low_dim_ft_type == 'inf_vacuum':
-        Ls = cell.get_lattice_Ls(dimension=cell.dimension)
-    else:
-        Ls = cell.get_lattice_Ls(dimension=3)
-    Ls = Ls[np.argsort(lib.norm(Ls, axis=1))]
+    rcut = pbc_eval_gto._estimate_rcut(cell)
+    Ls = pbc_eval_gto.get_lattice_Ls(cell, rcut=rcut.max())
+    Ls = Ls[np.argsort(lib.norm(Ls, axis=1), kind='stable')]
 
     non0tab = np.empty(((ngrids+BLKSIZE-1)//BLKSIZE, cell.nbas), dtype=np.uint8)
     libpbc.PBCnr_ao_screen(non0tab.ctypes.data_as(ctypes.c_void_p),
                            coords.ctypes.data_as(ctypes.c_void_p),
                            ctypes.c_int(ngrids),
                            Ls.ctypes.data_as(ctypes.c_void_p),
                            ctypes.c_int(len(Ls)),
@@ -154,15 +151,16 @@
 # When low_dim_ft_type is set, pbc_eval_gto treats the 2D system as a 3D system.
 # To get the correct particle number in numint module, the atomic grids needs to
 # be consistent with the treatment in pbc_eval_gto (see issue 164).
     if cell.dimension < 2 or cell.low_dim_ft_type == 'inf_vacuum':
         dimension = cell.dimension
     else:
         dimension = 3
-    Ls = cell.get_lattice_Ls(dimension=dimension)
+    rcut = pbc_eval_gto._estimate_rcut(cell)
+    Ls = pbc_eval_gto.get_lattice_Ls(cell, rcut=rcut.max())
 
     atm_coords = Ls.reshape(-1,1,3) + cell.atom_coords()
     atom_grids_tab = gen_atomic_grids(cell, atom_grid, radi_method, level, prune)
     coords_all = []
     weights_all = []
     b = cell.reciprocal_vectors(norm_to=1)
     supatm_idx = []
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/gks.py` & `pyscf-2.3.0/pyscf/pbc/dft/gks.py`

 * *Files 3% similar despite different names*

```diff
@@ -39,16 +39,21 @@
              kpt=None, kpts_band=None):
     '''Coulomb + XC functional for GKS.'''
     if cell is None: cell = ks.cell
     if dm is None: dm = ks.make_rdm1()
     if kpt is None: kpt = ks.kpt
     t0 = (logger.process_clock(), logger.perf_counter())
 
+    ni = ks._numint
+    if ks.nlc or ni.libxc.is_nlc(ks.xc):
+        raise NotImplementedError(f'NLC functional {ks.xc} + {ks.nlc}')
+
+    hybrid = ni.libxc.is_hybrid_xc(ks.xc)
+
     # TODO GKS with hybrid functional
-    hybrid = ks._numint.libxc.is_hybrid_xc(ks.xc)
     if hybrid:
         raise NotImplementedError
 
     # TODO GKS with multigrid method
 
     # ndim = 2, dm.shape = (2*nao, 2*nao)
     ground_state = (dm.ndim == 2 and kpts_band is None)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/kgks.py` & `pyscf-2.3.0/pyscf/pbc/dft/kgks.py`

 * *Files 4% similar despite different names*

```diff
@@ -51,14 +51,20 @@
         Veff = J + Vxc.
     '''
     if cell is None: cell = ks.cell
     if dm_kpts is None: dm_kpts = ks.make_rdm1()
     if kpts is None: kpts = ks.kpts
     t0 = (logger.process_clock(), logger.perf_counter())
 
+    ni = ks._numint
+    if ks.nlc or ni.libxc.is_nlc(ks.xc):
+        raise NotImplementedError(f'NLC functional {ks.xc} + {ks.nlc}')
+
+    hybrid = ni.libxc.is_hybrid_xc(ks.xc)
+
     # TODO GKS with hybrid functional
     hybrid = ks._numint.libxc.is_hybrid_xc(ks.xc)
     if hybrid:
         raise NotImplementedError
 
     # TODO GKS with multigrid method
 
@@ -92,24 +98,27 @@
     vxc = []
     for k in range(len(kpts)):
         vxc_k = np.asarray([vxc_spblk[0,k],vxc_spblk[1,k]], dtype=vxc_spblk.dtype)
         vxc_k = np.asarray(scipy.linalg.block_diag(*vxc_k))
         vxc.append(vxc_k)
     vxc = lib.asarray(vxc)
 
-    weight = 1./len(kpts)
+    nkpts = len(kpts)
+    weight = 1. / nkpts
     if not hybrid:
-        ks.with_df._j_only = False
         vj = ks.get_j(cell, dm_kpts, hermi, kpts, kpts_band)
         vxc += vj
     else:
         omega, alpha, hyb = ks._numint.rsh_and_hybrid_coeff(ks.xc, spin=cell.spin)
-        if getattr(ks.with_df, '_j_only', False):  # for GDF and MDF
-            logger.warn(ks, 'df.j_only cannot be used with hybrid functional')
+        if getattr(ks.with_df, '_j_only', False) and nkpts > 1: # for GDF and MDF:
             ks.with_df._j_only = False
+            if ks.with_df._cderi is not None:
+                logger.warn(ks, 'df.j_only cannot be used with hybrid '
+                            'functional. Rebuild cderi')
+                ks.with_df.build()
         vj, vk = ks.get_jk(cell, dm_kpts, hermi, kpts, kpts_band)
         vk *= hyb
         if omega != 0:
             vklr = ks.get_k(cell, dm_kpts, hermi, kpts, kpts_band, omega=omega)
             vklr *= (alpha - hyb)
             vk += vklr
         vxc += vj - vk
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/krks.py` & `pyscf-2.3.0/pyscf/pbc/dft/krks.py`

 * *Files 2% similar despite different names*

```diff
@@ -56,15 +56,19 @@
         Veff = J + Vxc.
     '''
     if cell is None: cell = ks.cell
     if dm is None: dm = ks.make_rdm1()
     if kpts is None: kpts = ks.kpts
     t0 = (logger.process_clock(), logger.perf_counter())
 
-    hybrid = ks._numint.libxc.is_hybrid_xc(ks.xc)
+    ni = ks._numint
+    if ks.nlc or ni.libxc.is_nlc(ks.xc):
+        raise NotImplementedError(f'NLC functional {ks.xc} + {ks.nlc}')
+
+    hybrid = ni.libxc.is_hybrid_xc(ks.xc)
 
     if not hybrid and isinstance(ks.with_df, multigrid.MultiGridFFTDF):
         n, exc, vxc = multigrid.nr_rks(ks.with_df, ks.xc, dm, hermi,
                                        kpts, kpts_band,
                                        with_j=True, return_j=False)
         logger.debug(ks, 'nelec by numeric integration = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
@@ -87,24 +91,27 @@
     else:
         max_memory = ks.max_memory - lib.current_memory()[0]
         n, exc, vxc = ks._numint.nr_rks(cell, ks.grids, ks.xc, dm, hermi,
                                         kpts, kpts_band, max_memory=max_memory)
         logger.debug(ks, 'nelec by numeric integration = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
 
-    weight = 1./len(kpts)
+    nkpts = len(kpts)
+    weight = 1. / nkpts
     if not hybrid:
-        ks.with_df._j_only = False
         vj = ks.get_j(cell, dm, hermi, kpts, kpts_band)
         vxc += vj
     else:
         omega, alpha, hyb = ks._numint.rsh_and_hybrid_coeff(ks.xc, spin=cell.spin)
-        if getattr(ks.with_df, '_j_only', False):  # for GDF and MDF
-            logger.warn(ks, 'df.j_only cannot be used with hybrid functional')
+        if getattr(ks.with_df, '_j_only', False) and nkpts > 1: # for GDF and MDF
             ks.with_df._j_only = False
+            if ks.with_df._cderi is not None:
+                logger.warn(ks, 'df.j_only cannot be used with hybrid '
+                            'functional. Rebuild cderi')
+                ks.with_df.build()
         vj, vk = ks.get_jk(cell, dm, hermi, kpts, kpts_band)
         vk *= hyb
         if omega != 0:
             vklr = ks.get_k(cell, dm, hermi, kpts, kpts_band, omega=omega)
             vklr *= (alpha - hyb)
             vk += vklr
         vxc += vj - vk * .5
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/krks_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/dft/krks_ksymm.py`

 * *Files 5% similar despite different names*

```diff
@@ -79,15 +79,19 @@
     weight = kpts.weights_ibz
     if not hybrid:
         vj = ks.get_j(cell, dm, hermi, kpts, kpts_band)
         vxc += vj
     else:
         omega, alpha, hyb = ks._numint.rsh_and_hybrid_coeff(ks.xc, spin=cell.spin)
         if getattr(ks.with_df, '_j_only', False):  # for GDF and MDF
+            logger.warn(ks, 'df.j_only cannot be used with hybrid functional')
             ks.with_df._j_only = False
+            # Rebuild df object due to the change of parameter _j_only
+            if ks.with_df._cderi is not None:
+                ks.with_df.build()
         vj, vk = ks.get_jk(cell, dm, hermi, kpts, kpts_band)
         vk *= hyb
         if omega != 0:
             vklr = ks.get_k(cell, dm, hermi, kpts, kpts_band, omega=omega)
             vklr *= (alpha - hyb)
             vk += vklr
         vxc += vj - vk * .5
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/krkspu.py` & `pyscf-2.3.0/pyscf/pbc/dft/krkspu.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/krkspu_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/dft/krkspu_ksymm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/kroks.py` & `pyscf-2.3.0/pyscf/pbc/dft/kroks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/kuks.py` & `pyscf-2.3.0/pyscf/pbc/dft/kuks.py`

 * *Files 3% similar despite different names*

```diff
@@ -41,15 +41,19 @@
     :func:`get_veff` fore more details.
     '''
     if cell is None: cell = ks.cell
     if dm is None: dm = ks.make_rdm1()
     if kpts is None: kpts = ks.kpts
     t0 = (logger.process_clock(), logger.perf_counter())
 
-    hybrid = ks._numint.libxc.is_hybrid_xc(ks.xc)
+    ni = ks._numint
+    if ks.nlc or ni.libxc.is_nlc(ks.xc):
+        raise NotImplementedError(f'NLC functional {ks.xc} + {ks.nlc}')
+
+    hybrid = ni.libxc.is_hybrid_xc(ks.xc)
 
     if not hybrid and isinstance(ks.with_df, multigrid.MultiGridFFTDF):
         n, exc, vxc = multigrid.nr_uks(ks.with_df, ks.xc, dm, hermi,
                                        kpts, kpts_band,
                                        with_j=True, return_j=False)
         logger.debug(ks, 'nelec by numeric integration = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
@@ -70,25 +74,28 @@
     else:
         max_memory = ks.max_memory - lib.current_memory()[0]
         n, exc, vxc = ks._numint.nr_uks(cell, ks.grids, ks.xc, dm, hermi,
                                         kpts, kpts_band, max_memory=max_memory)
         logger.debug(ks, 'nelec by numeric integration = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
 
-    weight = 1./len(kpts)
+    nkpts = len(kpts)
+    weight = 1. / nkpts
 
     if not hybrid:
-        ks.with_df._j_only = False
         vj = ks.get_j(cell, dm[0]+dm[1], hermi, kpts, kpts_band)
         vxc += vj
     else:
         omega, alpha, hyb = ks._numint.rsh_and_hybrid_coeff(ks.xc, spin=cell.spin)
-        if getattr(ks.with_df, '_j_only', False):  # for GDF and MDF
-            logger.warn(ks, 'df.j_only cannot be used with hybrid functional')
+        if getattr(ks.with_df, '_j_only', False) and nkpts > 1: # for GDF and MDF
             ks.with_df._j_only = False
+            if ks.with_df._cderi is not None:
+                logger.warn(ks, 'df.j_only cannot be used with hybrid '
+                            'functional. Rebuild cderi')
+                ks.with_df.build()
         vj, vk = ks.get_jk(cell, dm, hermi, kpts, kpts_band)
         vj = vj[0] + vj[1]
         vk *= hyb
         if omega != 0:
             vklr = ks.get_k(cell, dm, hermi, kpts, kpts_band, omega=omega)
             vklr *= (alpha - hyb)
             vk += vklr
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/kuks_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/dft/kuks_ksymm.py`

 * *Files 2% similar despite different names*

```diff
@@ -78,15 +78,19 @@
 
     if not hybrid:
         vj = ks.get_j(cell, dm[0]+dm[1], hermi, kpts, kpts_band)
         vxc += vj
     else:
         omega, alpha, hyb = ks._numint.rsh_and_hybrid_coeff(ks.xc, spin=cell.spin)
         if getattr(ks.with_df, '_j_only', False):  # for GDF and MDF
+            logger.warn(ks, 'df.j_only cannot be used with hybrid functional')
             ks.with_df._j_only = False
+            # Rebuild df object due to the change of parameter _j_only
+            if ks.with_df._cderi is not None:
+                ks.with_df.build()
         vj, vk = ks.get_jk(cell, dm, hermi, kpts, kpts_band)
         vj = vj[0] + vj[1]
         vk *= hyb
         if omega != 0:
             vklr = ks.get_k(cell, dm, hermi, kpts, kpts_band, omega=omega)
             vklr *= (alpha - hyb)
             vk += vklr
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/kukspu.py` & `pyscf-2.3.0/pyscf/pbc/dft/kukspu.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/kukspu_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/dft/kukspu_ksymm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/multigrid.py` & `pyscf-2.3.0/pyscf/pbc/dft/multigrid.py`

 * *Files 2% similar despite different names*

```diff
@@ -61,34 +61,39 @@
 EXPDROP = getattr(__config__, 'pbc_dft_multigrid_expdrop', 1e-12)
 IMAG_TOL = 1e-9
 
 
 def eval_mat(cell, weights, shls_slice=None, comp=1, hermi=0,
              xctype='LDA', kpts=None, mesh=None, offset=None, submesh=None):
     assert (all(cell._bas[:,NPRIM_OF] == 1))
+    if mesh is None:
+        mesh = cell.mesh
+    vol = cell.vol
+    weight_penalty = numpy.prod(mesh) / vol
+    exp_min = numpy.hstack(cell.bas_exps()).min()
+    theta_ij = exp_min / 2
+    lattice_sum_fac = max(2*numpy.pi*cell.rcut/(vol*theta_ij), 1)
+    precision = cell.precision / weight_penalty / lattice_sum_fac
+    if xctype != 'LDA':
+        precision *= .1
     atm, bas, env = gto.conc_env(cell._atm, cell._bas, cell._env,
                                  cell._atm, cell._bas, cell._env)
-    env[PTR_EXPDROP] = min(cell.precision*EXTRA_PREC, EXPDROP)
+    env[PTR_EXPDROP] = min(precision*EXTRA_PREC, EXPDROP)
     ao_loc = gto.moleintor.make_loc(bas, 'cart')
     if shls_slice is None:
         shls_slice = (0, cell.nbas, 0, cell.nbas)
     i0, i1, j0, j1 = shls_slice
     j0 += cell.nbas
     j1 += cell.nbas
     naoi = ao_loc[i1] - ao_loc[i0]
     naoj = ao_loc[j1] - ao_loc[j0]
 
-    if cell.dimension > 0:
-        Ls = numpy.asarray(cell.get_lattice_Ls(), order='C')
-    else:
-        Ls = numpy.zeros((1,3))
+    Ls = gto.eval_gto.get_lattice_Ls(cell)
     nimgs = len(Ls)
 
-    if mesh is None:
-        mesh = cell.mesh
     weights = numpy.asarray(weights, order='C')
     assert (weights.dtype == numpy.double)
     xctype = xctype.upper()
     n_mat = None
     if xctype == 'LDA':
         if weights.ndim == 1:
             weights = weights.reshape(-1, numpy.prod(mesh))
@@ -108,15 +113,15 @@
     b = numpy.linalg.inv(a.T)
     if offset is None:
         offset = (0, 0, 0)
     if submesh is None:
         submesh = mesh
     # log_prec is used to estimate the gto_rcut. Add EXTRA_PREC to count
     # other possible factors and coefficients in the integral.
-    log_prec = numpy.log(cell.precision * EXTRA_PREC)
+    log_prec = numpy.log(precision * EXTRA_PREC)
 
     if abs(a-numpy.diag(a.diagonal())).max() < 1e-12:
         lattice_type = '_orth'
     else:
         lattice_type = '_nonorth'
     eval_fn = 'NUMINTeval_' + xctype.lower() + lattice_type
     drv = libdft.NUMINT_fill2c
@@ -183,53 +188,58 @@
     '''Collocate the *real* density (opt. gradients) on the real-space grid.
 
     Kwargs:
         ignore_image :
             The output density is assumed to be real if ignore_imag=True.
     '''
     assert (all(cell._bas[:,NPRIM_OF] == 1))
+    if mesh is None:
+        mesh = cell.mesh
+    vol = cell.vol
+    weight_penalty = numpy.prod(mesh) / vol
+    exp_min = numpy.hstack(cell.bas_exps()).min()
+    theta_ij = exp_min / 2
+    lattice_sum_fac = max(2*numpy.pi*cell.rcut/(vol*theta_ij), 1)
+    precision = cell.precision / weight_penalty / lattice_sum_fac
+    if xctype != 'LDA':
+        precision *= .1
     atm, bas, env = gto.conc_env(cell._atm, cell._bas, cell._env,
                                  cell._atm, cell._bas, cell._env)
-    env[PTR_EXPDROP] = min(cell.precision*EXTRA_PREC, EXPDROP)
+    env[PTR_EXPDROP] = min(precision*EXTRA_PREC, EXPDROP)
     ao_loc = gto.moleintor.make_loc(bas, 'cart')
     if shls_slice is None:
         shls_slice = (0, cell.nbas, 0, cell.nbas)
     i0, i1, j0, j1 = shls_slice
     if hermi == 1:
         assert (i0 == j0 and i1 == j1)
     j0 += cell.nbas
     j1 += cell.nbas
     naoi = ao_loc[i1] - ao_loc[i0]
     naoj = ao_loc[j1] - ao_loc[j0]
     dm = numpy.asarray(dm, order='C')
     assert (dm.shape[-2:] == (naoi, naoj))
 
-    if cell.dimension > 0:
-        Ls = numpy.asarray(cell.get_lattice_Ls(), order='C')
-    else:
-        Ls = numpy.zeros((1,3))
+    Ls = gto.eval_gto.get_lattice_Ls(cell)
 
     if cell.dimension == 0 or kpts is None or gamma_point(kpts):
         nkpts, nimgs = 1, Ls.shape[0]
         dm = dm.reshape(-1,1,naoi,naoj).transpose(0,1,3,2)
     else:
         expkL = numpy.exp(1j*kpts.reshape(-1,3).dot(Ls.T))
         nkpts, nimgs = expkL.shape
         dm = dm.reshape(-1,nkpts,naoi,naoj).transpose(0,1,3,2)
     n_dm = dm.shape[0]
 
     a = cell.lattice_vectors()
     b = numpy.linalg.inv(a.T)
-    if mesh is None:
-        mesh = cell.mesh
     if offset is None:
         offset = (0, 0, 0)
     if submesh is None:
         submesh = mesh
-    log_prec = numpy.log(cell.precision * EXTRA_PREC)
+    log_prec = numpy.log(precision * EXTRA_PREC)
 
     if abs(a-numpy.diag(a.diagonal())).max() < 1e-12:
         lattice_type = '_orth'
     else:
         lattice_type = '_nonorth'
     xctype = xctype.upper()
     if xctype == 'LDA':
@@ -337,56 +347,48 @@
         rho.append(rho_i)
 
     if n_dm == 1:
         rho = rho[0]
     return rho
 
 def get_nuc(mydf, kpts=None):
+    kpts, is_single_kpt = fft._check_kpts(mydf, kpts)
     cell = mydf.cell
-    if kpts is None:
-        kpts_lst = numpy.zeros((1,3))
-    else:
-        kpts_lst = numpy.reshape(kpts, (-1,3))
-
     mesh = mydf.mesh
     charge = -cell.atom_charges()
     Gv = cell.get_Gv(mesh)
     SI = cell.get_SI(Gv)
     rhoG = numpy.dot(charge, SI)
 
     coulG = tools.get_coulG(cell, mesh=mesh, Gv=Gv)
     vneG = rhoG * coulG
     hermi = 1
-    vne = _get_j_pass2(mydf, vneG, hermi, kpts_lst)[0]
+    vne = _get_j_pass2(mydf, vneG, hermi, kpts)[0]
 
-    if kpts is None or numpy.shape(kpts) == (3,):
+    if is_single_kpt:
         vne = vne[0]
     return numpy.asarray(vne)
 
 def get_pp(mydf, kpts=None):
     '''Get the periodic pseudotential nuc-el AO matrix, with G=0 removed.
     '''
     from pyscf import gto
+    kpts, is_single_kpt = fft._check_kpts(mydf, kpts)
     cell = mydf.cell
-    if kpts is None:
-        kpts_lst = numpy.zeros((1,3))
-    else:
-        kpts_lst = numpy.reshape(kpts, (-1,3))
-
     mesh = mydf.mesh
     SI = cell.get_SI()
     Gv = cell.get_Gv(mesh)
     vpplocG = pseudo.get_vlocG(cell, Gv)
     vpplocG = -numpy.einsum('ij,ij->j', SI, vpplocG)
     # from get_jvloc_G0 function
     vpplocG[0] = numpy.sum(pseudo.get_alphas(cell))
     ngrids = len(vpplocG)
 
     hermi = 1
-    vpp = _get_j_pass2(mydf, vpplocG, hermi, kpts_lst)[0]
+    vpp = _get_j_pass2(mydf, vpplocG, hermi, kpts)[0]
 
     # vppnonloc evaluated in reciprocal space
     fakemol = gto.Mole()
     fakemol._atm = numpy.zeros((1,gto.ATM_SLOTS), dtype=numpy.int32)
     fakemol._bas = numpy.zeros((1,gto.BAS_SLOTS), dtype=numpy.int32)
     ptr = gto.PTR_ENV_START
     fakemol._env = numpy.zeros(ptr+10)
@@ -438,22 +440,22 @@
                         p0, p1 = p1, p1+nl*(l*2+1)
                         hl = numpy.asarray(hl)
                         SPG_lm_aoG = SPG_lm_aoGs[p0:p1].reshape(nl,l*2+1,-1)
                         tmp = numpy.einsum('ij,jmp->imp', hl, SPG_lm_aoG)
                         vppnl += numpy.einsum('imp,imq->pq', SPG_lm_aoG.conj(), tmp)
         return vppnl * (1./ngrids**2)
 
-    for k, kpt in enumerate(kpts_lst):
+    for k, kpt in enumerate(kpts):
         vppnl = vppnl_by_k(kpt)
         if gamma_point(kpt):
             vpp[k] = vpp[k].real + vppnl.real
         else:
             vpp[k] += vppnl
 
-    if kpts is None or numpy.shape(kpts) == (3,):
+    if is_single_kpt:
         vpp = vpp[0]
     return numpy.asarray(vpp)
 
 
 def get_j_kpts(mydf, dm_kpts, hermi=1, kpts=numpy.zeros((1,3)), kpts_band=None):
     '''Get the Coulomb (J) AO matrix at sampled k-points.
 
@@ -1770,32 +1772,33 @@
             break
     return tasks
 
 def _primitive_gto_cutoff(cell, precision=None):
     '''Cutoff raidus, above which each shell decays to a value less than the
     required precsion'''
     if precision is None:
-        precision = cell.precision * EXTRA_PREC
-    log_prec = min(numpy.log(precision), 0)
+        precision = cell.precision
+    vol = cell.vol
+    weight_penalty = vol
+    precision = cell.precision / max(weight_penalty, 1)
 
+    omega = cell.omega
     rcut = []
     ke_cutoff = []
     for ib in range(cell.nbas):
         l = cell.bas_angular(ib)
         es = cell.bas_exp(ib)
-        cs = abs(cell.bas_ctr_coeff(ib)).max(axis=1)
-        r = 5.
-        r = (((l+2)*numpy.log(r)+numpy.log(4*numpy.pi*cs) - log_prec) / es)**.5
-        r = (((l+2)*numpy.log(r)+numpy.log(4*numpy.pi*cs) - log_prec) / es)**.5
-
-# Errors in total number of electrons were observed with the default
-# precision. The energy cutoff (or the integration mesh) is not enough to
-# produce the desired accuracy. Scale precision by 0.1 to decrease the error.
-        ke_guess = gto.cell._estimate_ke_cutoff(es, l, cs, precision*0.1)
+        cs = abs(cell._libcint_ctr_coeff(ib)).max(axis=1)
+        norm_ang = ((2*l+1)/(4*numpy.pi))**.5
+        fac = 2*numpy.pi/vol * cs*norm_ang/es / precision
+        r = cell.rcut
+        r = (numpy.log(fac * r**(l+1) + 1.) / es)**.5
+        r = (numpy.log(fac * r**(l+1) + 1.) / es)**.5
 
+        ke_guess = gto.cell._estimate_ke_cutoff(es, l, cs, precision, omega)
         rcut.append(r)
         ke_cutoff.append(ke_guess)
     return rcut, ke_cutoff
 
 
 class MultiGridFFTDF(fft.FFTDF):
     def __init__(self, cell, kpts=numpy.zeros((1,3))):
@@ -1906,46 +1909,7 @@
 def _takebak_5d(out, a, indices):
     a_shape = a.shape
     out_shape = out.shape
     a = a.reshape((a_shape[0]*a_shape[1],) + a_shape[2:])
     out = out.reshape((out_shape[0]*out_shape[1],) + out_shape[2:])
     indices = (None,) + indices[2:]
     return _takebak_4d(out, a, indices)
-
-
-if __name__ == '__main__':
-    from pyscf.pbc import dft
-    numpy.random.seed(22)
-    cell = gto.M(
-        a = numpy.eye(3)*3.5668,
-        atom = '''C     0.      0.      0.
-                  C     0.8917  0.8917  0.8917
-                  C     1.7834  1.7834  0.
-                  C     2.6751  2.6751  0.8917
-                  C     1.7834  0.      1.7834
-                  C     2.6751  0.8917  2.6751
-                  C     0.      1.7834  1.7834
-                  C     0.8917  2.6751  2.6751''',
-        #basis = 'sto3g',
-        #basis = 'ccpvdz',
-        basis = 'gth-dzvp',
-        #basis = 'gth-szv',
-        #verbose = 5,
-        #mesh = [15]*3,
-        #precision=1e-6
-        pseudo = 'gth-pade'
-    )
-    multi_grids_tasks(cell, cell.mesh, 5)
-
-    nao = cell.nao_nr()
-    numpy.random.seed(1)
-    kpts = cell.make_kpts([3,1,1])
-
-    dm = numpy.random.random((len(kpts),nao,nao)) * .2
-    dm += numpy.eye(nao)
-    dm = dm + dm.transpose(0,2,1)
-
-    mf = dft.KRKS(cell)
-    ref = mf.get_veff(cell, dm, kpts=kpts)
-    out = multigrid(mf).get_veff(cell, dm, kpts=kpts)
-    print(abs(ref-out).max())
-
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/numint.py` & `pyscf-2.3.0/pyscf/pbc/dft/numint.py`

 * *Files 1% similar despite different names*

```diff
@@ -111,19 +111,15 @@
             also contains the value of the gradient in the x, y, and z
             directions.
 
     See Also:
         pyscf.dft.numint.eval_rho
 
     '''
-
-    if xctype == 'LDA' or xctype == 'HF':
-        ngrids, nao = ao.shape
-    else:
-        ngrids, nao = ao[0].shape
+    ngrids, nao = ao.shape[-2:]
 
     # complex orbitals or density matrix
     if numpy.iscomplexobj(ao) or numpy.iscomplexobj(dm):
         shls_slice = (0, cell.nbas)
         ao_loc = cell.ao_loc_nr()
         dm = dm.astype(numpy.complex128)
 
@@ -192,18 +188,15 @@
     return rho
 
 def eval_rho2(cell, ao, mo_coeff, mo_occ, non0tab=None, xctype='LDA',
               with_lapl=True, verbose=None):
     '''Refer to `pyscf.dft.numint.eval_rho2` for full documentation.
     '''
     xctype = xctype.upper()
-    if xctype == 'LDA' or xctype == 'HF':
-        ngrids, nao = ao.shape
-    else:
-        ngrids, nao = ao[0].shape
+    ngrids, nao = ao.shape[-2:]
 
     # complex orbitals or density matrix
     if numpy.iscomplexobj(ao) or numpy.iscomplexobj(mo_coeff):
         shls_slice = (0, cell.nbas)
         ao_loc = cell.ao_loc_nr()
         pos = mo_occ > OCCDROP
         cpos = numpy.einsum('ij,j->ij', mo_coeff[:,pos], numpy.sqrt(mo_occ[pos]))
@@ -243,15 +236,15 @@
                     rho[4]*= 2
                 rho[tau_idx] *= .5
         else:
             if xctype == 'LDA' or xctype == 'HF':
                 rho = numpy.zeros(ngrids)
             elif xctype == 'GGA':
                 rho = numpy.zeros((4,ngrids))
-            if with_lapl:
+            elif with_lapl:
                 # rho[4] = \nabla^2 rho, rho[5] = 1/2 |nabla f|^2
                 rho = numpy.zeros((6,ngrids))
                 tau_idx = 5
             else:
                 rho = numpy.zeros((5,ngrids))
                 tau_idx = 4
 
@@ -856,22 +849,32 @@
     elif xctype == 'MGGA':
         ao_deriv = 2 if numint.MGGA_DENSITY_LAPL else 1
     elif xctype == 'NLC':
         raise NotImplementedError('NLC')
     else:
         ao_deriv = 0
 
+    if isinstance(ni, KNumInt):
+        # mo_coeff of KRHF has [mo_k1, mo_k2, ...]
+        is_rhf = mo_coeff[0][0].ndim == 1
+    else:
+        is_rhf = mo_coeff[0].ndim == 1
+
     nao = cell.nao_nr()
-    if spin == 0:
+    if is_rhf:
         rho = []
         for ao_k1, ao_k2, mask, weight, coords \
                 in ni.block_loop(cell, grids, nao, ao_deriv, kpts, None, max_memory):
             rho.append(ni.eval_rho2(cell, ao_k1, mo_coeff, mo_occ, mask, xctype))
         rho = numpy.hstack(rho)
+        if spin == 1:
+            rho *= .5
+            rho = numpy.repeat(rho[numpy.newaxis], 2, axis=0)
     else:
+        assert spin == 1
         rhoa = []
         rhob = []
         for ao_k1, ao_k2, mask, weight, coords \
                 in ni.block_loop(cell, grids, nao, ao_deriv, kpts, None, max_memory):
             rhoa.append(ni.eval_rho2(cell, ao_k1, mo_coeff[0], mo_occ[0], mask, xctype))
             rhob.append(ni.eval_rho2(cell, ao_k1, mo_coeff[1], mo_occ[1], mask, xctype))
         rho = numpy.stack([numpy.hstack(rhoa), numpy.hstack(rhob)])
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/rks.py` & `pyscf-2.3.0/pyscf/pbc/dft/rks.py`

 * *Files 6% similar despite different names*

```diff
@@ -60,15 +60,19 @@
         dm is a list of density matrices.
     '''
     if cell is None: cell = ks.cell
     if dm is None: dm = ks.make_rdm1()
     if kpt is None: kpt = ks.kpt
     t0 = (logger.process_clock(), logger.perf_counter())
 
-    hybrid = ks._numint.libxc.is_hybrid_xc(ks.xc)
+    ni = ks._numint
+    if ks.nlc or ni.libxc.is_nlc(ks.xc):
+        raise NotImplementedError(f'NLC functional {ks.xc} + {ks.nlc}')
+
+    hybrid = ni.libxc.is_hybrid_xc(ks.xc)
 
     if not hybrid and isinstance(ks.with_df, multigrid.MultiGridFFTDF):
         n, exc, vxc = multigrid.nr_rks(ks.with_df, ks.xc, dm, hermi,
                                        kpt.reshape(1,3), kpts_band,
                                        with_j=True, return_j=False)
         logger.debug(ks, 'nelec by numeric integration = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
@@ -119,15 +123,15 @@
 
     vxc = lib.tag_array(vxc, ecoul=ecoul, exc=exc, vj=None, vk=None)
     return vxc
 
 def _patch_df_beckegrids(density_fit):
     def new_df(self, auxbasis=None, with_df=None, *args, **kwargs):
         mf = density_fit(self, auxbasis, with_df, *args, **kwargs)
-        mf.with_df._j_only = True
+        mf.with_df._j_only = not self._numint.libxc.is_hybrid_xc(self.xc)
         mf.grids = gen_grid.BeckeGrids(self.cell)
         mf.grids.level = getattr(__config__, 'pbc_dft_rks_RKS_grids_level',
                                  mf.grids.level)
         return mf
     return new_df
 
 NELEC_ERROR_TOL = getattr(__config__, 'pbc_dft_rks_prune_error_tol', 0.02)
@@ -152,48 +156,57 @@
     if isinstance(mf.with_df, multigrid.MultiGridFFTDF):
         rho = mf.with_df.get_rho(dm, kpt)
     else:
         rho = mf._numint.get_rho(mf.cell, dm, grids, kpt, mf.max_memory)
     return rho
 
 
-def _dft_common_init_(mf, xc='LDA,VWN'):
-    mf.xc = xc
-    mf.grids = gen_grid.UniformGrids(mf.cell)
-    # Use rho to filter grids
-    mf.small_rho_cutoff = getattr(__config__,
-                                  'pbc_dft_rks_RKS_small_rho_cutoff', 1e-7)
-##################################################
-# don't modify the following attributes, they are not input options
-    # Note Do not refer to .with_df._numint because mesh/coords may be different
-    if isinstance(mf, khf.KSCF):
-        if isinstance(mf.kpts, KPoints):
-            mf._numint = numint.KNumInt(mf.kpts.kpts)
-        else:
-            mf._numint = numint.KNumInt(mf.kpts)
-    else:
-        mf._numint = numint.NumInt()
-    mf._keys = mf._keys.union(['xc', 'grids', 'small_rho_cutoff'])
-
 class KohnShamDFT(mol_ks.KohnShamDFT):
     '''PBC-KS'''
 
-    __init__ = _dft_common_init_
+    def __init__(self, xc='LDA,VWN'):
+        self.xc = xc
+        self.grids = gen_grid.UniformGrids(self.cell)
+        self.nlc = ''
+        self.nlcgrids = None
+        # Use rho to filter grids
+        self.small_rho_cutoff = getattr(
+            __config__, 'pbc_dft_rks_RKS_small_rho_cutoff', 1e-7)
+##################################################
+# don't modify the following attributes, they are not input options
+        # Note Do not refer to .with_df._numint because mesh/coords may be different
+        if isinstance(self, khf.KSCF):
+            if isinstance(self.kpts, KPoints):
+                self._numint = numint.KNumInt(self.kpts.kpts)
+            else:
+                self._numint = numint.KNumInt(self.kpts)
+        else:
+            self._numint = numint.NumInt()
+        self._keys = self._keys.union(['xc', 'grids', 'small_rho_cutoff'])
 
     def dump_flags(self, verbose=None):
         logger.info(self, 'XC functionals = %s', self.xc)
         logger.info(self, 'small_rho_cutoff = %g', self.small_rho_cutoff)
         self.grids.dump_flags(verbose)
         return self
 
     def reset(self, mol=None):
         pbchf.SCF.reset(self, mol)
         self.grids.reset(mol)
         return self
 
+    def jk_method(self, J='FFTDF', K=None):
+        if K is None:
+            K = J
+        if (('RS' in J or 'RS' in K) and
+            not isinstance(self.grids, gen_grid.BeckeGrids)):
+            self.grids = gen_grid.BeckeGrids(self.cell)
+        super().jk_method(J, K)
+        return self
+
     def to_rks(self, xc=None):
         '''Convert the input mean-field object to a RKS/ROKS object.
 
         Note this conversion only changes the class of the mean-field object.
         The total energy and wave-function are the same as them in the input
         mean-field object.
         '''
@@ -248,14 +261,17 @@
         KohnShamDFT.__init__(self, xc)
 
     def dump_flags(self, verbose=None):
         pbchf.RHF.dump_flags(self, verbose)
         KohnShamDFT.dump_flags(self, verbose)
         return self
 
+    get_vsap = mol_ks.get_vsap
+    init_guess_by_vsap = mol_ks.init_guess_by_vsap
+
     get_veff = get_veff
     energy_elec = pyscf.dft.rks.energy_elec
     get_rho = get_rho
 
     density_fit = _patch_df_beckegrids(pbchf.RHF.density_fit)
     rs_density_fit = _patch_df_beckegrids(pbchf.RHF.rs_density_fit)
     mix_density_fit = _patch_df_beckegrids(pbchf.RHF.mix_density_fit)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/roks.py` & `pyscf-2.3.0/pyscf/pbc/dft/roks.py`

 * *Files 8% similar despite different names*

```diff
@@ -53,14 +53,17 @@
         rks.KohnShamDFT.__init__(self, xc)
 
     def dump_flags(self, verbose=None):
         rohf.ROHF.dump_flags(self, verbose)
         rks.KohnShamDFT.dump_flags(self, verbose)
         return self
 
+    get_vsap = rks.RKS.get_vsap
+    init_guess_by_vsap = rks.RKS.init_guess_by_vsap
+
     get_veff = get_veff
     energy_elec = pyscf.dft.uks.energy_elec
     get_rho = uks.get_rho
 
     density_fit = rks._patch_df_beckegrids(rohf.ROHF.density_fit)
     rs_density_fit = rks._patch_df_beckegrids(rohf.ROHF.rs_density_fit)
     mix_density_fit = rks._patch_df_beckegrids(rohf.ROHF.mix_density_fit)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/dft/uks.py` & `pyscf-2.3.0/pyscf/pbc/dft/uks.py`

 * *Files 4% similar despite different names*

```diff
@@ -26,14 +26,15 @@
 
 
 import numpy
 import pyscf.dft
 from pyscf import lib
 from pyscf.pbc.scf import uhf as pbcuhf
 from pyscf.lib import logger
+from pyscf.dft import uks as mol_uks
 from pyscf.pbc.dft import gen_grid
 from pyscf.pbc.dft import rks
 from pyscf.pbc.dft import multigrid
 from pyscf import __config__
 
 
 def get_veff(ks, cell=None, dm=None, dm_last=0, vhf_last=0, hermi=1,
@@ -42,15 +43,19 @@
     :func:`get_veff` fore more details.
     '''
     if cell is None: cell = ks.cell
     if dm is None: dm = ks.make_rdm1()
     if kpt is None: kpt = ks.kpt
     t0 = (logger.process_clock(), logger.perf_counter())
 
-    hybrid = ks._numint.libxc.is_hybrid_xc(ks.xc)
+    ni = ks._numint
+    if ks.nlc or ni.libxc.is_nlc(ks.xc):
+        raise NotImplementedError(f'NLC functional {ks.xc} + {ks.nlc}')
+
+    hybrid = ni.libxc.is_hybrid_xc(ks.xc)
 
     if not hybrid and isinstance(ks.with_df, multigrid.MultiGridFFTDF):
         n, exc, vxc = multigrid.nr_uks(ks.with_df, ks.xc, dm, hermi,
                                        kpt.reshape(1,3), kpts_band,
                                        with_j=True, return_j=False)
         logger.debug(ks, 'nelec by numeric integration = %s', n)
         t0 = logger.timer(ks, 'vxc', *t0)
@@ -125,14 +130,17 @@
         rks.KohnShamDFT.__init__(self, xc)
 
     def dump_flags(self, verbose=None):
         pbcuhf.UHF.dump_flags(self, verbose)
         rks.KohnShamDFT.dump_flags(self, verbose)
         return self
 
+    get_vsap = mol_uks.UKS.get_vsap
+    init_guess_by_vsap = mol_uks.UKS.init_guess_by_vsap
+
     get_veff = get_veff
     energy_elec = pyscf.dft.uks.energy_elec
     get_rho = get_rho
 
     density_fit = rks._patch_df_beckegrids(pbcuhf.UHF.density_fit)
     rs_density_fit = rks._patch_df_beckegrids(pbcuhf.UHF.rs_density_fit)
     mix_density_fit = rks._patch_df_beckegrids(pbcuhf.UHF.mix_density_fit)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/eph/eph_fd.py` & `pyscf-2.3.0/pyscf/pbc/eph/eph_fd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/geomopt/__init__.py` & `pyscf-2.3.0/pyscf/pbc/geomopt/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/geomopt/geometric_solver.py` & `pyscf-2.3.0/pyscf/geomopt/geometric_solver.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 #!/usr/bin/env python
-# Copyright 2014-2021 The PySCF Developers. All Rights Reserved.
+# Copyright 2014-2019 The PySCF Developers. All Rights Reserved.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
@@ -14,22 +14,26 @@
 # limitations under the License.
 
 '''
 Interface to geomeTRIC library https://github.com/leeping/geomeTRIC
 '''
 
 import os
+import uuid
 import tempfile
 import numpy
 import geometric
 import geometric.molecule
+#from geometric import molecule
 from pyscf import lib
-from pyscf.geomopt.addons import dump_mol_geometry
+from pyscf.lib import logger
+from pyscf.geomopt.addons import (as_pyscf_method, dump_mol_geometry,
+                                  symmetrize)  # noqa
 from pyscf import __config__
-from pyscf.pbc.grad.krhf import GradientsMixin
+from pyscf.grad.rhf import GradientsMixin
 
 try:
     from geometric import internal, optimize, nifty, engine, molecule
 except ImportError:
     msg = ('Geometry optimizer geomeTRIC not found.\ngeomeTRIC library '
            'can be found on github https://github.com/leeping/geomeTRIC.\n'
            'You can install geomeTRIC with "pip install geometric"')
@@ -44,19 +48,19 @@
 
 INCLUDE_GHOST = getattr(__config__, 'geomopt_berny_solver_optimize_include_ghost', True)
 ASSERT_CONV = getattr(__config__, 'geomopt_berny_solver_optimize_assert_convergence', True)
 
 class PySCFEngine(geometric.engine.Engine):
     def __init__(self, scanner):
         molecule = geometric.molecule.Molecule()
-        self.cell = cell = scanner.cell
-        molecule.elem = [cell.atom_symbol(i) for i in range(cell.natm)]
+        self.mol = mol = scanner.mol
+        molecule.elem = [mol.atom_symbol(i) for i in range(mol.natm)]
         # Molecule is the geometry parser for a bunch of formats which use
         # Angstrom for Cartesian coordinates by default.
-        molecule.xyzs = [cell.atom_coords()*lib.param.BOHR]  # In Angstrom
+        molecule.xyzs = [mol.atom_coords()*lib.param.BOHR]  # In Angstrom
         super(PySCFEngine, self).__init__(molecule)
 
         self.scanner = scanner
         self.cycle = 0
         self.e_last = 0
         self.callback = None
         self.maxsteps = 100
@@ -64,28 +68,30 @@
 
     def calc_new(self, coords, dirname):
         if self.cycle >= self.maxsteps:
             raise NotConvergedError('Geometry optimization is not converged in '
                                     '%d iterations' % self.maxsteps)
 
         g_scanner = self.scanner
-        cell = self.cell
+        mol = self.mol
         self.cycle += 1
-        lib.logger.note(g_scanner, '\nGeometry optimization cycle %d', self.cycle)
+        logger.note(g_scanner, '\nGeometry optimization cycle %d', self.cycle)
 
         # geomeTRIC requires coords and gradients in atomic unit
         coords = coords.reshape(-1,3)
-        if g_scanner.verbose >= lib.logger.NOTE:
-            dump_mol_geometry(cell, coords*lib.param.BOHR)
+        if g_scanner.verbose >= logger.NOTE:
+            dump_mol_geometry(mol, coords*lib.param.BOHR)
 
-        cell.set_geom_(coords, unit='Bohr')
-        energy, gradients = g_scanner(cell)
-        lib.logger.note(g_scanner,
-                        'cycle %d: E = %.12g  dE = %g  norm(grad) = %g', self.cycle,
-                        energy, energy - self.e_last, numpy.linalg.norm(gradients))
+        if mol.symmetry:
+            coords = symmetrize(mol, coords)
+
+        mol.set_geom_(coords, unit='Bohr')
+        energy, gradients = g_scanner(mol)
+        logger.note(g_scanner, 'cycle %d: E = %.12g  dE = %g  norm(grad) = %g',
+                    self.cycle, energy, energy - self.e_last, numpy.linalg.norm(gradients))
         self.e_last = energy
 
         if callable(self.callback):
             self.callback(locals())
 
         if self.assert_convergence and not g_scanner.converged:
             raise RuntimeError('Nuclear gradients of %s not converged' % g_scanner.base)
@@ -117,44 +123,52 @@
     elif isinstance(method, GradientsMixin):
         g_scanner = method.as_scanner()
     elif getattr(method, 'nuc_grad_method', None):
         g_scanner = method.nuc_grad_method().as_scanner()
     else:
         raise NotImplementedError('Nuclear gradients of %s not available' % method)
     if not include_ghost:
-        g_scanner.atmlst = numpy.where(method.cell.atom_charges() != 0)[0]
+        g_scanner.atmlst = numpy.where(method.mol.atom_charges() != 0)[0]
 
-    tmpf = tempfile.mktemp(dir=lib.param.TMPDIR)
     engine = PySCFEngine(g_scanner)
     engine.callback = callback
     engine.maxsteps = maxsteps
     # To avoid overwritting method.mol
-    engine.cell = g_scanner.cell.copy()
+    engine.mol = g_scanner.mol.copy()
 
     # When symmetry is enabled, the molecule may be shifted or rotated to make
     # the z-axis be the main axis. The transformation can cause inconsistency
     # between the optimization steps. The transformation is muted by setting
     # an explict point group to the keyword mol.symmetry (see symmetry
     # detection code in Mole.build function).
+    if engine.mol.symmetry:
+        engine.mol.symmetry = engine.mol.topgroup
+    engine.assert_convergence = assert_convergence
 
     # geomeTRIC library on pypi requires to provide config file log.ini.
     if not os.path.exists(os.path.abspath(
-            os.path.join(geometric.optimize.__file__, '..', 'log.ini'))):
+            os.path.join(geometric.optimize.__file__, '..', 'log.ini'))) and kwargs.get('logIni') is None:
         kwargs['logIni'] = os.path.abspath(os.path.join(__file__, '..', 'log.ini'))
 
-    engine.assert_convergence = assert_convergence
-    try:
-        geometric.optimize.run_optimizer(customengine=engine, input=tmpf,
-                                         constraints=constraints, **kwargs)
-        conv = True
-        # method.mol.set_geom_(m.xyzs[-1], unit='Angstrom')
-    except NotConvergedError as e:
-        lib.logger.note(method, str(e))
-        conv = False
-    return conv, engine.cell
+    with tempfile.TemporaryDirectory(dir=lib.param.TMPDIR) as tmpdir:
+        tmpf = os.path.join(tmpdir, str(uuid.uuid4()))
+
+        if 'hessian' in kwargs:
+            kwargs['hessian'] = _make_hessian(g_scanner, kwargs['hessian'], tmpdir)
+            logger.debug(g_scanner, 'Analytical hessian saved in %s', kwargs['hessian'])
+
+        try:
+            geometric.optimize.run_optimizer(customengine=engine, input=tmpf,
+                                             constraints=constraints, **kwargs)
+            conv = True
+            # method.mol.set_geom_(m.xyzs[-1], unit='Angstrom')
+        except NotConvergedError as e:
+            logger.note(method, str(e))
+            conv = False
+    return conv, engine.mol
 
 def optimize(method, assert_convergence=ASSERT_CONV,
              include_ghost=INCLUDE_GHOST, constraints=None, callback=None,
              maxsteps=100, **kwargs):
     '''Optimize geometry with geomeTRIC library for the given method.
 
     To adjust the convergence threshold, parameters can be set in kwargs as
@@ -171,76 +185,61 @@
         from pyscf import geometric_solver
         newmol = geometric_solver.optimize(method, **conv_params)
     '''
     # MRH, 07/23/2019: name all explicit kwargs for forward compatibility
     return kernel(method, assert_convergence=assert_convergence, include_ghost=include_ghost,
                   constraints=constraints, callback=callback, maxsteps=maxsteps, **kwargs)[1]
 
+def _make_hessian(g_scanner, hessian_option, tmpdir):
+    '''calculate hessian and saved to a file.
+    Returns the filename in the geomeTRIC supported format, e.g.
+    file:/path/to/hessian_file
+    '''
+    if not isinstance(hessian_option, str):
+        hessian_option = os.path.join(tmpdir, str(uuid.uuid4()))
+    if ':' in hessian_option:
+        hessian_file = hessian_option.split(':', 1)[1]
+    else:
+        hessian_file, hessian_option = hessian_option, f'first:{hessian_file}'
+
+    method = g_scanner.base
+    natm = method.mol.natm
+    try:
+        h = method.Hessian().kernel()
+    except (TypeError, NotImplementedError):
+        logger.warn(g_scanner, 'Analytical hessian for %s is not available', method)
+        hessian_option = False
+    else:
+        h = h.transpose(0,2,1,3).reshape(3*natm, 3*natm)
+        numpy.savetxt(hessian_file, h)
+    return hessian_option
+
 class GeometryOptimizer(lib.StreamObject):
     '''Optimize the molecular geometry for the input method.
 
     Note the method.mol will be changed after calling .kernel() method.
     '''
     def __init__(self, method):
         self.method = method
         self.callback = None
         self.params = {}
         self.converged = False
         self.max_cycle = 100
 
-
     @property
-    def cell(self):
-        return self.method.cell
-
-    @cell.setter
-    def cell(self, x):
-        self.method.cell = x
+    def mol(self):
+        return self.method.mol
+    @mol.setter
+    def mol(self, x):
         self.method.mol = x
 
     def kernel(self, params=None):
         if params is not None:
             self.params.update(params)
-        self.converged, self.cell = \
+        self.converged, self.mol = \
                 kernel(self.method, callback=self.callback,
                        maxsteps=self.max_cycle, **self.params)
-        return self.cell
+        return self.mol
     optimize = kernel
 
 class NotConvergedError(RuntimeError):
     pass
-
-del (INCLUDE_GHOST, ASSERT_CONV)
-
-
-if __name__ == '__main__':
-    from pyscf.pbc import gto, scf, grad
-    cell = gto.Cell()
-    cell.atom = '''
-    C 0.000000000000 0.000000000000 0.000000000000
-    C 1.685068664391 1.685068664391 1.685068664391
-    '''
-    cell.atom= [['C', [0.0, 0.0, 0.0]], ['C', [1.685068664391,1.685068664391,1.685068664391]]]
-    cell.a = '''
-    0.000000000, 3.370137329, 3.370137329
-    3.370137329, 0.000000000, 3.370137329
-    3.370137329, 3.370137329, 0.000000000'''
-    cell.basis = 'gth-szv'
-    cell.verbose= 4
-    cell.pseudo = 'gth-pade'
-    cell.unit = 'bohr'
-    cell.build()
-
-    kpts = cell.make_kpts([1,1,3])
-    mf = scf.KRHF(cell, kpts, exxdiv=None)
-    mf.conv_tol = 1e-14
-    mf.conv_tol_grad = 1e-8
-    conv_params = {
-        'convergence_energy': 1e-4,  # Eh
-        'convergence_grms': 1e-5,    # Eh/Bohr
-        'convergence_gmax': 1e-5,  # Eh/Bohr
-        'convergence_drms': 1.2e-2,  # Angstrom
-        'convergence_dmax': 1.8e-2,  # Angstrom
-    }
-    opt = GeometryOptimizer(mf).set(params=conv_params)#.run()
-    opt.run()
-    cell = opt.cell
```

### Comparing `pyscf-2.2.1/pyscf/pbc/grad/__init__.py` & `pyscf-2.3.0/pyscf/pbc/grad/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/grad/krhf.py` & `pyscf-2.3.0/pyscf/pbc/grad/krhf.py`

 * *Files 2% similar despite different names*

```diff
@@ -208,16 +208,21 @@
         return hcore
     return hcore_deriv
 
 def grad_nuc(cell, atmlst):
     '''
     Derivatives of nuclear repulsion energy wrt nuclear coordinates
     '''
-    ew_eta = cell.get_ewald_params()[0]
     chargs = cell.atom_charges()
+    ew_eta, ew_cut = cell.get_ewald_params()
+    log_precision = np.log(cell.precision / (chargs.sum()*16*np.pi**2))
+    ke_cutoff = -2*ew_eta**2*log_precision
+    mesh = cell.cutoff_to_mesh(ke_cutoff)
+    logger.debug1(cell, 'mesh for ewald %s', mesh)
+
     coords = cell.atom_coords()
     Lall = cell.get_lattice_Ls()
     natom = len(chargs)
     ewovrl_grad = np.zeros([natom,3])
 
     for i, qi in enumerate(chargs):
         ri = coords[i]
@@ -230,15 +235,14 @@
             r = np.sqrt(np.einsum('ji,ji->j', r1, r1))
             r = r.reshape(len(r),1)
             ewovrl_grad[i] += np.sum(- (qi * qj / r ** 3 * r1 *
                                         scipy.special.erfc(ew_eta * r).reshape(len(r),1)), axis = 0)
             ewovrl_grad[i] += np.sum(- qi * qj / r ** 2 * r1 * 2 * ew_eta / np.sqrt(np.pi) *
                                      np.exp(-ew_eta**2 * r ** 2).reshape(len(r),1), axis = 0)
 
-    mesh = gto.cell._cut_mesh_for_ewald(cell, cell.mesh)
     Gv, Gvbase, weights = cell.get_Gv_weights(mesh)
     absG2 = np.einsum('gi,gi->g', Gv, Gv)
     absG2[absG2==0] = 1e200
     ewg_grad = np.zeros([natom,3])
     SI = cell.get_SI(Gv)
     if cell.low_dim_ft_type is None or cell.dimension == 3:
         coulG = 4*np.pi / absG2
```

### Comparing `pyscf-2.2.1/pyscf/pbc/grad/krks.py` & `pyscf-2.3.0/pyscf/pbc/grad/krks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/grad/kuhf.py` & `pyscf-2.3.0/pyscf/pbc/grad/kuhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/grad/kuks.py` & `pyscf-2.3.0/pyscf/pbc/grad/kuks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/__init__.py` & `pyscf-2.3.0/pyscf/pbc/gto/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/_pbcintor.py` & `pyscf-2.3.0/pyscf/pbc/gto/_pbcintor.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/__init__.py` & `pyscf-2.3.0/pyscf/pbc/gto/basis/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-dzvp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-dzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-qzv2p.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-qzv2p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-qzv3p.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-qzv3p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-tzv2p.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-tzv2p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-aug-tzvp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-aug-tzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-cc-dzvp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-cc-dzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-cc-qzvp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-cc-qzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-cc-tzvp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-cc-tzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzv.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzv.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzvp-molopt-sr-q9.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzvp-molopt-sr-q9.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzvp-molopt-sr.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzvp-molopt-sr.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzvp-molopt.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzvp-molopt.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-dzvp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-dzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-qzv2p.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-qzv2p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-qzv3p.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-qzv3p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szv-molopt-sr.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szv-molopt-sr.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szv-molopt.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szv-molopt.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szv.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szv.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-szvp-molopt-sr-q9.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-szvp-molopt-sr-q9.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzv2p-molopt.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzv2p-molopt.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzv2p.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzv2p.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzv2px-molopt.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzv2px-molopt.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzvp-molopt.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzvp-molopt.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/gth-tzvp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/basis/gth-tzvp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/parse_cp2k.py` & `pyscf-2.3.0/pyscf/pbc/gto/basis/parse_cp2k.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/split_BASIS_MOLOPT.py` & `pyscf-2.3.0/pyscf/pbc/gto/basis/split_BASIS_MOLOPT.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/split_GTH_BASIS_SETS.py` & `pyscf-2.3.0/pyscf/pbc/gto/basis/split_GTH_BASIS_SETS.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/basis/split_HFX_BASIS.py` & `pyscf-2.3.0/pyscf/pbc/gto/basis/split_HFX_BASIS.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/cell.py` & `pyscf-2.3.0/pyscf/pbc/gto/cell.py`

 * *Files 3% similar despite different names*

```diff
@@ -391,18 +391,15 @@
     else:
         aosym = 's2'
     fill = getattr(libpbc, 'PBCnr2c_fill_k'+aosym)
     fintor = getattr(moleintor.libcgto, intor)
     cintopt = lib.c_null_ptr()
 
     rcut = max(cell1.rcut, cell2.rcut)
-    if cell1.dimension < 2 or cell1.low_dim_ft_type == 'inf_vacuum':
-        Ls = cell1.get_lattice_Ls(rcut=rcut, dimension=cell1.dimension)
-    else:
-        Ls = cell1.get_lattice_Ls(rcut=rcut, dimension=3)
+    Ls = cell1.get_lattice_Ls(rcut=rcut)
     expkL = np.asarray(np.exp(1j*np.dot(kpts_lst, Ls.T)), order='C')
     drv = libpbc.PBCnr2c_drv
 
     kderiv = kwargs.get('kderiv', 0)
     if kderiv > 0:
         hermi = 0
         aosym = 's1'
@@ -480,121 +477,113 @@
     nimgs = cell.get_bounding_sphere(rcut)
     return nimgs
 
 def _estimate_rcut(alpha, l, c, precision=INTEGRAL_PRECISION):
     '''rcut based on the overlap integrals. This estimation is too conservative
     in many cases. A possible replacement can be the value of the basis
     function at rcut ~ c*r^(l+2)*exp(-alpha*r^2) < precision'''
+    theta = alpha * .5
+    a1 = (alpha * 2)**-.5
+    norm_ang = (2*l+1)/(4*np.pi)
+    fac = 2*np.pi*c**2*norm_ang / theta / precision
     r0 = 20
-    # lattice_sum_penalty is the factor in terms of lattice sum in overlap
-    # integrals
-    lattice_sum_penalty = 4 * np.pi * r0 / alpha
-    C = c**2*(2*l+1)*alpha / precision * lattice_sum_penalty
-    # +1. to ensure np.log returning positive value
-    r0 = np.sqrt(2.*np.log(C*(r0**2*alpha)**(l+1)+1.) / alpha)
-    rcut = np.sqrt(2.*np.log(C*(r0**2*alpha)**(l+1)+1.) / alpha)
-    return rcut
+    # The estimation is enough for overlap. Errors are slightly larger for
+    # kinetic operator. The error in kinetic integrals may be dominant.
+    # For kinetic operator, basis becomes 2*a*r*|orig-basis>.
+    # A penalty term 4*a^2*r^2 is included in the estimation.
+    fac *= 4*alpha**2
+    r0 = (np.log(fac * r0 * (r0*.5+a1)**(2*l+2) + 1.) / theta)**.5
+    r0 = (np.log(fac * r0 * (r0*.5+a1)**(2*l+2) + 1.) / theta)**.5
+    return r0
 
-def bas_rcut(cell, bas_id, precision=INTEGRAL_PRECISION):
+def bas_rcut(cell, bas_id, precision=None):
     r'''Estimate the largest distance between the function and its image to
     reach the precision in overlap
 
     precision ~ \int g(r-0) g(r-Rcut)
     '''
+    if precision is None:
+        precision = cell.precision
     l = cell.bas_angular(bas_id)
     es = cell.bas_exp(bas_id)
-    cs = abs(cell.bas_ctr_coeff(bas_id)).max(axis=1)
+    cs = abs(cell._libcint_ctr_coeff(bas_id)).max(axis=1)
     rcut = _estimate_rcut(es, l, cs, precision)
     return rcut.max()
 
-def estimate_rcut(cell, precision=INTEGRAL_PRECISION):
+def estimate_rcut(cell, precision=None):
     '''Lattice-sum cutoff for the entire system'''
-    rcut = [cell.bas_rcut(ib, precision) for ib in range(cell.nbas)]
-    if rcut:
-        rcut_max = max(rcut)
-    else:
-        rcut_max = 0
-    return rcut_max
+    if cell.nbas == 0:
+        return 0.01
+    if precision is None:
+        precision = cell.precision
+    exps, cs = _extract_pgto_params(cell, 'min')
+    ls = cell._bas[:,mole.ANG_OF]
+    rcut = _estimate_rcut(exps, ls, cs, precision)
+    return rcut.max()
 
-def _rcut_penalty(cell):
-    '''Basis near the boundary of a cell may be closed to basis near the
-    boundary of the neighbour image. Use a penalty for this when calling
-    estimate_rcut
-    '''
-    a = cell.lattice_vectors()
-    if cell.dimension == 3:
-        vol = np.linalg.det(a)
-        penalty = vol ** (1./3) * 3**.5
-    elif cell.dimension == 2:
-        area = np.linalg.norm(np.cross(a[0], a[1]))
-        penalty = area ** .5 * 2**.5
-    elif cell.dimension == 1:
-        penalty = np.linalg.norm(a[0])
+def _estimate_ke_cutoff(alpha, l, c, precision=INTEGRAL_PRECISION, omega=0):
+    '''Energy cutoff estimation for nuclear attraction integrals'''
+    norm_ang = (2*l+1)/(4*np.pi)
+    fac = 32*np.pi**2*(2*np.pi)**1.5 * c**2*norm_ang / (2*alpha)**(2*l+.5) / precision
+    Ecut = 20.
+    if omega <= 0:
+        Ecut = np.log(fac * (Ecut*2)**(l-.5) + 1.) * 4*alpha
+        Ecut = np.log(fac * (Ecut*2)**(l-.5) + 1.) * 4*alpha
     else:
-        penalty = 0
-    return penalty
-
-def _estimate_ke_cutoff(alpha, l, c, precision=INTEGRAL_PRECISION, weight=1.):
-    '''Energy cutoff estimation based on cubic lattice'''
-    # This function estimates the energy cutoff for (ii|ii) type of electron
-    # repulsion integrals. The energy cutoff for nuclear attraction is larger
-    # than the energy cutoff for ERIs.  The estimated error is roughly
-    #     error ~ 64 pi^3 c^2 /((2l+1)!!(4a)^l) (2Ecut)^{l+.5} e^{-Ecut/4a}
-    # log_k0 = 3 + np.log(alpha) / 2
-    # l2fac2 = factorial2(l*2+1)
-    # log_rest = np.log(precision*l2fac2*(4*alpha)**l / (16*np.pi**2*c**2))
-    # Enuc_cut = 4*alpha * (log_k0*(2*l+1) - log_rest)
-    # Enuc_cut[Enuc_cut <= 0] = .5
-    # log_k0 = .5 * np.log(Ecut*2)
-    # Enuc_cut = 4*alpha * (log_k0*(2*l+1) - log_rest)
-    # Enuc_cut[Enuc_cut <= 0] = .5
-    #
-    # However, nuclear attraction can be evaluated with the trick of Ewald
-    # summation which largely reduces the requirements to the energy cutoff.
-    # In practice, the cutoff estimation for ERIs as below should be enough.
-    log_k0 = 3 + np.log(alpha) / 2
-    l2fac2 = factorial2(l*2+1)
-    log_rest = np.log(precision*l2fac2**2*(4*alpha)**(l*2+1) / (128*np.pi**4*c**4))
-    Ecut = 2*alpha * (log_k0*(4*l+3) - log_rest)
-    Ecut[Ecut <= 0] = .5
-    log_k0 = .5 * np.log(Ecut*2)
-    Ecut = 2*alpha * (log_k0*(4*l+3) - log_rest)
-    Ecut[Ecut <= 0] = .5
+        theta = 1./(1./(4*alpha) + 1./(2*omega**2))
+        Ecut = np.log(fac * (Ecut*2)**(l-.5) + 1.) * theta
+        Ecut = np.log(fac * (Ecut*2)**(l-.5) + 1.) * theta
     return Ecut
 
-def estimate_ke_cutoff(cell, precision=INTEGRAL_PRECISION):
-    '''Energy cutoff estimation for the entire system'''
-    Ecut_max = 0
-    for i in range(cell.nbas):
-        l = cell.bas_angular(i)
-        es = cell.bas_exp(i)
-        cs = abs(cell.bas_ctr_coeff(i)).max(axis=1)
-        ke_guess = _estimate_ke_cutoff(es, l, cs, precision)
-        Ecut_max = max(Ecut_max, ke_guess.max())
-    return Ecut_max
-
-def error_for_ke_cutoff(cell, ke_cutoff):
-    kmax = np.sqrt(ke_cutoff*2)
-    errmax = 0
-    for i in range(cell.nbas):
-        l = cell.bas_angular(i)
-        es = cell.bas_exp(i)
-        cs = abs(cell.bas_ctr_coeff(i)).max(axis=1)
-        fac = (256*np.pi**4*cs**4 * factorial2(l*4+3)
-               / factorial2(l*2+1)**2)
-        efac = np.exp(-ke_cutoff/(2*es))
-        err1 = .5*fac/(4*es)**(2*l+1) * kmax**(4*l+3) * efac
-        errmax = max(errmax, err1.max())
-        if np.any(ke_cutoff < 5*es):
-            err2 = (1.41*efac+2.51)*fac/(4*es)**(2*l+2) * kmax**(4*l+5)
-            errmax = max(errmax, err2[ke_cutoff<5*es].max())
-        if np.any(ke_cutoff < es):
-            err2 = (1.41*efac+2.51)*fac/2**(2*l+2) * np.sqrt(2*es)
-            errmax = max(errmax, err2[ke_cutoff<es].max())
-    return errmax
+def estimate_ke_cutoff(cell, precision=None):
+    '''Energy cutoff estimation for nuclear attraction integrals'''
+    if cell.nbas == 0:
+        return 0.
+    if precision is None:
+        precision = cell.precision
+    #precision /= cell.atom_charges().sum()
+    exps, cs = _extract_pgto_params(cell, 'max')
+    ls = cell._bas[:,mole.ANG_OF]
+    Ecut = _estimate_ke_cutoff(exps, ls, cs, precision, cell.omega)
+    return Ecut.max()
+
+def _extract_pgto_params(cell, op='min'):
+    '''A helper function for estimate_xxx function'''
+    es = []
+    cs = []
+    if op == 'min':
+        for i in range(cell.nbas):
+            e = cell.bas_exp(i)
+            c = cell._libcint_ctr_coeff(i)
+            idx = e.argmin()
+            es.append(e[idx])
+            cs.append(abs(c[idx]).max())
+    else:
+        for i in range(cell.nbas):
+            e = cell.bas_exp(i)
+            c = cell._libcint_ctr_coeff(i)
+            idx = e.argmax()
+            es.append(e[idx])
+            cs.append(abs(c[idx]).max())
+    return np.array(es), np.array(cs)
+
+def error_for_ke_cutoff(cell, ke_cutoff, omega=None):
+    '''Error estimation based on nuclear attraction integrals'''
+    if omega is None:
+        omega = cell.omega
+    exps, cs = _extract_pgto_params(cell, 'max')
+    ls = cell._bas[:,mole.ANG_OF]
+    norm_ang = (2*ls+1)/(4*np.pi)
+    fac = 32*np.pi**2*(2*np.pi)**1.5 * cs**2*norm_ang / (2*exps)**(2*ls+.5)
+    if omega <= 0:
+        err = fac * (2*ke_cutoff)**(ls-.5) * np.exp(-ke_cutoff/(4*exps))
+    else:
+        theta = 1./(1./(4*exps) + 1./(2*omega**2))
+        err = fac * (2*ke_cutoff)**(ls-.5) * np.exp(-ke_cutoff/theta)
+    return err.max()
 
 def get_bounding_sphere(cell, rcut):
     '''Finds all the lattice points within a sphere of radius rcut.
 
     Defines a parallelipiped given by -N_x <= n_x <= N_x, with x in [1,3]
     See Martin p. 85
 
@@ -687,38 +676,40 @@
     #rs, ws = radi.delley(n)
     #rs, ws = radi.treutler_ahlrichs(n)
     #rs, ws = radi.mura_knowles(n)
     rs, ws = radi.gauss_chebyshev(n)
     #return np.hstack((0,rs,-rs[::-1])), np.hstack((0,ws,ws[::-1]))
     return np.hstack((rs,-rs[::-1])), np.hstack((ws,ws[::-1]))
 
-def get_SI(cell, Gv=None):
+def get_SI(cell, Gv=None, mesh=None):
     '''Calculate the structure factor (0D, 1D, 2D, 3D) for all atoms; see MH (3.34).
 
     Args:
         cell : instance of :class:`Cell`
 
         Gv : (N,3) array
             G vectors
 
     Returns:
         SI : (natm, ngrids) ndarray, dtype=np.complex128
             The structure factor for each atom at each G-vector.
     '''
     coords = cell.atom_coords()
-    ngrids = np.prod(cell.mesh)
-    if Gv is None or Gv.shape[0] == ngrids:
-        basex, basey, basez = cell.get_Gv_weights(cell.mesh)[1]
+    if Gv is None:
+        if mesh is None:
+            mesh = cell.mesh
+        basex, basey, basez = cell.get_Gv_weights(mesh)[1]
         b = cell.reciprocal_vectors()
         rb = np.dot(coords, b.T)
         SIx = np.exp(-1j*np.einsum('z,g->zg', rb[:,0], basex))
         SIy = np.exp(-1j*np.einsum('z,g->zg', rb[:,1], basey))
         SIz = np.exp(-1j*np.einsum('z,g->zg', rb[:,2], basez))
         SI = SIx[:,:,None,None] * SIy[:,None,:,None] * SIz[:,None,None,:]
-        SI = SI.reshape(-1,ngrids)
+        natm = coords.shape[0]
+        SI = SI.reshape(natm, -1)
     else:
         SI = np.exp(-1j*np.dot(coords, Gv.T))
     return SI
 
 def get_ewald_params(cell, precision=None, mesh=None):
     r'''Choose a reasonable value of Ewald 'eta' and 'cut' parameters.
     eta^2 is the exponent coefficient of the model Gaussian charge for nucleus
@@ -735,48 +726,38 @@
 
         precision ~ erfc(eta*rcut) / rcut ~ e^{(-eta**2 rcut*2)}
 
     Returns:
         ew_eta, ew_cut : float
             The Ewald 'eta' and 'cut' parameters.
     '''
-    if precision is None:
-        precision = cell.precision
     if cell.natm == 0:
         return 0, 0
-    elif (cell.dimension < 2 or
+
+    if precision is None:
+        precision = cell.precision
+
+    if (cell.dimension < 2 or
           (cell.dimension == 2 and cell.low_dim_ft_type == 'inf_vacuum')):
         # Non-uniform PW grids are used for low-dimensional ewald summation.  The cutoff
         # estimation for long range part based on exp(G^2/(4*eta^2)) does not work for
         # non-uniform grids.  Smooth model density is preferred.
         ew_cut = cell.rcut
         ew_eta = np.sqrt(max(np.log(4*np.pi*ew_cut**2/precision)/ew_cut**2, .1))
-    else:
-        mesh = _cut_mesh_for_ewald(cell, mesh)
-        ke_cutoff = pbctools.mesh_to_cutoff(cell.lattice_vectors(), mesh).min()
+    elif cell.dimension == 2:
+        a = cell.lattice_vectors()
+        ew_cut = a[2,2] / 2
+        # ewovrl ~ erfc(eta*rcut) / rcut ~ e^{(-eta**2 rcut*2)} < precision
         log_precision = np.log(precision / (cell.atom_charges().sum()*16*np.pi**2))
-        ew_eta = np.sqrt(-ke_cutoff/(2*log_precision))
+        ew_eta = (-log_precision)**.5 / ew_cut
+    else:  # dimension == 3
+        ew_eta = 1./cell.vol**(1./6)
         ew_cut = _estimate_rcut(ew_eta**2, 0, 1., precision)
     return ew_eta, ew_cut
 
-MESH_FOR_EWALD = np.array([15] * 3)
-
-def _cut_mesh_for_ewald(cell, mesh):
-    if cell.dimension == 3:
-        return MESH_FOR_EWALD
-
-    mesh = MESH_FOR_EWALD.copy()
-    if (cell.dimension < 2 or
-        (cell.dimension == 2 and cell.low_dim_ft_type == 'inf_vacuum')):
-        mesh[cell.dimension:] = cell.mesh[cell.dimension:]
-    else:  # dimension == 2
-        # roughly 2 grids per bohr
-        mesh[2] = int(np.linalg.norm(cell.lattice_vectors()[2])) * 2 + 1
-    return mesh
-
 def ewald(cell, ew_eta=None, ew_cut=None):
     '''Perform real (R) and reciprocal (G) space Ewald sum for the energy.
 
     Formulation of Martin, App. F2.
 
     Returns:
         float
@@ -793,20 +774,18 @@
     if cell.natm == 0:
         return 0
 
     chargs = cell.atom_charges()
 
     if ew_eta is None or ew_cut is None:
         ew_eta, ew_cut = cell.get_ewald_params()
-        mesh = _cut_mesh_for_ewald(cell, cell.mesh)
-    else:
-        log_precision = np.log(cell.precision / (chargs.sum()*16*np.pi**2))
-        ke_cutoff = -2*ew_eta**2*log_precision
-        mesh = pbctools.cutoff_to_mesh(cell.lattice_vectors(), ke_cutoff)
-        logger.debug1(cell, 'mesh for ewald %s', mesh)
+    log_precision = np.log(cell.precision / (chargs.sum()*16*np.pi**2))
+    ke_cutoff = -2*ew_eta**2*log_precision
+    mesh = cell.cutoff_to_mesh(ke_cutoff)
+    logger.debug1(cell, 'mesh for ewald %s', mesh)
 
     coords = cell.atom_coords()
     Lall = cell.get_lattice_Ls(rcut=ew_cut)
 
     rLij = coords[:,None,:] - coords[None,:,:] + Lall[:,None,None,:]
     r = np.sqrt(np.einsum('Lijx,Lijx->Lij', rLij, rLij))
     rLij = None
@@ -828,14 +807,16 @@
     #   ZS_I(G) = \sum_a Z_a exp (i G.R_a)
 
     Gv, Gvbase, weights = cell.get_Gv_weights(mesh)
     absG2 = np.einsum('gi,gi->g', Gv, Gv)
     absG2[absG2==0] = 1e200
 
     if cell.dimension != 2 or cell.low_dim_ft_type == 'inf_vacuum':
+        # TODO: truncated Coulomb for 0D. The non-uniform grids for inf-vacuum
+        # have relatively large error
         coulG = 4*np.pi / absG2
         coulG *= weights
         ZSI = np.einsum("i,ij->j", chargs, cell.get_SI(Gv))
         ZexpG2 = ZSI * np.exp(-absG2/(4*ew_eta**2))
         ewg = .5 * np.einsum('i,i,i', ZSI.conj(), ZexpG2, coulG).real
 
     elif cell.dimension == 2:  # Truncated Coulomb
@@ -1284,15 +1265,15 @@
         _, mesh1 = self.lattice_symmetry.check_mesh_symmetry(mesh=mesh,
                                                              return_mesh=True)
         if np.prod(mesh1) != np.prod(mesh):
             logger.debug(self, 'mesh %s is symmetrized as %s', mesh, mesh1)
         return mesh1
 
 #Note: Exculde dump_input, parse_arg, basis from kwargs to avoid parsing twice
-    def build(self, dump_input=True, parse_arg=True,
+    def build(self, dump_input=True, parse_arg=mole.ARGPARSE,
               a=None, mesh=None, ke_cutoff=None, precision=None, nimgs=None,
               pseudo=None, basis=None, h=None, dimension=None, rcut= None,
               ecp=None, low_dim_ft_type=None,
               space_group_symmetry=None, symmorphic=None, *args, **kwargs):
         '''Setup Mole molecule and Cell and initialize some control parameters.
         Whenever you change the value of the attributes of :class:`Cell`,
         you need call this function to refresh the internal data of Cell.
@@ -1498,19 +1479,14 @@
             self._mesh = pbctools.cutoff_to_mesh(_a, ke_cutoff)
 
             if (self.dimension < 2 or
                 (self.dimension == 2 and self.low_dim_ft_type == 'inf_vacuum')):
                 self._mesh[self.dimension:] = _mesh_inf_vaccum(self)
             self._mesh_from_build = True
 
-            # Set minimal mesh grids to handle the case mesh==0. since Madelung
-            # constant may be computed even if the unit cell has 0 atoms. In this
-            # system, cell.mesh was initialized to 0.
-            self._mesh[self._mesh == 0] = 30
-
         if self.space_group_symmetry:
             from pyscf.pbc.symm import Symmetry
             _check_mesh_symm = False
             if not self._mesh_from_build:
                 _check_mesh_symm = True
             _lattice_symm = Symmetry(self)
             _lattice_symm.build(space_group_symmetry=True,
@@ -1524,14 +1500,22 @@
             self.dump_input()
             logger.info(self, 'lattice vectors  a1 [%.9f, %.9f, %.9f]', *_a[0])
             logger.info(self, '                 a2 [%.9f, %.9f, %.9f]', *_a[1])
             logger.info(self, '                 a3 [%.9f, %.9f, %.9f]', *_a[2])
             logger.info(self, 'dimension = %s', self.dimension)
             logger.info(self, 'low_dim_ft_type = %s', self.low_dim_ft_type)
             logger.info(self, 'Cell volume = %g', self.vol)
+            # Check atoms coordinates
+            if self.dimension > 0:
+                scaled_atom_coords = np.linalg.solve(_a.T, self.atom_coords().T).T
+                atom_boundary_max = scaled_atom_coords[:,:self.dimension].max(axis=0)
+                atom_boundary_min = scaled_atom_coords[:,:self.dimension].min(axis=0)
+                if (np.any(atom_boundary_max > 1) or np.any(atom_boundary_min < -1)):
+                    logger.warn(self, 'Atoms found out of the primitive cell.')
+
             if self.exp_to_discard is not None:
                 logger.info(self, 'exp_to_discard = %s', self.exp_to_discard)
             logger.info(self, 'rcut = %s (nimgs = %s)', self.rcut, self.nimgs)
             logger.info(self, 'lattice sum = %d cells', len(self.get_lattice_Ls()))
             logger.info(self, 'precision = %g', self.precision)
             logger.info(self, 'pseudo = %s', self.pseudo)
             if ke_cutoff is not None:
@@ -1704,14 +1688,31 @@
         if isinstance(abs_kpts, libkpts.KPoints):
             if kpts_in_ibz:
                 return abs_kpts.kpts_scaled_ibz
             else:
                 return abs_kpts.kpts_scaled
         return 1./(2*np.pi)*np.dot(abs_kpts, self.lattice_vectors().T)
 
+    def cutoff_to_mesh(self, ke_cutoff):
+        '''Convert KE cutoff to FFT-mesh
+
+        Args:
+            ke_cutoff : float
+                KE energy cutoff in a.u.
+
+        Returns:
+            mesh : (3,) array
+        '''
+        a = self.lattice_vectors()
+        dim = self.dimension
+        mesh = pbctools.cutoff_to_mesh(a, ke_cutoff)
+        if dim < 2 or (dim == 2 and self.low_dim_ft_type == 'inf_vacuum'):
+            mesh[dim:] = self.mesh[dim:]
+        return mesh
+
     make_kpts = get_kpts = make_kpts
 
     def copy(self):
         return copy(self)
 
     pack = pack
```

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/ecp.py` & `pyscf-2.3.0/pyscf/pbc/gto/ecp.py`

 * *Files 16% similar despite different names*

```diff
@@ -21,43 +21,38 @@
 '''
 
 from functools import reduce
 import copy
 import numpy
 from pyscf import lib
 from pyscf.pbc import gto
-from pyscf.gto import AS_ECPBAS_OFFSET, AS_NECPBAS
+from pyscf.gto import PTR_EXP, AS_ECPBAS_OFFSET, AS_NECPBAS
 
 
 def ecp_int(cell, kpts=None):
     from pyscf.pbc.df import incore
+    lib.logger.debug(cell, 'PBC-ECP integrals')
     if kpts is None:
         kpts_lst = numpy.zeros((1,3))
     else:
         kpts_lst = numpy.reshape(kpts, (-1,3))
 
     cell, contr_coeff = gto.cell._split_basis(cell)
     lib.logger.debug1(cell, 'nao %d -> nao %d', *(contr_coeff.shape))
 
     ecpcell = copy.copy(cell)
-    # append a fictitious s function to mimic the auxiliary index in pbc.incore.
-    # ptr2last_env_idx to force PBCnr3c_fill_* function to copy the entire "env"
-    ptr2last_env_idx = len(cell._env) - 1
-    ecpbas = numpy.vstack([[0, 0, 1, 1, 0, ptr2last_env_idx, 0, 0],
-                           cell._ecpbas]).astype(numpy.int32)
-    ecpcell._bas = ecpbas
-    # In pbc.incore _ecpbas is appended to the cell._bas and the
-    # fictitious s function.
-    cell._env[AS_ECPBAS_OFFSET] = cell.nbas + 1
+    # append a fake s function to mimic the auxiliary index in pbc.incore.
+    exp_ptr = cell._ecpbas[-1,PTR_EXP]
+    ecpcell._bas = numpy.array([[0, 0, 1, 1, 0, exp_ptr, 0, 0]], dtype=numpy.int32)
+    # _env[AS_ECPBAS_OFFSET] is to be determined in pbc.incore
     cell._env[AS_NECPBAS] = len(cell._ecpbas)
-    # shls_slice of auxiliary index (0,1) corresponds to the fictitious s function
+    # shls_slice of auxiliary index (0,1) corresponds to the fake s function
     shls_slice = (0, cell.nbas, 0, cell.nbas, 0, 1)
 
-    dfbuilder = incore._Int3cBuilder(cell, ecpcell, kpts_lst).build()
-    print(dfbuilder.supmol.nbas)
+    dfbuilder = incore.Int3cBuilder(cell, ecpcell, kpts_lst).build()
     int3c = dfbuilder.gen_int3c_kernel('ECPscalar', aosym='s2', comp=1,
                                        j_only=True, return_complex=True)
     buf = int3c(shls_slice)
     buf = buf.reshape(len(kpts_lst),-1)
     mat = []
     for k, kpt in enumerate(kpts_lst):
         v = lib.unpack_tril(buf[k], lib.HERMITIAN)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/eval_gto.py` & `pyscf-2.3.0/pyscf/pbc/gto/eval_gto.py`

 * *Files 26% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
 # Author: Qiming Sun <osirpt.sun@gmail.com>
 #
 
 import ctypes
-import numpy
+import numpy as np
 from pyscf import lib
 from pyscf.gto import moleintor
 from pyscf.gto.eval_gto import _get_intor_and_comp, BLKSIZE
 from pyscf.pbc.gto import _pbcintor
 from pyscf import __config__
 
 EXTRA_PREC = getattr(__config__, 'pbc_gto_eval_gto_extra_precision', 1e-2)
@@ -93,57 +93,52 @@
     '''
     if eval_name[:3] == 'PBC':  # PBCGTOval_xxx
         eval_name, comp = _get_intor_and_comp(cell, eval_name[3:], comp)
     else:
         eval_name, comp = _get_intor_and_comp(cell, eval_name, comp)
     eval_name = 'PBC' + eval_name
 
-    atm = numpy.asarray(cell._atm, dtype=numpy.int32, order='C')
-    bas = numpy.asarray(cell._bas, dtype=numpy.int32, order='C')
-    env = numpy.asarray(cell._env, dtype=numpy.double, order='C')
+    atm = np.asarray(cell._atm, dtype=np.int32, order='C')
+    bas = np.asarray(cell._bas, dtype=np.int32, order='C')
+    env = np.asarray(cell._env, dtype=np.double, order='C')
     natm = atm.shape[0]
     nbas = bas.shape[0]
     if kpts is None:
         if kpt is not None:
-            kpts_lst = numpy.reshape(kpt, (1,3))
+            kpts_lst = np.reshape(kpt, (1,3))
         else:
-            kpts_lst = numpy.zeros((1,3))
+            kpts_lst = np.zeros((1,3))
     else:
-        kpts_lst = numpy.reshape(kpts, (-1,3))
+        kpts_lst = np.reshape(kpts, (-1,3))
     nkpts = len(kpts_lst)
     ngrids = len(coords)
 
     if non0tab is None:
-        non0tab = numpy.empty(((ngrids+BLKSIZE-1)//BLKSIZE, nbas),
-                              dtype=numpy.uint8)
+        non0tab = np.empty(((ngrids+BLKSIZE-1)//BLKSIZE, nbas),
+                              dtype=np.uint8)
 # non0tab stores the number of images to be summed in real space.
 # Initializing it to 255 means all images should be included
         non0tab[:] = 0xff
 
     if ao_loc is None:
         ao_loc = moleintor.make_loc(bas, eval_name)
     if shls_slice is None:
         shls_slice = (0, nbas)
     sh0, sh1 = shls_slice
     nao = ao_loc[sh1] - ao_loc[sh0]
 
-    out = numpy.empty((nkpts,comp,nao,ngrids), dtype=numpy.complex128)
-    coords = numpy.asarray(coords, order='F')
+    out = np.empty((nkpts,comp,nao,ngrids), dtype=np.complex128)
+    coords = np.asarray(coords, order='F')
 
-    # For atoms near the boundary of the cell, it is necessary (even in low-
-    # dimensional systems) to include lattice translations in all 3 dimensions.
-    if Ls is None:
-        if cell.dimension < 2 or cell.low_dim_ft_type == 'inf_vacuum':
-            Ls = cell.get_lattice_Ls(dimension=cell.dimension)
-        else:
-            Ls = cell.get_lattice_Ls(dimension=3)
-        Ls = Ls[numpy.argsort(lib.norm(Ls, axis=1))]
-    expLk = numpy.exp(1j * numpy.asarray(numpy.dot(Ls, kpts_lst.T), order='C'))
     if rcut is None:
         rcut = _estimate_rcut(cell)
+    if Ls is None:
+        Ls = get_lattice_Ls(cell, rcut=rcut.max())
+        Ls = Ls[np.argsort(lib.norm(Ls, axis=1), kind='stable')]
+    expLk = np.exp(1j * np.asarray(np.dot(Ls, kpts_lst.T), order='C'))
 
     with cell.with_integral_screen(cutoff):
         drv = getattr(libpbc, eval_name)
         drv(ctypes.c_int(ngrids),
             (ctypes.c_int*2)(*shls_slice), ao_loc.ctypes.data_as(ctypes.c_void_p),
             Ls.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(len(Ls)),
             expLk.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(nkpts),
@@ -155,48 +150,104 @@
             bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(nbas),
             env.ctypes.data_as(ctypes.c_void_p))
 
     ao_kpts = []
     for k, kpt in enumerate(kpts_lst):
         v = out[k]
         if abs(kpt).sum() < 1e-9:
-            v = numpy.asarray(v.real, order='C')
+            v = np.asarray(v.real, order='C')
         v = v.transpose(0,2,1)
         if comp == 1:
             v = v[0]
         ao_kpts.append(v)
 
-    if kpts is None or numpy.shape(kpts) == (3,):  # A single k-point
+    if kpts is None or np.shape(kpts) == (3,):  # A single k-point
         ao_kpts = ao_kpts[0]
     return ao_kpts
 
 pbc_eval_gto = eval_gto
 
 def _estimate_rcut(cell):
     '''Cutoff raidus, above which each shell decays to a value less than the
     required precsion'''
-    log_prec = numpy.log(cell.precision * EXTRA_PREC)
+    vol = cell.vol
+    weight_penalty = vol # ~ V[r] * (vol/ngrids) * ngrids
+    precision = cell.precision / max(weight_penalty, 1)
     rcut = []
     for ib in range(cell.nbas):
         l = cell.bas_angular(ib)
         es = cell.bas_exp(ib)
-        cs = abs(cell.bas_ctr_coeff(ib)).max(axis=1)
-        r = 5.
-        r = (((l+2)*numpy.log(r)+numpy.log(cs) - log_prec) / es)**.5
-        r[r < 1.] = 1.
-        r = (((l+2)*numpy.log(r)+numpy.log(cs) - log_prec) / es)**.5
+        cs = abs(cell._libcint_ctr_coeff(ib)).max(axis=1)
+        norm_ang = ((2*l+1)/(4*np.pi))**.5
+        fac = 2*np.pi/vol * cs*norm_ang/es / precision
+        r = cell.rcut
+        r = (np.log(fac * r**(l+1) + 1.) / es)**.5
+        r = (np.log(fac * r**(l+1) + 1.) / es)**.5
         rcut.append(r.max())
-    return numpy.array(rcut)
+    return np.array(rcut)
 
+def get_lattice_Ls(cell, nimgs=None, rcut=None, dimension=None, discard=True):
+    '''Get lattice-sum vectors for eval_gto
+    '''
+    if dimension is None:
+        # For atoms near the boundary of the cell, it is necessary (even in low-
+        # dimensional systems) to include lattice translations in all 3 dimensions.
+        if cell.dimension < 2 or cell.low_dim_ft_type == 'inf_vacuum':
+            dimension = cell.dimension
+        else:
+            dimension = 3
+    if rcut is None:
+        rcut = cell.rcut
 
-if __name__ == '__main__':
-    from pyscf.pbc import gto
-    cell = gto.M(a=numpy.eye(3)*4, atom='He 1 1 1', basis=[[2,(1,.5),(.5,.5)]])
-    coords = cell.get_uniform_grids([10]*3)
-    ao_value = eval_gto(cell, "GTOval_sph", coords, kpts=cell.make_kpts([3]*3))
-    print(lib.finger(numpy.asarray(ao_value)) - (-0.27594803231989179+0.0064644591759109114j))
-
-    cell = gto.M(a=numpy.eye(3)*4, atom='He 1 1 1', basis=[[2,(1,.5),(.5,.5)]])
-    coords = cell.get_uniform_grids([10]*3)
-    ao_value = eval_gto(cell, "GTOval_ip_cart", coords, kpts=cell.make_kpts([3]*3))
-    print(lib.finger(numpy.asarray(ao_value)) - (0.38051517609460028+0.062526488684770759j))
+    if dimension == 0 or rcut <= 0:
+        return np.zeros((1, 3))
 
+    a = cell.lattice_vectors()
+    atom_coords = cell.atom_coords()
+    scaled_atom_coords = np.linalg.solve(a.T, atom_coords.T).T
+    atom_boundary_max = scaled_atom_coords[:,:dimension].max(axis=0)
+    atom_boundary_min = scaled_atom_coords[:,:dimension].min(axis=0)
+    atom_boundary_max[atom_boundary_max > 1] = 1
+    atom_boundary_min[atom_boundary_min <-1] = -1
+    atom_bound1 = np.diag(atom_boundary_max).dot(a[:dimension])
+    atom_bound2 = np.diag(atom_boundary_min).dot(a[:dimension])
+
+    def find_boundary(a):
+        aR = np.vstack([a, atom_bound1, atom_bound2])
+        r = np.linalg.qr(aR.T)[1]
+        ub = (rcut + abs(r[2,3:]).max()) / abs(r[2,2])
+        return ub
+
+    xb = find_boundary(a[[1,2,0]])
+    if dimension > 1:
+        yb = find_boundary(a[[2,0,1]])
+    else:
+        yb = 0
+    if dimension > 2:
+        zb = find_boundary(a)
+    else:
+        zb = 0
+    bounds = np.ceil([xb, yb, zb]).astype(int)
+    Ts = lib.cartesian_prod((np.arange(-bounds[0], bounds[0]+1),
+                             np.arange(-bounds[1], bounds[1]+1),
+                             np.arange(-bounds[2], bounds[2]+1)))
+    Ls = np.dot(Ts[:,:dimension], a[:dimension])
+
+    # grids with wrap_around: grids_edge ~ [-.5, .5]
+    # regular grids: grids_edge ~ [0, 1]
+    grids_edge = lib.cartesian_prod([[-.5, 1.]] * dimension).dot(a[:dimension])
+    edge_lb = grids_edge.min(axis=0)
+    edge_ub = grids_edge.max(axis=0)
+
+    grids2atm = Ls + atom_coords[:,None,:]
+    edge_filter1 = grids2atm > edge_lb
+    edge_filter2 = grids2atm < edge_ub
+    grids2atm[~edge_filter1[:,:,0],0] -= edge_lb[0]
+    grids2atm[~edge_filter1[:,:,1],1] -= edge_lb[1]
+    grids2atm[~edge_filter1[:,:,2],2] -= edge_lb[2]
+    grids2atm[~edge_filter2[:,:,0],0] -= edge_ub[0]
+    grids2atm[~edge_filter2[:,:,1],1] -= edge_ub[1]
+    grids2atm[~edge_filter2[:,:,2],2] -= edge_ub[2]
+    grids2atm[edge_filter1 & edge_filter2] = 0.
+    Ls_mask = (np.linalg.norm(grids2atm, axis=2) < rcut).any(axis=0)
+    Ls = Ls[Ls_mask]
+    return np.asarray(Ls, order='C')
```

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/__init__.py` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-blyp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-blyp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-bp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-bp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-hcth120.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-hcth120.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-hcth407.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-hcth407.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-hf-rev.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-hf-rev.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-hf.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-hf.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-olyp.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-olyp.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-pade.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-pade.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-pbe.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-pbe.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/gth-pbesol.dat` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/gth-pbesol.dat`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/parse_cp2k.py` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/parse_cp2k.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/pp.py` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/pp.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/pp_int.py` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/pp_int.py`

 * *Files 1% similar despite different names*

```diff
@@ -103,16 +103,16 @@
                                   (cell.low_dim_ft_type, cell.dimension))
     return vlocG
 
 # part2 Vnuc - Vloc
 def get_pp_loc_part2(cell, kpts=None):
     '''PRB, 58, 3641 Eq (1), integrals associated to C1, C2, C3, C4
     '''
-    from pyscf.pbc.df.incore import _IntNucBuilder
-    vpploc = _IntNucBuilder(cell, kpts).get_pp_loc_part2()
+    from pyscf.pbc.df.aft import _IntPPBuilder
+    vpploc = _IntPPBuilder(cell, kpts).get_pp_loc_part2()
     if kpts is None or numpy.shape(kpts) == (3,):
         vpploc = vpploc[0]
     return vpploc
 
 def get_pp_nl(cell, kpts=None):
     if kpts is None:
         kpts_lst = numpy.zeros((1,3))
```

### Comparing `pyscf-2.2.1/pyscf/pbc/gto/pseudo/split_GTH_POTENTIALS.py` & `pyscf-2.3.0/pyscf/pbc/gto/pseudo/split_GTH_POTENTIALS.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gw/gw_slow.py` & `pyscf-2.3.0/pyscf/pbc/gw/gw_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gw/kgw_slow.py` & `pyscf-2.3.0/pyscf/pbc/gw/kgw_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gw/kgw_slow_supercell.py` & `pyscf-2.3.0/pyscf/pbc/gw/kgw_slow_supercell.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gw/krgw_ac.py` & `pyscf-2.3.0/pyscf/pbc/gw/krgw_ac.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gw/krgw_cd.py` & `pyscf-2.3.0/pyscf/pbc/gw/krgw_cd.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/gw/kugw_ac.py` & `pyscf-2.3.0/pyscf/pbc/gw/kugw_ac.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/lib/__init__.py` & `pyscf-2.3.0/pyscf/pbc/lib/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/lib/arnoldi.py` & `pyscf-2.3.0/pyscf/pbc/lib/arnoldi.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/lib/chkfile.py` & `pyscf-2.3.0/pyscf/pbc/lib/chkfile.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/lib/kpts.py` & `pyscf-2.3.0/pyscf/pbc/lib/kpts.py`

 * *Files 1% similar despite different names*

```diff
@@ -55,14 +55,15 @@
         if kpts.verbose >= logger.WARN:
             logger.warn(kpts, 'k-points have lower symmetry than lattice.')
 
     bz2bz_k = -np.ones(nkpts+1, dtype=int)
     ibz2bz_k = []
     for k in range(nkpts-1, -1, -1):
         if bz2bz_k[k] == -1:
+            # Note:, bz2bz_ks[k] has duplicated index
             bz2bz_k[bz2bz_ks[k]] = k
             ibz2bz_k.append(k)
     ibz2bz_k = np.array(ibz2bz_k[::-1])
     bz2bz_k = bz2bz_k[:-1].copy()
 
     bz2ibz_k = np.empty(nkpts, int)
     bz2ibz_k[ibz2bz_k] = np.arange(len(ibz2bz_k))
```

### Comparing `pyscf-2.2.1/pyscf/pbc/lib/kpts_helper.py` & `pyscf-2.3.0/pyscf/pbc/lib/kpts_helper.py`

 * *Files 6% similar despite different names*

```diff
@@ -54,19 +54,40 @@
     kpts_fbz = kpts_fbz.round(decimal)
     kpts_fbz = np.mod(kpts_fbz, 1)
     if wrap_around:
         kpts_fbz[kpts_fbz >= 0.5] -= 1.0
     return kpts_fbz.reshape(shape)
 
 def member(kpt, kpts):
-    kpts = np.reshape(kpts, (len(kpts),kpt.size))
-    dk = abs(kpts-kpt.ravel()).max(axis=1)
-    return np.where(dk < KPT_DIFF_TOL)[0]
+    '''Return the indices of the common k-points in kpts'''
+    assert kpts.ndim == kpt.ndim + 1
+    dk = abs(kpts.reshape(-1,kpt.size) - kpt.ravel()).max(axis=1)
+    idx = np.where(dk < KPT_DIFF_TOL)[0]
+    if idx.size > 0:
+        idx = np.unique(idx)
+    return idx
+
+def intersection(kpts1, kpts2):
+    '''Return the indices of the common k-points in kpts1'''
+    assert kpts1.ndim == kpts2.ndim == 2
+    dk = abs(kpts1[:,None] - kpts2).max(axis=2)
+    idx = np.where(dk < KPT_DIFF_TOL)[0]
+    if idx.size > 0:
+        idx = np.unique(idx)
+    return idx
 
 def unique(kpts):
+    '''
+    Find the unique k-points
+
+    Returns the sorted unique k-points, the indices of the input that give the
+    unique elements, and the indices of the unique k-points that reconstruct the
+    input.
+    '''
+
     kpts = np.asarray(kpts)
     try:
         digits = int(-np.log10(KPT_DIFF_TOL))
         uniq_index, uniq_inverse = np.unique(
             kpts.round(digits), return_index=True, return_inverse=True, axis=0)[1:3]
         idx = uniq_index.argsort()
         rank = idx.argsort()
@@ -96,15 +117,30 @@
     scaled_kpts[scaled_kpts >= .5] -= 1
     scaled_kpts[scaled_kpts < -.5] += 1
 
     uniq_index, uniq_inverse = unique(scaled_kpts)[1:3]
     uniq_kpts = kpts[uniq_index]
     return uniq_kpts, uniq_index, uniq_inverse
 
-def group_by_conj_pairs(cell, kpts, wrap_around=True):
+def members_with_wrap_around(cell, kpts, test_kpts):
+    '''Search the indices of kpts in first Brillouin zone.
+    [where(k==test_kpts) for k in kpts]
+
+    kpts : array_like
+        kpts to index
+    test_kpts : array_like
+        The values against which to index each value of `kpts`.
+    '''
+    scaled_kpts = cell.get_scaled_kpts(kpts)
+    scaled_db = cell.get_scaled_kpts(test_kpts)
+    dk = scaled_kpts[:,None] - scaled_db
+    idx, idy = np.where(abs(np.modf(dk)[0]).max(axis=2) < KPT_DIFF_TOL)
+    return np.asarray(idy[idx.argsort()], dtype=np.int32)
+
+def group_by_conj_pairs(cell, kpts, wrap_around=True, return_kpts_pairs=True):
     '''Find all conjugation k-point pairs in the input kpts.
     This function lables three types of conjugation.
     1. self-conjugated. The two index in idx_pairs have the same value.
     2. conjugated to the k-point within the input kpts. The indices of conjugated
     k-points are held in idx_pairs.
     3. conjugated to the k-point not inside the input kpts. The record is (index, None).
     '''
@@ -136,21 +172,69 @@
         if conj_idx.size == 0:
             # conjugated k-point not in the kpts set
             idx_pairs.append((k, None))
         else:
             seen[conj_idx[0]] = True
             idx_pairs.append((k, conj_idx[0]))
 
-    kpts_pairs = []
-    for i, j in idx_pairs:
-        if j is None:
-            kpts_pairs.append((kpts[i], None))
+    if return_kpts_pairs:
+        kpts_pairs = []
+        for i, j in idx_pairs:
+            if j is None:
+                kpts_pairs.append((kpts[i], None))
+            else:
+                kpts_pairs.append((kpts[i], kpts[j]))
+        return idx_pairs, kpts_pairs
+    else:
+        return idx_pairs
+
+def kk_adapted_iter(cell, kpts, kk_idx=None, time_reversal_symmetry=True):
+    '''Generates kpt which is adapted to the kpt_p in (ij|p)'''
+    if kk_idx is not None and time_reversal_symmetry:
+        raise NotImplementedError('Time reversal symmetry with custom ki-kj pairs')
+
+    log = lib.logger.new_logger(cell)
+    nkpts = len(kpts)
+    dk = (kpts[None,:,:] - kpts[:,None,:]).reshape(-1, 3)
+    if kk_idx is not None:
+        dk = dk[kk_idx]
+    uniq_kpts, uniq_index, uniq_inverse = unique_with_wrap_around(cell, dk)
+    scaled_kpts = cell.get_scaled_kpts(uniq_kpts).round(5)
+    log.debug('Num uniq kpts %d', len(uniq_kpts))
+    k_conj_groups = group_by_conj_pairs(cell, uniq_kpts, return_kpts_pairs=False)
+    for k, k_conj in k_conj_groups:
+        self_conj = k == k_conj
+        if kk_idx is None:
+            kpt_ij_idx = np.where(uniq_inverse == k)[0]
+            assert k_conj is not None
+        else:
+            kpt_ij_idx = kk_idx[uniq_inverse == k]
+        kpt_ij_idx = np.asarray(kpt_ij_idx, dtype=np.int32)
+        kpti_idx = kpt_ij_idx // nkpts
+        kptj_idx = kpt_ij_idx % nkpts
+        log.debug1('ft_ao_pair for scaled kpt = %s', scaled_kpts[k])
+        log.debug2('ft_ao_pair for kpti_idx = %s', kpti_idx)
+        log.debug2('ft_ao_pair for kptj_idx = %s', kptj_idx)
+        yield uniq_kpts[k], kpti_idx, kptj_idx, self_conj
+
+        if self_conj or k_conj is None or time_reversal_symmetry:
+            continue
+
+        # For time-reversal symmetry
+        if kk_idx is None:
+            kpt_ij_idx = np.where(uniq_inverse == k_conj)[0]
         else:
-            kpts_pairs.append((kpts[i], kpts[j]))
-    return idx_pairs, kpts_pairs
+            kpt_ij_idx = kk_idx[uniq_inverse == k_conj]
+        kpt_ij_idx = np.asarray(kpt_ij_idx, dtype=np.int32)
+        kpti_idx = kpt_ij_idx // nkpts
+        kptj_idx = kpt_ij_idx % nkpts
+        log.debug1('ft_ao_pair for scaled kpt = %s', scaled_kpts[k_conj])
+        log.debug2('ft_ao_pair for kpti_idx = %s', kpti_idx)
+        log.debug2('ft_ao_pair for kptj_idx = %s', kptj_idx)
+        yield uniq_kpts[k_conj], kpti_idx, kptj_idx, self_conj
 
 def loop_kkk(nkpts):
     range_nkpts = range(nkpts)
     return itertools.product(range_nkpts, range_nkpts, range_nkpts)
 
 def conj_mapping(cell, kpts):
     '''Find the mapping index: -kpts = kpts[index]'''
```

### Comparing `pyscf-2.2.1/pyscf/pbc/lib/ktensor.py` & `pyscf-2.3.0/pyscf/pbc/lib/ktensor.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/lib/linalg_helper.py` & `pyscf-2.3.0/pyscf/pbc/lib/linalg_helper.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mp/__init__.py` & `pyscf-2.3.0/pyscf/pbc/mp/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mp/kmp2.py` & `pyscf-2.3.0/pyscf/pbc/mp/kmp2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mp/kmp2_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/mp/kmp2_ksymm.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mp/kmp2_stagger.py` & `pyscf-2.3.0/pyscf/pbc/mp/kmp2_stagger.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mp/kump2.py` & `pyscf-2.3.0/pyscf/pbc/mp/kump2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mp/mp2.py` & `pyscf-2.3.0/pyscf/pbc/mp/mp2.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpicc/__init__.py` & `pyscf-2.3.0/pyscf/pbc/mpicc/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpicc/kccsd_rhf.py` & `pyscf-2.3.0/pyscf/pbc/mpicc/kccsd_rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpicc/kintermediates_rhf.py` & `pyscf-2.3.0/pyscf/pbc/mpicc/kintermediates_rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpicc/mpi_kpoint_helper.py` & `pyscf-2.3.0/pyscf/pbc/mpicc/mpi_kpoint_helper.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpitools/__init__.py` & `pyscf-2.3.0/pyscf/pbc/mpitools/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpitools/mpi.py` & `pyscf-2.3.0/pyscf/pbc/mpitools/mpi.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpitools/mpi_blksize.py` & `pyscf-2.3.0/pyscf/pbc/mpitools/mpi_blksize.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpitools/mpi_helper.py` & `pyscf-2.3.0/pyscf/pbc/mpitools/mpi_helper.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpitools/mpi_load_balancer.py` & `pyscf-2.3.0/pyscf/pbc/mpitools/mpi_load_balancer.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/mpitools/mpi_pool.py` & `pyscf-2.3.0/pyscf/pbc/mpitools/mpi_pool.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/__init__.py` & `pyscf-2.3.0/pyscf/pbc/scf/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/_response_functions.py` & `pyscf-2.3.0/pyscf/pbc/scf/_response_functions.py`

 * *Files 2% similar despite different names*

```diff
@@ -46,21 +46,16 @@
             dm0 = mf.make_rdm1(mo_coeff, mo_occ)
             return multigrid._gen_rhf_response(mf, dm0, singlet, hermi)
 
         if singlet is None:  # for newton solver
             rho0, vxc, fxc = ni.cache_xc_kernel(cell, mf.grids, mf.xc, mo_coeff,
                                                 mo_occ, 0, kpts)
         else:
-            if isinstance(mo_occ, numpy.ndarray):
-                mo_occ = mo_occ*.5
-            else:
-                mo_occ = [x*.5 for x in mo_occ]
-            rho0, vxc, fxc = ni.cache_xc_kernel(cell, mf.grids, mf.xc,
-                                                [mo_coeff]*2, [mo_occ]*2,
-                                                spin=1, kpts=kpts)
+            rho0, vxc, fxc = ni.cache_xc_kernel(cell, mf.grids, mf.xc, mo_coeff,
+                                                mo_occ, 1, kpts)
         dm0 = None #mf.make_rdm1(mo_coeff, mo_occ)
 
         if max_memory is None:
             mem_now = lib.current_memory()[0]
             max_memory = max(2000, mf.max_memory*.8-mem_now)
 
         if singlet is None:  # Without specify singlet, general case
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/addons.py` & `pyscf-2.3.0/pyscf/pbc/scf/addons.py`

 * *Files 4% similar despite different names*

```diff
@@ -25,14 +25,15 @@
 import scipy.optimize
 from pyscf import lib
 from pyscf.pbc import gto as pbcgto
 from pyscf.pbc import tools
 from pyscf.lib import logger
 from pyscf.scf import addons as mol_addons
 from pyscf.pbc.lib.kpts import KPoints
+from pyscf.pbc.tools import k2gamma
 from pyscf import __config__
 
 SMEARING_METHOD = getattr(__config__, 'pbc_scf_addons_smearing_method', 'fermi')
 
 
 def project_mo_nr2nr(cell1, mo1, cell2, kpts=None):
     r''' Project orbital coefficients
@@ -44,34 +45,50 @@
         |\psi2> = P |\psi1> = |AO2>S^{-1}<AO2| AO1> C1 = |AO2> C2
 
         C2 = S^{-1}<AO2|AO1> C1
     '''
     s22 = cell2.pbc_intor('int1e_ovlp', hermi=1, kpts=kpts)
     s21 = pbcgto.intor_cross('int1e_ovlp', cell2, cell1, kpts=kpts)
     if kpts is None or numpy.shape(kpts) == (3,):  # A single k-point
-        return scipy.linalg.solve(s22, s21.dot(mo1), sym_pos=True)
+        return scipy.linalg.solve(s22, s21.dot(mo1), assume_a='pos')
     else:
         assert (len(kpts) == len(mo1))
-        return [scipy.linalg.solve(s22[k], s21[k].dot(mo1[k]), sym_pos=True)
+        return [scipy.linalg.solve(s22[k], s21[k].dot(mo1[k]), assume_a='pos')
                 for k, kpt in enumerate(kpts)]
 
+def project_dm_k2k(cell, dm, kpts1, kpts2):
+    '''Project density matrix from k-point mesh 1 to k-point mesh 2'''
+    bvk_mesh = k2gamma.kpts_to_kmesh(cell, kpts1)
+    Ls = k2gamma.translation_vectors_for_kmesh(cell, bvk_mesh, True)
+    c = _k2k_projection(kpts1, kpts2, Ls)
+    return lib.einsum('km,kuv->muv', c, dm)
+
+def _k2k_projection(kpts1, kpts2, Ls):
+    weight = 1. / len(Ls)
+    expRk1 = numpy.exp(1j*numpy.dot(Ls, kpts1.T))
+    expRk2 = numpy.exp(-1j*numpy.dot(Ls, kpts2.T))
+    c = expRk1.T.dot(expRk2) * weight
+    return (c*c.conj()).real.copy()
 
 def smearing_(mf, sigma=None, method=SMEARING_METHOD, mu0=None, fix_spin=False):
     '''Fermi-Dirac or Gaussian smearing'''
-    from pyscf.scf import uhf
+    from pyscf.scf import uhf, rohf
     from pyscf.scf import ghf
     from pyscf.pbc.scf import khf
     mf_class = mf.__class__
     is_uhf = isinstance(mf, uhf.UHF)
     is_ghf = isinstance(mf, ghf.GHF)
     is_rhf = (not is_uhf) and (not is_ghf)
     is_khf = isinstance(mf, khf.KSCF)
+    is_rohf = isinstance(mf, rohf.ROHF)
+    if is_rohf:
+        is_rhf = False
 
-    if fix_spin and not is_uhf:
-        raise KeyError("fix_spin only supports UHF.")
+    if fix_spin and not (is_uhf or is_rohf):
+        raise KeyError("fix_spin only supports UHF and ROHF.")
     if fix_spin and mu0 is not None:
         raise KeyError("fix_spin does not support fix mu0")
 
     def fermi_smearing_occ(m, mo_energy_kpts, sigma):
         occ = numpy.zeros_like(mo_energy_kpts)
         de = (mo_energy_kpts - m) / sigma
         occ[de<40] = 1./(numpy.exp(de[de<40])+1.)
@@ -89,14 +106,16 @@
         return mo_occ_kpts
 
     def get_occ(mo_energy_kpts=None, mo_coeff_kpts=None):
         '''Label the occupancies for each orbital for sampled k-points.
 
         This is a k-point version of scf.hf.SCF.get_occ
         '''
+        if is_rohf and fix_spin:
+            mo_energy_kpts=(mo_energy_kpts,mo_energy_kpts)
         kpts = getattr(mf, 'kpts', None)
         if isinstance(kpts, KPoints):
             mo_energy_kpts = kpts.transform_mo_energy(mo_energy_kpts)
 
         #mo_occ_kpts = mf_class.get_occ(mf, mo_energy_kpts, mo_coeff_kpts)
         if (mf.sigma == 0) or (not mf.sigma) or (not mf.smearing_method):
             mo_occ_kpts = mf_class.get_occ(mf, mo_energy_kpts, mo_coeff_kpts)
@@ -109,15 +128,15 @@
                 nkpts = len(kpts)
         else:
             nkpts = 1
         if isinstance(mf.mol, pbcgto.Cell):
             nelectron = mf.mol.tot_electrons(nkpts)
         else:
             nelectron = mf.mol.tot_electrons()
-        if is_uhf:
+        if is_uhf or (is_rohf and fix_spin):
             nocc = nelectron
             if fix_spin:
                 nocc = mf.nelec
                 mo_es = []
                 mo_es.append(numpy.hstack(mo_energy_kpts[0]))
                 mo_es.append(numpy.hstack(mo_energy_kpts[1]))
             else:
@@ -146,15 +165,15 @@
         if fix_spin:
             fermi = [mo_energy[0][nocc[0]-1], mo_energy[1][nocc[1]-1]]
         else:
             fermi = mo_energy[nocc-1]
         if mu0 is None:
             def nelec_cost_fn(m, _mo_es, _nelectron):
                 mo_occ_kpts = f_occ(m, _mo_es, sigma)
-                if is_rhf:
+                if is_rhf and not is_rohf:
                     mo_occ_kpts *= 2
                 return (mo_occ_kpts.sum() - _nelectron)**2
             if fix_spin:
                 mu = []
                 mo_occs = []
                 res = scipy.optimize.minimize(nelec_cost_fn, fermi[0], args=(mo_es[0], nocc[0]), method='Powell',
                                               options={'xtol': 1e-5, 'ftol': 1e-5, 'maxiter': 10000})
@@ -240,14 +259,16 @@
             else:
                 mo_occ_kpts = kpts.check_mo_occ_symmetry(mo_occ_kpts)
 
         if is_khf:
             tools.print_mo_energy_occ_kpts(mf,mo_energy_kpts,mo_occ_kpts,is_uhf)
         else:
             tools.print_mo_energy_occ(mf,mo_energy_kpts,mo_occ_kpts,is_uhf)
+        if is_rohf and fix_spin:
+            mo_occ_kpts=mo_occ_kpts[0]+mo_occ_kpts[1]
         return mo_occ_kpts
 
     def get_grad_tril(mo_coeff_kpts, mo_occ_kpts, fock):
         if is_khf:
             grad_kpts = []
             for k, mo in enumerate(mo_coeff_kpts):
                 f_mo = reduce(numpy.dot, (mo.T.conj(), fock[k], mo))
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/chkfile.py` & `pyscf-2.3.0/pyscf/pbc/scf/chkfile.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/cphf.py` & `pyscf-2.3.0/pyscf/pbc/scf/cphf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/ghf.py` & `pyscf-2.3.0/pyscf/pbc/scf/ghf.py`

 * *Files 7% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 
 '''
 Generalized Hartree-Fock for periodic systems at a single k-point
 '''
 
 import numpy as np
 import scipy.linalg
+from pyscf.lib import logger
 import pyscf.scf.ghf as mol_ghf
 from pyscf.pbc.scf import hf as pbchf
 from pyscf.pbc.scf import addons
 from pyscf.pbc.scf import chkfile  # noqa
 
 
 def get_jk(mf, cell=None, dm=None, hermi=0, kpt=None, kpts_band=None,
@@ -64,14 +65,16 @@
         _hermi = 0
     else:
         dms = np.stack((dmaa, dmbb))
         _hermi = 1
     nblocks, n_dm = dms.shape[:2]
     dms = dms.reshape(nblocks*n_dm, nao, nao)
 
+    if mf.rsjk:
+        logger.warn(mf, 'RSJK does not support GHF')
     j1, k1 = mf.with_df.get_jk(dms, _hermi, kpt, kpts_band, with_j, with_k,
                                exxdiv=mf.exxdiv)
 
     vj = vk = None
     if with_j:
         j1 = j1.reshape(nblocks,n_dm*nband,nao,nao)
         vj = np.zeros((n_dm*nband,nso,nso), j1.dtype)
@@ -130,27 +133,30 @@
             mo_energy : (nmo,) ndarray or a list of (nmo,) ndarray
                 Bands energies E_n(k)
             mo_coeff : (nao, nmo) ndarray or a list of (nao,nmo) ndarray
                 Band orbitals psi_n(k)
         '''
         raise NotImplementedError
 
-    def get_init_guess(self, cell=None, key='minao'):
-        if cell is None: cell = self.cell
-        dm = mol_ghf.GHF.get_init_guess(self, cell, key)
-        dm = pbchf.normalize_dm_(self, dm)
-        return dm
+    get_init_guess = pbchf.RHF.get_init_guess
+    init_guess_by_chkfile = mol_ghf.GHF.init_guess_by_chkfile
+    init_guess_by_minao = mol_ghf.GHF.init_guess_by_minao
+    init_guess_by_atom = mol_ghf.GHF.init_guess_by_atom
+    init_guess_by_huckel = mol_ghf.GHF.init_guess_by_huckel
 
     def convert_from_(self, mf):
         '''Convert given mean-field object to RHF/ROHF'''
         addons.convert_to_ghf(mf, self)
         return self
 
-    stability = None
-    nuc_grad_method = None
+    def x2c1e(self):
+        '''X2C with spin-orbit coupling effects in spin-orbital basis'''
+        from pyscf.pbc.x2c.x2c1e import x2c1e_gscf
+        return x2c1e_gscf(self)
+    x2c = sfx2c1e = x2c1e
 
 
 if __name__ == '__main__':
     from pyscf.pbc import gto
     from pyscf.pbc import scf
 
     cell = gto.Cell()
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/hf.py` & `pyscf-2.3.0/pyscf/pbc/scf/hf.py`

 * *Files 2% similar despite different names*

```diff
@@ -44,35 +44,37 @@
 from pyscf.pbc.lib.kpts_helper import gamma_point
 from pyscf import __config__
 
 
 def get_ovlp(cell, kpt=np.zeros(3)):
     '''Get the overlap AO matrix.
     '''
-    # Avoid pbcopt's prescreening in the lattice sum, for better accuracy
-    s = cell.pbc_intor('int1e_ovlp', hermi=0, kpts=kpt,
-                       pbcopt=lib.c_null_ptr())
+    precision = cell.precision * 1e-5
+    rcut = max(cell.rcut, gto.estimate_rcut(cell, precision))
+    with lib.temporary_env(cell, rcut=rcut, precision=precision):
+        # Avoid pbcopt's prescreening in the lattice sum, for better accuracy
+        s = cell.pbc_intor('int1e_ovlp', hermi=0, kpts=kpt,
+                           pbcopt=lib.c_null_ptr())
     s = lib.asarray(s)
     hermi_error = abs(s - np.rollaxis(s.conj(), -1, -2)).max()
     if hermi_error > cell.precision and hermi_error > 1e-12:
         logger.warn(cell, '%.4g error found in overlap integrals. '
                     'cell.precision  or  cell.rcut  can be adjusted to '
                     'improve accuracy.', hermi_error)
 
     cond = np.max(lib.cond(s))
-    if cond * cell.precision > 1e2:
-        prec = 1e2 / cond
-        rmin = max([cell.bas_rcut(ib, prec) for ib in range(cell.nbas)])
-        if cell.rcut < rmin:
-            logger.warn(cell, 'Singularity detected in overlap matrix.  '
-                        'Integral accuracy may be not enough.\n      '
-                        'You can adjust  cell.precision  or  cell.rcut  to '
-                        'improve accuracy.  Recommended values are\n      '
-                        'cell.precision = %.2g  or smaller.\n      '
-                        'cell.rcut = %.4g  or larger.', prec, rmin)
+    if cond * precision > 1e2:
+        prec = 1e7 / cond
+        rmin = gto.estimate_rcut(cell, prec*1e-5)
+        logger.warn(cell, 'Singularity detected in overlap matrix.  '
+                    'Integral accuracy may be not enough.\n      '
+                    'You can adjust  cell.precision  or  cell.rcut  to '
+                    'improve accuracy.  Recommended settings are\n      '
+                    'cell.precision < %.2g\n      '
+                    'cell.rcut > %.4g', prec, rmin)
     return s
 
 
 def get_hcore(cell, kpt=np.zeros(3)):
     '''Get the core Hamiltonian AO matrix.
     '''
     hcore = get_t(cell, kpt)
@@ -404,15 +406,15 @@
     b = np.linalg.inv(a).T
 
     grids = gen_grid.UniformGrids(cell)
     ke_cutoff = gto.estimate_ke_cutoff(cell, 1e-5)
     grids.mesh = tools.cutoff_to_mesh(a, ke_cutoff)
 
     dm = mf.make_rdm1()
-    rho = mf.get_rho(dm, grids, mf.kpt)
+    rho = mf.get_rho(dm, grids)
     origin = _search_dipole_gauge_origin(cell, grids, rho, log)
 
     def shift_grids(r):
         r_frac = lib.dot(r - origin, b.T)
         # Grids on the boundary (r_frac == +/-0.5) of the new cell may lead to
         # unbalanced contributions to the dipole moment. Exclude them from the
         # dipole and quadrupole
@@ -521,15 +523,15 @@
 
         self.with_df = df.FFTDF(cell)
         # Range separation JK builder
         self.rsjk = None
 
         self.exxdiv = exxdiv
         self.kpt = kpt
-        self.conv_tol = cell.precision * 10
+        self.conv_tol = max(cell.precision * 10, 1e-8)
 
         self._keys = self._keys.union(['cell', 'exxdiv', 'with_df', 'rsjk'])
 
     @property
     def kpt(self):
         if 'kpt' in self.__dict__:
             # To handle the attribute kpt loaded from chkfile
@@ -545,15 +547,19 @@
         if 'kpt' in self.__dict__:
             # To handle the attribute kpt loaded from chkfile
             self.kpt = self.__dict__.pop('kpt')
 
         if self.rsjk:
             if not np.all(self.rsjk.kpts == self.kpt):
                 self.rsjk = self.rsjk.__class__(cell, self.kpt.reshape(1,3))
-            self.rsjk.build(direct_scf_tol=self.direct_scf_tol)
+
+        # Let df.build() be called by get_jk function later on needs.
+        # DFT objects may need to initiailze df with different paramters.
+        #if self.with_df:
+        #    self.with_df.build()
 
         if self.verbose >= logger.WARN:
             self.check_sanity()
         return self
 
     def reset(self, cell=None):
         '''Reset cell and relevant attributes associated to the old cell object'''
@@ -582,15 +588,14 @@
         if not getattr(self.with_df, 'build', None):
             # .dump_flags() is called in pbc.df.build function
             self.with_df.dump_flags(verbose)
         return self
 
     def check_sanity(self):
         mol_hf.SCF.check_sanity(self)
-        self.with_df.check_sanity()
         if (isinstance(self.exxdiv, str) and self.exxdiv.lower() != 'ewald' and
             isinstance(self.with_df, df.df.DF)):
             logger.warn(self, 'exxdiv %s is not supported in DF or MDF',
                         self.exxdiv)
         return self
 
     def get_hcore(self, cell=None, kpt=None):
@@ -684,23 +689,16 @@
                  kpt=None, kpts_band=None):
         '''Hartree-Fock potential matrix for the given density matrix.
         See :func:`scf.hf.get_veff` and :func:`scf.hf.RHF.get_veff`
         '''
         if cell is None: cell = self.cell
         if dm is None: dm = self.make_rdm1()
         if kpt is None: kpt = self.kpt
-        if self.rsjk and self.direct_scf:
-            # Enable direct-SCF for real space JK builder
-            ddm = dm - dm_last
-            vj, vk = self.get_jk(cell, ddm, hermi, kpt, kpts_band)
-            vhf = vj - vk * .5
-            vhf += vhf_last
-        else:
-            vj, vk = self.get_jk(cell, dm, hermi, kpt, kpts_band)
-            vhf = vj - vk * .5
+        vj, vk = self.get_jk(cell, dm, hermi, kpt, kpts_band)
+        vhf = vj - vk * .5
         return vhf
 
     def get_jk_incore(self, cell=None, dm=None, hermi=1, kpt=None, omega=None,
                       **kwargs):
         '''Get Coulomb (J) and exchange (K) following :func:`scf.hf.RHF.get_jk_`.
 
         *Incore* version of Coulomb and exchange build only.
@@ -738,19 +736,15 @@
         '''Hook for dumping results and clearing up the object.'''
         mol_hf.SCF._finalize(self)
 
         if self.cell.charge != 0:
             makov_payne_correction(self)
         return self
 
-    def get_init_guess(self, cell=None, key='minao'):
-        if cell is None: cell = self.cell
-        dm = mol_hf.SCF.get_init_guess(self, cell, key)
-        dm = normalize_dm_(self, dm)
-        return dm
+    get_init_guess = mol_hf.SCF.get_init_guess
 
     def init_guess_by_1e(self, cell=None):
         if cell is None: cell = self.cell
         if cell.dimension < 3:
             logger.warn(self, 'Hcore initial guess is not recommended in '
                         'the SCF of low-dimensional systems.')
         return mol_hf.SCF.init_guess_by_1e(self, cell)
@@ -802,15 +796,18 @@
         '''Convert the input mean-field object to a UHF/UKS object'''
         return addons.convert_to_uhf(mf)
 
     def to_ghf(self, mf):
         '''Convert the input mean-field object to a GHF/GKS object'''
         return addons.convert_to_ghf(mf)
 
-    def nuc_grad_method(self, *args, **kwargs):
+    def stability(self):
+        raise NotImplementedError
+
+    def nuc_grad_method(self):
         raise NotImplementedError
 
     def jk_method(self, J='FFTDF', K=None):
         '''
         Set up the schemes to evaluate Coulomb and exchange matrix
 
         FFTDF: planewave density fitting using Fast Fourier Transform
@@ -829,19 +826,15 @@
         if 'DF' in J or 'DF' in K:
             if 'DF' in J and 'DF' in K:
                 assert J == K
             else:
                 df_method = J if 'DF' in J else K
                 self.with_df = getattr(df, df_method)(self.cell, self.kpt)
 
-        # For nuclear attraction
-        if ('RS' in J or 'RS' in K) and not self.with_df:
-            self.with_df = df.GDF(self.cell, self.kpt)
-
-        if J == 'RS' or K == 'RS':
+        if 'RS' in J or 'RS' in K:
             if not gamma_point(self.kpt):
                 raise NotImplementedError('Single k-point must be gamma point')
             self.rsjk = RangeSeparatedJKBuilder(self.cell, self.kpt)
             self.rsjk.verbose = self.verbose
 
         # For nuclear attraction
         if J == 'RS' and K == 'RS' and not isinstance(self.with_df, df.GDF):
@@ -860,14 +853,20 @@
     pbc-DFT method. It should be overwritten by the actual KohnShamDFT class
     when loading dft module.
     '''
 
 
 class RHF(SCF, mol_hf.RHF):
 
+    def get_init_guess(self, cell=None, key='minao'):
+        if cell is None: cell = self.cell
+        dm = SCF.get_init_guess(self, cell, key)
+        dm = normalize_dm_(self, dm)
+        return dm
+
     stability = mol_hf.RHF.stability
 
     def convert_from_(self, mf):
         '''Convert given mean-field object to RHF'''
         addons.convert_to_rhf(mf, self)
         return self
 
@@ -886,15 +885,15 @@
     Scale density matrix to make it produce the correct number of electrons.
     '''
     cell = mf.cell
     if isinstance(dm, np.ndarray) and dm.ndim == 2:
         ne = np.einsum('ij,ji->', dm, mf.get_ovlp(cell)).real
     else:
         ne = np.einsum('xij,ji->', dm, mf.get_ovlp(cell)).real
-    if abs(ne - cell.nelectron).sum() > 1e-7:
+    if abs(ne - cell.nelectron).sum() > 0.01:
         logger.debug(mf, 'Big error detected in the electron number '
                      'of initial guess density matrix (Ne/cell = %g)!\n'
                      '  This can cause huge error in Fock matrix and '
                      'lead to instability in SCF for low-dimensional '
                      'systems.\n  DM is normalized wrt the number '
                      'of electrons %s', ne, cell.nelectron)
         dm *= cell.nelectron / ne
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/kghf.py` & `pyscf-2.3.0/pyscf/pbc/scf/kghf.py`

 * *Files 10% similar despite different names*

```diff
@@ -19,14 +19,15 @@
 '''
 Generalized Hartree-Fock for periodic systems with k-point sampling
 '''
 
 from functools import reduce
 import numpy as np
 import scipy.linalg
+import pyscf.scf.hf as mol_hf  # noqa
 import pyscf.scf.ghf as mol_ghf  # noqa
 from pyscf import lib
 from pyscf.lib import logger
 from pyscf.pbc.scf import khf
 from pyscf.pbc.scf import ghf as pbcghf
 from pyscf.pbc.scf import addons
 from pyscf.pbc.df.df_jk import _format_jks
@@ -125,14 +126,27 @@
                          k, kpt[0], kpt[1], kpt[2],
                          mo_energy_kpts[k][mo_occ_kpts[k]> 0],
                          mo_energy_kpts[k][mo_occ_kpts[k]==0])
         np.set_printoptions(threshold=1000)
 
     return mo_occ_kpts
 
+def _cast_mol_init_guess(fn):
+    def fn_init_guess(mf, cell=None, kpts=None):
+        if cell is None: cell = mf.cell
+        if kpts is None: kpts = mf.kpts
+        dm = mol_ghf._from_rhf_init_dm(fn(cell))
+        nkpts = len(kpts)
+        dm_kpts = np.asarray([dm] * nkpts)
+        return dm_kpts
+    fn_init_guess.__name__ = fn.__name__
+    fn_init_guess.__doc__ = (
+        'Generates initial guess density matrix and the orbitals of the initial '
+        'guess DM ' + fn.__doc__)
+    return fn_init_guess
 
 class KGHF(pbcghf.GHF, khf.KSCF):
     '''GHF class for PBCs.
     '''
     def __init__(self, cell, kpts=np.zeros((1,3)),
                  exxdiv=getattr(__config__, 'pbc_scf_SCF_exxdiv', 'ewald')):
         khf.KSCF.__init__(self, cell, kpts, exxdiv)
@@ -188,43 +202,43 @@
             mo_energy : (nmo,) ndarray or a list of (nmo,) ndarray
                 Bands energies E_n(k)
             mo_coeff : (nao, nmo) ndarray or a list of (nao,nmo) ndarray
                 Band orbitals psi_n(k)
         '''
         raise NotImplementedError
 
-    get_init_guess = khf.KSCF.get_init_guess
-
     def _finalize(self):
         if self.converged:
             logger.note(self, 'converged SCF energy = %.15g', self.e_tot)
         else:
             logger.note(self, 'SCF not converged.')
             logger.note(self, 'SCF energy = %.15g after %d cycles',
                         self.e_tot, self.max_cycle)
         return self
 
     def convert_from_(self, mf):
         '''Convert given mean-field object to RHF/ROHF'''
         addons.convert_to_ghf(mf, self)
         return self
 
+    get_init_guess = khf.KRHF.get_init_guess
+    init_guess_by_minao = _cast_mol_init_guess(mol_hf.init_guess_by_minao)
+    init_guess_by_atom = _cast_mol_init_guess(mol_hf.init_guess_by_atom)
+    init_guess_by_chkfile = mol_ghf.init_guess_by_chkfile
+
     density_fit = khf.KSCF.density_fit
     rs_density_fit = khf.KSCF.rs_density_fit
     newton = khf.KSCF.newton
 
     def x2c1e(self):
         '''X2C with spin-orbit coupling effects in spin-orbital basis'''
         from pyscf.pbc.x2c.x2c1e import x2c1e_gscf
         return x2c1e_gscf(self)
-
     x2c = x2c1e
     sfx2c1e = khf.KSCF.sfx2c1e
-    stability = None
-    nuc_grad_method = None
 
 
 if __name__ == '__main__':
     from pyscf.pbc import gto
 
     cell = gto.Cell()
     cell.atom = '''
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/kghf_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/scf/kghf_ksymm.py`

 * *Files 2% similar despite different names*

```diff
@@ -174,16 +174,19 @@
             orbsym.append(orbsym_k)
         return orbsym
 
     orbsym = property(get_orbsym)
 
     get_jk = get_jk
     get_occ = get_occ
-    energy_elec = khf_ksymm.KsymAdaptedKSCF.energy_elec
-    get_init_guess = khf_ksymm.KsymAdaptedKSCF.get_init_guess
+    energy_elec = khf_ksymm.KsymAdaptedKRHF.energy_elec
+    get_init_guess = khf_ksymm.KsymAdaptedKRHF.get_init_guess
+    init_guess_by_minao = kghf.KGHF.init_guess_by_minao
+    init_guess_by_atom = kghf.KGHF.init_guess_by_atom
+    init_guess_by_chkfile = kghf.KGHF.init_guess_by_chkfile
 
 KGHF = KsymAdaptedKGHF
 
 if __name__ == "__main__":
     from pyscf.pbc import gto, scf
     cell = gto.Cell()
     cell.atom = '''
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/khf.py` & `pyscf-2.3.0/pyscf/pbc/scf/khf.py`

 * *Files 2% similar despite different names*

```diff
@@ -56,36 +56,15 @@
         kpts : (nkpts, 3) ndarray
 
     Returns:
         ovlp_kpts : (nkpts, nao, nao) ndarray
     '''
     if cell is None: cell = mf.cell
     if kpts is None: kpts = mf.kpts
-    # Avoid pbcopt's prescreening in the lattice sum, for better accuracy
-    s = cell.pbc_intor('int1e_ovlp', hermi=0, kpts=kpts,
-                       pbcopt=lib.c_null_ptr())
-    s = lib.asarray(s)
-    hermi_error = abs(s - s.conj().transpose(0,2,1)).max()
-    if hermi_error > cell.precision and hermi_error > 1e-12:
-        logger.warn(mf, '%.4g error found in overlap integrals. '
-                    'cell.precision  or  cell.rcut  can be adjusted to '
-                    'improve accuracy.', hermi_error)
-
-    cond = np.max(lib.cond(s))
-    if cond * cell.precision > 1e2:
-        prec = 1e2 / cond
-        rmin = max([cell.bas_rcut(ib, prec) for ib in range(cell.nbas)])
-        if cell.rcut < rmin:
-            logger.warn(mf, 'Singularity detected in overlap matrix.  '
-                        'Integral accuracy may be not enough.\n      '
-                        'You can adjust  cell.precision  or  cell.rcut  to '
-                        'improve accuracy.  Recommended values are\n      '
-                        'cell.precision = %.2g  or smaller.\n      '
-                        'cell.rcut = %.4g  or larger.', prec, rmin)
-    return s
+    return pbchf.get_ovlp(cell, kpts)
 
 
 def get_hcore(mf, cell=None, kpts=None):
     '''Get the core Hamiltonian AO matrices at sampled k-points.
 
     Args:
         kpts : (nkpts, 3) ndarray
@@ -249,17 +228,16 @@
 def make_rdm1(mo_coeff_kpts, mo_occ_kpts, **kwargs):
     '''One particle density matrices for all k-points.
 
     Returns:
         dm_kpts : (nkpts, nao, nao) ndarray
     '''
     nkpts = len(mo_occ_kpts)
-    dm_kpts = [mol_hf.make_rdm1(mo_coeff_kpts[k], mo_occ_kpts[k])
-               for k in range(nkpts)]
-    return lib.asarray(dm_kpts)
+    dm = [mol_hf.make_rdm1(mo_coeff_kpts[k], mo_occ_kpts[k]) for k in range(nkpts)]
+    return lib.tag_array(dm, mo_coeff=mo_coeff_kpts, mo_occ=mo_occ_kpts)
 
 
 def energy_elec(mf, dm_kpts=None, h1e_kpts=None, vhf_kpts=None):
     '''Following pyscf.scf.hf.energy_elec()
     '''
     if dm_kpts is None: dm_kpts = mf.make_rdm1()
     if h1e_kpts is None: h1e_kpts = mf.get_hcore()
@@ -341,14 +319,43 @@
                 e, c = scipy.linalg.eigh(f1)
                 mo1[:,idx] = np.dot(orb, c)
                 mo_e[idx] = e
         mo_coeff.append(mo1)
         mo_energy.append(mo_e)
     return mo_energy, mo_coeff
 
+def _cast_mol_init_guess(fn):
+    def fn_init_guess(mf, cell=None, kpts=None):
+        if cell is None: cell = mf.cell
+        if kpts is None: kpts = mf.kpts
+        dm = fn(cell)
+        nkpts = len(kpts)
+        dm_kpts = np.asarray([dm] * nkpts)
+        if hasattr(dm, 'mo_coeff'):
+            mo_coeff = [dm.mo_coeff] * nkpts
+            mo_occ = [dm.mo_occ] * nkpts
+            dm_kpts = lib.tag_array(dm_kpts, mo_coeff=mo_coeff, mo_occ=mo_occ)
+        return dm_kpts
+    fn_init_guess.__name__ = fn.__name__
+    fn_init_guess.__doc__ = (
+        'Generates initial guess density matrix and the orbitals of the initial '
+        'guess DM ' + fn.__doc__)
+    return fn_init_guess
+
+def init_guess_by_minao(cell, kpts=None):
+    '''Generates initial guess density matrix and the orbitals of the initial
+    guess DM based on ANO basis.
+    '''
+    return KSCF(cell).init_guess_by_minao(cell, kpts)
+
+def init_guess_by_atom(cell, kpts=None):
+    '''Generates initial guess density matrix and the orbitals of the initial
+    guess DM based on the superposition of atomic HF density matrix.
+    '''
+    return KSCF(cell).init_guess_by_atom(cell, kpts)
 
 def init_guess_by_chkfile(cell, chkfile_name, project=None, kpts=None):
     '''Read the KHF results from checkpoint file, then project it to the
     basis defined by ``cell``
 
     Returns:
         Density matrix, 3D ndarray
@@ -471,15 +478,15 @@
 
         self.with_df = df.FFTDF(cell)
         # Range separation JK builder
         self.rsjk = None
 
         self.exxdiv = exxdiv
         self.kpts = kpts
-        self.conv_tol = cell.precision * 10
+        self.conv_tol = max(cell.precision * 10, 1e-8)
 
         self.exx_built = False
         self._keys = self._keys.union(['cell', 'exx_built', 'exxdiv', 'with_df', 'rsjk'])
 
     @property
     def kpts(self):
         if 'kpts' in self.__dict__:
@@ -535,15 +542,14 @@
         if not getattr(self.with_df, 'build', None):
             # .dump_flags() is called in pbc.df.build function
             self.with_df.dump_flags(verbose)
         return self
 
     def check_sanity(self):
         mol_hf.SCF.check_sanity(self)
-        self.with_df.check_sanity()
         if (isinstance(self.exxdiv, str) and self.exxdiv.lower() != 'ewald' and
             isinstance(self.with_df, df.df.DF)):
             logger.warn(self, 'exxdiv %s is not supported in DF or MDF',
                         self.exxdiv)
         return self
 
     def build(self, cell=None):
@@ -555,67 +561,36 @@
         if 'kpts' in self.__dict__:
             # To handle the attribute kpts loaded from chkfile
             self.kpts = self.__dict__.pop('kpts')
 
         if self.rsjk:
             if not np.all(self.rsjk.kpts == self.kpts):
                 self.rsjk = self.rsjk.__class__(cell, self.kpts)
-            self.rsjk.build(direct_scf_tol=self.direct_scf_tol)
+
+        # Let df.build() be called by get_jk function later on needs.
+        # DFT objects may need to initiailze df with different paramters.
+        #if self.with_df:
+        #    self.with_df.build()
 
         if self.verbose >= logger.WARN:
             self.check_sanity()
         return self
 
-    def get_init_guess(self, cell=None, key='minao'):
-        if cell is None:
-            cell = self.cell
-        dm_kpts = None
-        key = key.lower()
-        if key == '1e' or key == 'hcore':
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif getattr(cell, 'natm', 0) == 0:
-            logger.info(self, 'No atom found in cell. Use 1e initial guess')
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif key == 'atom':
-            dm = self.init_guess_by_atom(cell)
-        elif key[:3] == 'chk':
-            try:
-                dm_kpts = self.from_chk()
-            except (IOError, KeyError):
-                logger.warn(self, 'Fail to read %s. Use MINAO initial guess',
-                            self.chkfile)
-                dm = self.init_guess_by_minao(cell)
-        else:
-            dm = self.init_guess_by_minao(cell)
-
-        if dm_kpts is None:
-            dm_kpts = lib.asarray([dm]*len(self.kpts))
-
-        ne = np.einsum('kij,kji->', dm_kpts, self.get_ovlp(cell)).real
-        # FIXME: consider the fractional num_electron or not? This maybe
-        # relate to the charged system.
-        nkpts = len(self.kpts)
-        nelectron = float(self.cell.tot_electrons(nkpts))
-        if abs(ne - nelectron) > 1e-7*nkpts:
-            logger.debug(self, 'Big error detected in the electron number '
-                         'of initial guess density matrix (Ne/cell = %g)!\n'
-                         '  This can cause huge error in Fock matrix and '
-                         'lead to instability in SCF for low-dimensional '
-                         'systems.\n  DM is normalized wrt the number '
-                         'of electrons %s', ne/nkpts, nelectron/nkpts)
-            dm_kpts *= (nelectron / ne).reshape(-1,1,1)
-        return dm_kpts
+    get_init_guess = pbchf.SCF.get_init_guess
 
     def init_guess_by_1e(self, cell=None):
         if cell is None: cell = self.cell
         if cell.dimension < 3:
             logger.warn(self, 'Hcore initial guess is not recommended in '
                         'the SCF of low-dimensional systems.')
         return mol_hf.SCF.init_guess_by_1e(self, cell)
 
+    init_guess_by_minao = _cast_mol_init_guess(mol_hf.init_guess_by_minao)
+    init_guess_by_atom = _cast_mol_init_guess(mol_hf.init_guess_by_atom)
+
     get_hcore = get_hcore
     get_ovlp = get_ovlp
     get_fock = get_fock
     get_occ = get_occ
     energy_elec = energy_elec
     get_fermi = get_fermi
 
@@ -647,22 +622,16 @@
     def get_veff(self, cell=None, dm_kpts=None, dm_last=0, vhf_last=0, hermi=1,
                  kpts=None, kpts_band=None):
         '''Hartree-Fock potential matrix for the given density matrix.
         See :func:`scf.hf.get_veff` and :func:`scf.hf.RHF.get_veff`
         '''
         if dm_kpts is None:
             dm_kpts = self.make_rdm1()
-        if self.rsjk and self.direct_scf:
-            # Enable direct-SCF for real space JK builder
-            ddm = dm_kpts - dm_last
-            vj, vk = self.get_jk(cell, ddm, hermi, kpts, kpts_band)
-            return vhf_last + vj - vk * .5
-        else:
-            vj, vk = self.get_jk(cell, dm_kpts, hermi, kpts, kpts_band)
-            return vj - vk * .5
+        vj, vk = self.get_jk(cell, dm_kpts, hermi, kpts, kpts_band)
+        return vj - vk * .5
 
     def analyze(self, verbose=None, with_meta_lowdin=WITH_META_LOWDIN,
                 **kwargs):
         if verbose is None: verbose = self.verbose
         return analyze(self, verbose, with_meta_lowdin, **kwargs)
 
     def get_grad(self, mo_coeff_kpts, mo_occ_kpts, fock=None):
@@ -854,14 +823,35 @@
         else:
             nkpts = len(self.kpts)
         if cell.spin != 0 and nkpts % 2 != 0:
             logger.warn(self, 'Problematic nelec %s and number of k-points %d '
                         'found in KRHF method.', cell.nelec, nkpts)
         return KSCF.check_sanity(self)
 
+    def get_init_guess(self, cell=None, key='minao'):
+        dm_kpts = pbchf.SCF.get_init_guess(self, cell, key)
+        nkpts = len(self.kpts)
+        if dm_kpts.ndim == 2:
+            # dm[nao,nao] at gamma point -> dm_kpts[nkpts,nao,nao]
+            dm_kpts = np.repeat(dm_kpts[None,:,:], nkpts, axis=0)
+
+        ne = np.einsum('kij,kji->', dm_kpts, self.get_ovlp(cell)).real
+        # FIXME: consider the fractional num_electron or not? This maybe
+        # relate to the charged system.
+        nelectron = float(self.cell.tot_electrons(nkpts))
+        if abs(ne - nelectron) > 0.01*nkpts:
+            logger.debug(self, 'Big error detected in the electron number '
+                         'of initial guess density matrix (Ne/cell = %g)!\n'
+                         '  This can cause huge error in Fock matrix and '
+                         'lead to instability in SCF for low-dimensional '
+                         'systems.\n  DM is normalized wrt the number '
+                         'of electrons %s', ne/nkpts, nelectron/nkpts)
+            dm_kpts *= (nelectron / ne).reshape(-1,1,1)
+        return dm_kpts
+
     def convert_from_(self, mf):
         '''Convert given mean-field object to KRHF'''
         addons.convert_to_rhf(mf, self)
         return self
 
     def nuc_grad_method(self):
         from pyscf.pbc.grad import krhf
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/khf_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/scf/khf_ksymm.py`

 * *Files 3% similar despite different names*

```diff
@@ -183,45 +183,25 @@
                         madelung*nelectron * -.5)
         logger.info(self, 'DF object = %s', self.with_df)
         if not getattr(self.with_df, 'build', None):
             self.with_df.dump_flags(verbose)
         return self
 
     def get_init_guess(self, cell=None, key='minao'):
-        if cell is None:
-            cell = self.cell
-        dm_kpts = None
-        key = key.lower()
-        if key == '1e' or key == 'hcore':
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif getattr(cell, 'natm', 0) == 0:
-            logger.info(self, 'No atom found in cell. Use 1e initial guess')
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif key == 'atom':
-            dm = self.init_guess_by_atom(cell)
-        elif key[:3] == 'chk':
-            try:
-                dm_kpts = self.from_chk()
-            except (IOError, KeyError):
-                logger.warn(self, 'Fail to read %s. Use MINAO initial guess',
-                            self.chkfile)
-                dm = self.init_guess_by_minao(cell)
-        else:
-            dm = self.init_guess_by_minao(cell)
-
-        if dm_kpts is None:
-            dm_kpts = lib.asarray([dm]*self.kpts.nkpts_ibz)
+        dm_kpts = khf.KSCF.get_init_guess(self, cell, key)
+        if dm_kpts.ndim == 2:
+            dm_kpts = np.asarray([dm_kpts]*self.kpts.nkpts_ibz)
+        elif len(dm_kpts) != self.kpts.nkpts_ibz:
+            dm_kpts = dm_kpts[self.kpts.ibz2bz]
 
         ne = np.einsum('k,kij,kji', self.kpts.weights_ibz, dm_kpts, self.get_ovlp(cell)).real
-        # FIXME: consider the fractional num_electron or not? This maybe
-        # relate to the charged system.
         nkpts = self.kpts.nkpts
         ne *= nkpts
         nelectron = float(self.cell.tot_electrons(nkpts))
-        if abs(ne - nelectron) > 1e-7*nkpts:
+        if abs(ne - nelectron) > 0.01*nkpts:
             logger.debug(self, 'Big error detected in the electron number '
                          'of initial guess density matrix (Ne/cell = %g)!\n'
                          '  This can cause huge error in Fock matrix and '
                          'lead to instability in SCF for low-dimensional '
                          'systems.\n  DM is normalized wrt the number '
                          'of electrons %s', ne/nkpts, nelectron/nkpts)
             dm_kpts *= (nelectron / ne).reshape(-1,1,1)
@@ -258,16 +238,19 @@
         if ndm != kpts.nkpts_ibz:
             raise RuntimeError("Number of input density matrices does not \
                                match the number of IBZ kpts: %d vs %d."
                                % (ndm, kpts.nkpts_ibz))
         dm_kpts = kpts.transform_dm(dm_kpts)
         if kpts_band is None: kpts_band = kpts.kpts_ibz
         cpu0 = (logger.process_clock(), logger.perf_counter())
-        vj, vk = self.with_df.get_jk(dm_kpts, hermi, kpts.kpts, kpts_band,
-                                     with_j, with_k, omega, exxdiv=self.exxdiv)
+        if self.rsjk:
+            raise NotImplementedError('rsjk with k-points symmetry')
+        else:
+            vj, vk = self.with_df.get_jk(dm_kpts, hermi, kpts.kpts, kpts_band,
+                                         with_j, with_k, omega, exxdiv=self.exxdiv)
         logger.timer(self, 'vj and vk', *cpu0)
         return vj, vk
 
     def init_guess_by_chkfile(self, chk=None, project=None, kpts=None):
         if isinstance(kpts, np.ndarray):
             return super(KsymAdaptedKSCF, self).init_guess_by_chkfile(chk, project, kpts)
         if kpts is None: kpts = self.kpts
@@ -310,15 +293,15 @@
     def _finalize(self):
         khf.KSCF._finalize(self)
         if not self.use_ao_symmetry:
             return self
 
         orbsym = self.get_orbsym()
         for k, mo_e in enumerate(self.mo_energy):
-            idx = np.argsort(mo_e.round(9), kind='mergesort')
+            idx = np.argsort(mo_e.round(9), kind='stable')
             self.mo_energy[k] = self.mo_energy[k][idx]
             self.mo_occ[k] = self.mo_occ[k][idx]
             self.mo_coeff[k] = lib.tag_array(self.mo_coeff[k][:,idx], orbsym=orbsym[k][idx])
 
         self.dump_chk({'e_tot': self.e_tot, 'mo_energy': self.mo_energy,
                        'mo_coeff': self.mo_coeff, 'mo_occ': self.mo_occ})
         return self
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/krohf.py` & `pyscf-2.3.0/pyscf/pbc/scf/krohf.py`

 * *Files 4% similar despite different names*

```diff
@@ -45,15 +45,15 @@
     dma = []
     dmb = []
     for k, occ in enumerate(mo_occ_kpts):
         mo_a = mo_coeff_kpts[k][:,occ> 0]
         mo_b = mo_coeff_kpts[k][:,occ==2]
         dma.append(np.dot(mo_a, mo_a.conj().T))
         dmb.append(np.dot(mo_b, mo_b.conj().T))
-    return lib.asarray((dma,dmb))
+    return lib.tag_array((dma, dmb), mo_coeff=mo_coeff_kpts, mo_occ=mo_occ_kpts)
 
 def get_fock(mf, h1e=None, s1e=None, vhf=None, dm=None, cycle=-1, diis=None,
              diis_start_cycle=None, level_shift_factor=None, damp_factor=None):
     h1e_kpts, s_kpts, vhf_kpts, dm_kpts = h1e, s1e, vhf, dm
     if h1e_kpts is None: h1e_kpts = mf.get_hcore()
     if vhf_kpts is None: vhf_kpts = mf.get_veff(mf.cell, dm_kpts)
     focka = h1e_kpts + vhf_kpts[0]
@@ -256,15 +256,14 @@
 
 init_guess_by_chkfile = kuhf.init_guess_by_chkfile
 
 
 class KROHF(khf.KRHF, pbcrohf.ROHF):
     '''UHF class with k-point sampling.
     '''
-    conv_tol = getattr(__config__, 'pbc_scf_KSCF_conv_tol', 1e-7)
     conv_tol_grad = getattr(__config__, 'pbc_scf_KSCF_conv_tol_grad', None)
     direct_scf = getattr(__config__, 'pbc_scf_SCF_direct_scf', True)
 
     def __init__(self, cell, kpts=np.zeros((1,3)),
                  exxdiv=getattr(__config__, 'pbc_scf_SCF_exxdiv', 'ewald')):
         khf.KSCF.__init__(self, cell, kpts, exxdiv)
         self.nelec = None
@@ -290,60 +289,31 @@
 
     def dump_flags(self, verbose=None):
         khf.KSCF.dump_flags(self, verbose)
         logger.info(self, 'number of electrons per cell  '
                     'alpha = %d beta = %d', *self.nelec)
         return self
 
-#?    def get_init_guess(self, cell=None, key='minao'):
-#?        dm_kpts = khf.KSCF.get_init_guess(self, cell, key)
-#?        if dm_kpts.ndim != 4:  # The KRHF initial guess
-#?            # dm_kpts shape should be (spin, nkpts, nao, nao)
-#?            dm_kpts = lib.asarray([dm_kpts*.5,]*2)
-#?        return dm_kpts
-#?
     def get_init_guess(self, cell=None, key='minao'):
-        if cell is None:
-            cell = self.cell
-        dm_kpts = None
-        key = key.lower()
-        if key == '1e' or key == 'hcore':
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif getattr(cell, 'natm', 0) == 0:
-            logger.info(self, 'No atom found in cell. Use 1e initial guess')
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif key == 'atom':
-            dm = self.init_guess_by_atom(cell)
-        elif key[:3] == 'chk':
-            try:
-                dm_kpts = self.from_chk()
-            except (IOError, KeyError):
-                logger.warn(self, 'Fail to read %s. Use MINAO initial guess',
-                            self.chkfile)
-                dm = self.init_guess_by_minao(cell)
-        else:
-            dm = self.init_guess_by_minao(cell)
-
-        if dm_kpts is None:
-            nkpts = len(self.kpts)
+        dm_kpts = khf.KSCF.get_init_guess(self, cell, key)
+        assert dm_kpts.shape[0] == 2
+        nkpts = len(self.kpts)
+        if dm_kpts.ndim != 4:
             # dm[spin,nao,nao] at gamma point -> dm_kpts[spin,nkpts,nao,nao]
-            dm_kpts = np.repeat(dm[:,None,:,:], nkpts, axis=1)
+            dm_kpts = np.repeat(dm_kpts[:,None,:,:], nkpts, axis=1)
 
         ne = np.einsum('xkij,kji->', dm_kpts, self.get_ovlp(cell)).real
-        # FIXME: consider the fractional num_electron or not? This maybe
-        # relates to the charged system.
-        nkpts = len(self.kpts)
         nelec = float(sum(self.nelec))
-        if np.any(abs(ne - nelec) > 1e-7*nkpts):
+        if np.any(abs(ne - nelec) > 0.01*nkpts):
             logger.debug(self, 'Big error detected in the electron number '
                          'of initial guess density matrix (Ne/cell = %g)!\n'
                          '  This can cause huge error in Fock matrix and '
                          'lead to instability in SCF for low-dimensional '
                          'systems.\n  DM is normalized wrt the number '
-                         'of electrons %g', ne/nkpts, nelec/nkpts)
+                         'of electrons %s', ne.mean()/nkpts, nelec/nkpts)
             dm_kpts *= nelec / ne
         return dm_kpts
 
     init_guess_by_minao  = pbcrohf.ROHF.init_guess_by_minao
     init_guess_by_atom   = pbcrohf.ROHF.init_guess_by_atom
     init_guess_by_huckel = pbcrohf.ROHF.init_guess_by_huckel
 
@@ -359,22 +329,16 @@
             dm_kpts = self.make_rdm1()
         if getattr(dm_kpts, 'mo_coeff', None) is not None:
             mo_coeff = dm_kpts.mo_coeff
             mo_occ_a = [(x > 0).astype(np.double) for x in dm_kpts.mo_occ]
             mo_occ_b = [(x ==2).astype(np.double) for x in dm_kpts.mo_occ]
             dm_kpts = lib.tag_array(dm_kpts, mo_coeff=(mo_coeff,mo_coeff),
                                     mo_occ=(mo_occ_a,mo_occ_b))
-        if self.rsjk and self.direct_scf:
-            ddm = dm_kpts - dm_last
-            vj, vk = self.get_jk(cell, ddm, hermi, kpts, kpts_band)
-            vhf = vj[0] + vj[1] - vk
-            vhf += vhf_last
-        else:
-            vj, vk = self.get_jk(cell, dm_kpts, hermi, kpts, kpts_band)
-            vhf = vj[0] + vj[1] - vk
+        vj, vk = self.get_jk(cell, dm_kpts, hermi, kpts, kpts_band)
+        vhf = vj[0] + vj[1] - vk
         return vhf
 
     def get_grad(self, mo_coeff_kpts, mo_occ_kpts, fock=None):
         if fock is None:
             dm1 = self.make_rdm1(mo_coeff_kpts, mo_occ_kpts)
             fock = self.get_hcore(self.cell, self.kpts) + self.get_veff(self.cell, dm1)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/kuhf.py` & `pyscf-2.3.0/pyscf/pbc/scf/kuhf.py`

 * *Files 2% similar despite different names*

```diff
@@ -52,15 +52,16 @@
     '''
     nkpts = len(mo_occ_kpts[0])
     nao, nmo = mo_coeff_kpts[0][0].shape
     def make_dm(mos, occs):
         return [np.dot(mos[k]*occs[k], mos[k].T.conj()) for k in range(nkpts)]
     dm_kpts =(make_dm(mo_coeff_kpts[0], mo_occ_kpts[0]) +
               make_dm(mo_coeff_kpts[1], mo_occ_kpts[1]))
-    return lib.asarray(dm_kpts).reshape(2,nkpts,nao,nao)
+    dm = lib.asarray(dm_kpts).reshape(2,nkpts,nao,nao)
+    return lib.tag_array(dm, mo_coeff=mo_coeff_kpts, mo_occ=mo_occ_kpts)
 
 def get_fock(mf, h1e=None, s1e=None, vhf=None, dm=None, cycle=-1, diis=None,
              diis_start_cycle=None, level_shift_factor=None, damp_factor=None):
     h1e_kpts, s_kpts, vhf_kpts, dm_kpts = h1e, s1e, vhf, dm
     if h1e_kpts is None: h1e_kpts = mf.get_hcore()
     if vhf_kpts is None: vhf_kpts = mf.get_veff(mf.cell, dm_kpts)
     f_kpts = h1e_kpts + vhf_kpts
@@ -321,29 +322,22 @@
         if project:
             mo = addons.project_mo_nr2nr(chk_cell, mo, cell, kpts)
             for k, c in enumerate(mo):
                 norm = np.einsum('pi,pi->i', c.conj(), s[k].dot(c))
                 mo[k] /= np.sqrt(norm)
         return mo
 
-    if kpts.shape == chk_kpts.shape and np.allclose(kpts, chk_kpts):
-        def makedm(mos, occs):
-            moa, mob = mos
-            mos = (fproj(moa, kpts), fproj(mob, kpts))
-            return make_rdm1(mos, occs)
-    else:
-        def makedm(mos, occs):
-            where = [np.argmin(lib.norm(chk_kpts-kpt, axis=1)) for kpt in kpts]
-            moa, mob = mos
-            occa, occb = occs
-            dkpts = [chk_kpts[w]-kpts[i] for i,w in enumerate(where)]
-            mos = (fproj([moa[w] for w in where], dkpts),
-                   fproj([mob[w] for w in where], dkpts))
-            occs = ([occa[i] for i in where], [occb[i] for i in where])
-            return make_rdm1(mos, occs)
+    def makedm(mos, occs):
+        moa, mob = mos
+        mos = (fproj(moa, chk_kpts), fproj(mob, chk_kpts))
+        dm = make_rdm1(mos, occs)
+        if kpts.shape != chk_kpts.shape or not np.allclose(kpts, chk_kpts):
+            dm = [addons.project_dm_k2k(cell, dm[0], chk_kpts, kpts),
+                  addons.project_dm_k2k(cell, dm[1], chk_kpts, kpts)]
+        return np.asarray(dm)
 
     if getattr(mo[0], 'ndim', None) == 2:  # KRHF
         mo_occa = [(occ>1e-8).astype(np.double) for occ in mo_occ]
         mo_occb = [occ-mo_occa[k] for k,occ in enumerate(mo_occ)]
         dm = makedm((mo, mo), (mo_occa, mo_occb))
     else:  # KUHF
         dm = makedm(mo, mo_occ)
@@ -371,15 +365,14 @@
 
 get_rho = khf.get_rho
 
 
 class KUHF(khf.KSCF, pbcuhf.UHF):
     '''UHF class with k-point sampling.
     '''
-    conv_tol = getattr(__config__, 'pbc_scf_KSCF_conv_tol', 1e-7)
     conv_tol_grad = getattr(__config__, 'pbc_scf_KSCF_conv_tol_grad', None)
     direct_scf = getattr(__config__, 'pbc_scf_SCF_direct_scf', True)
 
     def __init__(self, cell, kpts=np.zeros((1,3)),
                  exxdiv=getattr(__config__, 'pbc_scf_SCF_exxdiv', 'ewald')):
         khf.KSCF.__init__(self, cell, kpts, exxdiv)
         self.nelec = None
@@ -408,86 +401,52 @@
     def dump_flags(self, verbose=None):
         khf.KSCF.dump_flags(self, verbose)
         logger.info(self, 'number of electrons per cell  '
                     'alpha = %d beta = %d', *self.nelec)
         return self
 
     def get_init_guess(self, cell=None, key='minao'):
-        if cell is None:
-            cell = self.cell
-        dm_kpts = None
-        key = key.lower()
-        if key == '1e' or key == 'hcore':
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif getattr(cell, 'natm', 0) == 0:
-            logger.info(self, 'No atom found in cell. Use 1e initial guess')
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif key == 'atom':
-            dm = self.init_guess_by_atom(cell)
-        elif key[:3] == 'chk':
-            try:
-                dm_kpts = self.from_chk()
-            except (IOError, KeyError):
-                logger.warn(self, 'Fail to read %s. Use MINAO initial guess',
-                            self.chkfile)
-                dm = self.init_guess_by_minao(cell)
-        else:
-            dm = self.init_guess_by_minao(cell)
-
-        if dm_kpts is None:
-            nkpts = len(self.kpts)
+        dm_kpts = khf.KSCF.get_init_guess(self, cell, key)
+        assert dm_kpts.shape[0] == 2
+        nkpts = len(self.kpts)
+        if dm_kpts.ndim != 4:
             # dm[spin,nao,nao] at gamma point -> dm_kpts[spin,nkpts,nao,nao]
-            dm_kpts = np.repeat(dm[:,None,:,:], nkpts, axis=1)
-            dm_kpts[0,:] *= 1.01
-            dm_kpts[1,:] *= 0.99  # To slightly break spin symmetry
-            assert dm_kpts.shape[0]==2
+            dm_kpts = np.repeat(dm_kpts[:,None,:,:], nkpts, axis=1)
 
         ne = np.einsum('xkij,kji->x', dm_kpts, self.get_ovlp(cell)).real
-        # FIXME: consider the fractional num_electron or not? This maybe
-        # relates to the charged system.
-        nkpts = len(self.kpts)
         nelec = np.asarray(self.nelec)
-        if np.any(abs(ne - nelec) > 1e-7*nkpts):
+        if np.any(abs(ne - nelec) > 0.01*nkpts):
             logger.debug(self, 'Big error detected in the electron number '
                          'of initial guess density matrix (Ne/cell = %g)!\n'
                          '  This can cause huge error in Fock matrix and '
                          'lead to instability in SCF for low-dimensional '
                          'systems.\n  DM is normalized wrt the number '
                          'of electrons %s', ne.mean()/nkpts, nelec/nkpts)
             dm_kpts *= (nelec / ne).reshape(2,-1,1,1)
         return dm_kpts
 
     get_fock = get_fock
     get_fermi = get_fermi
     get_occ = get_occ
     energy_elec = energy_elec
-
     get_rho = get_rho
 
     def get_veff(self, cell=None, dm_kpts=None, dm_last=0, vhf_last=0, hermi=1,
                  kpts=None, kpts_band=None):
         if dm_kpts is None:
             dm_kpts = self.make_rdm1()
-        if self.rsjk and self.direct_scf:
-            ddm = dm_kpts - dm_last
-            vj, vk = self.get_jk(cell, ddm, hermi, kpts, kpts_band)
-            vhf = vj[0] + vj[1] - vk
-            vhf += vhf_last
-        else:
-            vj, vk = self.get_jk(cell, dm_kpts, hermi, kpts, kpts_band)
-            vhf = vj[0] + vj[1] - vk
+        vj, vk = self.get_jk(cell, dm_kpts, hermi, kpts, kpts_band)
+        vhf = vj[0] + vj[1] - vk
         return vhf
 
-
     def analyze(self, verbose=None, with_meta_lowdin=WITH_META_LOWDIN,
                 **kwargs):
         if verbose is None: verbose = self.verbose
         return khf.analyze(self, verbose, with_meta_lowdin, **kwargs)
 
-
     def get_grad(self, mo_coeff_kpts, mo_occ_kpts, fock=None):
         if fock is None:
             dm1 = self.make_rdm1(mo_coeff_kpts, mo_occ_kpts)
             fock = self.get_hcore(self.cell, self.kpts) + self.get_veff(self.cell, dm1)
 
         def grad(mo, mo_occ, fock):
             occidx = mo_occ > 0
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/kuhf_ksymm.py` & `pyscf-2.3.0/pyscf/pbc/scf/kuhf_ksymm.py`

 * *Files 8% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 #
 
 import numpy as np
 from pyscf import __config__
 from pyscf import lib
 from pyscf.lib import logger
 from pyscf.pbc.lib import kpts as libkpts
-from pyscf.pbc.scf import khf_ksymm, kuhf
+from pyscf.pbc.scf import khf_ksymm, khf, kuhf
 from pyscf.pbc.lib.kpts import KPoints
 
 @lib.with_doc(kuhf.get_occ.__doc__)
 def get_occ(mf, mo_energy_kpts=None, mo_coeff_kpts=None):
     if mo_energy_kpts is None:
         mo_energy_kpts = mf.mo_energy
     kpts = mf.kpts
@@ -143,50 +143,28 @@
     def dump_flags(self, verbose=None):
         khf_ksymm.KsymAdaptedKSCF.dump_flags(self, verbose)
         logger.info(self, 'number of electrons per unit cell  '
                     'alpha = %d beta = %d', *self.nelec)
         return self
 
     def get_init_guess(self, cell=None, key='minao'):
-        if cell is None:
-            cell = self.cell
-        dm_kpts = None
-        key = key.lower()
-        if key == '1e' or key == 'hcore':
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif getattr(cell, 'natm', 0) == 0:
-            logger.info(self, 'No atom found in cell. Use 1e initial guess')
-            dm_kpts = self.init_guess_by_1e(cell)
-        elif key == 'atom':
-            dm = self.init_guess_by_atom(cell)
-        elif key[:3] == 'chk':
-            try:
-                dm_kpts = self.from_chk()
-            except (IOError, KeyError):
-                logger.warn(self, 'Fail to read %s. Use MINAO initial guess',
-                            self.chkfile)
-                dm = self.init_guess_by_minao(cell)
-        else:
-            dm = self.init_guess_by_minao(cell)
-
-        if dm_kpts is None:
+        dm_kpts = khf.KSCF.get_init_guess(self, cell, key)
+        assert dm_kpts.shape[0]==2
+        if dm_kpts.ndim != 4:
             nkpts = self.kpts.nkpts_ibz
             # dm[spin,nao,nao] at gamma point -> dm_kpts[spin,nkpts,nao,nao]
-            dm_kpts = np.repeat(dm[:,None,:,:], nkpts, axis=1)
-            dm_kpts[0,:] *= 1.01
-            dm_kpts[1,:] *= 0.99  # To slightly break spin symmetry
-            assert dm_kpts.shape[0]==2
+            dm_kpts = np.repeat(dm_kpts[:,None,:,:], nkpts, axis=1)
+        elif dm_kpts.shape[1] != self.kpts.nkpts_ibz:
+            dm_kpts = dm_kpts[:,self.kpts.ibz2bz]
 
         ne = np.einsum('k,xkij,kji->x', self.kpts.weights_ibz, dm_kpts, self.get_ovlp(cell)).real
-        # FIXME: consider the fractional num_electron or not? This maybe
-        # relates to the charged system.
         nkpts = self.kpts.nkpts
         ne *= nkpts
         nelec = np.asarray(self.nelec)
-        if np.any(abs(ne - nelec) > 1e-7*nkpts):
+        if np.any(abs(ne - nelec) > 0.01*nkpts):
             logger.debug(self, 'Big error detected in the electron number '
                          'of initial guess density matrix (Ne/cell = %g)!\n'
                          '  This can cause huge error in Fock matrix and '
                          'lead to instability in SCF for low-dimensional '
                          'systems.\n  DM is normalized wrt the number '
                          'of electrons %s', ne.mean()/nkpts, nelec/nkpts)
             dm_kpts *= (nelec / ne).reshape(2,-1,1,1)
@@ -214,15 +192,15 @@
         kuhf.KUHF._finalize(self)
         if not self.use_ao_symmetry:
             return
 
         orbsym = self.get_orbsym()
         for s in range(2):
             for k, mo_e in enumerate(self.mo_energy[s]):
-                idx = np.argsort(mo_e.round(9), kind='mergesort')
+                idx = np.argsort(mo_e.round(9), kind='stable')
                 self.mo_energy[s][k] = self.mo_energy[s][k][idx]
                 self.mo_occ[s][k] = self.mo_occ[s][k][idx]
                 self.mo_coeff[s][k] = lib.tag_array(self.mo_coeff[s][k][:,idx],
                                                     orbsym=orbsym[s][k][idx])
         self.dump_chk({'e_tot': self.e_tot, 'mo_energy': self.mo_energy,
                        'mo_coeff': self.mo_coeff, 'mo_occ': self.mo_occ})
         return self
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/newton_ah.py` & `pyscf-2.3.0/pyscf/pbc/scf/newton_ah.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/rohf.py` & `pyscf-2.3.0/pyscf/pbc/scf/rohf.py`

 * *Files 14% similar despite different names*

```diff
@@ -94,23 +94,16 @@
             dm = np.asarray((dm*.5,dm*.5))
         if getattr(dm, 'mo_coeff', None) is not None:
             mo_coeff = dm.mo_coeff
             mo_occ_a = (dm.mo_occ > 0).astype(np.double)
             mo_occ_b = (dm.mo_occ ==2).astype(np.double)
             dm = lib.tag_array(dm, mo_coeff=(mo_coeff,mo_coeff),
                                mo_occ=(mo_occ_a,mo_occ_b))
-        if self.rsjk and self.direct_scf:
-            # Enable direct-SCF for real space JK builder
-            ddm = dm - dm_last
-            vj, vk = self.get_jk(cell, ddm, hermi, kpt, kpts_band)
-            vhf = vj[0] + vj[1] - vk
-            vhf += vhf_last
-        else:
-            vj, vk = self.get_jk(cell, dm, hermi, kpt, kpts_band)
-            vhf = vj[0] + vj[1] - vk
+        vj, vk = self.get_jk(cell, dm, hermi, kpt, kpts_band)
+        vhf = vj[0] + vj[1] - vk
         return vhf
 
     def get_bands(self, kpts_band, cell=None, dm=None, kpt=None):
         '''Get energy bands at the given (arbitrary) 'band' k-points.
 
         Returns:
             mo_energy : (nmo,) ndarray or a list of (nmo,) ndarray
@@ -118,32 +111,24 @@
             mo_coeff : (nao, nmo) ndarray or a list of (nao,nmo) ndarray
                 Band orbitals psi_n(k)
         '''
         raise NotImplementedError
 
     dip_moment = pbchf.SCF.dip_moment
 
-    def get_init_guess(self, cell=None, key='minao'):
-        if cell is None: cell = self.cell
-        dm = mol_rohf.ROHF.get_init_guess(self, cell, key)
-        dm = pbchf.normalize_dm_(self, dm)
-        return dm
+    get_init_guess = pbchf.RHF.get_init_guess
 
     def init_guess_by_1e(self, cell=None):
         if cell is None: cell = self.cell
         if cell.dimension < 3:
             logger.warn(self, 'Hcore initial guess is not recommended in '
                         'the SCF of low-dimensional systems.')
         return mol_rohf.ROHF.init_guess_by_1e(self, cell)
 
-    def init_guess_by_chkfile(self, chk=None, project=True, kpt=None):
-        if chk is None: chk = self.chkfile
-        if kpt is None: kpt = self.kpt
-        return pbcuhf.init_guess_by_chkfile(self.cell, chk, project, kpt)
-
+    init_guess_by_chkfile = pbcuhf.UHF.init_guess_by_chkfile
     init_guess_by_minao  = mol_rohf.ROHF.init_guess_by_minao
     init_guess_by_atom   = mol_rohf.ROHF.init_guess_by_atom
     init_guess_by_huckel = mol_rohf.ROHF.init_guess_by_huckel
 
     analyze = mol_rohf.ROHF.analyze
     canonicalize = mol_rohf.ROHF.canonicalize
     spin_square = mol_rohf.ROHF.spin_square
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/rsjk.py` & `pyscf-2.3.0/pyscf/pbc/scf/rsjk.py`

 * *Files 24% similar despite different names*

```diff
@@ -17,72 +17,82 @@
 #
 
 '''
 Range separation JK builder
 
 Ref:
     Q. Sun, arXiv:2012.07929
+    Q. Sun, arXiv:2302.11307
 '''
 
 import copy
 import ctypes
 import numpy as np
 import scipy.linalg
 from pyscf import gto
 from pyscf import lib
 from pyscf.lib import logger
 from pyscf.scf import _vhf
 from pyscf.pbc import gto as pbcgto
 from pyscf.pbc.tools import pbc as pbctools
 from pyscf.pbc.tools import k2gamma
-from pyscf.pbc.df import aft, aft_jk, rsdf_builder
+from pyscf.pbc.scf import addons
+from pyscf.pbc.df import aft, rsdf_builder, aft_jk
 from pyscf.pbc.df import ft_ao
 from pyscf.pbc.df.df_jk import (zdotNN, zdotCN, zdotNC, _ewald_exxdiv_for_G0,
                                 _format_dms, _format_kpts_band, _format_jks)
-from pyscf.pbc.df.incore import _get_cache_size
-from pyscf.pbc.lib.kpts_helper import (is_zero, unique_with_wrap_around,
-                                       group_by_conj_pairs)
+from pyscf.pbc.df.incore import libpbc, _get_cache_size, LOG_ADJUST
+from pyscf.pbc.lib.kpts_helper import (is_zero, kk_adapted_iter,
+                                       group_by_conj_pairs, intersection)
 from pyscf import __config__
 
 # Threshold of steep bases and local bases
-RCUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_rcut_threshold', 2.0)
-# kecut=10 can rougly converge GTO with alpha=0.5
-KECUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_kecut_threshold', 10.0)
+RCUT_THRESHOLD = getattr(__config__, 'pbc_scf_rsjk_rcut_threshold', 1.0)
+OMEGA_MIN = rsdf_builder.OMEGA_MIN
+INDEX_MIN = rsdf_builder.INDEX_MIN
 
-libpbc = lib.load_library('libpbc')
-
-class RangeSeparatedJKBuilder(object):
+class RangeSeparatedJKBuilder(lib.StreamObject):
     def __init__(self, cell, kpts=np.zeros((1,3))):
         self.cell = cell
         self.stdout = cell.stdout
         self.verbose = cell.verbose
         self.max_memory = cell.max_memory
         self.mesh = None
         self.kpts = np.reshape(kpts, (-1, 3))
         self.purify = True
 
-        if cell.omega != 0:
+        if cell.omega == 0:
+            self.omega = None
+        elif cell.omega < 0:
             # Initialize omega to cell.omega for HF exchange of short range
             # int2e in RSH functionals
-            self.omega = abs(cell.omega)
+            self.omega = -cell.omega
         else:
-            self.omega = None
+            raise RuntimeError('RSJK does not support LR integrals')
         self.rs_cell = None
+        self.cell_d = None
         # Born-von Karman supercell
         self.bvk_kmesh = None
         self.supmol_sr = None
         self.supmol_ft = None
-        # For shells in bvkcell, use overlap mask to remove d-d block
-        self.ovlp_mask = None
+        self.supmol_d = None
         # which shells are located in the first primitive cell
         self.cell0_basis_mask = None
         self.ke_cutoff = None
-        self.vhfopt = None
-        # Use fully uncontracted basis for jk_sr part
-        self.fully_uncontracted = False
+        self.direct_scf_tol = None
+        # Use the k-point conjugation symmetry between k and -k
+        self.time_reversal_symmetry = True
+        self.exclude_dd_block = True
+        self.allow_drv_nodddd = True
+        self._sr_without_dddd = None
+        # Allow to approximate vk_lr with less mesh if mo_coeff not attached to dm.
+        self.approx_vk_lr_missing_mo = False
+        # TODO: incrementally build SR part
+        self._last_vs = (0, 0)
+        self._qindex = None
 
         self._keys = set(self.__dict__.keys())
 
     def has_long_range(self):
         '''Whether to add the long-range part computed with AFT/FFT integrals'''
         return self.omega is None or abs(self.cell.omega) < self.omega
 
@@ -90,301 +100,392 @@
         logger.info(self, '\n')
         logger.info(self, '******** %s ********', self.__class__)
         logger.info(self, 'mesh = %s (%d PWs)', self.mesh, np.prod(self.mesh))
         logger.info(self, 'omega = %s', self.omega)
         logger.info(self, 'purify = %s', self.purify)
         logger.info(self, 'bvk_kmesh = %s', self.bvk_kmesh)
         logger.info(self, 'ke_cutoff = %s', self.ke_cutoff)
-        logger.info(self, 'fully_uncontracted = %s', self.fully_uncontracted)
+        logger.info(self, 'time_reversal_symmetry = %s', self.time_reversal_symmetry)
         logger.info(self, 'has_long_range = %s', self.has_long_range())
+        logger.info(self, 'exclude_dd_block = %s', self.exclude_dd_block)
+        logger.info(self, 'allow_drv_nodddd = %s', self.allow_drv_nodddd)
+        logger.debug(self, 'approx_vk_lr_missing_mo = %s', self.approx_vk_lr_missing_mo)
         return self
 
     def reset(self, cell=None):
         if cell is not None:
             self.cell = cell
         self.rs_cell = None
+        self.cell_d = None
         self.supmol_sr = None
         self.supmol_ft = None
+        self.supmol_d = None
+        self.exclude_dd_block = True
+        self.approx_vk_lr_missing_mo = False
+        self._last_vs = (0, 0)
+        self._qindex = None
         return self
 
-    def build(self, omega=None, direct_scf_tol=None, intor='int2e'):
+    def build(self, omega=None, intor='int2e'):
         cpu0 = logger.process_clock(), logger.perf_counter()
         log = logger.new_logger(self)
         cell = self.cell
         kpts = self.kpts
 
         if omega is not None:
             self.omega = omega
 
-        if self.omega is None:
+        if self.omega is None or self.omega == 0:
             # Search a proper range-separation parameter omega that can balance the
             # computational cost between the real space integrals and moment space
             # integrals
             self.omega, self.mesh, self.ke_cutoff = _guess_omega(cell, kpts, self.mesh)
         else:
-            self.ke_cutoff = aft.estimate_ke_cutoff_for_omega(cell, self.omega)
-            self.mesh = pbctools.cutoff_to_mesh(cell.lattice_vectors(), self.ke_cutoff)
+            self.ke_cutoff = estimate_ke_cutoff_for_omega(cell, self.omega)
+            self.mesh = cell.cutoff_to_mesh(self.ke_cutoff)
+
+        if cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum':
+            # To ensure trunc-coulG converged for all basis
+            self.mesh[2] = rsdf_builder._estimate_meshz(cell)
+
+        self.check_sanity()
 
         log.info('omega = %.15g  ke_cutoff = %s  mesh = %s',
                  self.omega, self.ke_cutoff, self.mesh)
 
-        if direct_scf_tol is None:
-            nimgs = cell.rcut**3 / cell.vol
-            direct_scf_tol = cell.precision / (nimgs * cell.npgto_nr())
-        log.debug('Set direct_scf_tol %g', direct_scf_tol)
-        direct_scf_tol = cell.precision**1.5
-        direct_scf_tol = 1e-12
+        # AFT part exchange cost may be dominant
+        if cell.nao * len(kpts) > 5000:
+            log.debug1('Disable exclude_dd_block')
+            self.exclude_dd_block = False
 
+        # basis with cutoff under ~150 eV are handled by AFTDF
+        ke_cutoff = max(6., self.ke_cutoff)
         rs_cell = ft_ao._RangeSeparatedCell.from_cell(
-            cell, self.ke_cutoff, RCUT_THRESHOLD, verbose=log)
+            cell, ke_cutoff, RCUT_THRESHOLD, in_rsjk=True, verbose=log)
         self.rs_cell = rs_cell
 
         self.bvk_kmesh = kmesh = k2gamma.kpts_to_kmesh(cell, kpts)
         log.debug('kmesh for bvk-cell = %s', kmesh)
 
-        # Estimate rcut to generate Ls. rcut (and the translation vectors Ls)
-        # here needs to cover all possible shells to converge int3c2e.
-        # cell.rcut only converge the GTOval on grids thus it cannot be used here.
-        smooth_bas_mask = rs_cell.bas_type == ft_ao.SMOOTH_BASIS
-        cell_exps = rs_cell.bas_exps()
-        exps_d = [cell_exps[ib] for ib in range(rs_cell.nbas) if smooth_bas_mask[ib]]
-        exps_c = [cell_exps[ib] for ib in range(rs_cell.nbas) if not smooth_bas_mask[ib]]
-        if not exps_c: # Only smooth functions
-            rcut_sr = cell.rcut
-        else:
-            if not exps_d:  # Only compact functions
-                exp_d_min = exp_c_min = np.hstack(exps_c).min()
-                aij = exp_d_min
-                eij = exp_d_min / 2
-            else:  # both smooth and compact functions exist
-                exp_d_min = np.hstack(exps_d).min()
-                exp_c_min = np.hstack(exps_c).min()
-                aij = exp_d_min + exp_c_min
-                eij = exp_d_min * exp_c_min / aij
-            theta = 1/(self.omega**-2 + 2./aij)
-            fac = 8*(exp_d_min*exp_c_min/aij**2)**1.5 / (theta * np.pi)**.5
-            x_ratio = 1 / (exp_d_min/theta + 2*exp_c_min/aij)
-            exp_fac = 2 * eij * x_ratio**2 + theta * (1 - 2*exp_c_min/aij*x_ratio)**2
-
-            rcut_sr = cell.rcut  # initial guess
-            rcut_sr = ((-np.log(direct_scf_tol
-                                * (1 - 2*exp_c_min/aij*x_ratio) * rcut_sr
-                                / (2*np.pi*fac)) / exp_fac)**.5)
-            log.debug1('exp_d_min = %g, exp_c_min = %g, rcut_sr = %g',
-                       exp_d_min, exp_c_min, rcut_sr)
-
-        if self.fully_uncontracted:
-            log.debug('make supmol from fully uncontracted cell basis')
-            pcell, contr_coeff = rs_cell.decontract_basis(to_cart=True)
-            self.contr_coeff = scipy.linalg.block_diag(*contr_coeff)
-            self.supmol_sr = _ExtendedMoleSR.from_cell(
-                pcell, kmesh, self.omega, rcut_sr, log)
-        else:
-            log.debug('make supmol from partially uncontracted cell basis')
-            self.supmol_sr = _ExtendedMoleSR.from_cell(
-                rs_cell, kmesh, self.omega, rcut_sr, log)
-        self.supmol_sr = self.supmol_sr.strip_basis()
-        # In _get_lr_k_kpts, fft for cell_d ft_aopair is less efficient than
-        # analytical FT
-        cell_d = rs_cell.smooth_basis_cell()
-        self.supmol_d = ft_ao._ExtendedMole.from_cell(cell_d, kmesh, verbose=log)
-        self.supmol_d = self.supmol_d.strip_basis()
+        exp_min = np.hstack(cell.bas_exps()).min()
+        lattice_sum_factor = max((2*cell.rcut)**3/cell.vol * 1/exp_min, 1)
+        cutoff = cell.precision / lattice_sum_factor * .1
+        self.direct_scf_tol = cutoff
+        log.debug('Set RangeSeparationJKBuilder.direct_scf_tol to %g', cutoff)
+
+        rcut_sr = estimate_rcut(rs_cell, self.omega,
+                                exclude_dd_block=self.exclude_dd_block)
+        supmol_sr = ft_ao.ExtendedMole.from_cell(rs_cell, kmesh, rcut_sr.max(), log)
+        supmol_sr.omega = -self.omega
+        self.supmol_sr = supmol_sr.strip_basis(rcut_sr)
+        log.debug('supmol nbas = %d cGTO = %d pGTO = %d',
+                  supmol_sr.nbas, supmol_sr.nao, supmol_sr.npgto_nr())
 
         if self.has_long_range():
-            self.supmol_ft = rsdf_builder._ExtendedMoleFT.from_cell(
-                rs_cell, kmesh, rcut_sr, log)
-            self.supmol_ft = self.supmol_ft.strip_basis()
-
-        supmol = self.supmol_sr
-        log.debug('supmol nbas = %d cGTO = %d pGTO = %d',
-                  supmol.nbas, supmol.nao, supmol.npgto_nr())
-        log.debug('supmol_d nbas = %d cGTO = %d',
-                  self.supmol_d.nbas, self.supmol_d.nao)
+            rcut = rsdf_builder.estimate_ft_rcut(
+                rs_cell, exclude_dd_block=self.exclude_dd_block)
+            supmol_ft = rsdf_builder._ExtendedMoleFT.from_cell(
+                rs_cell, kmesh, rcut.max(), log)
+            supmol_ft.exclude_dd_block = self.exclude_dd_block
+            self.supmol_ft = supmol_ft.strip_basis(rcut)
+            log.debug('sup-mol-ft nbas = %d cGTO = %d pGTO = %d',
+                      supmol_ft.nbas, supmol_ft.nao, supmol_ft.npgto_nr())
+
+            self.cell_d = rs_cell.smooth_basis_cell()
+            if self.cell_d.nbas > 0:
+                rcut = ft_ao.estimate_rcut(self.cell_d)
+                supmol_d = ft_ao.ExtendedMole.from_cell(
+                    self.cell_d, self.bvk_kmesh, rcut.max(), log)
+                self.supmol_d = supmol_d.strip_basis(rcut)
+                log.debug('supmol_d nbas = %d cGTO = %d', supmol_d.nbas, supmol_d.nao)
         log.timer_debug1('initializing supmol', *cpu0)
 
-        # Intialize vhfopt
-        with supmol.with_integral_screen(direct_scf_tol**2):
-            vhfopt = _vhf.VHFOpt(supmol, cell._add_suffix(intor),
-                                 qcondname=libpbc.PBCVHFsetnr_direct_scf)
-        self.vhfopt = vhfopt
-        vhfopt.direct_scf_tol = direct_scf_tol
-        log.timer('initializing vhfopt', *cpu0)
-
-        # Remove the smooth-smooth basis block.
-        # Modify the contents of vhfopt.q_cond inplace
-        q_cond = self.get_q_cond()
-        smooth_idx = supmol.bas_type_to_indices(ft_ao.SMOOTH_BASIS)
-        q_cond[smooth_idx[:,None], smooth_idx] = 1e-200
-
-        sh_loc = supmol.sh_loc
-        bvk_q_cond = lib.condense('NP_absmax', q_cond, sh_loc, sh_loc)
-        self.ovlp_mask = (bvk_q_cond > direct_scf_tol).astype(np.int8)
+        self._cintopt = _vhf.make_cintopt(supmol_sr._atm, supmol_sr._bas,
+                                          supmol_sr._env, 'int2e')
+        nbas = supmol_sr.nbas
+        qindex = np.empty((3,nbas,nbas), dtype=np.int16)
+        ao_loc = supmol_sr.ao_loc
+        with supmol_sr.with_integral_screen(self.direct_scf_tol**2):
+            libpbc.PBCVHFsetnr_direct_scf(
+                libpbc.int2e_sph, self._cintopt,
+                qindex.ctypes.data_as(ctypes.c_void_p),
+                ao_loc.ctypes.data_as(ctypes.c_void_p),
+                supmol_sr._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol_sr.natm),
+                supmol_sr._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol_sr.nbas),
+                supmol_sr._env.ctypes.data_as(ctypes.c_void_p))
+        libpbc.PBCVHFsetnr_sindex(
+            qindex[2:].ctypes.data_as(ctypes.c_void_p),
+            supmol_sr._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol_sr.natm),
+            supmol_sr._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol_sr.nbas),
+            supmol_sr._env.ctypes.data_as(ctypes.c_void_p))
+
+        if self.exclude_dd_block:
+            # Remove the smooth-smooth basis block.
+            smooth_idx = supmol_sr.bas_type_to_indices(ft_ao.SMOOTH_BASIS)
+            qindex[0,smooth_idx[:,None], smooth_idx] = INDEX_MIN
+
+        self.qindex = qindex
+
+        log.timer('initializing qindex', *cpu0)
         return self
 
-    def get_q_cond(self):
-        supmol = self.supmol_sr
-        q_cond = self.vhfopt.get_q_cond((supmol.nbas, supmol.nbas))
-        return q_cond
+    @property
+    def qindex(self):
+        if self._qindex is None or isinstance(self._qindex, np.ndarray):
+            return self._qindex
+        return self._qindex['qindex'][:]
+
+    @qindex.setter
+    def qindex(self, x):
+        if x.size < self.max_memory*.2e6:
+            self._qindex = x
+        else:
+            self._qindex = lib.H5TmpFile()
+            self._qindex['qindex'] = x
+            self._qindex.flush()
+
+    def _sort_qcond_cell0(self, seg_loc, seg2sh, nbasp, qindex):
+        '''Sort qcond for ij-pair in cell0 so that loops in PBCVHF_direct_drv
+        can be "break" early
+        '''
+        qcell0_ijij = _qcond_cell0_abstract(qindex[0], seg_loc, seg2sh, nbasp)
+        qcell0_iijj = _qcond_cell0_abstract(qindex[1], seg_loc, seg2sh, nbasp)
+        idx = np.asarray(qcell0_ijij.ravel().argsort(kind='stable'), np.int32)[::-1]
+        jsh_idx, ish_idx = divmod(idx, nbasp)
+        ish_idx = np.asarray(ish_idx, dtype=np.int32, order='C')
+        jsh_idx = np.asarray(jsh_idx, dtype=np.int32, order='C')
+        return qcell0_ijij, qcell0_iijj, ish_idx, jsh_idx
 
     def _get_jk_sr(self, dm_kpts, hermi=1, kpts=None, kpts_band=None,
                    with_j=True, with_k=True, omega=None, exxdiv=None):
         if omega is not None:  # J/K for RSH functionals
             raise NotImplementedError
 
         cpu0 = logger.process_clock(), logger.perf_counter()
-        if self.supmol_sr is None:
-            self.build()
+        log = logger.new_logger(self)
 
         comp = 1
         nkpts = kpts.shape[0]
-        vhfopt = self.vhfopt
         supmol = self.supmol_sr
         cell = self.cell
+        rs_cell = self.rs_cell
         nao = cell.nao
         bvk_ncells, rs_nbas, nimgs = supmol.bas_mask.shape
-        nbands = bvk_ncells
-
-        # A map to assign each basis of supmol._bas the index in
-        # [bvk_cell-id, bas-id, image-id]
-        bas_map = np.where(supmol.bas_mask.ravel())[0].astype(np.int32)
 
         if dm_kpts.ndim != 4:
             dm = dm_kpts.reshape(-1, nkpts, nao, nao)
         else:
             dm = dm_kpts
         n_dm = dm.shape[0]
 
-        if self.fully_uncontracted:
-            # parameters for decontracted basis are different
-            c = self.contr_coeff
-            dm = lib.einsum('nkij,pi,qj->nkpq', dm, c, c)
-            decontracted_cell = supmol.rs_cell
-            nbasp = decontracted_cell.nbas
-            cell0_ao_loc = decontracted_cell.ao_loc
+        cutoff = int(np.log(self.direct_scf_tol) * LOG_ADJUST)
+
+        self._sr_without_dddd = (
+            self.allow_drv_nodddd and
+            not self.exclude_dd_block and
+            self.cell_d.nbas > 0 and
+            self.has_long_range() and
+            (cell.dimension == 3 or cell.low_dim_ft_type != 'inf_vacuum'))
+
+        if self._sr_without_dddd:
+            # To exclude (dd|dd) block, diffused shell needs to be independent
+            # segments in PBCVHF_direct_drv1. Decontract the segments in rs-shell.
+            # map ao indices in cell to ao indices in rs_cell
+            log.debug1('get_jk_sr with PBCVHF_direct_drv_nodddd')
+            drv = libpbc.PBCVHF_direct_drv_nodddd
+            ao_map = lib.locs_to_indices(cell.ao_loc, rs_cell.bas_map)
+            rs_nao = ao_map.size
+            rs_dm = np.empty((n_dm,nkpts*rs_nao,rs_nao), dtype=dm.dtype)
+            idx = np.arange(nkpts)[:,None] * nao + ao_map
+            idx = np.asarray(idx, dtype=np.int32).ravel()
+            for i in range(n_dm):
+                lib.take_2d(dm[i].reshape(nkpts*nao,nao), idx, ao_map, out=rs_dm[i])
+            dm = rs_dm.reshape(n_dm,nkpts,rs_nao,rs_nao)
+            nbasp = rs_cell.nbas
+            cell0_ao_loc = rs_cell.ao_loc
+
+            # uncontracted (local, diffused) basis segments in bvk-cell
+            seg_loc = lib.locs_to_indices(
+                supmol.seg_loc, np.arange(supmol.seg_loc.size-1))
+            seg_loc = np.append(seg_loc, supmol.seg_loc[-1]).astype(np.int32)
         else:
+            drv = libpbc.PBCVHF_direct_drv
             nbasp = cell.nbas  # The number of shells in the primitive cell
             cell0_ao_loc = cell.ao_loc
-        nao = dm.shape[-1]
+            seg_loc = supmol.seg_loc
+
+        qindex = self.qindex
+        qcell0_ijij, qcell0_iijj, ish_idx, jsh_idx = \
+                self._sort_qcond_cell0(seg_loc, supmol.seg2sh, nbasp, qindex)
 
         weight = 1. / nkpts
-        expRk = np.exp(1j*np.dot(supmol.bvkmesh_Ls, kpts.T))
+        expLk = np.exp(1j*np.dot(supmol.bvkmesh_Ls, kpts.T))
         # Utilized symmetry sc_dm[R,S] = sc_dm[S-R] = sc_dm[(S-R)%N]
-        #:phase = expRk / nkpts**.5
+        #:phase = expLk / nkpts**.5
         #:sc_dm = lib.einsum('Rk,nkuv,Sk->nRuSv', phase, sc_dm, phase.conj())
-        sc_dm = lib.einsum('k,Sk,nkuv->nSuv', expRk[0]*weight, expRk.conj(), dm)
+        sc_dm = lib.einsum('k,Sk,nkuv->nSuv', expLk[0]*weight, expLk.conj(), dm)
         dm_translation = k2gamma.double_translation_indices(self.bvk_kmesh).astype(np.int32)
         dm_imag_max = abs(sc_dm.imag).max()
         is_complex_dm = dm_imag_max > 1e-6
         if is_complex_dm:
             if dm_imag_max < 1e-2:
-                logger.warn(self, 'DM in (BvK) cell has small imaginary part.  '
-                            'It may be a signal of symmetry broken in k-point symmetry')
+                log.warn('DM in (BvK) cell has small imaginary part.  '
+                         'It may be a signal of symmetry broken in k-point symmetry')
             sc_dm = np.vstack([sc_dm.real, sc_dm.imag])
+            self.purify = False
         else:
             sc_dm = sc_dm.real
-        sc_dm = np.asarray(sc_dm.reshape(-1, bvk_ncells, nao, nao), order='C')
+        nao1 = dm.shape[-1]
+        sc_dm = np.asarray(sc_dm.reshape(-1, bvk_ncells, nao1, nao1), order='C')
         n_sc_dm = sc_dm.shape[0]
 
         # * sparse_ao_loc has dimension (Nk,nbas), corresponding to the
         # bvkcell with all basis
-        sparse_ao_loc = nao * np.arange(bvk_ncells)[:,None] + cell0_ao_loc[:-1]
-        sparse_ao_loc = np.append(sparse_ao_loc.ravel(), nao * bvk_ncells)
+        sparse_ao_loc = nao1 * np.arange(bvk_ncells)[:,None] + cell0_ao_loc[:-1]
+        sparse_ao_loc = np.append(sparse_ao_loc.ravel(), nao1 * bvk_ncells)
         dm_cond = [lib.condense('NP_absmax', d, sparse_ao_loc, cell0_ao_loc)
-                   for d in sc_dm]
-        dm_cond = np.asarray(np.max(dm_cond, axis=0), order='C')
-        libpbc.CVHFset_dm_cond(vhfopt._this,
-                               dm_cond.ctypes.data_as(ctypes.c_void_p), dm_cond.size)
+                   for d in sc_dm.reshape(n_sc_dm, bvk_ncells*nao1, nao1)]
+        dm_cond = np.max(dm_cond, axis=0)
+        dm_cond[dm_cond < 1e-100] = 1e-100
+        dmindex = np.log(dm_cond)
+        dmindex *= LOG_ADJUST
+        dmindex = np.asarray(dmindex, order='C', dtype=np.int16)
+        dmindex = dmindex.reshape(bvk_ncells, nbasp, nbasp)
         dm_cond = None
 
         bvk_nbas = nbasp * bvk_ncells
         shls_slice = (0, nbasp, 0, bvk_nbas, 0, bvk_nbas, 0, bvk_nbas)
 
         cache_size = _get_cache_size(cell, 'int2e_sph')
         cell0_dims = cell0_ao_loc[1:] - cell0_ao_loc[:-1]
         cache_size += cell0_dims.max()**4 * comp * 2
 
         if hermi:
             fdot_suffix = 's2kl'
         else:
             fdot_suffix = 's1'
+        nvs = 1
         if with_j and with_k:
             fdot = 'PBCVHF_contract_jk_' + fdot_suffix
-            vs = np.zeros((2, n_sc_dm, nao, nbands, nao))
+            nvs = 2
         elif with_j:
             fdot = 'PBCVHF_contract_j_' + fdot_suffix
-            vs = np.zeros((1, n_sc_dm, nao, nbands, nao))
         else:  # with_k
             fdot = 'PBCVHF_contract_k_' + fdot_suffix
-            vs = np.zeros((1, n_sc_dm, nao, nbands, nao))
+        vs = np.zeros((nvs, n_sc_dm, nao1, bvk_ncells, nao1))
 
         if supmol.cart:
             intor = 'PBCint2e_cart'
         else:
             intor = 'PBCint2e_sph'
 
-        drv = libpbc.PBCVHF_direct_drv
         drv(getattr(libpbc, fdot), getattr(libpbc, intor),
             vs.ctypes.data_as(ctypes.c_void_p),
             sc_dm.ctypes.data_as(ctypes.c_void_p),
-            ctypes.c_int(vs.size), ctypes.c_int(n_dm),
-            ctypes.c_int(bvk_ncells), ctypes.c_int(nimgs),
-            ctypes.c_int(nkpts), ctypes.c_int(nbands),
+            ctypes.c_int(vs.size), ctypes.c_int(n_sc_dm),
+            ctypes.c_int(bvk_ncells), ctypes.c_int(nimgs), ctypes.c_int(nkpts),
             ctypes.c_int(nbasp), ctypes.c_int(comp),
-            supmol.sh_loc.ctypes.data_as(ctypes.c_void_p),
+            seg_loc.ctypes.data_as(ctypes.c_void_p),
+            supmol.seg2sh.ctypes.data_as(ctypes.c_void_p),
             cell0_ao_loc.ctypes.data_as(ctypes.c_void_p),
+            rs_cell.bas_type.ctypes.data_as(ctypes.c_void_p),
             (ctypes.c_int*8)(*shls_slice),
             dm_translation.ctypes.data_as(ctypes.c_void_p),
-            self.ovlp_mask.ctypes.data_as(ctypes.c_void_p),
-            bas_map.ctypes.data_as(ctypes.c_void_p),
-            vhfopt._cintopt, vhfopt._this, ctypes.c_int(cache_size),
+            qindex.ctypes.data_as(ctypes.c_void_p),
+            dmindex.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(cutoff),
+            qcell0_ijij.ctypes.data_as(ctypes.c_void_p),
+            qcell0_iijj.ctypes.data_as(ctypes.c_void_p),
+            ish_idx.ctypes.data_as(ctypes.c_void_p),
+            jsh_idx.ctypes.data_as(ctypes.c_void_p),
+            self._cintopt, ctypes.c_int(cache_size),
             supmol._atm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.natm),
             supmol._bas.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(supmol.nbas),
             supmol._env.ctypes.data_as(ctypes.c_void_p))
 
         if is_complex_dm:
             vs = vs[:,:n_dm] + vs[:,n_dm:] * 1j
 
-        if self.fully_uncontracted:
-            c = self.contr_coeff
-            vs = lib.einsum('snpkq,pi,qj->snikj', vs, c, c)
+        if self._sr_without_dddd:
+            jdx = np.arange(bvk_ncells)[:,None] * nao + ao_map
+            jdx = np.asarray(jdx, dtype=np.int32).ravel()
+            rs_vs = vs.reshape(nvs*n_dm, nao1, bvk_ncells*nao1)
+            vs = np.zeros((nvs*n_dm, nao, bvk_ncells*nao), dtype=rs_vs.dtype)
+            for i in range(nvs*n_dm):
+                lib.takebak_2d(vs[i], rs_vs[i], ao_map, jdx, thread_safe=False)
+            vs = vs.reshape(nvs,n_dm,nao,bvk_ncells,nao)
 
-        if kpts_band is None:
-            vs = lib.einsum('snpRq,Rk->snkpq', vs, expRk)
-        else:
-            logger.warn(self, 'Approximate J/K matrices at kpts_band '
-                        'with the bvk-cell dervied from kpts')
+        if kpts_band is not None:
             kpts_band = np.reshape(kpts_band, (-1, 3))
-            vs = lib.einsum('snpRq,Rk->snkpq', vs,
-                            np.exp(1j*np.dot(supmol.bvkmesh_Ls, kpts_band.T)))
-
-        logger.timer_debug1(self, 'short range part vj and vk', *cpu0)
+            subset_only = intersection(kpts, kpts_band).size == len(kpts_band)
+            if not subset_only:
+                log.warn('Approximate J/K matrices at kpts_band '
+                         'with the bvk-cell dervied from kpts')
+                expLk = np.exp(1j*np.dot(supmol.bvkmesh_Ls, kpts_band.T))
+        vs = lib.einsum('snpRq,Rk->snkpq', vs, expLk)
+        vs = np.asarray(vs, order='C')
+        log.timer_debug1('short range part vj and vk', *cpu0)
         return vs
 
     def get_jk(self, dm_kpts, hermi=1, kpts=None, kpts_band=None,
                with_j=True, with_k=True, omega=None, exxdiv=None):
+        cell = self.cell
         if omega is not None:  # J/K for RSH functionals
             if omega > 0:  # Long-range part only, call AFTDF
-                cell = self.cell
                 dfobj = aft.AFTDF(cell, self.kpts)
-                ke_cutoff = aft.estimate_ke_cutoff_for_omega(cell, omega)
-                dfobj.mesh = pbctools.cutoff_to_mesh(cell.lattice_vectors(), ke_cutoff)
+                ke_cutoff = estimate_ke_cutoff_for_omega(cell, omega)
+                dfobj.mesh = cell.cutoff_to_mesh(ke_cutoff)
                 return dfobj.get_jk(dm_kpts, hermi, kpts, kpts_band,
                                     with_j, with_k, omega, exxdiv)
             elif omega < 0:  # Short-range part only
                 if self.omega is not None and self.omega != omega:
                     raise RuntimeError(f'omega = {omega}, self.omega = {self.omega}')
                 raise NotImplementedError
 
+        if self.supmol_sr is None:
+            self.build()
+
         # Does not support to specify arbitrary kpts
         if kpts is not None and abs(kpts-self.kpts).max() > 1e-7:
             raise RuntimeError('kpts error. kpts cannot be modified in RSJK')
-        kpts = self.kpts
+        kpts = np.asarray(self.kpts.reshape(-1, 3), order='C')
+
+        mo_coeff = getattr(dm_kpts, 'mo_coeff', None)
+        mo_occ = getattr(dm_kpts, 'mo_occ', None)
+        dm_kpts = np.asarray(dm_kpts)
+        dms = _format_dms(dm_kpts, kpts)
+
+        # compute delta vs if dm is obtained from SCF make_rdm1
+        if mo_coeff is not None:
+            last_dm, last_vs = self._last_vs
+            vs = self._get_jk_sr(dms-last_dm, hermi, kpts, kpts_band,
+                                 with_j, with_k, omega, exxdiv)
+            vs += last_vs
+            self._last_vs = (dms, vs.copy())
+            last_dm = last_vs = None
+
+            # dm ~= dm_factor * dm_factor.T
+            n_dm, nkpts, nao = dms.shape[:3]
+            # mo_coeff, mo_occ are not a list of aligned array if
+            # remove_lin_dep was applied to scf object
+            if dm_kpts.ndim == 4:  # KUHF
+                nocc = max(max(np.count_nonzero(x > 0) for x in z) for z in mo_occ)
+                dm_factor = [[x[:,:nocc] for x in mo] for mo in mo_coeff]
+                occs = [[x[:nocc] for x in z] for z in mo_occ]
+            else:  # KRHF
+                nocc = max(np.count_nonzero(x > 0) for x in mo_occ)
+                dm_factor = [[mo[:,:nocc] for mo in mo_coeff]]
+                occs = [[x[:nocc] for x in mo_occ]]
+            dm_factor = np.array(dm_factor, dtype=np.complex128, order='C')
+            dm_factor *= np.sqrt(np.array(occs, dtype=np.double))[:,:,None]
+        else:
+            vs = self._get_jk_sr(dms, hermi, kpts, kpts_band,
+                                 with_j, with_k, omega, exxdiv)
+            dm_factor = None
+        dms = lib.tag_array(dms, dm_factor=dm_factor)
 
-        vs = self._get_jk_sr(dm_kpts, hermi, kpts, kpts_band,
-                             with_j, with_k, omega, exxdiv)
         if with_j and with_k:
             vj, vk = vs
         elif with_j:
             vj, vk = vs[0], None
         else:
             vj, vk = None, vs[0]
 
@@ -392,32 +493,36 @@
             phase = np.exp(1j*np.dot(self.supmol_sr.bvkmesh_Ls, kpts.T))
             phase /= np.sqrt(len(kpts))
         else:
             phase = None
 
         if with_j:
             if self.has_long_range():
-                vj += self._get_lr_j_kpts(dm_kpts, hermi, kpts, kpts_band)
+                vj += self._get_vj_lr(dms, hermi, kpts, kpts_band)
             if hermi:
                 vj = (vj + vj.conj().transpose(0,1,3,2)) * .5
-            if self.purify and kpts_band is None:
-                vj = _purify(vj, phase)
+            vj = _purify(vj, phase)
             vj = _format_jks(vj, dm_kpts, kpts_band, kpts)
             if is_zero(kpts) and dm_kpts.dtype == np.double:
                 vj = vj.real.copy()
 
         if with_k:
-            # The AFT-FFT mixed implementation may use a large amount of memory
-            # vk += self._get_lr_k_kpts1(dm_kpts, hermi, kpts, kpts_band, exxdiv)
             if self.has_long_range():
-                vk += self._get_lr_k_kpts(dm_kpts, hermi, kpts, kpts_band, exxdiv)
+                approx_vk_lr = dm_factor is None and self.approx_vk_lr_missing_mo
+                if not approx_vk_lr:
+                    vk += self._get_vk_lr(dms, hermi, kpts, kpts_band, exxdiv)
+                else:
+                    mesh1 = np.array(self.mesh)//3*2 + 1
+                    logger.debug(self, 'Approximate lr_k with mesh %s', mesh1)
+                    with lib.temporary_env(self, mesh=mesh1):
+                        vk += self._get_vk_lr(dms, hermi, kpts, kpts_band, exxdiv)
+                    self.approx_vk_lr_missing_mo = False
             if hermi:
                 vk = (vk + vk.conj().transpose(0,1,3,2)) * .5
-            if self.purify and kpts_band is None:
-                vk = _purify(vk, phase)
+            vk = _purify(vk, phase)
             vk = _format_jks(vk, dm_kpts, kpts_band, kpts)
             if is_zero(kpts) and dm_kpts.dtype == np.double:
                 vk = vk.real.copy()
 
         return vj, vk
 
     weighted_coulG = aft.weighted_coulG
@@ -428,539 +533,804 @@
         # module to handle the SR- and regular integrals in the same framework
         return (self.weighted_coulG(kpt, exx, mesh) -
                 self.weighted_coulG_SR(kpt, exx, mesh))
 
     def weighted_coulG_SR(self, kpt=np.zeros(3), exx=False, mesh=None):
         return self.weighted_coulG(kpt, False, mesh, -self.omega)
 
-
-    def _get_lr_j_kpts(self, dm_kpts, hermi=1, kpts=np.zeros((1,3)), kpts_band=None):
+    def _get_vj_lr(self, dm_kpts, hermi=1, kpts=np.zeros((1,3)), kpts_band=None):
         '''
         Long-range part of J matrix
+        '''
+        if kpts_band is None:
+            return self._get_lr_j_kpts(dm_kpts, hermi, kpts)
 
-        C ~ compact basis, D ~ diffused basis
-
-        Compute J matrix with coulG_LR:
-        (CC|CC) (CC|CD) (CC|DC) (CD|CC) (CD|CD) (CD|DC) (DC|CC) (DC|CD) (DC|DC)
+        logger.warn(self, 'Approximate kpts_band for vj with k-point projection')
+        vj = self._get_lr_j_kpts(dm_kpts, hermi, kpts)
+        pk2k = addons._k2k_projection(kpts, kpts_band, self.supmol_ft.bvkmesh_Ls)
+        return lib.einsum('nkpq,kh->nhpq', vj, pk2k)
 
-        Compute J matrix with full coulG:
-        (CC|DD) (CD|DD) (DC|DD) (DD|CC) (DD|CD) (DD|DC) (DD|DD)
+    def _get_lr_j_kpts(self, dm_kpts, hermi=1, kpts=np.zeros((1,3))):
+        '''
+        Long-range part of J matrix
         '''
-        if kpts_band is not None:
-            return self._get_lr_j_for_bands(dm_kpts, hermi, kpts, kpts_band)
-
         if len(kpts) == 1 and not is_zero(kpts):
             raise NotImplementedError('Single k-point get-j')
 
         cpu0 = logger.process_clock(), logger.perf_counter()
         log = logger.new_logger(self)
         cell = self.cell
         rs_cell = self.rs_cell
-        cell_d = rs_cell.smooth_basis_cell()
-        mesh = self.mesh
-        ngrids = np.prod(mesh)
+        if self.exclude_dd_block or self._sr_without_dddd:
+            cell_d = self.cell_d
+            naod = cell_d.nao
+            ngrids_d = np.prod(cell_d.mesh)
+        else:
+            cell_d = None
+            naod = ngrids_d = 0
         kpts = np.asarray(kpts.reshape(-1, 3), order='C')
-        dms = _format_dms(dm_kpts, kpts)
+        dms = dm_kpts
         n_dm, nkpts, nao = dms.shape[:3]
-        naod = cell_d.nao
+        mesh = self.mesh
+        ngrids = np.prod(mesh)
 
-        vj_kpts = np.zeros((n_dm,nkpts,nao,nao), dtype=np.complex128)
+        is_real = is_zero(kpts) and dms.dtype == np.double
+        if is_real:
+            vj_kpts = np.zeros((n_dm,nkpts,nao,nao))
+        else:
+            vj_kpts = np.zeros((n_dm,nkpts,nao,nao), dtype=np.complex128)
 
         # TODO: aosym == 's2'
         aosym = 's1'
         ft_kern = self.supmol_ft.gen_ft_kernel(
-            aosym, return_complex=True, verbose=log)
+            aosym, return_complex=False, kpts=kpts, verbose=log)
         Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
-        weight = 1./nkpts
 
         kpt_allow = np.zeros(3)
         coulG = self.weighted_coulG(kpt_allow, False, mesh)
-        coulG_SR = self.weighted_coulG_SR(kpt_allow, False, mesh)
-        if cell.dimension >= 2:
+
+        if (cell.dimension == 3 or
+            (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum')):
             G0_idx = 0  # due to np.fft.fftfreq convension
-            G0_weight = kws[0] if isinstance(kws, np.ndarray) else kws
-            coulG_SR[G0_idx] += np.pi/self.omega**2 * G0_weight
-        # Long-range part is calculated as the difference
-        # coulG(cell.omega) - coulG(self.omega) . It can support both regular
-        # integrals and LR integrals.
-        coulG_LR = coulG - coulG_SR
+            # G=0 associated to 2e integrals in real-space
+            coulG_SR_at_G0 = np.pi/self.omega**2
+            # For cell.dimension = 2, coulG is computed with truncated coulomb
+            # interactions. The 3d coulG_SR below is to remove the analytical
+            # SR from get_jk_sr (which was computed with full Coulomb) then to
+            # add truncated Coulomb for AFT part.
+            with lib.temporary_env(cell, dimension=3):
+                coulG_SR = self.weighted_coulG_SR(kpt_allow, False, mesh)
+            coulG_SR[G0_idx] += coulG_SR_at_G0 * kws
+        else:
+            coulG_SR = self.weighted_coulG_SR(kpt_allow, False, mesh)
+            coulG_SR_at_G0 = None
 
         if naod > 0:
-            aoR_ks, aoI_ks = rsdf_builder._eval_gto(cell_d, mesh, kpts)
             smooth_bas_mask = rs_cell.bas_type == ft_ao.SMOOTH_BASIS
             smooth_bas_idx = rs_cell.bas_map[smooth_bas_mask]
-            smooth_ao_idx = rs_cell.get_ao_indices(smooth_bas_idx, cell.ao_loc)
+            ao_d_idx = rs_cell.get_ao_indices(smooth_bas_idx, cell.ao_loc)
+
+        mem_now = lib.current_memory()[0]
+        max_memory = self.max_memory - mem_now
+        log.debug1('max_memory = %d MB (%d in use)', max_memory+mem_now, mem_now)
+        Gblksize = max(24, int(max_memory*.8e6/16/(nao**2+naod**2)/(nkpts+1))//8*8)
+        Gblksize = min(Gblksize, ngrids)
+        log.debug1('Gblksize = %d', Gblksize)
+
+        if not self.exclude_dd_block or naod == 0:
+            log.debug1('get_lr_j_kpts with aft_aopair')
+            # Long-range part is calculated as the difference
+            # coulG(cell.omega) - coulG(self.omega) . It can support both regular
+            # integrals and LR integrals.
+            coulG_LR = coulG - coulG_SR
+            buf = np.empty(nkpts*Gblksize*nao**2*2)
+            for p0, p1 in lib.prange(0, ngrids, Gblksize):
+                Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, out=buf)
+                aft_jk._update_vj_(vj_kpts, Gpq, dms, coulG_LR[p0:p1])
+            Gpq = buf = None
+
+            if self._sr_without_dddd and naod > 0:
+                log.debug1('get_lr_j_kpts dd block with mesh %s', cell_d.mesh)
+                if cell.dimension < 2:
+                    raise NotImplementedError
+                if cell.dimension == 2 and cell.low_dim_ft_type == 'inf_vacuum':
+                    raise NotImplementedError
+                aoR_ks, aoI_ks = rsdf_builder._eval_gto(cell_d, cell_d.mesh, kpts)
+
+                # rho = einsum('nkji,kig,kjg->ng', dm, ao.conj(), ao)
+                rho = np.zeros((n_dm, ngrids_d))
+                tmpR = np.empty((naod, ngrids_d))
+                tmpI = np.empty((naod, ngrids_d))
+                dm_dd = dms[:,:,ao_d_idx[:,None],ao_d_idx]
+                dmR_dd = np.asarray(dm_dd.real, order='C')
+                dmI_dd = np.asarray(dm_dd.imag, order='C')
+                # vG = einsum('ij,gji->g', dm_dd[k], aoao[k]) * coulG
+                for i in range(n_dm):
+                    for k in range(nkpts):
+                        zdotNN(dmR_dd[i,k].T, dmI_dd[i,k].T,
+                               aoR_ks[k], aoI_ks[k], 1, tmpR, tmpI)
+                        rho[i] += np.einsum('ig,ig->g', aoR_ks[k], tmpR)
+                        rho[i] += np.einsum('ig,ig->g', aoI_ks[k], tmpI)
+
+                if coulG_SR_at_G0 is not None:
+                    with lib.temporary_env(cell_d, dimension=3):
+                        coulG_SR = pbctools.get_coulG(cell_d, omega=-self.omega)
+                    coulG_SR[G0_idx] += coulG_SR_at_G0
+                else:
+                    coulG_SR = pbctools.get_coulG(cell_d, omega=-self.omega)
+                coulG_SR *= cell.vol / ngrids_d
+                vG = pbctools.fft(rho, cell_d.mesh) * coulG_SR
+                vR = pbctools.ifft(vG, cell_d.mesh).real
+
+                nband = nkpts
+                vjR_dd = np.empty((naod,naod))
+                vjI_dd = np.empty((naod,naod))
+                for i in range(n_dm):
+                    for k in range(nband):
+                        aowR = np.einsum('xi,x->xi', aoR_ks[k].T, vR[i])
+                        aowI = np.einsum('xi,x->xi', aoI_ks[k].T, vR[i])
+                        zdotCN(aoR_ks[k], aoI_ks[k], aowR, aowI, 1, vjR_dd, vjI_dd)
+                        if is_real:
+                            vj = vjR_dd
+                        else:
+                            vj = vjR_dd + vjI_dd*1j
+                        lib.takebak_2d(vj_kpts[i,k], vj, ao_d_idx, ao_d_idx,
+                                       thread_safe=False)
+
+        elif naod > 0 and ngrids < ngrids_d:
+            # Prefer AFTDF for everything otherwise cell_d.mesh have to be used
+            # for AFTDF
+            log.debug1('get_lr_j_kpts dd block cached aft_aopair_dd')
+            ft_kern_dd = self.supmol_d.gen_ft_kernel(
+                aosym, return_complex=False, kpts=kpts, verbose=log)
+
+            def merge_dd(Gpq, p0, p1):
+                '''Merge diffused basis block into ao-pair tensor inplace'''
+                GpqR, GpqI = Gpq
+                pqG_ddR, pqG_ddI = ft_kern_dd(Gv[p0:p1], gxyz[p0:p1], Gvbase,
+                                              kpt_allow, kpts)
+                # Gpq should be an array of (nkpts,ni,nj,ngrids) in C order
+                if not GpqR[0].flags.c_contiguous:
+                    assert GpqR[0].strides[0] == 8  # stride for grids
+                for k in range(nkpts):
+                    libpbc.PBC_ft_fuse_dd_s1(
+                        GpqR[k].ctypes.data_as(ctypes.c_void_p),
+                        GpqI[k].ctypes.data_as(ctypes.c_void_p),
+                        pqG_ddR[k].ctypes.data_as(ctypes.c_void_p),
+                        pqG_ddI[k].ctypes.data_as(ctypes.c_void_p),
+                        ao_d_idx.ctypes.data_as(ctypes.c_void_p),
+                        ctypes.c_int(nao), ctypes.c_int(naod), ctypes.c_int(p1-p0))
+                return (GpqR, GpqI)
+
+            buf = np.empty(nkpts*Gblksize*nao**2*2)
+            for p0, p1 in lib.prange(0, ngrids, Gblksize):
+                Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, out=buf)
+                aft_jk._update_vj_(vj_kpts, Gpq, dms, -coulG_SR[p0:p1])
+                Gpq = merge_dd(Gpq, p0, p1)
+                aft_jk._update_vj_(vj_kpts, Gpq, dms, coulG[p0:p1])
+            Gpq = buf = None
+
+        elif naod > 0:
+            log.debug1('get_lr_j_kpts dd block cached fft_aopair_dd')
+            aoR_ks, aoI_ks = rsdf_builder._eval_gto(cell_d, mesh, kpts)
 
             # rho = einsum('nkji,kig,kjg->ng', dm, ao.conj(), ao)
             rho = np.zeros((n_dm, ngrids))
             tmpR = np.empty((naod, ngrids))
             tmpI = np.empty((naod, ngrids))
-            dmR_dd = np.asarray(dms.real[:,:,smooth_ao_idx[:,None],smooth_ao_idx], order='C')
-            dmI_dd = np.asarray(dms.imag[:,:,smooth_ao_idx[:,None],smooth_ao_idx], order='C')
+            dm_dd = dms[:,:,ao_d_idx[:,None],ao_d_idx]
+            dmR_dd = np.asarray(dm_dd.real, order='C')
+            dmI_dd = np.asarray(dm_dd.imag, order='C')
             # vG = einsum('ij,gji->g', dm_dd[k], aoao[k]) * coulG
             for i in range(n_dm):
                 for k in range(nkpts):
                     zdotNN(dmR_dd[i,k].T, dmI_dd[i,k].T, aoR_ks[k], aoI_ks[k], 1, tmpR, tmpI)
                     rho[i] += np.einsum('ig,ig->g', aoR_ks[k], tmpR)
                     rho[i] += np.einsum('ig,ig->g', aoI_ks[k], tmpI)
             vG_dd = pbctools.ifft(rho, mesh) * cell.vol * coulG
-            vG_dd *= weight
             tmpR = tmpI = dmR_dd = dmI_dd = None
             cpu1 = log.timer_debug1('get_lr_j_kpts dd block', *cpu0)
 
             mem_now = lib.current_memory()[0]
-            max_memory = (self.max_memory - mem_now) * .9
+            max_memory = self.max_memory - mem_now
             log.debug1('max_memory = %d MB (%d in use)', max_memory+mem_now, mem_now)
-            Gblksize = max(72, int(max_memory*1e6/16/nao**2/(nkpts+1)))
+            Gblksize = min(Gblksize, int(max_memory*.8e6/16/(nao**2+naod**2)/(nkpts+1))//8*8)
             log.debug1('Gblksize = %d', Gblksize)
+            buf = np.empty(nkpts*Gblksize*nao**2*2)
             for p0, p1 in lib.prange(0, ngrids, Gblksize):
-                Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, kpts)
-                #: aft_jk._update_vj_(vj_kpts, aoaoks, dms, coulG[p0:p1], weight)
-                #: aft_jk._update_vj_(vj_kpts, aoaoks, dms, coulG_SR[p0:p1], -weight)
+                Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, out=buf)
+                #: aft_jk._update_vj_(vj_kpts, aoaoks, dms, coulG[p0:p1], 1)
+                #: aft_jk._update_vj_(vj_kpts, aoaoks, dms, coulG_SR[p0:p1], -1)
+                GpqR, GpqI = Gpq
                 for i in range(n_dm):
-                    rho = np.einsum('kij,kgij->g', dms[i].conj(), Gpq).conj()
-                    # NOTE: vG_dd are updated inplace. It stores the full vG then
+                    rhoR = np.einsum('kij,kgij->g', dms[i].real, GpqR)
+                    rhoI = -np.einsum('kij,kgij->g', dms[i].real, GpqI)
+                    if not is_real:
+                        rhoR += np.einsum('kij,kgij->g', dms[i].imag, GpqI)
+                        rhoI += np.einsum('kij,kgij->g', dms[i].imag, GpqR)
+                    rho = rhoR + rhoI * 1j
                     vG = vG_dd[i,p0:p1]
-                    vG += coulG[p0:p1] * weight * rho
-                    vG_SR = coulG_SR[p0:p1] * weight * rho
+                    # Update vG_dd inplace to include rho contributions
+                    vG += coulG[p0:p1] * rho
+                    vG_SR = coulG_SR[p0:p1] * rho
                     # vG_LR contains full vG of dd-block and vG_LR of rest blocks
                     vG_LR = vG - vG_SR
-                    vj_kpts[i] += np.einsum('g,kgij->kij', vG_LR, Gpq)
+                    vj_kpts[i].real += np.einsum('g,kgij->kij', vG_LR.real, GpqR)
+                    vj_kpts[i].real -= np.einsum('g,kgij->kij', vG_LR.imag, GpqI)
+                    if not is_real:
+                        vj_kpts[i].imag += np.einsum('g,kgij->kij', vG_LR.real, GpqI)
+                        vj_kpts[i].imag += np.einsum('g,kgij->kij', vG_LR.imag, GpqR)
                 Gpq = None
             log.timer_debug1('get_lr_j_kpts ft_aopair', *cpu1)
 
             vR = pbctools.fft(vG_dd, mesh).real * (cell.vol/ngrids)
             vjR_dd = np.empty((naod, naod))
             vjI_dd = np.empty((naod, naod))
             for i in range(n_dm):
                 for k in range(nkpts):
                     tmpR = aoR_ks[k] * vR[i]
                     tmpI = aoI_ks[k] * vR[i]
                     zdotCN(aoR_ks[k], aoI_ks[k], tmpR.T, tmpI.T, 1, vjR_dd, vjI_dd)
-                    lib.takebak_2d(vj_kpts[i,k], vjR_dd + vjI_dd * 1j,
-                                   smooth_ao_idx, smooth_ao_idx)
+                    if is_real:
+                        vj_dd = vjR_dd
+                    else:
+                        vj_dd = vjR_dd + vjI_dd * 1j
+                    lib.takebak_2d(vj_kpts[i,k], vj_dd, ao_d_idx, ao_d_idx,
+                                   thread_safe=False)
 
         else:
-            max_memory = (self.max_memory - lib.current_memory()[0]) * .9
-            Gblksize = max(16, int(max_memory*1e6/16/nao**2/(nkpts+1)))
-            for p0, p1 in lib.prange(0, ngrids, Gblksize):
-                Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, kpts)
-                for i in range(n_dm):
-                    rho = np.einsum('kij,kgij->g', dms[i].conj(), Gpq).conj()
-                    vG_LR = coulG_LR[p0:p1] * weight * rho
-                    vj_kpts[i] += np.einsum('g,kgij->kij', vG_LR, Gpq)
-                Gpq = None
+            raise RuntimeError(f'exclude_dd_block={self.exclude_dd_block} '
+                               f'sr_without_dddd={self._sr_without_dddd} naod={naod}')
 
+        if nkpts > 1:
+            vj_kpts *= 1./nkpts
         log.timer_debug1('get_lr_j_kpts', *cpu0)
         return vj_kpts
 
-    def _get_lr_j_for_bands(self, dm_kpts, hermi=1, kpts=np.zeros((1,3)), kpts_band=None):
-        raise NotImplementedError
-
-    def _get_lr_k_kpts(self, dm_kpts, hermi=1, kpts=np.zeros((1,3)), kpts_band=None,
-                       exxdiv=None):
+    def _get_vk_lr(self, dm_kpts, hermi=1, kpts=np.zeros((1,3)), kpts_band=None,
+                   exxdiv=None):
         '''
         Long-range part of K matrix
+        '''
+        if kpts_band is None:
+            return self._get_lr_k_kpts(dm_kpts, hermi, kpts, exxdiv)
 
-        C ~ compact basis, D ~ diffused basis
-
-        Compute K matrix with coulG_LR:
-        (CC|CC) (CC|CD) (CC|DC) (CD|CC) (CD|CD) (CD|DC) (DC|CC) (DC|CD) (DC|DC)
+        # Note: Errors in k2k-projection for vj is relatively small.
+        # k2k-projection for vk has significant finite-size errors.
+        logger.warn(self, 'Approximate kpts_band for vk with k-point projection')
+        vk = self._get_lr_k_kpts(dm_kpts, hermi, kpts, exxdiv=None)
+        pk2k = addons._k2k_projection(kpts, kpts_band, self.supmol_ft.bvkmesh_Ls)
+        vk = lib.einsum('nkpq,kh->nhpq', vk, pk2k)
+        if exxdiv == 'ewald':
+            _ewald_exxdiv_for_G0(self.cell, kpts, dm_kpts, vk, kpts_band)
+        return vk
 
-        Compute K matrix with full coulG:
-        (CC|DD) (CD|DD) (DC|DD) (DD|CC) (DD|CD) (DD|DC) (DD|DD)
+    def _get_lr_k_kpts(self, dm_kpts, hermi=1, kpts=np.zeros((1,3)), exxdiv=None):
+        '''
+        Long-range part of K matrix
         '''
-        assert kpts_band is None
         cpu0 = cpu1 = logger.process_clock(), logger.perf_counter()
         log = logger.new_logger(self)
         cell = self.cell
         rs_cell = self.rs_cell
-        cell_d = rs_cell.smooth_basis_cell()
+        if self.exclude_dd_block or self._sr_without_dddd:
+            cell_d = self.cell_d
+            naod = cell_d.nao
+            ngrids_d = np.prod(cell_d.mesh)
+        else:
+            cell_d = None
+            naod = ngrids_d = 0
 
         mesh = self.mesh
         ngrids = np.prod(mesh)
-        dm_kpts = lib.asarray(dm_kpts, order='C')
-        dms = _format_dms(dm_kpts, kpts)
-        nset, nkpts, nao = dms.shape[:3]
-        naod = cell_d.nao
-
-        kpts_band = _format_kpts_band(kpts_band, kpts)
-        nband = len(kpts_band)
-        vkR = np.zeros((nset,nband,nao,nao))
-        vkI = np.zeros((nset,nband,nao,nao))
-        dmsR = np.asarray(dms.real, order='C')
-        dmsI = np.asarray(dms.imag, order='C')
+        dms = dm_kpts
+        n_dm, nkpts, nao = dms.shape[:3]
+        vkR = np.zeros((n_dm,nkpts,nao,nao))
+        vkI = np.zeros((n_dm,nkpts,nao,nao))
         vk = [vkR, vkI]
-        dm = [dmsR, dmsI]
         weight = 1. / nkpts
 
+        # Test if vk[k] == vk[k_conj].conj()
+        t_rev_pairs = group_by_conj_pairs(cell, kpts, return_kpts_pairs=False)
+        try:
+            t_rev_pairs = np.asarray(t_rev_pairs, dtype=np.int32, order='F')
+        except TypeError:
+            t_rev_pairs = [[k, k] if k_conj is None else [k, k_conj]
+                           for k, k_conj in t_rev_pairs]
+            t_rev_pairs = np.asarray(t_rev_pairs, dtype=np.int32, order='F')
+        log.debug1('Num kpts conj_pairs %d', len(t_rev_pairs))
+        time_reversal_symmetry = self.time_reversal_symmetry
+        if time_reversal_symmetry:
+            for k, k_conj in t_rev_pairs:
+                if k != k_conj and abs(dms[:,k_conj] - dms[:,k].conj()).max() > 1e-6:
+                    time_reversal_symmetry = False
+                    log.debug2('Disable time_reversal_symmetry')
+                    break
+
+        # TODO: aosym == 's2'
         aosym = 's1'
-        ft_kern = self.supmol_ft.gen_ft_kernel(
-            aosym, return_complex=False, verbose=log)
+        if time_reversal_symmetry:
+            k_to_compute = np.zeros(nkpts, dtype=np.int8)
+            k_to_compute[t_rev_pairs[:,0]] = 1
+        else:
+            k_to_compute = np.ones(nkpts, dtype=np.int8)
+            t_rev_pairs = None
+
+        dm_factor = getattr(dm_kpts, 'dm_factor', None)
+        contract_mo_early = False
+        if dm_factor is None:
+            dmsR = np.asarray(dms.real, order='C')
+            dmsI = np.asarray(dms.imag, order='C')
+            dm = [dmsR, dmsI]
+            dm_factor = None
+            if np.count_nonzero(k_to_compute) >= 2 * lib.num_threads():
+                update_vk = aft_jk._update_vk1_
+            else:
+                update_vk = aft_jk._update_vk_
+        else:
+            # dm ~= dm_factor * dm_factor.T
+            nocc = dm_factor.shape[-1]
+            if nocc == 0:
+                return vkR
+
+            bvk_ncells, rs_nbas, nimgs = self.supmol_ft.bas_mask.shape
+            s_nao = self.supmol_ft.nao
+            contract_mo_early = (time_reversal_symmetry and naod == 0 and
+                                 bvk_ncells*nao*6 > s_nao*nocc*n_dm)
+            log.debug2('time_reversal_symmetry = %s bvk_ncells = %d '
+                       's_nao = %d nocc = %d n_dm = %d',
+                       time_reversal_symmetry, bvk_ncells, s_nao, nocc, n_dm)
+            log.debug2('Use algorithm contract_mo_early = %s', contract_mo_early)
+            if contract_mo_early:
+                bvk_kmesh = self.bvk_kmesh
+                rcut = ft_ao.estimate_rcut(cell)
+                supmol = ft_ao.ExtendedMole.from_cell(cell, bvk_kmesh, rcut.max())
+                supmol = supmol.strip_basis(rcut)
+                s_nao = supmol.nao
+                moR, moI = aft_jk._mo_k2gamma(supmol, dm_factor, kpts, t_rev_pairs)
+                if abs(moI).max() < 1e-5:
+                    dm = [moR, None]
+                    ft_kern = aft_jk._gen_ft_kernel_fake_gamma(cell, supmol, aosym)
+                    update_vk = aft_jk._update_vk_fake_gamma
+                else:
+                    contract_mo_early = False
+                moR = moI = None
+
+            if not contract_mo_early:
+                dm = [np.asarray(dm_factor.real, order='C'),
+                      np.asarray(dm_factor.imag, order='C')]
+                if np.count_nonzero(k_to_compute) >= 2 * lib.num_threads():
+                    update_vk = aft_jk._update_vk1_dmf
+                else:
+                    update_vk = aft_jk._update_vk_dmf
+        log.debug2('set update_vk to %s', update_vk)
+
+        if not contract_mo_early:
+            ft_kern = self.supmol_ft.gen_ft_kernel(
+                aosym, return_complex=False, kpts=kpts, verbose=log)
+
         Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
+        Gv = np.asarray(Gv, order='F')
         gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
+        G0_idx = 0
+        if (cell.dimension == 3 or
+            (cell.dimension == 2 and cell.low_dim_ft_type != 'inf_vacuum')):
+            coulG_SR_at_G0 = np.pi/self.omega**2 * kws
+        else:
+            coulG_SR_at_G0 = None
 
-        uniq_kpts, uniq_index, uniq_inverse = unique_with_wrap_around(
-            cell, (kpts[None,:,:] - kpts[:,None,:]).reshape(-1, 3))
-        scaled_uniq_kpts = cell_d.get_scaled_kpts(uniq_kpts).round(5)
-        log.debug('Num uniq kpts %d', len(uniq_kpts))
-        log.debug2('Scaled unique kpts %s', scaled_uniq_kpts)
+        if naod > 0:
+            smooth_bas_mask = rs_cell.bas_type == ft_ao.SMOOTH_BASIS
+            smooth_bas_idx = rs_cell.bas_map[smooth_bas_mask]
+            ao_d_idx = rs_cell.get_ao_indices(smooth_bas_idx, cell.ao_loc)
 
         mem_now = lib.current_memory()[0]
         max_memory = max(2000, (self.max_memory - mem_now))
         log.debug1('max_memory = %d MB (%d in use)', max_memory+mem_now, mem_now)
 
-        cache_size = (naod*(naod+1)*ngrids*(nkpts+1))*16e-6
-        log.debug1('naod = %d cache_size = %d', naod, cache_size)
-
-        if naod > 0:
-            ao_loc = cell.ao_loc
-            smooth_bas_mask = rs_cell.bas_type == ft_ao.SMOOTH_BASIS
-            smooth_bas_idx = rs_cell.bas_map[smooth_bas_mask]
-            smooth_ao_idx = rs_cell.get_ao_indices(smooth_bas_idx, ao_loc)
-
-            # compute the dd blocks with fft_aopair_dd is more efficient than
-            # aft_aopair_dd. But it requires a large mount of memory
-            if max_memory * .8 > cache_size:
+        if self.exclude_dd_block and not self._sr_without_dddd and naod > 0:
+            cache_size = (naod*(naod+1)*ngrids*(nkpts+1))*16e-6
+            log.debug1('naod = %d cache_size = %d', naod, cache_size)
+
+            # fft_aopair_dd seems less efficient than aft_aopair_dd
+            if 0 and max_memory * .5 > cache_size and cell.dimension >= 2:
+                from pyscf.pbc.dft.multigrid import _take_5d
+                mesh_d = cell_d.mesh
                 log.debug1('merge_dd with cached fft_aopair_dd')
-                aoR_ks, aoI_ks = rsdf_builder._eval_gto(cell_d, mesh, kpts)
-                coords = cell_d.get_uniform_grids(mesh)
+                aoR_ks, aoI_ks = rsdf_builder._eval_gto(cell_d, mesh_d, kpts)
+                coords = cell_d.get_uniform_grids(mesh_d)
                 max_memory -= cache_size
+                gx = np.fft.fftfreq(mesh[0], 1./mesh[0]).astype(np.int32)
+                gy = np.fft.fftfreq(mesh[1], 1./mesh[1]).astype(np.int32)
+                gz = np.fft.fftfreq(mesh[2], 1./mesh[2]).astype(np.int32)
 
                 def fft_aopair_dd(ki, kj, expmikr):
                     # einsum('g,ig,jg->ijg', expmikr, ao_ki.conj(), ao_kj)
-                    pqG_ddR = np.empty((naod**2, ngrids))
-                    pqG_ddI = np.empty((naod**2, ngrids))
+                    pqG_ddR = np.empty((naod**2, ngrids_d))
+                    pqG_ddI = np.empty((naod**2, ngrids_d))
                     expmikrR, expmikrI = expmikr
                     libpbc.PBC_zjoin_fCN_s1(
                         pqG_ddR.ctypes.data_as(ctypes.c_void_p),
                         pqG_ddI.ctypes.data_as(ctypes.c_void_p),
                         expmikrR.ctypes.data_as(ctypes.c_void_p),
                         expmikrI.ctypes.data_as(ctypes.c_void_p),
                         aoR_ks[ki].ctypes.data_as(ctypes.c_void_p),
                         aoI_ks[ki].ctypes.data_as(ctypes.c_void_p),
                         aoR_ks[kj].ctypes.data_as(ctypes.c_void_p),
                         aoI_ks[kj].ctypes.data_as(ctypes.c_void_p),
-                        ctypes.c_int(naod), ctypes.c_int(naod), ctypes.c_int(ngrids))
-                    pqG_dd = pqG_ddR + pqG_ddI * 1j
+                        ctypes.c_int(naod), ctypes.c_int(naod), ctypes.c_int(ngrids_d))
+                    pqG_dd = np.empty((naod**2, ngrids_d), dtype=np.complex128)
+                    pqG_dd.real = pqG_ddR
+                    pqG_dd.imag = pqG_ddI
                     pqG_ddR = pqG_ddI = None
-                    pqG_dd *= cell.vol / ngrids
-                    pqG_dd = pbctools.fft(pqG_dd, mesh)
-                    return pqG_dd.reshape(naod, naod, ngrids)
+                    pqG_dd *= cell.vol / ngrids_d
+                    pqG_dd = pbctools.fft(pqG_dd, mesh_d).reshape(naod, naod, *mesh_d)
+                    pqG_dd = _take_5d(pqG_dd, (None, None, gx, gy, gz))
+                    return np.asarray(pqG_dd.reshape(naod, naod, ngrids), order='C')
 
-                def merge_dd(Gpq, p0, p1, ki_lst, kj_lst, cache):
+                cache = {}
+                def merge_dd(Gpq, p0, p1, ki_lst, kj_lst):
                     '''Merge diffused basis block into ao-pair tensor inplace'''
                     expmikr = np.exp(-1j * np.dot(coords, kpts[kj_lst[0]]-kpts[ki_lst[0]]))
                     expmikrR = np.asarray(expmikr.real, order='C')
                     expmikrI = np.asarray(expmikr.imag, order='C')
                     GpqR, GpqI = Gpq
                     # Gpq should be an array of (nkpts,ni,nj,ngrids) in C order
                     if not GpqR[0].flags.c_contiguous:
                         assert GpqR[0].strides[0] == 8  # stride for grids
+                    cpu0 = logger.process_clock(), logger.perf_counter()
                     for k, (ki, kj) in enumerate(zip(ki_lst, kj_lst)):
                         if (ki, kj) not in cache:
                             log.debug3('cache dd block (%d, %d)', ki, kj)
                             cache[ki, kj] = fft_aopair_dd(ki, kj, (expmikrR, expmikrI))
 
                         pqG_dd = cache[ki, kj]
                         libpbc.PBC_ft_zfuse_dd_s1(
-                            GpqR[k].ctypes.data_as(ctypes.c_void_p),
-                            GpqI[k].ctypes.data_as(ctypes.c_void_p),
+                            GpqR[kj].ctypes.data_as(ctypes.c_void_p),
+                            GpqI[kj].ctypes.data_as(ctypes.c_void_p),
                             pqG_dd.ctypes.data_as(ctypes.c_void_p),
-                            smooth_ao_idx.ctypes.data_as(ctypes.c_void_p),
+                            ao_d_idx.ctypes.data_as(ctypes.c_void_p),
                             (ctypes.c_int*2)(p0, p1), ctypes.c_int(nao),
                             ctypes.c_int(naod), ctypes.c_int(ngrids))
+                    log.timer_debug1('merge_dd', *cpu0)
                     return (GpqR, GpqI)
+
+                cpu1 = log.timer_debug1('get_lr_k_kpts initializing dd block', *cpu1)
+
             else:
                 log.debug1('merge_dd with aft_aopair_dd')
+                ft_kern_dd = self.supmol_d.gen_ft_kernel(
+                    aosym, return_complex=False, kpts=kpts, verbose=log)
 
-                aft_aopair_dd = self.supmol_d.gen_ft_kernel(
-                    aosym, return_complex=False, verbose=log)
-
-                def merge_dd(Gpq, p0, p1, ki_lst, kj_lst, cache):
+                buf1 = None
+                def merge_dd(Gpq, p0, p1, ki_lst, kj_lst):
                     '''Merge diffused basis block into ao-pair tensor inplace'''
                     kpt = kpts[kj_lst[0]] - kpts[ki_lst[0]]
-                    kptjs = kpts[kptj_idx]
                     GpqR, GpqI = Gpq
-                    pqG_ddR, pqG_ddI = aft_aopair_dd(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt, kptjs)
-                    nkpts = len(kptjs)
+                    pqG_ddR, pqG_ddI = ft_kern_dd(Gv[p0:p1], gxyz[p0:p1], Gvbase,
+                                                  kpt, out=buf1)
                     # Gpq should be an array of (nkpts,ni,nj,ngrids) in C order
                     if not GpqR[0].flags.c_contiguous:
                         assert GpqR[0].strides[0] == 8  # stride for grids
                     for k in range(nkpts):
                         libpbc.PBC_ft_fuse_dd_s1(
                             GpqR[k].ctypes.data_as(ctypes.c_void_p),
                             GpqI[k].ctypes.data_as(ctypes.c_void_p),
                             pqG_ddR[k].ctypes.data_as(ctypes.c_void_p),
                             pqG_ddI[k].ctypes.data_as(ctypes.c_void_p),
-                            smooth_ao_idx.ctypes.data_as(ctypes.c_void_p),
+                            ao_d_idx.ctypes.data_as(ctypes.c_void_p),
                             ctypes.c_int(nao), ctypes.c_int(naod), ctypes.c_int(p1-p0))
                     return (GpqR, GpqI)
 
-            cpu1 = log.timer_debug1('get_lr_k_kpts dd block', *cpu1)
-
-        for group_id, (k, k_conj) in enumerate(group_by_conj_pairs(cell, uniq_kpts)[0]):
-            kpt_ij_idx = np.where(uniq_inverse == k)[0]
-            kpti_idx = kpt_ij_idx // nkpts
-            kptj_idx = kpt_ij_idx % nkpts
-            nkptj = len(kptj_idx)
-            kptjs = kpts[kptj_idx]
-            kpt = uniq_kpts[k]
-            log.debug1('ft_ao_pair for kpt = %s', kpt)
-            log.debug2('ft_ao_pair for kpti_idx = %s', kpti_idx)
-            log.debug2('ft_ao_pair for kptj_idx = %s', kptj_idx)
-            swap_2e = k_conj is not None and k != k_conj
-
-            coulG = self.weighted_coulG(kpt, exxdiv, mesh)
-            coulG_SR = self.weighted_coulG_SR(kpt, False, mesh)
-
-            # G=0 associated to 2e integrals in real-space
-            if cell.dimension >= 2 and is_zero(uniq_kpts[k]):
-                G0_idx = 0
-                G0_weight = kws[G0_idx] if isinstance(kws, np.ndarray) else kws
-                coulG_SR[G0_idx] += np.pi/self.omega**2 * G0_weight
-            coulG_LR = coulG - coulG_SR
-
-            Gblksize = max(56, int(max_memory*1e6/16/nao**2/(nkptj+max(nkptj,3))))
+        if contract_mo_early:
+            Gblksize = max(24, int((max_memory*1e6/16-nkpts*nao**2*3)/
+                                   (nao*s_nao+nao*nkpts*nocc))//8*8)
             Gblksize = min(Gblksize, ngrids, 200000)
             log.debug1('Gblksize = %d', Gblksize)
+            buf = np.empty(Gblksize*s_nao*nao*2)
+        else:
+            Gblksize = max(24, int(max_memory*.8e6/16/(nao**2+naod**2)/(nkpts+3))//8*8)
+            Gblksize = min(Gblksize, ngrids, 200000)
+            log.debug1('Gblksize = %d', Gblksize)
+            buf = np.empty(nkpts*Gblksize*nao**2*2)
             if naod > 0:
-                cache = {}
-                vkcoulG = self.weighted_coulG(kpt, exxdiv, mesh)
+                buf1 = np.empty(nkpts*Gblksize*naod**2*2)
+
+        for group_id, (kpt, ki_idx, kj_idx, self_conj) \
+                in enumerate(kk_adapted_iter(cell, kpts)):
+            coulG = self.weighted_coulG(kpt, exxdiv, mesh)
+            if coulG_SR_at_G0 is not None:
+                # For cell.dimension = 2, coulG is computed with truncated coulomb
+                # interactions. The 3d coulG_SR below is to remove the analytical
+                # SR from get_jk_sr (which was computed with full Coulomb) then
+                # add the truncated Coulomb for AFT part.
+                with lib.temporary_env(cell, dimension=3):
+                    coulG_SR = self.weighted_coulG_SR(kpt, False, mesh)
+                if is_zero(kpt):
+                    coulG_SR[G0_idx] += coulG_SR_at_G0
+            else:
+                coulG_SR = self.weighted_coulG_SR(kpt, False, mesh)
+
+            if self.exclude_dd_block and not self._sr_without_dddd and naod > 0:
                 for p0, p1 in lib.prange(0, ngrids, Gblksize):
-                    log.debug3('_update_vk_ [%s:%s]', p0, p1)
-                    Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt, kptjs)
-                    _update_vk_(vk, Gpq, dm, coulG_SR[p0:p1],
-                                -weight, kpti_idx, kptj_idx, swap_2e)
-                    Gpq = merge_dd(Gpq, p0, p1, kpti_idx, kptj_idx, cache)
-                    _update_vk_(vk, Gpq, dm, vkcoulG[p0:p1],
-                                weight, kpti_idx, kptj_idx, swap_2e)
+                    # C ~ compact basis, D ~ diffused basis
+                    # K matrix with coulG_LR:
+                    # (CC|CC) (CC|CD) (CC|DC) (CD|CC) (CD|CD) (CD|DC) (DC|CC) (DC|CD) (DC|DC)
+                    # K matrix with full coulG:
+                    # (CC|DD) (CD|DD) (DC|DD) (DD|CC) (DD|CD) (DD|DC) (DD|DD)
+                    log.debug3('update_vk [%s:%s]', p0, p1)
+                    Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt, out=buf)
+                    update_vk(vk, Gpq, dm, coulG_SR[p0:p1] * -weight, ki_idx,
+                              kj_idx, not self_conj, k_to_compute, t_rev_pairs)
+                    Gpq = merge_dd(Gpq, p0, p1, ki_idx, kj_idx)
+                    update_vk(vk, Gpq, dm, coulG[p0:p1] * weight, ki_idx,
+                              kj_idx, not self_conj, k_to_compute, t_rev_pairs)
                     Gpq = None
+                # clear cache to release memory for merge_dd function
+                cache = {}
             else:
+                coulG_LR = coulG - coulG_SR
                 for p0, p1 in lib.prange(0, ngrids, Gblksize):
-                    log.debug3('_update_vk_ [%s:%s]', p0, p1)
-                    Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt, kptjs)
-                    _update_vk_(vk, Gpq, dm, coulG_LR[p0:p1],
-                                weight, kpti_idx, kptj_idx, swap_2e)
+                    log.debug3('update_vk [%s:%s]', p0, p1)
+                    Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt, out=buf)
+                    update_vk(vk, Gpq, dm, coulG_LR[p0:p1] * weight, ki_idx,
+                              kj_idx, not self_conj, k_to_compute, t_rev_pairs)
+                    Gpq = None
+            cpu1 = log.timer_debug1(f'ft_aopair group {group_id}', *cpu1)
+
+        if self._sr_without_dddd and naod > 0:
+            # (DD|DD) with full coulG, rest terms with coulG_LR
+            log.debug1('ft_aopair dd-blcok for dddd-block ERI')
+            if cell.dimension < 2:
+                raise NotImplementedError
+            if cell.dimension == 2 and cell.low_dim_ft_type == 'inf_vacuum':
+                raise NotImplementedError
+            vkR_dd = np.zeros((n_dm,nkpts,naod,naod))
+            vkI_dd = np.zeros((n_dm,nkpts,naod,naod))
+            vk_dd = [vkR_dd, vkI_dd]
+            if dm_factor is None:
+                dmsR, dmsI = dm
+                dmR_dd = np.asarray(dmsR[:,:,ao_d_idx[:,None],ao_d_idx], order='C')
+                dmI_dd = np.asarray(dmsI[:,:,ao_d_idx[:,None],ao_d_idx], order='C')
+                dm_dd = [dmR_dd, dmI_dd]
+            else:
+                assert update_vk is not aft_jk._update_vk_fake_gamma
+                dmfR, dmfI = dm
+                dmfR_dd = np.asarray(dmfR[:,:,ao_d_idx], order='C')
+                dmfI_dd = np.asarray(dmfI[:,:,ao_d_idx], order='C')
+                dm_dd = [dmfR_dd, dmfI_dd]
+
+            # AFT mesh for ERI is usually smaller than cell_d.mesh
+            ke_cutoff = aft.estimate_ke_cutoff(cell_d)
+            mesh_d = cell_d.cutoff_to_mesh(ke_cutoff)
+            log.debug1('lr_k dd-block ke_cutoff = %s mesh = %s', ke_cutoff, mesh_d)
+
+            ft_kern_dd = self.supmol_d.gen_ft_kernel(
+                aosym, return_complex=False, kpts=kpts, verbose=log)
+            Gv, Gvbase, kws = cell_d.get_Gv_weights(mesh_d)
+            gxyz = lib.cartesian_prod([np.arange(len(x)) for x in Gvbase])
+            ngrids_d = len(Gv)
+
+            Gblksize = max(24, int(max_memory*.8e6/16/naod**2/(nkpts+max(nkpts,3)))//8*8)
+            Gblksize = min(Gblksize, ngrids_d)
+            log.debug1('Gblksize = %d', Gblksize)
+            buf = np.empty(nkpts*Gblksize*naod**2*2)
+            for group_id, (kpt, ki_idx, kj_idx, self_conj) \
+                    in enumerate(kk_adapted_iter(cell, kpts)):
+                with lib.temporary_env(cell, dimension=3):
+                    coulG_SR = self.weighted_coulG_SR(kpt, False, mesh_d)
+                if is_zero(kpt) and coulG_SR_at_G0 is not None:
+                    coulG_SR[G0_idx] += coulG_SR_at_G0
+
+                for p0, p1 in lib.prange(0, ngrids_d, Gblksize):
+                    Gpq = ft_kern_dd(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt, out=buf)
+                    update_vk(vk_dd, Gpq, dm_dd, coulG_SR[p0:p1] * weight,
+                              ki_idx, kj_idx, not self_conj, k_to_compute, t_rev_pairs)
                     Gpq = None
-            cpu1 = log.timer_debug1('ft_aopair group %d'%group_id, *cpu1)
+                cpu1 = log.timer_debug1(f'ft_aopair dd-block group {group_id}', *cpu1)
 
-        if (is_zero(kpts) and is_zero(kpts_band) and
-            not np.iscomplexobj(dm_kpts)):
+            for i in range(n_dm):
+                for k in range(nkpts):
+                    lib.takebak_2d(vkR[i,k], vkR_dd[i,k], ao_d_idx, ao_d_idx,
+                                   thread_safe=False)
+                    lib.takebak_2d(vkI[i,k], vkI_dd[i,k], ao_d_idx, ao_d_idx,
+                                   thread_safe=False)
+
+        buf = buf1 = None
+        if is_zero(kpts) and not np.iscomplexobj(dm_kpts):
             vk_kpts = vkR
         else:
             vk_kpts = vkR + vkI * 1j
 
         # Add ewald_exxdiv contribution because G=0 was not included in the
         # non-uniform grids
         if (exxdiv == 'ewald' and
             (cell.dimension < 2 or  # 0D and 1D are computed with inf_vacuum
              (cell.dimension == 2 and cell.low_dim_ft_type == 'inf_vacuum'))):
-            _ewald_exxdiv_for_G0(cell, kpts_band, dms, vk_kpts, kpts_band)
+            _ewald_exxdiv_for_G0(cell, kpts, dms, vk_kpts, kpts)
 
+        if time_reversal_symmetry:
+            for k, k_conj in t_rev_pairs:
+                if k != k_conj:
+                    vk_kpts[:,k_conj] = vk_kpts[:,k].conj()
         log.timer_debug1('get_lr_k_kpts', *cpu0)
         return vk_kpts
 
 RangeSeparationJKBuilder = RangeSeparatedJKBuilder
 
 def _purify(mat_kpts, phase):
+    if phase is None:
+        return mat_kpts
     #:mat_bvk = np.einsum('Rk,nkij,Sk->nRSij', phase, mat_kpts, phase.conj())
     #:return np.einsum('Rk,nRSij,Sk->nkij', phase.conj(), mat_bvk.real, phase)
     nkpts = phase.shape[1]
     mat_bvk = lib.einsum('k,Sk,nkuv->nSuv', phase[0], phase.conj(), mat_kpts)
     return lib.einsum('S,Sk,nSuv->nkuv', nkpts*phase[:,0].conj(), phase, mat_bvk.real)
 
-class _PrimitiveCell(ft_ao._RangeSeparatedCell):
-    '''Cell with partially de-contracted basis'''
-    def __init__(self):
-        self.ref_cell = None
-        self.bas_map = None
-        self.bas_type = None
-        self.sh_loc = None
-        self.contr_coeff = None
-
-    @classmethod
-    def from_cell(cls, cell, ke_cut_threshold=KECUT_THRESHOLD,
-                  rcut_threshold=None, precision=None, verbose=None):
-        log = logger.new_logger(cell, verbose)
-        if precision is None:
-            precision = cell.precision
-
-        pcell, contr_coeff = cell.decontract_basis(to_cart=True)
-        rs_cell = pcell.view(cls)
-        rs_cell.ref_cell = pcell
-
-        rs_cell.contr_coeff = scipy.linalg.block_diag(*contr_coeff)
-        exps = rs_cell._env[rs_cell._bas[:,gto.PTR_EXP]]
-        l = rs_cell._bas[:,gto.ANG_OF]
-        ke_cut = pbcgto.cell._estimate_ke_cutoff(exps, l, 1, precision)
-
-        rs_cell.bas_type = np.empty(rs_cell.nbas, dtype=np.int32)
-        rs_cell.bas_type[ke_cut < ke_cut_threshold] = ft_ao.SMOOTH_BASIS
-        rs_cell.bas_type[ke_cut >= ke_cut_threshold] = ft_ao.LOCAL_BASIS
-        # For each basis of rs_cell, bas_map gives the basis in cell
-        rs_cell.bas_map = np.arange(rs_cell.nbas, dtype=np.int32)
-        rs_cell.sh_loc = np.append(np.arange(rs_cell.nbas), rs_cell.nbas).astype(np.int32)
-        rs_cell.ke_cutoff = ke_cut_threshold
-        rs_cell.precision = precision
-        log.debug3('%s.bas_type %s', cls, rs_cell.bas_type)
-        log.debug3('%s.sh_loc %s', cls, rs_cell.sh_loc)
-        return rs_cell
-
-class _ExtendedMoleSR(rsdf_builder._ExtendedMoleSR):
-    '''Extended Mole for short-range ERIs without dd-blocks'''
-
-    def strip_basis(self):
-        '''Remove redundant remote basis'''
-        rs_cell = self.rs_cell
-        bas_mask = self.bas_mask
-        compact_bas_mask = rs_cell.bas_type != ft_ao.SMOOTH_BASIS
-        omega = self.omega
-        bas_exps = rs_cell.bas_exps()
-        exps = np.array([e.min() for e in bas_exps])
-        exps_c = exps[compact_bas_mask]
-        if exps_c.size > 0:
-            exp_min = exps.min()
-            exp_c_min = exps_c.min()
-            aij = exp_min + exps_c
-            eij = exp_min * exps_c / aij
-            akl = exp_c_min + exp_min
-            ekl = exp_c_min * exp_min / akl
-            theta = 1./(omega**-2 + 1./aij + 1./akl)
-            LKs = self.Ls[:,None,:] + self.bvkmesh_Ls
-
-            # For basis on the boundary of a cell, boundary_penalty can adjust
-            # the LKs to get a proper distance estimation between basis
-            #boundary_penalty = pbcgto.cell._rcut_penalty(rs_cell) - 2
-            #rLK = np.linalg.norm(LKs, axis=2) - boundary_penalty
-            shifts = lib.cartesian_prod([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]])
-            a_off_bond = rs_cell.lattice_vectors() - 1.
-            boundary_penalty = np.einsum('te,ex->tx', shifts, a_off_bond)
-            rLK = np.linalg.norm(LKs + boundary_penalty[:,None,None], axis=-1).min(axis=0)
-            rLK[rLK < 1e-2] = 1e-2  # avoid singularity in upper_bounds
-            rr = rLK ** 2
-
-            x_ratio = 1. / (exp_min**2/(exps_c*aij) + exp_c_min/akl + exp_min/theta)
-            y_ratio = 1. / (exp_c_min*exps_c/(exp_min*akl) + exp_min/aij + exps_c/theta)
-            exp_fac = (ekl * x_ratio**2 + eij * y_ratio**2 +
-                       theta * (1 - exp_c_min/akl*x_ratio - exp_min/aij*y_ratio)**2)
-
-            fac = 8*(exp_min**2*exp_c_min*exps_c/(aij*akl)**2)**.75 / (theta*np.pi)**.5
-            upper_bounds = np.einsum('i,lk,ilk->kil', fac, 2*np.pi/rr,
-                                     np.exp(-exp_fac[:,None,None]*rr))
-
-            # FIXME: test if needed. Seems errors are negligible
-            # cutoff = rs_cell.precision * ft_ao.LATTICE_SUM_PENALTY
-            cutoff = rs_cell.precision
-            bas_mask[:,compact_bas_mask] = upper_bounds > cutoff
-
-            # determine rcut boundary for diffused functions
-            exps_d = exps[~compact_bas_mask]
-            if exps_d.size > 0:
-                aij = exp_c_min + exps_d
-                eij = exp_c_min * exps_d / aij
-                akl = exp_c_min + exp_min
-                ekl = exp_c_min * exp_min / akl
-                theta = 1./(omega**-2 + 1./aij + 1./akl)
-                x_ratio = 1. / (exp_min*exp_c_min/(exps_d *aij) + exp_c_min/akl + exp_min/theta)
-                y_ratio = 1. / (exps_d *exp_c_min/(exp_min*akl) + exp_c_min/aij + exps_d /theta)
-                exp_fac = (ekl * x_ratio**2 + eij * y_ratio**2 +
-                           theta * (1 - exp_c_min/akl*x_ratio - exp_c_min/aij*y_ratio)**2)
-                fac = 8*(exp_min*exp_c_min**2*exps_d/(aij*akl)**2)**.75 / (theta*np.pi)**.5
-                upper_bounds = np.einsum('i,lk,ilk->ilk', fac, 2*np.pi/rLK,
-                                         np.exp(-exp_fac[:,None,None]*rr))
-                bas_mask[:,~compact_bas_mask] = upper_bounds.transpose(2,0,1) > cutoff
-
-            bas_mask[0,:,0] = True
-
-        nbas0 = self._bas.shape[0]
-        self._bas = np.asarray(self._bas[bas_mask.ravel()], dtype=np.int32, order='C')
-        nbas1 = self._bas.shape[0]
-        logger.debug1(self, 'strip_basis %d to %d ', nbas0, nbas1)
-        self.sh_loc = self.bas_mask_to_sh_loc(rs_cell, bas_mask)
-        self.bas_mask = bas_mask
-        return self
 
+def estimate_rcut(rs_cell, omega, precision=None,
+                  exclude_dd_block=True):
+    '''Estimate rcut for 2e SR-integrals'''
+    if precision is None:
+        precision = rs_cell.precision
+
+    rs_cell = rs_cell
+    exps, cs = pbcgto.cell._extract_pgto_params(rs_cell, 'min')
+    ls = rs_cell._bas[:,gto.ANG_OF]
+
+    exp_min_idx = exps.argmin()
+    cost = cs * (.5*abs(omega)*rs_cell.rcut)**ls / (2*exps)**(ls/2+.75)
+    ai_idx = ak_idx = cost.argmax()
+    compact_mask = rs_cell.bas_type != ft_ao.SMOOTH_BASIS
+    compact_idx = np.where(compact_mask)[0]
+    if exclude_dd_block and compact_idx.size > 0:
+        ak_idx = compact_idx[cost[compact_idx].argmax()]
+    logger.debug2(rs_cell, 'ai_idx=%d ak_idx=%d', ai_idx, ak_idx)
+    # Case 1: l in cell0, product kl ~ dc, product ij ~ dd and dc
+    # This includes interactions (dc|dd)
+    ak = exps[ak_idx]
+    lk = rs_cell._bas[ak_idx,gto.ANG_OF]
+    ck = cs[ak_idx]
+    aj = exps
+    lj = ls
+    cj = cs
+    ai = exps[ai_idx]
+    li = rs_cell._bas[ai_idx,gto.ANG_OF]
+    ci = cs[ai_idx]
+    al = exps[exp_min_idx]
+    ll = rs_cell._bas[exp_min_idx,gto.ANG_OF]
+    cl = cs[exp_min_idx]
+
+    aij = ai + aj
+    akl = ak + al
+    lij = li + lj
+    lkl = lk + ll
+    l4 = lij + lkl
+    norm_ang = ((2*li+1)*(2*lj+1)*(2*lk+1)*(2*ll+1)/(4*np.pi)**4)**.5
+    c1 = ci * cj * ck * cl * norm_ang
+    theta = omega**2*aij*akl/(aij*akl + (aij+akl)*omega**2)
+    sfac = omega**2*aj*al/(aj*al + (aj+al)*omega**2) / theta
+    fl = 2
+    fac = 2**(li+lk)*np.pi**2.5*c1 * theta**(l4-.5)
+    fac *= 2*np.pi/rs_cell.vol/theta
+    fac /= aij**(li+1.5) * akl**(lk+1.5) * aj**lj * al**ll
+    fac *= fl / precision
+
+    r0 = rs_cell.rcut
+    r0 = (np.log(fac * r0 * (sfac*r0)**(l4-1) + 1.) / (sfac*theta))**.5
+    r0 = (np.log(fac * r0 * (sfac*r0)**(l4-1) + 1.) / (sfac*theta))**.5
+    rcut = r0
+
+    if exclude_dd_block and 0 < compact_idx.size < rs_cell.nbas:
+        # Case 2: l in cell0, product kl ~ dc, product ij ~ cd
+        # so as to exclude interaction (dc|dd)
+        smooth_mask = ~compact_mask
+        ai, li, ci = ak, lk, ck
+        aj = exps[smooth_mask]
+        lj = ls[smooth_mask]
+        cj = cs[smooth_mask]
+        aij = ai + aj
+        lij = li + lj
+        l4 = lij + lkl
+        norm_ang = ((2*li+1)*(2*lj+1)*(2*lk+1)*(2*ll+1)/(4*np.pi)**4)**.5
+        c1 = ci * cj * ck * cl * norm_ang
+        theta = omega**2*aij*akl/(aij*akl + (aij+akl)*omega**2)
+        sfac = omega**2*aj*al/(aj*al + (aj+al)*omega**2) / theta
+        fl = 2
+        fac = 2**(li+lk)*np.pi**2.5*c1 * theta**(l4-.5)
+        fac *= 2*np.pi/rs_cell.vol/theta
+        fac /= aij**(li+1.5) * akl**(lk+1.5) * aj**lj * al**ll
+        fac *= fl / precision
+
+        r0 = rcut[smooth_mask]
+        r0 = (np.log(fac * r0 * (sfac*r0)**(l4-1) + 1.) / (sfac*theta))**.5
+        r0 = (np.log(fac * r0 * (sfac*r0)**(l4-1) + 1.) / (sfac*theta))**.5
+        rcut[smooth_mask] = r0
+    return rcut
 
 def _guess_omega(cell, kpts, mesh=None):
     a = cell.lattice_vectors()
-    naop = cell.npgto_nr()
-    nao = cell.nao
+    if cell.dimension == 0:
+        if mesh is None:
+            mesh = cell.mesh
+        ke_cutoff = pbctools.mesh_to_cutoff(a, mesh).min()
+        return 0, mesh, ke_cutoff
+
+    precision = cell.precision
     nkpts = len(kpts)
     if mesh is None:
-        rcut = cell.rcut
-        omega_min = 0.25
-        omega_min = 0.75 * (-np.log(cell.precision * np.pi**.5 * rcut**2 * omega_min))**.5 / rcut
-        ke_min = aft.estimate_ke_cutoff_for_omega(cell, omega_min)
-        mesh_min = pbctools.cutoff_to_mesh(a, ke_min)
-        # FIXME: balance the two workloads
-        # int2e integrals ~ naop*(cell.rcut**3/cell.vol*naop)**3
-        # ft_ao integrals ~ nkpts*naop*(cell.rcut**3/cell.vol*naop)*mesh**3
-        #                   nkpts**2*naop**3*mesh**3
-        nimgs = (cell.rcut**3 / cell.vol) ** (cell.dimension / 3)
-        # mesh = [max(4, int((nimgs * naop**2 / nkpts**.5) ** (1./3) * 0.5))] * 3
-        # mesh = [max(4, int((nimgs**1.5 * naop**2 / nkpts**.5) ** (1./3) * 0.2))] * 3
-        # mesh = [max(4, int((nimgs**2 * naop**2 / nkpts**.5) ** (1./3) * 0.125))] * 3
-        # mesh = [max(4, int((nimgs**1.5 * naop**1.5 / nkpts**.5) ** (1./3) * 0.5))] * 3
-        # mesh = [max(4, int((nimgs * naop / nkpts**.5) ** (1./3) * 1.5))] * 3
-        # mesh = [max(4, int((nimgs * naop / nkpts**.5) ** (1./3) * 1.5))] * 3
-        # mesh = [max(4, int((nimgs * naop / nkpts**(1./3)) ** (1./3) * 1.5))] * 3
-        nimgs = 8 * nimgs
-        mesh = (nimgs**2*naop**2 / (nkpts**.5 * naop * nimgs * 2e3 +
-                                    nkpts**2*nao**2))**(1./3) * 8 + 1
-        mesh = int(min((cell.max_memory*1e6/32/(.7*nao)**2)**(1./3), mesh))
-        mesh = np.max([mesh_min, [mesh] * 3], axis=0)
-    mesh = np.min([cell.mesh, mesh], axis=0)
-    ke_cutoff = min(pbctools.mesh_to_cutoff(a, mesh[:cell.dimension]))
-    # FIXME: test if needed
-    # precision = cell.precision * ft_ao.LATTICE_SUM_PENALTY
-    precision = cell.precision
-    omega = aft.estimate_omega_for_ke_cutoff(cell, ke_cutoff, precision)
+        omega_min = OMEGA_MIN
+        ke_min = estimate_ke_cutoff_for_omega(cell, omega_min)
+        nk = nkpts**(1./3)
+        ke_cutoff = 50 / (.7+.25*nk+.05*nk**3)
+        ke_cutoff = max(ke_cutoff, ke_min)
+        mesh = cell.cutoff_to_mesh(ke_cutoff)
+    else:
+        mesh = np.asarray(mesh)
+    ke_cutoff = min(pbctools.mesh_to_cutoff(a, mesh)[:cell.dimension])
+    omega = estimate_omega_for_ke_cutoff(cell, ke_cutoff, precision)
     return omega, mesh, ke_cutoff
 
-def _update_vk_(vk, Gpq, dms, coulG, weight, kpti_idx, kptj_idx, swap_2e):
-    vkR, vkI = vk
-    GpqR, GpqI = Gpq
-    dmsR, dmsI = dms
-    nG = len(coulG)
-    n_dm = vkR.shape[0]
-    nao = vkR.shape[-1]
-    bufR = np.empty((nG*nao**2))
-    bufI = np.empty((nG*nao**2))
-    buf1R = np.empty((nG*nao**2))
-    buf1I = np.empty((nG*nao**2))
-
-    for k, (ki, kj) in enumerate(zip(kpti_idx, kptj_idx)):
-        # case 1: k_pq = (pi|iq)
-        #:v4 = np.einsum('ijL,lkL->ijkl', pqk, pqk.conj())
-        #:vk += np.einsum('ijkl,jk->il', v4, dm)
-        pLqR = np.ndarray((nao,nG,nao), buffer=bufR)
-        pLqI = np.ndarray((nao,nG,nao), buffer=bufI)
-        pLqR[:] = GpqR[k].transpose(1,0,2)
-        pLqI[:] = GpqI[k].transpose(1,0,2)
-        iLkR = np.ndarray((nao,nG,nao), buffer=buf1R)
-        iLkI = np.ndarray((nao,nG,nao), buffer=buf1I)
-        for i in range(n_dm):
-            zdotNN(pLqR.reshape(-1,nao), pLqI.reshape(-1,nao),
-                   dmsR[i,kj], dmsI[i,kj], 1,
-                   iLkR.reshape(-1,nao), iLkI.reshape(-1,nao))
-            iLkR *= coulG.reshape(1,nG,1)
-            iLkI *= coulG.reshape(1,nG,1)
-            zdotNC(iLkR.reshape(nao,-1), iLkI.reshape(nao,-1),
-                   pLqR.reshape(nao,-1).T, pLqI.reshape(nao,-1).T,
-                   weight, vkR[i,ki], vkI[i,ki], 1)
-
-        # case 2: k_pq = (iq|pi)
-        #:v4 = np.einsum('iLj,lLk->ijkl', pqk, pqk.conj())
-        #:vk += np.einsum('ijkl,li->kj', v4, dm)
-        # <r|-G+k_rs|s> = conj(<s|G-k_rs|r>) = conj(<s|G+k_sr|r>)
-        if swap_2e:
-            for i in range(n_dm):
-                zdotNN(dmsR[i,ki], dmsI[i,ki], pLqR.reshape(nao,-1),
-                       pLqI.reshape(nao,-1), 1,
-                       iLkR.reshape(nao,-1), iLkI.reshape(nao,-1))
-                iLkR *= coulG.reshape(1,nG,1)
-                iLkI *= coulG.reshape(1,nG,1)
-                zdotCN(pLqR.reshape(-1,nao).T, pLqI.reshape(-1,nao).T,
-                       iLkR.reshape(-1,nao), iLkI.reshape(-1,nao),
-                       weight, vkR[i,kj], vkI[i,kj], 1)
+def estimate_ke_cutoff_for_omega(cell, omega, precision=None):
+    '''Energy cutoff for FFTDF to converge attenuated Coulomb in moment space
+    '''
+    if precision is None:
+        precision = cell.precision
+    ai = np.hstack(cell.bas_exps()).max()
+    theta = 1./(1./ai + omega**-2)
+    fac = 32*np.pi**2 * theta / precision
+    Ecut = 20.
+    Ecut = np.log(fac / (2*Ecut) + 1.) * 2*theta
+    Ecut = np.log(fac / (2*Ecut) + 1.) * 2*theta
+    return Ecut
+
+def estimate_omega_for_ke_cutoff(cell, ke_cutoff, precision=None):
+    '''The minimal omega in attenuated Coulombl given energy cutoff
+    '''
+    if precision is None:
+        precision = cell.precision
+#    # esitimation based on \int dk 4pi/k^2 exp(-k^2/4omega) sometimes is not
+#    # enough to converge the 2-electron integrals. A penalty term here is to
+#    # reduce the error in integrals
+#    precision *= 1e-2
+#    kmax = (ke_cutoff*2)**.5
+#    log_rest = np.log(precision / (16*np.pi**2 * kmax**lmax))
+#    omega = (-.5 * ke_cutoff / log_rest)**.5
+#    return omega
+
+    ai = np.hstack(cell.bas_exps()).max()
+    aij = ai * 2
+    fac = 32*np.pi**2 / precision
+    omega = .3
+    theta = 1./(1./ai + omega**-2)
+    omega2 = 1./(np.log(fac * theta/ (2*ke_cutoff) + 1.)*2/ke_cutoff - 1./aij)
+    if omega2 > 0:
+        theta = 1./(1./ai + 1./omega2)
+        omega2 = 1./(np.log(fac * theta/ (2*ke_cutoff) + 1.)*2/ke_cutoff - 1./aij)
+    omega = max(omega2, 0)**.5
+    if omega < OMEGA_MIN:
+        logger.warn(cell, 'omega=%g smaller than the required minimal value %g. '
+                    'Set omega to %g', omega2, OMEGA_MIN, OMEGA_MIN)
+        omega = OMEGA_MIN
+    return omega
+
+def _qcond_cell0_abstract(qcond, seg_loc, seg2sh, nbasp):
+    '''Find the max qcond for ij pair'''
+    # The first shell in each seg_loc[i]:seg_loc[i+1] is inside cell0
+    cell0_prim_idx = seg2sh[np.arange(seg_loc[nbasp])]
+    qcond_sub = qcond[:,cell0_prim_idx]
+    sh_loc = seg2sh[seg_loc]
+    nbas_bvk = sh_loc.size - 1
+    qtmp = np.empty((nbas_bvk, cell0_prim_idx.size), dtype=qcond.dtype)
+    for i, (i0, i1) in enumerate(zip(sh_loc[:-1], sh_loc[1:])):
+        if i0 != i1:
+            qtmp[i] = qcond_sub[i0:i1].max(axis=0)
+        else:
+            qtmp[i] = INDEX_MIN
+    qcond_cell0 = np.empty((nbas_bvk, nbasp), dtype=qcond.dtype)
+    for j, (j0, j1) in enumerate(zip(seg_loc[:nbasp], seg_loc[1:nbasp+1])):
+        if j0 != j1:
+            qcond_cell0[:,j] = qtmp[:,j0:j1].max(axis=1)
+        else:
+            qcond_cell0[:,j] = INDEX_MIN
+    return qcond_cell0
```

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/scfint.py` & `pyscf-2.3.0/pyscf/pbc/scf/scfint.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/stability.py` & `pyscf-2.3.0/pyscf/pbc/scf/stability.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/scf/uhf.py` & `pyscf-2.3.0/pyscf/pbc/scf/uhf.py`

 * *Files 2% similar despite different names*

```diff
@@ -155,23 +155,16 @@
     def get_veff(self, cell=None, dm=None, dm_last=0, vhf_last=0, hermi=1,
                  kpt=None, kpts_band=None):
         if cell is None: cell = self.cell
         if dm is None: dm = self.make_rdm1()
         if kpt is None: kpt = self.kpt
         if isinstance(dm, np.ndarray) and dm.ndim == 2:
             dm = np.asarray((dm*.5,dm*.5))
-        if self.rsjk and self.direct_scf:
-            # Enable direct-SCF for real space JK builder
-            ddm = dm - dm_last
-            vj, vk = self.get_jk(cell, ddm, hermi, kpt, kpts_band)
-            vhf = vj[0] + vj[1] - vk
-            vhf += vhf_last
-        else:
-            vj, vk = self.get_jk(cell, dm, hermi, kpt, kpts_band)
-            vhf = vj[0] + vj[1] - vk
+        vj, vk = self.get_jk(cell, dm, hermi, kpt, kpts_band)
+        vhf = vj[0] + vj[1] - vk
         return vhf
 
     def get_bands(self, kpts_band, cell=None, dm=None, kpt=None):
         '''Get energy bands at the given (arbitrary) 'band' k-points.
 
         Returns:
             mo_energy : (nmo,) ndarray or a list of (nmo,) ndarray
@@ -217,19 +210,15 @@
         if dm is None:
             dm = self.make_rdm1()
         rho = kwargs.pop('rho', None)
         if rho is None:
             rho = self.get_rho(dm)
         return dip_moment(cell, dm, unit, verbose, rho=rho, kpt=self.kpt, **kwargs)
 
-    def get_init_guess(self, cell=None, key='minao'):
-        if cell is None: cell = self.cell
-        dm = mol_uhf.UHF.get_init_guess(self, cell, key)
-        dm = pbchf.normalize_dm_(self, dm)
-        return dm
+    get_init_guess = pbchf.RHF.get_init_guess
 
     def init_guess_by_1e(self, cell=None):
         if cell is None: cell = self.cell
         if cell.dimension < 3:
             logger.warn(self, 'Hcore initial guess is not recommended in '
                         'the SCF of low-dimensional systems.')
         return mol_uhf.UHF.init_guess_by_1e(self, cell)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/symm/__init__.py` & `pyscf-2.3.0/pyscf/pbc/symm/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/symm/basis.py` & `pyscf-2.3.0/pyscf/pbc/symm/basis.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/symm/geom.py` & `pyscf-2.3.0/pyscf/pbc/symm/geom.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/symm/group.py` & `pyscf-2.3.0/pyscf/pbc/symm/group.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/symm/pyscf_spglib.py` & `pyscf-2.3.0/pyscf/pbc/symm/pyscf_spglib.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/symm/space_group.py` & `pyscf-2.3.0/pyscf/pbc/symm/space_group.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/symm/symmetry.py` & `pyscf-2.3.0/pyscf/pbc/symm/symmetry.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/symm/tables.py` & `pyscf-2.3.0/pyscf/pbc/symm/tables.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tddft/__init__.py` & `pyscf-2.3.0/pyscf/pbc/tddft/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/__init__.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/kproxy.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/kproxy.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/kproxy_supercell.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/kproxy_supercell.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/krhf.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/krhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/krhf_slow.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/krhf_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/krhf_slow_gamma.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/krhf_slow_gamma.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/krhf_slow_supercell.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/krhf_slow_supercell.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/krks.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/krks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/kuhf.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/kuhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/kuks.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/kuks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/proxy.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/proxy.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/rhf.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/rhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/rhf_slow.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/rhf_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/rks.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/rks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/uhf.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/uhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tdscf/uks.py` & `pyscf-2.3.0/pyscf/pbc/tdscf/uks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tools/__init__.py` & `pyscf-2.3.0/pyscf/pbc/tools/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tools/k2gamma.py` & `pyscf-2.3.0/pyscf/pbc/tools/k2gamma.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,34 +29,35 @@
 from fractions import Fraction
 import numpy as np
 import scipy.linalg
 from pyscf import lib
 from pyscf.lib import logger
 from pyscf.pbc import tools
 from pyscf.pbc.lib.kpts import KPoints
+from pyscf.pbc.lib.kpts_helper import group_by_conj_pairs
 
 
 def kpts_to_kmesh(cell, kpts, precision=None):
     '''Find the minimal k-points mesh to include all input kpts'''
     scaled_kpts = cell.get_scaled_kpts(kpts)
     logger.debug3(cell, '    scaled_kpts kpts %s', scaled_kpts)
     # cell.nimgs are the upper limits for kmesh
     kmesh = np.asarray(cell.nimgs) * 2 + 1
     if precision is None:
-        precision = cell.precision
+        precision = cell.precision * 1e2
     for i in range(3):
         floats = scaled_kpts[:,i]
         uniq_floats_idx = np.unique(floats.round(6), return_index=True)[1]
         uniq_floats = floats[uniq_floats_idx]
-        # Limit the number of images to 20 in each direction
-        fracs = [Fraction(x).limit_denominator(20) for x in uniq_floats]
+        # Limit the number of images to 30 in each direction
+        fracs = [Fraction(x).limit_denominator(30) for x in uniq_floats]
         denominators = np.unique([x.denominator for x in fracs])
         common_denominator = reduce(np.lcm, denominators)
         fs = common_denominator * uniq_floats
-        if abs(fs - np.rint(fs)).max() < max(precision, 1e-5):
+        if abs(uniq_floats - np.rint(fs)/common_denominator).max() < precision:
             kmesh[i] = min(kmesh[i], common_denominator)
         if cell.verbose >= logger.DEBUG3:
             logger.debug3(cell, 'dim=%d common_denominator %d  error %g',
                           i, common_denominator, abs(fs - np.rint(fs)).max())
             logger.debug3(cell, '    unique kpts %s', uniq_floats)
             logger.debug3(cell, '    frac kpts %s', fracs)
     return kmesh
@@ -134,44 +135,62 @@
     scell, phase = get_phase(cell, kpts, kmesh)
 
     E_g = np.hstack(mo_energy)
     C_k = np.asarray(mo_coeff)
     Nk, Nao, Nmo = C_k.shape
     NR = phase.shape[0]
 
+    k_conj_groups = group_by_conj_pairs(cell, kpts, return_kpts_pairs=False)
+    k_phase = np.eye(Nk, dtype=np.complex128)
+    r2x2 = np.array([[1., 1j], [1., -1j]]) * .5**.5
+    pairs = [[k, k_conj] for k, k_conj in k_conj_groups
+             if k_conj is not None and k != k_conj]
+    for idx in np.array(pairs):
+        k_phase[idx[:,None],idx] = r2x2
     # Transform AO indices
-    C_gamma = np.einsum('Rk, kum -> Rukm', phase, C_k)
+    C_gamma = np.einsum('Rk,kum,kh->Ruhm', phase, C_k, k_phase)
     C_gamma = C_gamma.reshape(Nao*NR, Nk*Nmo)
 
-    E_sort_idx = np.argsort(E_g)
+    # Pure imaginary orbitals to real
+    cR_max = abs(C_gamma.real).max(axis=0)
+    C_gamma[:,cR_max < 1e-5] *= -1j
+
+    E_sort_idx = np.argsort(E_g, kind='stable')
     E_g = E_g[E_sort_idx]
-    C_gamma = C_gamma[:,E_sort_idx]
-    s = scell.pbc_intor('int1e_ovlp')
-    assert (abs(reduce(np.dot, (C_gamma.conj().T, s, C_gamma))
-               - np.eye(Nmo*Nk)).max() < 1e-5)
-
-    # For degenerated MOs, the transformed orbitals in super cell may not be
-    # real. Construct a sub Fock matrix in super-cell to find a proper
-    # transformation that makes the transformed MOs real.
-    E_k_degen = abs(E_g[1:] - E_g[:-1]) < 1e-3
-    degen_mask = np.append(False, E_k_degen) | np.append(E_k_degen, False)
-    if np.any(E_k_degen):
-        if abs(C_gamma[:,~degen_mask].imag).max() < 1e-4:
-            shift = min(E_g[degen_mask]) - .1
-            f = np.dot(C_gamma[:,degen_mask] * (E_g[degen_mask] - shift),
-                       C_gamma[:,degen_mask].conj().T)
-            assert (abs(f.imag).max() < 1e-4)
-
-            e, na_orb = scipy.linalg.eigh(f.real, s, type=2)
-            C_gamma = C_gamma.real
-            C_gamma[:,degen_mask] = na_orb[:, e>1e-7]
-        else:
-            f = np.dot(C_gamma * E_g, C_gamma.conj().T)
-            assert (abs(f.imag).max() < 1e-4)
-            e, C_gamma = scipy.linalg.eigh(f.real, s, type=2)
+
+    cI_max = abs(C_gamma.imag).max(axis=0)
+    if cI_max.max() < 1e-5:
+        C_gamma = C_gamma.real[:,E_sort_idx]
+    else:
+        C_gamma = C_gamma[:,E_sort_idx]
+        s = scell.pbc_intor('int1e_ovlp')
+        # assert (abs(reduce(np.dot, (C_gamma.conj().T, s, C_gamma))
+        #            - np.eye(Nmo*Nk)).max() < 1e-5)
+
+        # For degenerated MOs, the transformed orbitals in super cell may not be
+        # real. Construct a sub Fock matrix in super-cell to find a proper
+        # transformation that makes the transformed MOs real.
+        E_k_degen = abs(E_g[1:] - E_g[:-1]) < 1e-3
+        degen_mask = np.append(False, E_k_degen) | np.append(E_k_degen, False)
+        degen_mask[cI_max < 1e-5] = False
+        if np.any(E_k_degen):
+            c_rest = C_gamma[:,~degen_mask]
+            if c_rest.size > 0 and abs(c_rest.imag).max() < 1e-4:
+                shift = min(E_g[degen_mask]) - .1
+                f = np.dot(C_gamma[:,degen_mask] * (E_g[degen_mask] - shift),
+                           C_gamma[:,degen_mask].conj().T)
+                assert (abs(f.imag).max() < 1e-4)
+
+                e, na_orb = scipy.linalg.eigh(f.real, s, type=2)
+                C_gamma = C_gamma.real
+                C_gamma[:,degen_mask] = na_orb[:, e>1e-7]
+            else:
+                f = np.dot(C_gamma * E_g, C_gamma.conj().T)
+                assert (abs(f.imag).max() < 1e-4)
+                e, C_gamma = scipy.linalg.eigh(f.real, s, type=2)
 
     s_k = cell.pbc_intor('int1e_ovlp', kpts=kpts)
     # overlap between k-point unitcell and gamma-point supercell
     s_k_g = np.einsum('kuv,Rk->kuRv', s_k, phase.conj()).reshape(Nk,Nao,NR*Nao)
     # The unitary transformation from k-adapted orbitals to gamma-point orbitals
     mo_phase = lib.einsum('kum,kuv,vi->kmi', C_k.conj(), s_k_g, C_gamma)
 
@@ -190,15 +209,15 @@
     def transform(mo_energy, mo_coeff, mo_occ):
         if isinstance(kmf.kpts, KPoints):
             kpts = kmf.kpts.kpts
         else:
             kpts = kmf.kpts
         scell, E_g, C_gamma = mo_k2gamma(kmf.cell, mo_energy, mo_coeff,
                                          kpts, kmesh)[:3]
-        E_sort_idx = np.argsort(np.hstack(mo_energy))
+        E_sort_idx = np.argsort(np.hstack(mo_energy), kind='stable')
         mo_occ = np.hstack(mo_occ)[E_sort_idx]
         return scell, E_g, C_gamma, mo_occ
 
     if isinstance(kmf.kpts, KPoints):
         mo_coeff = kmf.kpts.transform_mo_coeff(kmf.mo_coeff)
         mo_energy = kmf.kpts.transform_mo_energy(kmf.mo_energy)
         mo_occ = kmf.kpts.transform_mo_occ(kmf.mo_occ)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/tools/lattice.py` & `pyscf-2.3.0/pyscf/pbc/tools/lattice.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tools/make_test_cell.py` & `pyscf-2.3.0/pyscf/pbc/tools/make_test_cell.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tools/print_funcs.py` & `pyscf-2.3.0/pyscf/pbc/tools/print_funcs.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tools/pyscf_ase.py` & `pyscf-2.3.0/pyscf/pbc/tools/pyscf_ase.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tools/pywannier90.py` & `pyscf-2.3.0/pyscf/pbc/tools/pywannier90.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/tools/tril.py` & `pyscf-2.3.0/pyscf/pbc/tools/tril.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/x2c/__init__.py` & `pyscf-2.3.0/pyscf/pbc/x2c/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/pbc/x2c/sfx2c1e.py` & `pyscf-2.3.0/pyscf/pbc/x2c/sfx2c1e.py`

 * *Files 3% similar despite different names*

```diff
@@ -31,17 +31,17 @@
 from pyscf.lib import logger
 from pyscf.x2c import x2c
 from pyscf.pbc import gto as pbcgto
 from pyscf.pbc import tools
 from pyscf.pbc.df import aft
 from pyscf.pbc.df import aft_jk
 from pyscf.pbc.df import ft_ao
-from pyscf.pbc.df import incore
 from pyscf.pbc.df import gdf_builder
 from pyscf.pbc.scf import ghf
+from pyscf.pbc.lib.kpts_helper import is_zero
 from pyscf import __config__
 
 
 def sfx2c1e(mf):
     '''Spin-free X2C.
     For the given SCF object, it updates the hcore constructor.
 
@@ -250,67 +250,70 @@
     nkpts = len(kpts_lst)
     nao = cell.nao_nr()
     nao_pair = nao * (nao+1) // 2
 
     eta, mesh, ke_cutoff = gdf_builder._guess_eta(cell, kpts_lst)
     log.debug1('get_pnucp eta = %s mesh = %s', eta, mesh)
 
-    nuccell = incore._compensate_nuccell(cell, eta)
-    wj = mydf._int_nuc_vloc(nuccell, kpts_lst, 'int3c2e_pvp1')
+    dfbuilder = gdf_builder._CCNucBuilder(cell, kpts_lst)
+    dfbuilder.exclude_dd_block = False
+    dfbuilder.build()
+    fakenuc = aft._fake_nuc(cell, with_pseudo=cell._pseudo)
+    wj = dfbuilder._int_nuc_vloc(fakenuc, 'int3c2e_pvp1', aosym='s2')
     t1 = log.timer_debug1('pnucp pass1: analytic int', *t1)
 
     charge = -cell.atom_charges() # Apply Koseki effective charge?
     if cell.dimension == 3:
-        nucbar = sum([z/nuccell.bas_exp(i)[0] for i,z in enumerate(charge)])
+        mod_cell = dfbuilder.modchg_cell
+        nucbar = (charge / numpy.hstack(mod_cell.bas_exps())).sum()
         nucbar *= numpy.pi/cell.vol
 
         ovlp = cell.pbc_intor('int1e_kin', 1, lib.HERMITIAN, kpts_lst)
         for k in range(nkpts):
             s = lib.pack_tril(ovlp[k])
             # *2 due to the factor 1/2 in T
             wj[k] -= nucbar*2 * s
 
-    dfbuilder = incore._IntNucBuilder(cell, kpts_lst).build()
-    supmol_ft = dfbuilder.supmol.strip_basis()
-    ft_kern = supmol_ft.gen_ft_kernel('s2', intor='GTO_ft_pdotp',
-                                      return_complex=False, verbose=log)
+    ft_kern = dfbuilder.supmol_ft.gen_ft_kernel(
+        's2', intor='GTO_ft_pdotp', return_complex=False,
+        kpts=kpts_lst, verbose=log)
 
     Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
     gxyz = lib.cartesian_prod([numpy.arange(len(x)) for x in Gvbase])
     ngrids = Gv.shape[0]
     kpt_allow = numpy.zeros(3)
     coulG = tools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv)
     coulG *= kws
-    aoaux = ft_ao.ft_ao(nuccell, Gv)
+    aoaux = ft_ao.ft_ao(dfbuilder.modchg_cell, Gv)
     vG = numpy.einsum('i,xi->x', charge, aoaux) * coulG
     vGR = vG.real
     vGI = vG.imag
     max_memory = max(2000, mydf.max_memory-lib.current_memory()[0])
     Gblksize = max(16, int(max_memory*1e6/16/nao_pair/nkpts))
     Gblksize = min(Gblksize, ngrids, 200000)
     log.debug1('max_memory = %s  Gblksize = %s  ngrids = %s',
                max_memory, Gblksize, ngrids)
 
     buf = numpy.empty((2, nkpts, Gblksize, nao_pair))
     for p0, p1 in lib.prange(0, ngrids, Gblksize):
         # shape of Gpq (nkpts, nGv, nao_pair)
-        Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, kpts_lst, out=buf)
+        Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, out=buf)
         for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
             vR  = numpy.einsum('k,kx->x', vGR[p0:p1], GpqR)
             vR += numpy.einsum('k,kx->x', vGI[p0:p1], GpqI)
             wj[k] += vR
-            if not aft_jk.gamma_point(kpts_lst[k]):
+            if not is_zero(kpts_lst[k]):
                 vI  = numpy.einsum('k,kx->x', vGR[p0:p1], GpqI)
                 vI -= numpy.einsum('k,kx->x', vGI[p0:p1], GpqR)
                 wj[k] += vI * 1j
     t1 = log.timer_debug1('contracting pnucp', *t1)
 
     wj_kpts = []
     for k, kpt in enumerate(kpts_lst):
-        if aft_jk.gamma_point(kpt):
+        if is_zero(kpt):
             wj_kpts.append(lib.unpack_tril(wj[k].real.copy()))
         else:
             wj_kpts.append(lib.unpack_tril(wj[k]))
 
     if kpts is None or numpy.shape(kpts) == (3,):
         wj_kpts = wj_kpts[0]
     return numpy.asarray(wj_kpts)
```

### Comparing `pyscf-2.2.1/pyscf/pbc/x2c/x2c1e.py` & `pyscf-2.3.0/pyscf/pbc/x2c/x2c1e.py`

 * *Files 3% similar despite different names*

```diff
@@ -34,18 +34,18 @@
 from pyscf.lib import logger
 from pyscf.x2c import x2c
 from pyscf.pbc import gto as pbcgto
 from pyscf.pbc import tools
 from pyscf.pbc.df import aft
 from pyscf.pbc.df import aft_jk
 from pyscf.pbc.df import ft_ao
-from pyscf.pbc.df import incore
 from pyscf.pbc.df import gdf_builder
 from pyscf.pbc.scf import ghf
 from pyscf.pbc.x2c import sfx2c1e
+from pyscf.pbc.lib.kpts_helper import is_zero
 from pyscf import __config__
 
 def x2c1e_gscf(mf):
     '''
     For the given *GHF* object, it generates X2C1E-GSCF object in spin-orbital basis
     and updates the hcore constructor.
 
@@ -211,71 +211,64 @@
 
     log = logger.Logger(cell.stdout, cell.verbose)
     t1 = (logger.process_clock(), logger.perf_counter())
 
     nkpts = len(kpts_lst)
     nao = cell.nao_nr()
 
+    dfbuilder = gdf_builder._CCNucBuilder(cell, kpts_lst)
+    dfbuilder.exclude_dd_block = False
+    dfbuilder.build()
     eta, mesh, ke_cutoff = gdf_builder._guess_eta(cell, kpts_lst)
     log.debug1('get_pnucp eta = %s mesh = %s', eta, mesh)
-    nuccell = copy.copy(cell)
-    half_sph_norm = .5/numpy.sqrt(numpy.pi)
-    norm = half_sph_norm/mole.gaussian_int(2, eta)
-    chg_env = [eta, norm]
-    ptr_eta = cell._env.size
-    ptr_norm = ptr_eta + 1
-    chg_bas = [[ia, 0, 1, 1, 0, ptr_eta, ptr_norm, 0] for ia in range(cell.natm)]
-    nuccell._atm = cell._atm
-    nuccell._bas = numpy.asarray(chg_bas, dtype=numpy.int32)
-    nuccell._env = numpy.hstack((cell._env, chg_env))
 
-    soc_mat = mydf._int_nuc_vloc(nuccell, kpts_lst, 'int3c2e_pvxp1_sph',
-                                 aosym='s1', comp=3)
+    fakenuc = aft._fake_nuc(cell, with_pseudo=cell._pseudo)
+    soc_mat = dfbuilder._int_nuc_vloc(fakenuc, 'int3c2e_pvxp1_sph',
+                                      aosym='s1', comp=3)
     soc_mat = soc_mat.reshape(nkpts,3,nao,nao)
     t1 = log.timer_debug1('pnucp pass1: analytic int', *t1)
 
-    dfbuilder = incore._IntNucBuilder(cell, kpts_lst).build()
-    supmol_ft = dfbuilder.supmol.strip_basis()
-    ft_kern = supmol_ft.gen_ft_kernel('s1', intor='GTO_ft_pxp_sph', comp=3,
-                                      return_complex=False, verbose=log)
+    ft_kern = dfbuilder.supmol_ft.gen_ft_kernel(
+        's1', intor='GTO_ft_pxp_sph', comp=3, return_complex=False,
+        kpts=kpts_lst, verbose=log)
 
     Gv, Gvbase, kws = cell.get_Gv_weights(mesh)
     gxyz = lib.cartesian_prod([numpy.arange(len(x)) for x in Gvbase])
     ngrids = Gv.shape[0]
     kpt_allow = numpy.zeros(3)
     coulG = tools.get_coulG(cell, kpt_allow, mesh=mesh, Gv=Gv)
     coulG *= kws
-    aoaux = ft_ao.ft_ao(nuccell, Gv)
+    aoaux = ft_ao.ft_ao(dfbuilder.modchg_cell, Gv)
     charge = -cell.atom_charges() # Apply Koseki effective charge?
     vG = numpy.einsum('i,xi->x', charge, aoaux) * coulG
     vGR = vG.real
     vGI = vG.imag
 
     max_memory = max(2000, mydf.max_memory-lib.current_memory()[0])
     Gblksize = max(16, int(max_memory*1e6/16/3/nao**2/nkpts))
     Gblksize = min(Gblksize, ngrids, 200000)
     log.debug1('max_memory = %s  Gblksize = %s  ngrids = %s',
                max_memory, Gblksize, ngrids)
 
     for p0, p1 in lib.prange(0, ngrids, Gblksize):
         # shape of Gpq (nkpts, nGv, nao_pair)
-        Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow, kpts_lst)
+        Gpq = ft_kern(Gv[p0:p1], gxyz[p0:p1], Gvbase, kpt_allow)
         for k, (GpqR, GpqI) in enumerate(zip(*Gpq)):
             vR  = numpy.einsum('k,ckpq->cpq', vGR[p0:p1], GpqR)
             vR += numpy.einsum('k,ckpq->cpq', vGI[p0:p1], GpqI)
             soc_mat[k] += vR
-            if not aft_jk.gamma_point(kpts_lst[k]):
+            if not is_zero(kpts_lst[k]):
                 vI  = numpy.einsum('k,ckpq->cpq', vGR[p0:p1], GpqI)
                 vI -= numpy.einsum('k,ckpq->cpq', vGI[p0:p1], GpqR)
                 soc_mat[k] += vI * 1j
     t1 = log.timer_debug1('contracting pnucp', *t1)
 
     soc_mat_kpts = []
     for k, kpt in enumerate(kpts_lst):
-        if aft_jk.gamma_point(kpt):
+        if is_zero(kpt):
             soc_mat_kpts.append(soc_mat[k].real.reshape(3,nao,nao))
         else:
             soc_mat_kpts.append(soc_mat[k].reshape(3,nao,nao))
 
     if kpts is None or numpy.shape(kpts) == (3,):
         soc_mat_kpts = soc_mat_kpts[0]
     return numpy.asarray(soc_mat_kpts)
```

### Comparing `pyscf-2.2.1/pyscf/qmmm/__init__.py` & `pyscf-2.3.0/pyscf/qmmm/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/qmmm/itrf.py` & `pyscf-2.3.0/pyscf/qmmm/itrf.py`

 * *Files 25% similar despite different names*

```diff
@@ -28,15 +28,15 @@
 from pyscf import scf
 from pyscf import mcscf
 from pyscf import grad
 from pyscf.lib import logger
 from pyscf.qmmm import mm_mole
 
 
-def add_mm_charges(scf_method, atoms_or_coords, charges, unit=None):
+def add_mm_charges(scf_method, atoms_or_coords, charges, radii=None, unit=None):
     '''Embedding the one-electron (non-relativistic) potential generated by MM
     point charges into QM Hamiltonian.
 
     The total energy includes the regular QM energy, the interaction between
     the nuclei in QM region and the MM charges, and the static Coulomb
     interaction between the electron density and the MM charges. It does not
     include the static Coulomb interactions of the MM point charges, the MM
@@ -46,15 +46,18 @@
     Args:
         scf_method : a HF or DFT object
 
         atoms_or_coords : 2D array, shape (N,3)
             MM particle coordinates
         charges : 1D array
             MM particle charges
+
     Kwargs:
+        radii : 1D array
+            The Gaussian charge distribution radii of MM atoms.
         unit : str
             Bohr, AU, Ang (case insensitive). Default is the same to mol.unit
 
     Returns:
         Same method object as the input scf_method with modified 1e Hamiltonian
 
     Note:
@@ -70,15 +73,16 @@
     >>> mf = mm_charge(dft.RKS(mol), [(0.5,0.6,0.8)], [-0.3])
     >>> mf.kernel()
     -101.940495711284
     '''
     mol = scf_method.mol
     if unit is None:
         unit = mol.unit
-    mm_mol = mm_mole.create_mm_mol(atoms_or_coords, charges, unit)
+    mm_mol = mm_mole.create_mm_mol(atoms_or_coords, charges,
+                                   radii=radii, unit=unit)
     return qmmm_for_scf(scf_method, mm_mol)
 
 # Define method mm_charge for backward compatibility
 mm_charge = add_mm_charges
 
 def qmmm_for_scf(scf_method, mm_mol):
     '''Add the potential of MM particles to SCF (HF and DFT) method or CASCI
@@ -119,28 +123,50 @@
                 coords = self.mm_mol.atom_coords()
                 charges = self.mm_mol.atom_charges()
                 for i, z in enumerate(charges):
                     logger.debug(self, '%.9g    %s', z, coords[i])
             return self
 
         def get_hcore(self, mol=None):
-            if mol is None: mol = self.mol
+            if mol is None:
+                mol = self.mol
+            mm_mol = self.mm_mol
+
             if getattr(method_class, 'get_hcore', None):
                 h1e = method_class.get_hcore(self, mol)
             else:  # DO NOT modify post-HF objects to avoid the MM charges applied twice
                 raise RuntimeError('mm_charge function cannot be applied on post-HF methods')
 
-            coords = self.mm_mol.atom_coords()
-            charges = self.mm_mol.atom_charges()
+            coords = mm_mol.atom_coords()
+            charges = mm_mol.atom_charges()
             nao = mol.nao
             max_memory = self.max_memory - lib.current_memory()[0]
             blksize = int(min(max_memory*1e6/8/nao**2, 200))
-            for i0, i1 in lib.prange(0, charges.size, blksize):
-                j3c = mol.intor('int1e_grids', hermi=1, grids=coords[i0:i1])
-                h1e += numpy.einsum('kpq,k->pq', j3c, -charges[i0:i1])
+            blksize = max(blksize, 1)
+            if mm_mol.charge_model == 'gaussian':
+                expnts = mm_mol.get_zetas()
+
+                if mol.cart:
+                    intor = 'int3c2e_cart'
+                else:
+                    intor = 'int3c2e_sph'
+                cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas,
+                                                     mol._env, intor)
+                v = 0
+                for i0, i1 in lib.prange(0, charges.size, blksize):
+                    fakemol = gto.fakemol_for_charges(coords[i0:i1], expnts[i0:i1])
+                    j3c = df.incore.aux_e2(mol, fakemol, intor=intor,
+                                           aosym='s2ij', cintopt=cintopt)
+                    v += numpy.einsum('xk,k->x', j3c, -charges[i0:i1])
+                v = lib.unpack_tril(v)
+                h1e += v
+            else:
+                for i0, i1 in lib.prange(0, charges.size, blksize):
+                    j3c = mol.intor('int1e_grids', hermi=1, grids=coords[i0:i1])
+                    h1e += numpy.einsum('kpq,k->pq', j3c, -charges[i0:i1])
             return h1e
 
         def energy_nuc(self):
             # interactions between QM nuclei and MM particles
             nuc = self.mol.energy_nuc()
             coords = self.mm_mol.atom_coords()
             charges = self.mm_mol.atom_charges()
@@ -159,27 +185,29 @@
         return QMMM(scf_method, mm_mol)
     else:  # post-HF methods
         scf_method._scf = QMMM(scf_method._scf, mm_mol).run()
         scf_method.mo_coeff = scf_method._scf.mo_coeff
         scf_method.mo_energy = scf_method._scf.mo_energy
         return scf_method
 
-def add_mm_charges_grad(scf_grad, atoms_or_coords, charges, unit=None):
+def add_mm_charges_grad(scf_grad, atoms_or_coords, charges, radii=None, unit=None):
     '''Apply the MM charges in the QM gradients' method.  It affects both the
     electronic and nuclear parts of the QM fragment.
 
     Args:
         scf_grad : a HF or DFT gradient object (grad.HF or grad.RKS etc)
             Once the add_mm_charges_grad was applied, it affects all post-HF
             calculations eg MP2, CCSD, MCSCF etc
         coords : 2D array, shape (N,3)
             MM particle coordinates
         charges : 1D array
             MM particle charges
     Kwargs:
+        radii : 1D array
+            The Gaussian charge distribution radii of MM atoms.
         unit : str
             Bohr, AU, Ang (case insensitive). Default is the same to mol.unit
 
     Returns:
         Same gradeints method object as the input scf_grad method
 
     Examples:
@@ -194,15 +222,16 @@
     [[-0.25912357 -0.29235976 -0.38245077]
      [-1.70497052 -1.89423883  1.2794798 ]]
     '''
     assert (isinstance(scf_grad, grad.rhf.Gradients))
     mol = scf_grad.mol
     if unit is None:
         unit = mol.unit
-    mm_mol = mm_mole.create_mm_mol(atoms_or_coords, charges, unit)
+    mm_mol = mm_mole.create_mm_mol(atoms_or_coords, charges,
+                                   radii=radii, unit=unit)
     mm_grad = qmmm_grad_for_scf(scf_grad)
     mm_grad.base.mm_mol = mm_mol
     return mm_grad
 
 # Define method mm_charge_grad for backward compatibility
 mm_charge_grad = add_mm_charges_grad
 
@@ -234,27 +263,85 @@
                 charges = self.base.mm_mol.atom_charges()
                 for i, z in enumerate(charges):
                     logger.debug1(self, '%.9g    %s', z, coords[i])
             return self
 
         def get_hcore(self, mol=None):
             ''' (QM 1e grad) + <-d/dX i|q_mm/r_mm|j>'''
-            if mol is None: mol = self.mol
-            coords = self.base.mm_mol.atom_coords()
-            charges = self.base.mm_mol.atom_charges()
+            if mol is None:
+                mol = self.mol
+            mm_mol = self.base.mm_mol
+            coords = mm_mol.atom_coords()
+            charges = mm_mol.atom_charges()
 
             nao = mol.nao
             max_memory = self.max_memory - lib.current_memory()[0]
             blksize = int(min(max_memory*1e6/8/nao**2/3, 200))
+            blksize = max(blksize, 1)
             g_qm = grad_class.get_hcore(self, mol)
-            for i0, i1 in lib.prange(0, charges.size, blksize):
-                j3c = mol.intor('int1e_grids_ip', grids=coords[i0:i1])
-                g_qm += numpy.einsum('ikpq,k->ipq', j3c, charges[i0:i1])
+            if mm_mol.charge_model == 'gaussian':
+                expnts = mm_mol.get_zetas()
+                if mol.cart:
+                    intor = 'int3c2e_ip1_cart'
+                else:
+                    intor = 'int3c2e_ip1_sph'
+                cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas,
+                                                     mol._env, intor)
+                v = 0
+                for i0, i1 in lib.prange(0, charges.size, blksize):
+                    fakemol = gto.fakemol_for_charges(coords[i0:i1], expnts[i0:i1])
+                    j3c = df.incore.aux_e2(mol, fakemol, intor, aosym='s1',
+                                           comp=3, cintopt=cintopt)
+                    v += numpy.einsum('ipqk,k->ipq', j3c, charges[i0:i1])
+                g_qm += v
+            else:
+                for i0, i1 in lib.prange(0, charges.size, blksize):
+                    j3c = mol.intor('int1e_grids_ip', grids=coords[i0:i1])
+                    g_qm += numpy.einsum('ikpq,k->ipq', j3c, charges[i0:i1])
             return g_qm
 
+        def grad_hcore_mm(self, dm, mol=None):
+            r'''Nuclear gradients of the electronic energy
+            with respect to MM atoms:
+
+            ... math::
+                g = \sum_{ij} \frac{\partial hcore_{ij}}{\partial R_{I}} P_{ji},
+
+            where I represents MM atoms.
+
+            Args:
+                dm : array
+                    The QM density matrix.
+            '''
+            if mol is None:
+                mol = self.mol
+            mm_mol = self.base.mm_mol
+
+            coords = mm_mol.atom_coords()
+            charges = mm_mol.atom_charges()
+            expnts = mm_mol.get_zetas()
+
+            intor = 'int3c2e_ip2'
+            nao = mol.nao
+            max_memory = self.max_memory - lib.current_memory()[0]
+            blksize = int(min(max_memory*1e6/8/nao**2/3, 200))
+            blksize = max(blksize, 1)
+            cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas,
+                                                 mol._env, intor)
+
+            g = numpy.empty_like(coords)
+            for i0, i1 in lib.prange(0, charges.size, blksize):
+                fakemol = gto.fakemol_for_charges(coords[i0:i1], expnts[i0:i1])
+                j3c = df.incore.aux_e2(mol, fakemol, intor, aosym='s1',
+                                       comp=3, cintopt=cintopt)
+                g[i0:i1] = numpy.einsum('ipqk,qp->ik', j3c * charges[i0:i1], dm).T
+            return g
+
+        contract_hcore_mm = grad_hcore_mm # for backward compatibility
+
         def grad_nuc(self, mol=None, atmlst=None):
             if mol is None: mol = self.mol
             coords = self.base.mm_mol.atom_coords()
             charges = self.base.mm_mol.atom_charges()
 
             g_qm = grad_class.grad_nuc(self, mol, atmlst)
 # nuclei lattice interaction
@@ -263,14 +350,32 @@
                 q1 = mol.atom_charge(i)
                 r1 = mol.atom_coord(i)
                 r = lib.norm(r1-coords, axis=1)
                 g_mm[i] = -q1 * numpy.einsum('i,ix,i->x', charges, r1-coords, 1/r**3)
             if atmlst is not None:
                 g_mm = g_mm[atmlst]
             return g_qm + g_mm
+
+        def grad_nuc_mm(self, mol=None):
+            '''Nuclear gradients of the QM-MM nuclear energy
+            (in the form of point charge Coulomb interactions)
+            with respect to MM atoms.
+            '''
+            if mol is None:
+                mol = self.mol
+            mm_mol = self.base.mm_mol
+            coords = mm_mol.atom_coords()
+            charges = mm_mol.atom_charges()
+            g_mm = numpy.zeros_like(coords)
+            for i in range(mol.natm):
+                q1 = mol.atom_charge(i)
+                r1 = mol.atom_coord(i)
+                r = lib.norm(r1-coords, axis=1)
+                g_mm += q1 * numpy.einsum('i,ix,i->ix', charges, r1-coords, 1/r**3)
+            return g_mm
     return QMMM(scf_grad)
 
 # A tag to label the derived class
 class _QMMM:
     pass
 class _QMMMGrad:
     pass
```

### Comparing `pyscf-2.2.1/pyscf/scf/__init__.py` & `pyscf-2.3.0/pyscf/scf/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/_response_functions.py` & `pyscf-2.3.0/pyscf/scf/_response_functions.py`

 * *Files 2% similar despite different names*

```diff
@@ -41,15 +41,15 @@
     if mo_coeff is None: mo_coeff = mf.mo_coeff
     if mo_occ is None: mo_occ = mf.mo_occ
     mol = mf.mol
     if isinstance(mf, hf.KohnShamDFT):
         from pyscf.dft import numint
         ni = mf._numint
         ni.libxc.test_deriv_order(mf.xc, 2, raise_error=True)
-        if getattr(mf, 'nlc', '') != '':
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
             logger.warn(mf, 'NLC functional found in DFT object.  Its second '
                         'deriviative is not available. Its contribution is '
                         'not included in the response function.')
         omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
         hybrid = ni.libxc.is_hybrid_xc(mf.xc)
 
         # mf can be pbc.dft.RKS object with multigrid
@@ -58,18 +58,18 @@
             from pyscf.pbc.dft import multigrid
             dm0 = mf.make_rdm1(mo_coeff, mo_occ)
             return multigrid._gen_rhf_response(mf, dm0, singlet, hermi)
 
         if singlet is None:
             # for ground state orbital hessian
             rho0, vxc, fxc = ni.cache_xc_kernel(mol, mf.grids, mf.xc,
-                                                mo_coeff, mo_occ, 0)
+                                                mo_coeff, mo_occ, spin=0)
         else:
             rho0, vxc, fxc = ni.cache_xc_kernel(mol, mf.grids, mf.xc,
-                                                [mo_coeff]*2, [mo_occ*.5]*2, spin=1)
+                                                mo_coeff, mo_occ, spin=1)
         dm0 = None  #mf.make_rdm1(mo_coeff, mo_occ)
 
         if max_memory is None:
             mem_now = lib.current_memory()[0]
             max_memory = max(2000, mf.max_memory*.8-mem_now)
 
         if singlet is None:
@@ -151,15 +151,15 @@
     '''
     if mo_coeff is None: mo_coeff = mf.mo_coeff
     if mo_occ is None: mo_occ = mf.mo_occ
     mol = mf.mol
     if isinstance(mf, hf.KohnShamDFT):
         ni = mf._numint
         ni.libxc.test_deriv_order(mf.xc, 2, raise_error=True)
-        if getattr(mf, 'nlc', '') != '':
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
             logger.warn(mf, 'NLC functional found in DFT object.  Its second '
                         'deriviative is not available. Its contribution is '
                         'not included in the response function.')
         omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
         hybrid = ni.libxc.is_hybrid_xc(mf.xc)
 
         # mf can be pbc.dft.UKS object with multigrid
@@ -224,15 +224,15 @@
     if mo_occ is None: mo_occ = mf.mo_occ
     mol = mf.mol
     if isinstance(mf, hf.KohnShamDFT):
         from pyscf.dft import numint2c, r_numint
         ni = mf._numint
         assert isinstance(ni, (numint2c.NumInt2C, r_numint.RNumInt))
         ni.libxc.test_deriv_order(mf.xc, 2, raise_error=True)
-        if getattr(mf, 'nlc', '') != '':
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
             raise NotImplementedError('NLC')
         omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
         hybrid = ni.libxc.is_hybrid_xc(mf.xc)
 
         # mf can be pbc.dft.UKS object with multigrid
         if (not hybrid and
             'MultiGridFFTDF' == getattr(mf, 'with_df', None).__class__.__name__):
```

### Comparing `pyscf-2.2.1/pyscf/scf/_vhf.py` & `pyscf-2.3.0/pyscf/scf/_vhf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/addons.py` & `pyscf-2.3.0/pyscf/scf/addons.py`

 * *Files 1% similar despite different names*

```diff
@@ -479,29 +479,29 @@
     Snorm = numpy.dot(numpy.diag(normlz), numpy.dot(S, numpy.diag(normlz)))
 
     # Sort the basis functions according to the Gershgorin circle
     # theorem so that the Cholesky routine is well-initialized
     odS = numpy.abs(Snorm)
     numpy.fill_diagonal(odS, 0.0)
     odSs = numpy.sum(odS, axis=0)
-    sortidx = numpy.argsort(odSs)
+    sortidx = numpy.argsort(odSs, kind='stable')
 
     # Run the pivoted Cholesky decomposition
     Ssort = Snorm[numpy.ix_(sortidx, sortidx)].copy()
     c, piv, r_c = pivoted_cholesky(Ssort, tol=cholthr)
     # The functions we're going to use are given by the pivot as
     idx = sortidx[piv[:r_c]]
 
     # Get the (un-normalized) sub-basis
     Ssub = S[numpy.ix_(idx, idx)].copy()
     # Orthogonalize sub-basis
     Xsub = canonical_orth_(Ssub, thr=canthr)
 
     # Full X
-    X = numpy.zeros((S.shape[0], Xsub.shape[1]))
+    X = numpy.zeros((S.shape[0], Xsub.shape[1]), dtype=Xsub.dtype)
     X[idx,:] = Xsub
 
     return X
 
 def remove_linear_dep_(mf, threshold=LINEAR_DEP_THRESHOLD,
                        lindep=LINEAR_DEP_TRIGGER,
                        cholesky_threshold=CHOLESKY_THRESHOLD,
@@ -520,36 +520,43 @@
     if cond < 1./lindep and not force_pivoted_cholesky:
         return mf
 
     logger.info(mf, 'Applying remove_linear_dep_ on SCF object.')
     logger.debug(mf, 'Overlap condition number %g', cond)
     if (cond < 1./numpy.finfo(s.dtype).eps and not force_pivoted_cholesky):
         logger.info(mf, 'Using canonical orthogonalization with threshold {}'.format(threshold))
-        def eigh(h, s):
-            x = canonical_orth_(s, threshold)
-            xhx = reduce(numpy.dot, (x.T.conj(), h, x))
-            e, c = numpy.linalg.eigh(xhx)
-            c = numpy.dot(x, c)
-            return e, c
-        mf._eigh = eigh
+        mf._eigh = _eigh_with_canonical_orth(threshold)
     else:
         logger.info(mf, 'Using partial Cholesky orthogonalization '
                     '(doi:10.1063/1.5139948, doi:10.1103/PhysRevA.101.032504)')
         logger.info(mf, 'Using threshold {} for pivoted Cholesky'.format(cholesky_threshold))
         logger.info(mf, 'Using threshold {} to orthogonalize the subbasis'.format(threshold))
-        def eigh(h, s):
-            x = partial_cholesky_orth_(s, canthr=threshold, cholthr=cholesky_threshold)
-            xhx = reduce(numpy.dot, (x.T.conj(), h, x))
-            e, c = numpy.linalg.eigh(xhx)
-            c = numpy.dot(x, c)
-            return e, c
-        mf._eigh = eigh
+        mf._eigh = _eigh_with_pivot_cholesky(threshold, cholesky_threshold)
     return mf
 remove_linear_dep = remove_linear_dep_
 
+def _eigh_with_canonical_orth(threshold=LINEAR_DEP_THRESHOLD):
+    def eigh(h, s):
+        x = canonical_orth_(s, threshold)
+        xhx = reduce(lib.dot, (x.conj().T, h, x))
+        e, c = scipy.linalg.eigh(xhx)
+        c = numpy.dot(x, c)
+        return e, c
+    return eigh
+
+def _eigh_with_pivot_cholesky(threshold=LINEAR_DEP_THRESHOLD,
+                              cholesky_threshold=CHOLESKY_THRESHOLD):
+    def eigh(h, s):
+        x = partial_cholesky_orth_(s, canthr=threshold, cholthr=cholesky_threshold)
+        xhx = reduce(lib.dot, (x.conj().T, h, x))
+        e, c = scipy.linalg.eigh(xhx)
+        c = numpy.dot(x, c)
+        return e, c
+    return eigh
+
 def convert_to_uhf(mf, out=None, remove_df=False):
     '''Convert the given mean-field object to the unrestricted HF/KS object
 
     Note this conversion only changes the class of the mean-field object.
     The total energy and wave-function are the same as them in the input
     mf object. If mf is an second order SCF (SOSCF) object, the SOSCF layer
     will be discarded. Its underlying SCF object mf._scf will be converted.
@@ -891,18 +898,18 @@
         nocca = numpy.count_nonzero(mo_occ[0]>0)
         nvira = nmo - nocca
         noccb = numpy.count_nonzero(mo_occ[1]>0)
         nvirb = nmo - noccb
         # round(6) to avoid numerical uncertainty in degeneracy
         es = numpy.append(mo_energy[0][mo_occ[0] >0],
                           mo_energy[1][mo_occ[1] >0])
-        oidx = numpy.argsort(es.round(6))
+        oidx = numpy.argsort(es.round(6), kind='stable')
         es = numpy.append(mo_energy[0][mo_occ[0]==0],
                           mo_energy[1][mo_occ[1]==0])
-        vidx = numpy.argsort(es.round(6))
+        vidx = numpy.argsort(es.round(6), kind='stable')
         orbspin = numpy.append(numpy.array([0]*nocca+[1]*noccb)[oidx],
                                numpy.array([0]*nvira+[1]*nvirb)[vidx])
     return orbspin
 
 del (LINEAR_DEP_THRESHOLD, LINEAR_DEP_TRIGGER)
 
 def fast_newton(mf, mo_coeff=None, mo_occ=None, dm0=None,
```

### Comparing `pyscf-2.2.1/pyscf/scf/atom_hf.py` & `pyscf-2.3.0/pyscf/scf/atom_hf.py`

 * *Files 1% similar despite different names*

```diff
@@ -129,51 +129,52 @@
 
     def get_occ(self, mo_energy=None, mo_coeff=None):
         '''spherically averaged fractional occupancy'''
         mol = self.mol
         symb = mol.atom_symbol(0)
 
         nelec_ecp = mol.atom_nelec_core(0)
-        coreshl = gto.ecp.core_configuration(nelec_ecp)
+        coreshl = gto.ecp.core_configuration(nelec_ecp, atom_symbol=gto.mole._std_symbol(symb))
 
         occ = []
         for l in range(param.L_MAX):
             n2occ, frac = frac_occ(symb, l, self.atomic_configuration)
             degen = 2 * l + 1
             idx = mol._bas[:,gto.ANG_OF] == l
             nbas_l = mol._bas[idx,gto.NCTR_OF].sum()
             if l < 4:
                 n2occ -= coreshl[l]
                 assert n2occ <= nbas_l
 
                 logger.debug1(self, 'l = %d  occ = %d + %.4g', l, n2occ, frac)
 
-                occ_l = numpy.zeros(nbas_l)
-                occ_l[:n2occ] = 2
-                if frac > 0:
-                    occ_l[n2occ] = frac
-                occ.append(numpy.repeat(occ_l, degen))
+                if nbas_l > 0:
+                    occ_l = numpy.zeros(nbas_l)
+                    occ_l[:n2occ] = 2
+                    if frac > 0:
+                        occ_l[n2occ] = frac
+                    occ.append(numpy.repeat(occ_l, degen))
             else:
                 occ.append(numpy.zeros(nbas_l * degen))
 
         return numpy.hstack(occ)
 
     def get_grad(self, mo_coeff, mo_occ, fock=None):
         return 0
 
     def scf(self, *args, **kwargs):
         kwargs['dump_chk'] = False
         return hf.RHF.scf(self, *args, **kwargs)
 
     def _finalize(self):
         if self.converged:
-            logger.info(self, 'Atomic HF for atom  %s  converged. SCF energy = %.15g',
+            logger.info(self, 'Atomic HF for atom  %s  converged. SCF energy = %.15g\n',
                         self.mol.atom_symbol(0), self.e_tot)
         else:
-            logger.info(self, 'Atomic HF for atom  %s  not converged. SCF energy = %.15g',
+            logger.info(self, 'Atomic HF for atom  %s  not converged. SCF energy = %.15g\n',
                         self.mol.atom_symbol(0), self.e_tot)
         return self
 
 AtomSphericAverageRHF = AtomSphAverageRHF
 
 
 class AtomHF1e(rohf.HF1e, AtomSphAverageRHF):
```

### Comparing `pyscf-2.2.1/pyscf/scf/atom_ks.py` & `pyscf-2.3.0/pyscf/scf/atom_ks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/chkfile.py` & `pyscf-2.3.0/pyscf/scf/chkfile.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/cphf.py` & `pyscf-2.3.0/pyscf/scf/cphf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/dhf.py` & `pyscf-2.3.0/pyscf/scf/dhf.py`

 * *Files 1% similar despite different names*

```diff
@@ -531,20 +531,15 @@
                 logger.info(self, 'HOMO %d = %.12g  LUMO %d = %.12g',
                             nocc, mo_energy[n2c+nocc-1],
                             nocc+1, mo_energy[n2c+nocc])
                 logger.debug1(self, 'NES  mo_energy = %s', mo_energy[:n2c])
                 logger.debug(self, 'PES  mo_energy = %s', mo_energy[n2c:])
         return mo_occ
 
-    # full density matrix for UHF
-    def make_rdm1(self, mo_coeff=None, mo_occ=None, **kwargs):
-        if mo_coeff is None: mo_coeff = self.mo_coeff
-        if mo_occ is None: mo_occ = self.mo_occ
-        return make_rdm1(mo_coeff, mo_occ, **kwargs)
-
+    make_rdm1 = lib.module_method(make_rdm1, absences=['mo_coeff', 'mo_occ'])
     energy_elec = energy_elec
 
     def init_direct_scf(self, mol=None):
         if mol is None: mol = self.mol
         def set_vkscreen(opt, name):
             opt._this.contents.r_vkscreen = _vhf._fpointer(name)
 
@@ -647,15 +642,15 @@
         if s is None: s = self.get_ovlp(mol)
         return mulliken_pop(mol, dm, s=s, verbose=verbose)
 
     @lib.with_doc(dip_moment.__doc__)
     def dip_moment(self, mol=None, dm=None, unit='Debye', verbose=logger.NOTE,
                    **kwargs):
         if mol is None: mol = self.mol
-        if dm is None: dm =self.make_rdm1()
+        if dm is None: dm = self.make_rdm1()
         return dip_moment(mol, dm, unit, verbose=verbose, **kwargs)
 
     def sfx2c1e(self):
         raise NotImplementedError
     def x2c1e(self):
         from pyscf.x2c import x2c
         x2chf = x2c.UHF(self.mol)
```

### Comparing `pyscf-2.2.1/pyscf/scf/diis.py` & `pyscf-2.3.0/pyscf/scf/diis.py`

 * *Files 0% similar despite different names*

```diff
@@ -101,15 +101,15 @@
     elif isinstance(f, numpy.ndarray) and f.ndim == 3 and s.ndim == 3:
         errvec = []
         for i in range(f.shape[0]):
             sdf = reduce(numpy.dot, (Corth[i].conj().T, s[i], d[i], f[i], Corth[i]))
             if orbsym is not None:
                 sdf[sym_forbid] = 0
             errvec.append((sdf.conj().T - sdf).ravel())
-        errvec = numpy.vstack(errvec).ravel()
+        errvec = numpy.hstack(errvec)
 
     elif f.ndim == s.ndim+1 and f.shape[0] == 2:  # for UHF
         errvec = numpy.hstack([
             get_err_vec_orth(s, d[0], f[0], Corth[0]).ravel(),
             get_err_vec_orth(s, d[1], f[1], Corth[1]).ravel()])
     else:
         raise RuntimeError('Unknown SCF DIIS type')
```

### Comparing `pyscf-2.2.1/pyscf/scf/ghf.py` & `pyscf-2.3.0/pyscf/scf/ghf.py`

 * *Files 8% similar despite different names*

```diff
@@ -144,15 +144,15 @@
             vk[:,nao:,:nao] = k1[3]
         vk = vk.reshape(dm.shape)
 
     return vj, vk
 
 def get_occ(mf, mo_energy=None, mo_coeff=None):
     if mo_energy is None: mo_energy = mf.mo_energy
-    e_idx = numpy.argsort(mo_energy)
+    e_idx = numpy.argsort(mo_energy.round(9), kind='stable')
     e_sort = mo_energy[e_idx]
     nmo = mo_energy.size
     mo_occ = numpy.zeros(nmo)
     nocc = mf.mol.nelectron
     mo_occ[e_idx[:nocc]] = 1
     if mf.verbose >= logger.INFO and nocc < nmo:
         if e_sort[nocc-1]+1e-3 > e_sort[nocc]:
@@ -412,14 +412,16 @@
             fock = self.get_hcore(self.mol) + self.get_veff(self.mol, dm1)
         occidx = mo_occ > 0
         viridx = ~occidx
         g = reduce(numpy.dot, (mo_coeff[:,occidx].T.conj(), fock,
                                mo_coeff[:,viridx]))
         return g.conj().T.ravel()
 
+    get_init_guess = hf.RHF.get_init_guess
+
     @lib.with_doc(hf.SCF.init_guess_by_minao.__doc__)
     def init_guess_by_minao(self, mol=None):
         return _from_rhf_init_dm(hf.SCF.init_guess_by_minao(self, mol))
 
     @lib.with_doc(hf.SCF.init_guess_by_atom.__doc__)
     def init_guess_by_atom(self, mol=None):
         return _from_rhf_init_dm(hf.SCF.init_guess_by_atom(self, mol))
@@ -438,28 +440,23 @@
     @lib.with_doc(hf.get_jk.__doc__)
     def get_jk(self, mol=None, dm=None, hermi=0, with_j=True, with_k=True,
                omega=None):
         if mol is None: mol = self.mol
         if dm is None: dm = self.make_rdm1()
         nao = mol.nao
         dm = numpy.asarray(dm)
+        # nao = 0 for HF with custom Hamiltonian
+        if dm.shape[-1] != nao * 2 and nao != 0:
+            raise ValueError('Dimension inconsistent '
+                             f'dm.shape = {dm.shape}, mol.nao = {nao}')
 
         def jkbuild(mol, dm, hermi, with_j, with_k, omega=None):
-            if (not omega and
-                (self._eri is not None or mol.incore_anyway or self._is_mem_enough())):
-                if self._eri is None:
-                    self._eri = mol.intor('int2e', aosym='s8')
-                return hf.dot_eri_dm(self._eri, dm, hermi, with_j, with_k)
-            else:
-                return hf.SCF.get_jk(self, mol, dm, hermi, with_j, with_k, omega)
-
-        if nao == dm.shape[-1]:
-            vj, vk = jkbuild(mol, dm, hermi, with_j, with_k, omega)
-        else:  # GHF density matrix, shape (2N,2N)
-            vj, vk = get_jk(mol, dm, hermi, with_j, with_k, jkbuild, omega)
+            return hf.RHF.get_jk(self, mol, dm, hermi, with_j, with_k, omega)
+
+        vj, vk = get_jk(mol, dm, hermi, with_j, with_k, jkbuild, omega)
         return vj, vk
 
     def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
         if mol is None: mol = self.mol
         if dm is None: dm = self.make_rdm1()
         if self._eri is not None or not self.direct_scf:
             vj, vk = self.get_jk(mol, dm, hermi)
@@ -550,33 +547,7 @@
         idx, idy = numpy.diag_indices(nao)
         dm[idx+nao,idy] = dm[idx,idy+nao] = dma.diagonal() * .05
     return dm
 
 
 class HF1e(GHF):
     scf = hf._hf1e_scf
-
-
-del (PRE_ORTH_METHOD)
-
-
-if __name__ == '__main__':
-    mol = gto.Mole()
-    mol.verbose = 3
-    mol.atom = 'H 0 0 0; H 0 0 1; O .5 .6 .2'
-    mol.basis = 'ccpvdz'
-    mol.build()
-
-    mf = GHF(mol)
-    mf.kernel()
-
-    dm = mf.init_guess_by_1e(mol)
-    dm = dm + 0j
-    nao = mol.nao_nr()
-    numpy.random.seed(12)
-    dm[:nao,nao:] = numpy.random.random((nao,nao)) * .1j
-    dm[nao:,:nao] = dm[:nao,nao:].T.conj()
-    mf.kernel(dm)
-    mf.canonicalize(mf.mo_coeff, mf.mo_occ)
-    mf.analyze()
-    print(mf.spin_square())
-    print(mf.e_tot - -75.9125824421352)
```

### Comparing `pyscf-2.2.1/pyscf/scf/ghf_symm.py` & `pyscf-2.3.0/pyscf/scf/ghf_symm.py`

 * *Files 2% similar despite different names*

```diff
@@ -189,24 +189,24 @@
         rest_idx = numpy.ones(mo_occ.size, dtype=bool)
         nelec_fix = 0
         for i, ir in enumerate(mol.irrep_id):
             irname = mol.irrep_name[i]
             ir_idx = numpy.where(orbsym == ir)[0]
             if irname in self.irrep_nelec:
                 n = self.irrep_nelec[irname]
-                occ_sort = numpy.argsort(mo_energy[ir_idx].round(9), kind='mergesort')
+                occ_sort = numpy.argsort(mo_energy[ir_idx].round(9), kind='stable')
                 occ_idx  = ir_idx[occ_sort[:n]]
                 mo_occ[occ_idx] = 1
                 nelec_fix += n
                 rest_idx[ir_idx] = False
         nelec_float = mol.nelectron - nelec_fix
         assert (nelec_float >= 0)
         if nelec_float > 0:
             rest_idx = numpy.where(rest_idx)[0]
-            occ_sort = numpy.argsort(mo_energy[rest_idx].round(9), kind='mergesort')
+            occ_sort = numpy.argsort(mo_energy[rest_idx].round(9), kind='stable')
             occ_idx  = rest_idx[occ_sort[:nelec_float]]
             mo_occ[occ_idx] = 1
 
         vir_idx = (mo_occ==0)
         if self.verbose >= logger.INFO and numpy.count_nonzero(vir_idx) > 0:
             ehomo = max(mo_energy[~vir_idx])
             elumo = min(mo_energy[ vir_idx])
@@ -233,16 +233,16 @@
         return mo_occ
 
     def _finalize(self):
         ghf.GHF._finalize(self)
 
         # Using mergesort because it is stable. We don't want to change the
         # ordering of the symmetry labels when two orbitals are degenerated.
-        o_sort = numpy.argsort(self.mo_energy[self.mo_occ> 0].round(9), kind='mergesort')
-        v_sort = numpy.argsort(self.mo_energy[self.mo_occ==0].round(9), kind='mergesort')
+        o_sort = numpy.argsort(self.mo_energy[self.mo_occ> 0].round(9), kind='stable')
+        v_sort = numpy.argsort(self.mo_energy[self.mo_occ==0].round(9), kind='stable')
         orbsym = self.get_orbsym(self.mo_coeff)
         self.mo_energy = numpy.hstack((self.mo_energy[self.mo_occ> 0][o_sort],
                                        self.mo_energy[self.mo_occ==0][v_sort]))
         self.mo_coeff = numpy.hstack((self.mo_coeff[:,self.mo_occ> 0].take(o_sort, axis=1),
                                       self.mo_coeff[:,self.mo_occ==0].take(v_sort, axis=1)))
         orbsym = numpy.hstack((orbsym[self.mo_occ> 0][o_sort],
                                orbsym[self.mo_occ==0][v_sort]))
```

### Comparing `pyscf-2.2.1/pyscf/scf/hf.py` & `pyscf-2.3.0/pyscf/scf/hf.py`

 * *Files 1% similar despite different names*

```diff
@@ -175,16 +175,14 @@
         dm_last = dm
         last_hf_e = e_tot
 
         fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis)
         mo_energy, mo_coeff = mf.eig(fock, s1e)
         mo_occ = mf.get_occ(mo_energy, mo_coeff)
         dm = mf.make_rdm1(mo_coeff, mo_occ)
-        # attach mo_coeff and mo_occ to dm to improve DFT get_veff efficiency
-        dm = lib.tag_array(dm, mo_coeff=mo_coeff, mo_occ=mo_occ)
         vhf = mf.get_veff(mol, dm, dm_last, vhf)
         e_tot = mf.energy_tot(dm, h1e, vhf)
 
         # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock
         # instead of the statement "fock = h1e + vhf" because Fock matrix may
         # be modified in some methods.
         fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
@@ -213,15 +211,14 @@
 
     if scf_conv and conv_check:
         # An extra diagonalization, to remove level shift
         #fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf
         mo_energy, mo_coeff = mf.eig(fock, s1e)
         mo_occ = mf.get_occ(mo_energy, mo_coeff)
         dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm
-        dm = lib.tag_array(dm, mo_coeff=mo_coeff, mo_occ=mo_occ)
         vhf = mf.get_veff(mol, dm, dm_last, vhf)
         e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot
 
         fock = mf.get_fock(h1e, s1e, vhf, dm)
         norm_gorb = numpy.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
         if not TIGHT_GRAD_CONV_TOL:
             norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
@@ -360,24 +357,27 @@
         basis_ano = []
         if gto.is_ghost_atom(symb):
             return occ, basis_ano
 
         stdsymb = gto.mole._std_symbol(symb)
         basis_add = gto.basis.load('ano', stdsymb)
 # coreshl defines the core shells to be removed in the initial guess
-        coreshl = gto.ecp.core_configuration(nelec_ecp)
-        #coreshl = (0,0,0,0)  # it keeps all core electrons in the initial guess
+        coreshl = gto.ecp.core_configuration(nelec_ecp, atom_symbol=stdsymb)
+        # coreshl = (0,0,0,0)  # it keeps all core electrons in the initial guess
         for l in range(4):
             ndocc, frac = atom_hf.frac_occ(stdsymb, l)
-            assert ndocc >= coreshl[l]
-            degen = l * 2 + 1
-            occ_l = [2,]*(ndocc-coreshl[l]) + [frac,]
-            occ.append(numpy.repeat(occ_l, degen))
-            basis_ano.append([l] + [b[:1] + b[1+coreshl[l]:ndocc+2]
-                                    for b in basis_add[l][1:]])
+            if ndocc >= coreshl[l]:
+                degen = l * 2 + 1
+                occ_l = [2, ]*(ndocc-coreshl[l]) + [frac, ]
+                occ.append(numpy.repeat(occ_l, degen))
+                basis_ano.append([l] + [b[:1] + b[1+coreshl[l]:ndocc+2]
+                                        for b in basis_add[l][1:]])
+            else:
+                logger.debug(mol, '*** ECP incorporates partially occupied '
+                             'shell of l = %d for atom %s ***', l, symb)
         occ = numpy.hstack(occ)
 
         if nelec_ecp > 0:
             if symb in mol._basis:
                 input_basis = mol._basis[symb]
             elif stdsymb in mol._basis:
                 input_basis = mol._basis[stdsymb]
@@ -393,19 +393,20 @@
             occ4ecp = []
             for l in range(4):
                 nbas_l = sum((len(bas[1]) - 1) for bas in basis4ecp[l])
                 ndocc, frac = atom_hf.frac_occ(stdsymb, l)
                 ndocc -= coreshl[l]
                 assert ndocc <= nbas_l
 
-                occ_l = numpy.zeros(nbas_l)
-                occ_l[:ndocc] = 2
-                if frac > 0:
-                    occ_l[ndocc] = frac
-                occ4ecp.append(numpy.repeat(occ_l, l * 2 + 1))
+                if nbas_l > 0:
+                    occ_l = numpy.zeros(nbas_l)
+                    occ_l[:ndocc] = 2
+                    if frac > 0:
+                        occ_l[ndocc] = frac
+                    occ4ecp.append(numpy.repeat(occ_l, l * 2 + 1))
 
             occ4ecp = numpy.hstack(occ4ecp)
             basis4ecp = lib.flatten(basis4ecp)
 
 # Compared to ANO valence basis, to check whether the ECP basis set has
 # reasonable AO-character contraction.  The ANO valence AO should have
 # significant overlap to ECP basis if the ECP basis has AO-character.
@@ -448,19 +449,22 @@
             occ.append(occdic[symb])
             new_atom.append(mol._atom[ia])
     occ = numpy.hstack(occ)
 
     pmol = gto.Mole()
     pmol._atm, pmol._bas, pmol._env = pmol.make_env(new_atom, basis, [])
     pmol._built = True
-    dm = addons.project_dm_nr2nr(pmol, numpy.diag(occ), mol)
+
+    #: dm = addons.project_dm_nr2nr(pmol, numpy.diag(occ), mol)
+    mo = addons.project_mo_nr2nr(pmol, numpy.eye(pmol.nao), mol)
+    dm = lib.dot(mo*occ, mo.conj().T)
 # normalize eletron number
 #    s = mol.intor_symmetric('int1e_ovlp')
 #    dm *= mol.nelectron / (dm*s).sum()
-    return dm
+    return lib.tag_array(dm, mo_coeff=mo, mo_occ=occ)
 
 
 def init_guess_by_1e(mol):
     '''Generate initial guess density matrix from core hamiltonian
 
     Returns:
         Density matrix, 2D ndarray
@@ -476,37 +480,44 @@
     Returns:
         Density matrix, 2D ndarray
     '''
     from pyscf.scf import atom_hf
     atm_scf = atom_hf.get_atm_nrhf(mol)
     aoslice = mol.aoslice_by_atom()
     atm_dms = []
+    mo_coeff = []
+    mo_occ = []
     for ia in range(mol.natm):
         symb = mol.atom_symbol(ia)
         if symb not in atm_scf:
             symb = mol.atom_pure_symbol(ia)
 
         if symb in atm_scf:
             e_hf, e, c, occ = atm_scf[symb]
-            dm = numpy.dot(c*occ, c.conj().T)
         else:  # symb's basis is not specified in the input
             nao_atm = aoslice[ia,3] - aoslice[ia,2]
-            dm = numpy.zeros((nao_atm, nao_atm))
+            c = numpy.zeros((nao_atm, nao_atm))
+            occ = numpy.zeros(nao_atm)
 
-        atm_dms.append(dm)
+        atm_dms.append(numpy.dot(c*occ, c.conj().T))
+        mo_coeff.append(c)
+        mo_occ.append(occ)
 
     dm = scipy.linalg.block_diag(*atm_dms)
+    mo_coeff = scipy.linalg.block_diag(*mo_coeff)
+    mo_occ = numpy.hstack(occ)
 
     if mol.cart:
         cart2sph = mol.cart2sph_coeff(normalized='sp')
-        dm = reduce(numpy.dot, (cart2sph, dm, cart2sph.T))
+        dm = reduce(lib.dot, (cart2sph, dm, cart2sph.T))
+        mo_coeff = lib.dot(cart2sph, mo_coeff)
 
     for k, v in atm_scf.items():
         logger.debug1(mol, 'Atom %s, E = %.12g', k, v[0])
-    return dm
+    return lib.tag_array(dm, mo_coeff=mo_coeff, mo_occ=mo_occ)
 
 def init_guess_by_huckel(mol):
     '''Generate initial guess density matrix from a Huckel calculation based
     on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089
 
     Returns:
         Density matrix, 2D ndarray
@@ -679,15 +690,16 @@
         One-particle density matrix, 2D ndarray
     '''
     mocc = mo_coeff[:,mo_occ>0]
 # DO NOT make tag_array for dm1 here because this DM array may be modified and
 # passed to functions like get_jk, get_vxc.  These functions may take the tags
 # (mo_coeff, mo_occ) to compute the potential if tags were found in the DM
 # array and modifications to DM array may be ignored.
-    return numpy.dot(mocc*mo_occ[mo_occ>0], mocc.conj().T)
+    dm = numpy.dot(mocc*mo_occ[mo_occ>0], mocc.conj().T)
+    return lib.tag_array(dm, mo_coeff=mo_coeff, mo_occ=mo_occ)
 
 def make_rdm2(mo_coeff, mo_occ, **kwargs):
     '''Two-particle density matrix in AO representation
 
     Args:
         mo_coeff : 2D ndarray
             Orbital coefficients. Each column is one orbital.
@@ -1302,14 +1314,15 @@
         return mf
 
     logger.info(mf, 'Create scanner for %s', mf.__class__)
 
     class SCF_Scanner(mf.__class__, lib.SinglePointScanner):
         def __init__(self, mf_obj):
             self.__dict__.update(mf_obj.__dict__)
+            self._last_mol_fp = mf.mol.ao_loc
 
         def __call__(self, mol_or_geom, **kwargs):
             if isinstance(mol_or_geom, gto.Mole):
                 mol = mol_or_geom
             else:
                 mol = self.mol.set_geom_(mol_or_geom, inplace=False)
 
@@ -1319,34 +1332,27 @@
             if 'dm0' in kwargs:
                 dm0 = kwargs.pop('dm0')
             elif self.mo_coeff is None:
                 dm0 = None
             elif self.chkfile and h5py.is_hdf5(self.chkfile):
                 dm0 = self.from_chk(self.chkfile)
             else:
-                dm0 = self.make_rdm1()
+                dm0 = None
                 # dm0 form last calculation cannot be used in the current
                 # calculation if a completely different system is given.
                 # Obviously, the systems are very different if the number of
                 # basis functions are different.
                 # TODO: A robust check should include more comparison on
                 # various attributes between current `mol` and the `mol` in
                 # last calculation.
-                if dm0.shape[-1] != mol.nao:
-                    #TODO:
-                    #from pyscf.scf import addons
-                    #if numpy.any(last_mol.atom_charges() != mol.atom_charges()):
-                    #    dm0 = None
-                    #elif non-relativistic:
-                    #    addons.project_dm_nr2nr(last_mol, dm0, last_mol)
-                    #else:
-                    #    addons.project_dm_r2r(last_mol, dm0, last_mol)
-                    dm0 = None
+                if numpy.array_equal(self._last_mol_fp, mol.ao_loc):
+                    dm0 = self.make_rdm1()
             self.mo_coeff = None  # To avoid last mo_coeff being used by SOSCF
             e_tot = self.kernel(dm0=dm0, **kwargs)
+            self._last_mol_fp = mol.ao_loc
             return e_tot
 
     return SCF_Scanner(mf)
 
 ############
 
 
@@ -1563,14 +1569,15 @@
                              envs['mo_coeff'], envs['mo_occ'],
                              overwrite_mol=False)
         return self
 
     @lib.with_doc(init_guess_by_minao.__doc__)
     def init_guess_by_minao(self, mol=None):
         if mol is None: mol = self.mol
+        logger.info(self, 'Initial guess from minao.')
         return init_guess_by_minao(mol)
 
     @lib.with_doc(init_guess_by_atom.__doc__)
     def init_guess_by_atom(self, mol=None):
         if mol is None: mol = self.mol
         logger.info(self, 'Initial guess from superposition of atomic densities.')
         return init_guess_by_atom(mol)
@@ -1629,37 +1636,18 @@
                 dm = self.init_guess_by_chkfile()
             except (IOError, KeyError):
                 logger.warn(self, 'Fail in reading %s. Use MINAO initial guess',
                             self.chkfile)
                 dm = self.init_guess_by_minao(mol)
         else:
             dm = self.init_guess_by_minao(mol)
-        if self.verbose >= logger.DEBUG1:
-            s = self.get_ovlp()
-            if isinstance(dm, numpy.ndarray) and dm.ndim == 2:
-                nelec = numpy.einsum('ij,ji', dm, s).real
-            else:  # UHF
-                nelec =(numpy.einsum('ij,ji', dm[0], s).real,
-                        numpy.einsum('ij,ji', dm[1], s).real)
-            logger.debug1(self, 'Nelec from initial guess = %s', nelec)
         return dm
 
-    # full density matrix for RHF
-    @lib.with_doc(make_rdm1.__doc__)
-    def make_rdm1(self, mo_coeff=None, mo_occ=None, **kwargs):
-        if mo_occ is None: mo_occ = self.mo_occ
-        if mo_coeff is None: mo_coeff = self.mo_coeff
-        return make_rdm1(mo_coeff, mo_occ, **kwargs)
-
-    @lib.with_doc(make_rdm2.__doc__)
-    def make_rdm2(self, mo_coeff=None, mo_occ=None, **kwargs):
-        if mo_occ is None: mo_occ = self.mo_occ
-        if mo_coeff is None: mo_coeff = self.mo_coeff
-        return make_rdm2(mo_coeff, mo_occ, **kwargs)
-
+    make_rdm1 = lib.module_method(make_rdm1, absences=['mo_coeff', 'mo_occ'])
+    make_rdm2 = lib.module_method(make_rdm2, absences=['mo_coeff', 'mo_occ'])
     energy_elec = energy_elec
     energy_tot = energy_tot
 
     def energy_nuc(self):
         return self.mol.energy_nuc()
 
     # A hook for overloading convergence criteria in SCF iterations. Assigning
@@ -1834,15 +1822,15 @@
     def remove_soscf(self):
         '''Remove the SOSCF decorator'''
         from pyscf.soscf import newton_ah
         return newton_ah.remove_soscf(self)
 
     def nuc_grad_method(self):  # pragma: no cover
         '''Hook to create object for analytical nuclear gradients.'''
-        pass
+        raise NotImplementedError
 
     def update_(self, chkfile=None):
         '''Read attributes from the chkfile then replace the attributes of
         current object.  It's an alias of function update_from_chk_.
         '''
         from pyscf.scf import chkfile as chkmod
         if chkfile is None: chkfile = self.chkfile
@@ -2028,14 +2016,17 @@
         elif isinstance(self, scf.hf.UHF):
             return self.to_uks(xc)
         elif isinstance(self, scf.hf.GHF):
             return self.to_gks(xc)
         else:
             raise RuntimeError(f'to_ks does not support {self.__class__}')
 
+    def stability(self):
+        raise NotImplementedError
+
 
 class KohnShamDFT:
     '''A mock DFT base class
 
     The base class KohnShamDFT is defined in the dft.rks module. This class can
     be used to verify if an SCF object is a Hartree-Fock method or a DFT method.
     It should be overwritten by the actual KohnShamDFT class when loading dft module.
@@ -2048,14 +2039,22 @@
     def check_sanity(self):
         mol = self.mol
         if mol.nelectron != 1 and mol.spin != 0:
             logger.warn(self, 'Invalid number of electrons %d for RHF method.',
                         mol.nelectron)
         return SCF.check_sanity(self)
 
+    def get_init_guess(self, mol=None, key='minao'):
+        dm = SCF.get_init_guess(self, mol, key)
+        if self.verbose >= logger.DEBUG1:
+            s = self.get_ovlp()
+            nelec = numpy.einsum('ij,ji', dm, s).real
+            logger.debug1(self, 'Nelec from initial guess = %s', nelec)
+        return dm
+
     @lib.with_doc(get_jk.__doc__)
     def get_jk(self, mol=None, dm=None, hermi=1, with_j=True, with_k=True,
                omega=None):
         # Note the incore version, which initializes an _eri array in memory.
         if mol is None: mol = self.mol
         if dm is None: dm = self.make_rdm1()
         if (not omega and
```

### Comparing `pyscf-2.2.1/pyscf/scf/hf_symm.py` & `pyscf-2.3.0/pyscf/scf/hf_symm.py`

 * *Files 2% similar despite different names*

```diff
@@ -211,15 +211,15 @@
             s_ir = reduce(numpy.dot, (so.conj().T, s, so))
             fock_ir = numpy.dot(sosc*esub, sosc.conj().T)
             mo_energy, u = mf._eigh(fock_ir, s_ir)
             idx = abs(mo_energy) > emin
             es.append(mo_energy[idx])
             cs.append(numpy.dot(mol.symm_orb[i], u[:,idx]))
         es = numpy.hstack(es).round(7)
-        idx = numpy.argsort(es, kind='mergesort')
+        idx = numpy.argsort(es, kind='stable')
         assert (numpy.allclose(es[idx], esub.round(7)))
         mo_coeff[:,degidx] = numpy.hstack(cs)[:,idx]
     return mo_coeff
 
 def so2ao_mo_coeff(so, irrep_mo_coeff):
     '''Transfer the basis of MO coefficients, from symmetry-adapted basis to AO basis
     '''
@@ -472,24 +472,24 @@
         rest_idx = numpy.ones(mo_occ.size, dtype=bool)
         nelec_fix = 0
         for i, ir in enumerate(mol.irrep_id):
             irname = mol.irrep_name[i]
             if irname in self.irrep_nelec:
                 ir_idx = numpy.where(orbsym == ir)[0]
                 n = self.irrep_nelec[irname]
-                occ_sort = numpy.argsort(mo_energy[ir_idx].round(9), kind='mergesort')
+                occ_sort = numpy.argsort(mo_energy[ir_idx].round(9), kind='stable')
                 occ_idx  = ir_idx[occ_sort[:n//2]]
                 mo_occ[occ_idx] = 2
                 nelec_fix += n
                 rest_idx[ir_idx] = False
         nelec_float = mol.nelectron - nelec_fix
         assert (nelec_float >= 0)
         if nelec_float > 0:
             rest_idx = numpy.where(rest_idx)[0]
-            occ_sort = numpy.argsort(mo_energy[rest_idx].round(9), kind='mergesort')
+            occ_sort = numpy.argsort(mo_energy[rest_idx].round(9), kind='stable')
             occ_idx  = rest_idx[occ_sort[:nelec_float//2]]
             mo_occ[occ_idx] = 2
 
         vir_idx = (mo_occ==0)
         if self.verbose >= logger.INFO and numpy.count_nonzero(vir_idx) > 0:
             ehomo = max(mo_energy[~vir_idx])
             elumo = min(mo_energy[ vir_idx])
@@ -513,16 +513,16 @@
 
     def _finalize(self):
         hf.RHF._finalize(self)
 
         # sort MOs wrt orbital energies, it should be done last.
         # Using mergesort because it is stable. We don't want to change the
         # ordering of the symmetry labels when two orbitals are degenerated.
-        o_sort = numpy.argsort(self.mo_energy[self.mo_occ> 0].round(9), kind='mergesort')
-        v_sort = numpy.argsort(self.mo_energy[self.mo_occ==0].round(9), kind='mergesort')
+        o_sort = numpy.argsort(self.mo_energy[self.mo_occ> 0].round(9), kind='stable')
+        v_sort = numpy.argsort(self.mo_energy[self.mo_occ==0].round(9), kind='stable')
         idx = numpy.arange(self.mo_energy.size)
         idx = numpy.hstack((idx[self.mo_occ> 0][o_sort],
                             idx[self.mo_occ==0][v_sort]))
         self.mo_energy = self.mo_energy[idx]
         self.mo_occ = self.mo_occ[idx]
         orbsym = self.get_orbsym(self.mo_coeff)
         orbsym = orbsym[idx]
@@ -760,25 +760,25 @@
             mo_coeff = self.mo_coeff
         if mo_occ is None:
             mo_occ = self.mo_occ
         mo_a = mo_coeff[:,mo_occ>0]
         mo_b = mo_coeff[:,mo_occ==2]
         dm_a = numpy.dot(mo_a, mo_a.conj().T)
         dm_b = numpy.dot(mo_b, mo_b.conj().T)
-        return numpy.array((dm_a, dm_b))
+        return lib.tag_array((dm_a, dm_b), mo_coeff=mo_coeff, mo_occ=mo_occ)
 
     def _finalize(self):
         rohf.ROHF._finalize(self)
 
         # sort MOs wrt orbital energies, it should be done last.
         # Using mergesort because it is stable. We don't want to change the
         # ordering of the symmetry labels when two orbitals are degenerated.
-        c_sort = numpy.argsort(self.mo_energy[self.mo_occ==2].round(9), kind='mergesort')
-        o_sort = numpy.argsort(self.mo_energy[self.mo_occ==1].round(9), kind='mergesort')
-        v_sort = numpy.argsort(self.mo_energy[self.mo_occ==0].round(9), kind='mergesort')
+        c_sort = numpy.argsort(self.mo_energy[self.mo_occ==2].round(9), kind='stable')
+        o_sort = numpy.argsort(self.mo_energy[self.mo_occ==1].round(9), kind='stable')
+        v_sort = numpy.argsort(self.mo_energy[self.mo_occ==0].round(9), kind='stable')
         idx = numpy.arange(self.mo_energy.size)
         idx = numpy.hstack((idx[self.mo_occ==2][c_sort],
                             idx[self.mo_occ==1][o_sort],
                             idx[self.mo_occ==0][v_sort]))
         if getattr(self.mo_energy, 'mo_ea', None) is not None:
             mo_ea = self.mo_energy.mo_ea[idx]
             mo_eb = self.mo_energy.mo_eb[idx]
```

### Comparing `pyscf-2.2.1/pyscf/scf/jk.py` & `pyscf-2.3.0/pyscf/scf/jk.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/rohf.py` & `pyscf-2.3.0/pyscf/scf/rohf.py`

 * *Files 6% similar despite different names*

```diff
@@ -31,19 +31,25 @@
 
 WITH_META_LOWDIN = getattr(__config__, 'scf_analyze_with_meta_lowdin', True)
 MO_BASE = getattr(__config__, 'MO_BASE', 1)
 
 
 def init_guess_by_minao(mol):
     dm = hf.init_guess_by_minao(mol)
-    return numpy.array((dm*.5, dm*.5))
+    dm = numpy.array((dm*.5, dm*.5))
+    if hasattr(dm, 'mo_coeff'):
+        dm = lib.tag_array(dm, mo_coeff=dm.mo_coeff, mo_occ=dm.mo_occ)
+    return dm
 
 def init_guess_by_atom(mol):
     dm = hf.init_guess_by_atom(mol)
-    return numpy.array((dm*.5, dm*.5))
+    dm = numpy.array((dm*.5, dm*.5))
+    if hasattr(dm, 'mo_coeff'):
+        dm = lib.tag_array(dm, mo_coeff=dm.mo_coeff, mo_occ=dm.mo_occ)
+    return dm
 
 init_guess_by_huckel = uhf.init_guess_by_huckel
 init_guess_by_chkfile = uhf.init_guess_by_chkfile
 
 def get_fock(mf, h1e=None, s1e=None, vhf=None, dm=None, cycle=-1, diis=None,
              diis_start_cycle=None, level_shift_factor=None, damp_factor=None):
     '''Build fock matrix based on Roothaan's effective fock.
@@ -221,21 +227,21 @@
     g[uniq_var_b] += fockb[uniq_var_b]
     return g[uniq_var_a | uniq_var_b]
 
 def make_rdm1(mo_coeff, mo_occ, **kwargs):
     '''One-particle density matrix.  mo_occ is a 1D array, with occupancy 1 or 2.
     '''
     if isinstance(mo_occ, numpy.ndarray) and mo_occ.ndim == 1:
-        mo_occa = mo_occ > 0
-        mo_occb = mo_occ == 2
+        mo_occa = (mo_occ > 0).astype(numpy.double)
+        mo_occb = (mo_occ ==2).astype(numpy.double)
     else:
         mo_occa, mo_occb = mo_occ
     dm_a = numpy.dot(mo_coeff*mo_occa, mo_coeff.conj().T)
     dm_b = numpy.dot(mo_coeff*mo_occb, mo_coeff.conj().T)
-    return numpy.array((dm_a, dm_b))
+    return lib.tag_array((dm_a, dm_b), mo_coeff=mo_coeff, mo_occ=mo_occ)
 
 def energy_elec(mf, dm=None, h1e=None, vhf=None):
     if dm is None: dm = mf.make_rdm1()
     elif isinstance(dm, numpy.ndarray) and dm.ndim == 2:
         dm = numpy.array((dm*.5, dm*.5))
     return uhf.energy_elec(mf, dm, h1e, vhf)
 
@@ -341,14 +347,16 @@
 
     def dump_flags(self, verbose=None):
         hf.SCF.dump_flags(self, verbose)
         nelec = self.nelec
         logger.info(self, 'num. doubly occ = %d  num. singly occ = %d',
                     nelec[1], nelec[0]-nelec[1])
 
+    get_init_guess = uhf.UHF.get_init_guess
+
     def init_guess_by_minao(self, mol=None):
         if mol is None: mol = self.mol
         return init_guess_by_minao(mol)
 
     def init_guess_by_atom(self, mol=None):
         if mol is None: mol = self.mol
         logger.info(self, 'Initial guess from the superpostion of atomic densties.')
@@ -393,33 +401,33 @@
 
     @lib.with_doc(make_rdm1.__doc__)
     def make_rdm1(self, mo_coeff=None, mo_occ=None, **kwargs):
         if mo_coeff is None: mo_coeff = self.mo_coeff
         if mo_occ is None: mo_occ = self.mo_occ
         if self.mol.spin < 0:
             # Flip occupancies of alpha and beta orbitals
-            mo_occ = (mo_occ == 2), (mo_occ > 0)
+            mo_occ = (numpy.asarray(mo_occ == 2, dtype=numpy.double),
+                      numpy.asarray(mo_occ > 0, dtype=numpy.double))
         return make_rdm1(mo_coeff, mo_occ, **kwargs)
 
     energy_elec = energy_elec
 
     @lib.with_doc(uhf.get_veff.__doc__)
     def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
         if mol is None: mol = self.mol
         if dm is None: dm = self.make_rdm1()
         if isinstance(dm, numpy.ndarray) and dm.ndim == 2:
             dm = numpy.array((dm*.5, dm*.5))
 
         if self._eri is not None or not self.direct_scf:
-            if getattr(dm, 'mo_coeff', None) is not None:
-                mo_coeff = dm.mo_coeff
-                mo_occ_a = (dm.mo_occ > 0).astype(numpy.double)
-                mo_occ_b = (dm.mo_occ ==2).astype(numpy.double)
-                dm = lib.tag_array(dm, mo_coeff=(mo_coeff,mo_coeff),
-                                   mo_occ=(mo_occ_a,mo_occ_b))
+            if hasattr(dm, 'mo_occ') and numpy.ndim(dm.mo_occ) == 1:
+                mo_occa = (dm.mo_occ > 0).astype(numpy.double)
+                mo_occb = (dm.mo_occ ==2).astype(numpy.double)
+                dm = lib.tag_array(dm, mo_coeff=(dm.mo_coeff,)*2,
+                                   mo_occ=(mo_occa,mo_occb))
             vj, vk = self.get_jk(mol, dm, hermi)
             vhf = vj[0] + vj[1] - vk
         else:
             ddm = dm - numpy.asarray(dm_last)
             vj, vk = self.get_jk(mol, ddm, hermi)
             vhf = vj[0] + vj[1] - vk
             vhf += numpy.asarray(vhf_last)
```

### Comparing `pyscf-2.2.1/pyscf/scf/stability.py` & `pyscf-2.3.0/pyscf/scf/stability.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/stability_slow.py` & `pyscf-2.3.0/pyscf/scf/stability_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/ucphf.py` & `pyscf-2.3.0/pyscf/scf/ucphf.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/scf/uhf.py` & `pyscf-2.3.0/pyscf/scf/uhf.py`

 * *Files 1% similar despite different names*

```diff
@@ -145,15 +145,15 @@
     mo_b = mo_coeff[1]
     dm_a = numpy.dot(mo_a*mo_occ[0], mo_a.conj().T)
     dm_b = numpy.dot(mo_b*mo_occ[1], mo_b.conj().T)
 # DO NOT make tag_array for DM here because the DM arrays may be modified and
 # passed to functions like get_jk, get_vxc.  These functions may take the tags
 # (mo_coeff, mo_occ) to compute the potential if tags were found in the DM
 # arrays and modifications to DM arrays may be ignored.
-    return numpy.array((dm_a, dm_b))
+    return lib.tag_array((dm_a, dm_b), mo_coeff=mo_coeff, mo_occ=mo_occ)
 
 def make_rdm2(mo_coeff, mo_occ):
     '''Two-particle density matrix in AO representation
 
     Args:
         mo_coeff : tuple of 2D ndarrays
             Orbital coefficients for alpha and beta spins. Each column is one orbital.
@@ -826,14 +826,23 @@
             mo_coeff = self.mo_coeff
         if mo_occ is None:
             mo_occ = self.mo_occ
         return make_rdm2(mo_coeff, mo_occ, **kwargs)
 
     energy_elec = energy_elec
 
+    def get_init_guess(self, mol=None, key='minao'):
+        dm = hf.SCF.get_init_guess(self, mol, key)
+        if self.verbose >= logger.DEBUG1:
+            s = self.get_ovlp()
+            nelec =(numpy.einsum('ij,ji', dm[0], s).real,
+                    numpy.einsum('ij,ji', dm[1], s).real)
+            logger.debug1(self, 'Nelec from initial guess = %s', nelec)
+        return dm
+
     def init_guess_by_minao(self, mol=None, breaksym=BREAKSYM):
         '''Initial guess in terms of the overlap to minimal basis.'''
         if mol is None: mol = self.mol
         user_set_breaksym = getattr(self, "init_guess_breaksym", None)
         if user_set_breaksym is not None:
             breaksym = user_set_breaksym
         # For spin polarized system, no need to manually break spin symmetry
```

### Comparing `pyscf-2.2.1/pyscf/scf/uhf_symm.py` & `pyscf-2.3.0/pyscf/scf/uhf_symm.py`

 * *Files 4% similar despite different names*

```diff
@@ -417,16 +417,16 @@
             ir_idxb = numpy.where(orbsymb == ir)[0]
             if irname in self.irrep_nelec:
                 if isinstance(self.irrep_nelec[irname], (int, numpy.integer)):
                     nelecb = self.irrep_nelec[irname] // 2
                     neleca = self.irrep_nelec[irname] - nelecb
                 else:
                     neleca, nelecb = self.irrep_nelec[irname]
-                ea_idx = numpy.argsort(mo_energy[0][ir_idxa].round(9), kind='mergesort')
-                eb_idx = numpy.argsort(mo_energy[1][ir_idxb].round(9), kind='mergesort')
+                ea_idx = numpy.argsort(mo_energy[0][ir_idxa].round(9), kind='stable')
+                eb_idx = numpy.argsort(mo_energy[1][ir_idxb].round(9), kind='stable')
                 mo_occ[0,ir_idxa[ea_idx[:neleca]]] = 1
                 mo_occ[1,ir_idxb[eb_idx[:nelecb]]] = 1
                 neleca_fix += neleca
                 nelecb_fix += nelecb
             else:
                 idx_ea_left.append(ir_idxa)
                 idx_eb_left.append(ir_idxb)
@@ -435,21 +435,21 @@
         neleca_float = nelec[0] - neleca_fix
         nelecb_float = nelec[1] - nelecb_fix
         assert (neleca_float >= 0)
         assert (nelecb_float >= 0)
         if len(idx_ea_left) > 0:
             idx_ea_left = numpy.hstack(idx_ea_left)
             ea_left = mo_energy[0][idx_ea_left]
-            ea_sort = numpy.argsort(ea_left.round(9), kind='mergesort')
+            ea_sort = numpy.argsort(ea_left.round(9), kind='stable')
             occ_idx = idx_ea_left[ea_sort][:neleca_float]
             mo_occ[0][occ_idx] = 1
         if len(idx_eb_left) > 0:
             idx_eb_left = numpy.hstack(idx_eb_left)
             eb_left = mo_energy[1][idx_eb_left]
-            eb_sort = numpy.argsort(eb_left.round(9), kind='mergesort')
+            eb_sort = numpy.argsort(eb_left.round(9), kind='stable')
             occ_idx = idx_eb_left[eb_sort][:nelecb_float]
             mo_occ[1][occ_idx] = 1
 
         vir_idx = (mo_occ[0]==0)
         if self.verbose >= logger.INFO and numpy.count_nonzero(vir_idx) > 0:
             noccsa = []
             noccsb = []
@@ -494,18 +494,18 @@
     def _finalize(self):
         uhf.UHF._finalize(self)
 
         ea = numpy.hstack(self.mo_energy[0])
         eb = numpy.hstack(self.mo_energy[1])
         # Using mergesort because it is stable. We don't want to change the
         # ordering of the symmetry labels when two orbitals are degenerated.
-        oa_sort = numpy.argsort(ea[self.mo_occ[0]>0 ].round(9), kind='mergesort')
-        va_sort = numpy.argsort(ea[self.mo_occ[0]==0].round(9), kind='mergesort')
-        ob_sort = numpy.argsort(eb[self.mo_occ[1]>0 ].round(9), kind='mergesort')
-        vb_sort = numpy.argsort(eb[self.mo_occ[1]==0].round(9), kind='mergesort')
+        oa_sort = numpy.argsort(ea[self.mo_occ[0]>0 ].round(9), kind='stable')
+        va_sort = numpy.argsort(ea[self.mo_occ[0]==0].round(9), kind='stable')
+        ob_sort = numpy.argsort(eb[self.mo_occ[1]>0 ].round(9), kind='stable')
+        vb_sort = numpy.argsort(eb[self.mo_occ[1]==0].round(9), kind='stable')
         idxa = numpy.arange(ea.size)
         idxa = numpy.hstack((idxa[self.mo_occ[0]> 0][oa_sort],
                              idxa[self.mo_occ[0]==0][va_sort]))
         idxb = numpy.arange(eb.size)
         idxb = numpy.hstack((idxb[self.mo_occ[1]> 0][ob_sort],
                              idxb[self.mo_occ[1]==0][vb_sort]))
         self.mo_energy = (ea[idxa], eb[idxb])
```

### Comparing `pyscf-2.2.1/pyscf/sgx/sgx.py` & `pyscf-2.3.0/pyscf/sgx/sgx.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/sgx/sgx_jk.py` & `pyscf-2.3.0/pyscf/sgx/sgx_jk.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/solvent/__init__.py` & `pyscf-2.3.0/pyscf/solvent/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/solvent/_attach_solvent.py` & `pyscf-2.3.0/pyscf/solvent/_attach_solvent.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/solvent/_ddcosmo_tdscf_grad.py` & `pyscf-2.3.0/pyscf/solvent/_ddcosmo_tdscf_grad.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/solvent/ddcosmo.py` & `pyscf-2.3.0/pyscf/solvent/ddcosmo.py`

 * *Files 1% similar despite different names*

```diff
@@ -380,15 +380,15 @@
         # Note all values are scaled by 1/r_vdw to make the formulas
         # consistent to Psi in JCP, 141, 184108
         part_weights = weights_1sph.copy()
         part_weights[fi[ja]>1] /= fi[ja,fi[ja]>1]
         for ka in atoms_with_vdw_overlap(ja, atom_coords, r_vdw):
             vjk = r_vdw[ja] * coords_1sph + atom_coords[ja] - atom_coords[ka]
             tjk = lib.norm(vjk, axis=1) / r_vdw[ka]
-            wjk = pcmobj.regularize_xt(tjk, eta, r_vdw[ka])
+            wjk = pcmobj.regularize_xt(tjk, eta)
             wjk *= part_weights
             pol = sph.multipoles(vjk, lmax)
             p1 = 0
             for l in range(lmax+1):
                 fac = 4*numpy.pi/(l*2+1) / r_vdw[ka]**(l+1)
                 p0, p1 = p1, p1 + (l*2+1)
                 a = numpy.einsum('xn,n,mn->xm', ylm_1sph, wjk, pol[l])
@@ -404,15 +404,15 @@
     ngrid_1sph = coords_1sph.shape[0]
     fi = numpy.zeros((natm,ngrid_1sph))
     for ia in range(natm):
         for ja in atoms_with_vdw_overlap(ia, atom_coords, r_vdw):
             v = r_vdw[ia]*coords_1sph + atom_coords[ia] - atom_coords[ja]
             rv = lib.norm(v, axis=1)
             t = rv / r_vdw[ja]
-            xt = pcmobj.regularize_xt(t, eta, r_vdw[ja])
+            xt = pcmobj.regularize_xt(t, eta)
             fi[ia] += xt
     fi[fi < 1e-20] = 0
     return fi
 
 def make_phi(pcmobj, dm, r_vdw, ui, ylm_1sph, with_nuc=True):
     '''
     Induced potential of ddCOSMO model
@@ -847,16 +847,15 @@
         return .5 * f_epsilon * vmat.reshape(dm_shape)
 
     energy = energy
     gen_solver = as_solver = gen_ddcosmo_solver
     get_atomic_radii = get_atomic_radii
 
     def regularize_xt(self, t, eta, scale=1):
-        # scale = eta*scale, is it correct?
-        return regularize_xt(t, eta*scale)
+        return regularize_xt(t, eta)
 
     def nuc_grad_method(self, grad_method):
         '''For grad_method in vacuum, add nuclear gradients of solvent
         '''
         from pyscf import tdscf
         from pyscf.solvent import ddcosmo_grad, _ddcosmo_tdscf_grad
         if self.frozen:
```

### Comparing `pyscf-2.2.1/pyscf/solvent/ddcosmo_grad.py` & `pyscf-2.3.0/pyscf/solvent/ddcosmo_grad.py`

 * *Files 2% similar despite different names*

```diff
@@ -160,16 +160,16 @@
         tmp = part_weights[fi[ja]>1] / fi[ja,fi[ja]>1]
         part_weights1[:,:,fi[ja]>1] = -tmp * fi1[:,:,ja,fi[ja]>1]
 
         for ka in ddcosmo.atoms_with_vdw_overlap(ja, atom_coords, r_vdw):
             vjk = r_vdw[ja] * coords_1sph + atom_coords[ja] - atom_coords[ka]
             rv = lib.norm(vjk, axis=1)
             tjk = rv / r_vdw[ka]
-            wjk0 = pcmobj.regularize_xt(tjk, eta, r_vdw[ka])
-            wjk1 = regularize_xt1(tjk, eta*r_vdw[ka])
+            wjk0 = pcmobj.regularize_xt(tjk, eta)
+            wjk1 = regularize_xt1(tjk, eta)
             sjk = vjk.T / rv
             wjk1 = 1./r_vdw[ka] * wjk1 * sjk
 
             wjk01 = wjk0 * part_weights1
             wjk0 *= part_weights
             wjk1 *= part_weights
 
@@ -239,15 +239,15 @@
     ngrid_1sph = coords_1sph.shape[0]
     fi1 = numpy.zeros((natm,3,natm,ngrid_1sph))
     for ia in range(natm):
         for ja in ddcosmo.atoms_with_vdw_overlap(ia, atom_coords, r_vdw):
             v = r_vdw[ia]*coords_1sph + atom_coords[ia] - atom_coords[ja]
             rv = lib.norm(v, axis=1)
             t = rv / r_vdw[ja]
-            xt1 = regularize_xt1(t, eta*r_vdw[ja])
+            xt1 = regularize_xt1(t, eta)
             s_ij = v.T / rv
             xt1 = 1./r_vdw[ja] * xt1 * s_ij
             fi1[ia,:,ia] += xt1
             fi1[ja,:,ia] -= xt1
 
     fi = ddcosmo.make_fi(pcmobj, r_vdw)
     fi1[:,:,fi<1e-20] = 0
```

### Comparing `pyscf-2.2.1/pyscf/solvent/ddpcm.py` & `pyscf-2.3.0/pyscf/solvent/ddpcm.py`

 * *Files 1% similar despite different names*

```diff
@@ -145,16 +145,15 @@
     r'''
     ddPCM energy
     Es = 1/2 f(eps) \int rho(r) W(r) dr
     '''
     epcm = gen_ddpcm_solver(pcmobj, pcmobj.verbose)(dm)[0]
     return epcm
 
-def regularize_xt(t, eta, scale=1):
-    eta *= scale
+def regularize_xt(t, eta):
     xt = numpy.zeros_like(t)
     inner = t <= 1-eta
     on_shell = (1-eta < t) & (t < 1)
     xt[inner] = 1
     ti = t[on_shell] - eta*.5
     # JCP, 144, 054101
     xt[on_shell] = 1./eta**4 * (1-ti)**2 * (ti-1+2*eta)**2
@@ -326,15 +325,15 @@
         dielectric = self.eps
         f_epsilon = (dielectric-1.)/dielectric
         return .5 * f_epsilon * vmat
 
     gen_solver = as_solver = gen_ddpcm_solver
 
     def regularize_xt(self, t, eta, scale=1):
-        return regularize_xt(t, eta, scale)
+        return regularize_xt(t, eta)
 
     def nuc_grad_method(self, grad_method):
         raise NotImplementedError
 
 
 if __name__ == '__main__':
     from pyscf import scf
```

### Comparing `pyscf-2.2.1/pyscf/solvent/pol_embed.py` & `pyscf-2.3.0/pyscf/solvent/pol_embed.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/soscf/__init__.py` & `pyscf-2.3.0/pyscf/soscf/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/soscf/ciah.py` & `pyscf-2.3.0/pyscf/soscf/ciah.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/soscf/newton_ah.py` & `pyscf-2.3.0/pyscf/soscf/newton_ah.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/symm/Dmatrix.py` & `pyscf-2.3.0/pyscf/symm/Dmatrix.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/symm/__init__.py` & `pyscf-2.3.0/pyscf/symm/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/symm/addons.py` & `pyscf-2.3.0/pyscf/symm/addons.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/symm/basis.py` & `pyscf-2.3.0/pyscf/symm/basis.py`

 * *Files 1% similar despite different names*

```diff
@@ -458,15 +458,15 @@
                 if n % 2:
                     return (n//2)*10 + COOV_IRREP_ID_TABLE['_odd'+symb[-1]]
                 else:
                     return (n//2)*10 + COOV_IRREP_ID_TABLE['_even'+symb[-1]]
             except (KeyError, ValueError):
                 raise PointGroupSymmetryError(f'Incorrect Coov irrep {symb}')
     else:
-        raise PointGroupSymmetryError('%s is not proper for linear molecule.' % gpname)
+        raise PointGroupSymmetryError(f'Incorrect cylindrical symmetry group {gpname}')
 
 DOOH_IRREP_SYMBS = ('A1g' , 'A2g' , 'E1gx', 'E1gy' , 'A2u', 'A1u' , 'E1uy', 'E1ux')
 DOOH_IRREP_SYMBS_EXT = ('gx' , 'gy' , 'gx', 'gy' , 'uy', 'ux' , 'uy', 'ux')
 COOV_IRREP_SYMBS = ('A1' , 'A2' , 'E1x', 'E1y')
 def linearmole_irrep_id2symb(gpname, irrep_id):
     if gpname == 'Dooh':
         if irrep_id < 10:
@@ -477,21 +477,23 @@
             return 'E%d%s' % (l, DOOH_IRREP_SYMBS_EXT[n])
     elif gpname == 'Coov':
         if irrep_id < 10:
             return COOV_IRREP_SYMBS[irrep_id]
         else:
             l = abs(linearmole_irrep2momentum(irrep_id))
             n = irrep_id % 10
+            if n >= 4:
+                raise PointGroupSymmetryError(f'Incorrect Coov irrep {irrep_id}')
             if n % 2:
                 xy = 'y'
             else:
                 xy = 'x'
             return 'E%d%s' % (l, xy)
     else:
-        raise PointGroupSymmetryError('%s is not proper for linear molecule.' % gpname)
+        raise PointGroupSymmetryError(f'Incorrect cylindrical symmetry group {gpname}')
 
 def linearmole_irrep2momentum(irrep_id):
     if irrep_id % 10 in (0, 1, 5, 4):
         l = irrep_id // 10 * 2
     else:
         l = irrep_id // 10 * 2 + 1
     if irrep_id % 10 in (1, 3, 4, 6):  # Ey
```

### Comparing `pyscf-2.2.1/pyscf/symm/cg.py` & `pyscf-2.3.0/pyscf/symm/cg.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/symm/geom.py` & `pyscf-2.3.0/pyscf/symm/geom.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/symm/param.py` & `pyscf-2.3.0/pyscf/symm/param.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/symm/sph.py` & `pyscf-2.3.0/pyscf/symm/sph.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tddft/__init__.py` & `pyscf-2.3.0/pyscf/tddft/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tdscf/__init__.py` & `pyscf-2.3.0/pyscf/tdscf/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tdscf/common_slow.py` & `pyscf-2.3.0/pyscf/tdscf/common_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tdscf/dhf.py` & `pyscf-2.3.0/pyscf/tdscf/dhf.py`

 * *Files 0% similar despite different names*

```diff
@@ -119,16 +119,16 @@
         b = b - numpy.einsum('jaib->iajb', eri_mo[:nocc,nocc:,:nocc,nocc:]) * hyb
         return a, b
 
     if isinstance(mf, dft.KohnShamDFT):
         from pyscf.dft import xc_deriv
         ni = mf._numint
         ni.libxc.test_deriv_order(mf.xc, 2, raise_error=True)
-        if getattr(mf, 'nlc', '') != '':
-            raise NotImplementedError
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            raise NotImplementedError('DKS-TDDFT for NLC functionals')
 
         omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
 
         a, b = add_hf_(a, b, hyb)
 
         xctype = ni._xc_type(mf.xc)
         dm0 = mf.make_rdm1(mo_coeff, mo_occ)
```

### Comparing `pyscf-2.2.1/pyscf/tdscf/dks.py` & `pyscf-2.3.0/pyscf/tdscf/dks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tdscf/ghf.py` & `pyscf-2.3.0/pyscf/tdscf/ghf.py`

 * *Files 1% similar despite different names*

```diff
@@ -151,16 +151,16 @@
         b -= numpy.einsum('jaib->iajb', eri_mo[:nocc,nocc:,:nocc,nocc:]) * hyb
         return a, b
 
     if isinstance(mf, dft.KohnShamDFT):
         from pyscf.dft import xc_deriv
         ni = mf._numint
         ni.libxc.test_deriv_order(mf.xc, 2, raise_error=True)
-        if getattr(mf, 'nlc', '') != '':
-            raise NotImplementedError
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            raise NotImplementedError('DKS-TDDFT NLC functional')
 
         if not mf.collinear:
             raise NotImplementedError
 
         omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
 
         a, b = add_hf_(a, b, hyb)
```

### Comparing `pyscf-2.2.1/pyscf/tdscf/gks.py` & `pyscf-2.3.0/pyscf/tdscf/gks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tdscf/proxy.py` & `pyscf-2.3.0/pyscf/tdscf/proxy.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tdscf/rhf.py` & `pyscf-2.3.0/pyscf/tdscf/rhf.py`

 * *Files 0% similar despite different names*

```diff
@@ -140,15 +140,15 @@
         b += numpy.einsum('iajb->iajb', eri_mo[:nocc,nocc:,:nocc,nocc:]) * 2
         b -= numpy.einsum('jaib->iajb', eri_mo[:nocc,nocc:,:nocc,nocc:]) * hyb
 
     if isinstance(mf, scf.hf.KohnShamDFT):
         from pyscf.dft import xc_deriv
         ni = mf._numint
         ni.libxc.test_deriv_order(mf.xc, 2, raise_error=True)
-        if getattr(mf, 'nlc', '') != '':
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
             logger.warn(mf, 'NLC functional found in DFT object.  Its second '
                         'deriviative is not available. Its contribution is '
                         'not included in the response function.')
         omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
 
         add_hf_(a, b, hyb)
```

### Comparing `pyscf-2.2.1/pyscf/tdscf/rhf_slow.py` & `pyscf-2.3.0/pyscf/tdscf/rhf_slow.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tdscf/rks.py` & `pyscf-2.3.0/pyscf/tdscf/rks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tdscf/uhf.py` & `pyscf-2.3.0/pyscf/tdscf/uhf.py`

 * *Files 1% similar despite different names*

```diff
@@ -177,15 +177,15 @@
         a_ab += numpy.einsum('iabj->iajb', eri_ab[:nocc_a,nocc_a:,nocc_b:,:nocc_b])
         b_ab += numpy.einsum('iajb->iajb', eri_ab[:nocc_a,nocc_a:,:nocc_b,nocc_b:])
 
     if isinstance(mf, scf.hf.KohnShamDFT):
         from pyscf.dft import xc_deriv
         ni = mf._numint
         ni.libxc.test_deriv_order(mf.xc, 2, raise_error=True)
-        if getattr(mf, 'nlc', '') != '':
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
             logger.warn(mf, 'NLC functional found in DFT object.  Its second '
                         'deriviative is not available. Its contribution is '
                         'not included in the response function.')
         omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
 
         add_hf_(a, b, hyb)
```

### Comparing `pyscf-2.2.1/pyscf/tdscf/uks.py` & `pyscf-2.3.0/pyscf/tdscf/uks.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/__init__.py` & `pyscf-2.3.0/pyscf/tools/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/c60struct.py` & `pyscf-2.3.0/pyscf/tools/c60struct.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/chgcar.py` & `pyscf-2.3.0/pyscf/tools/chgcar.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/chkfile_util.py` & `pyscf-2.3.0/pyscf/tools/chkfile_util.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/cubegen.py` & `pyscf-2.3.0/pyscf/tools/cubegen.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/dump_mat.py` & `pyscf-2.3.0/pyscf/tools/dump_mat.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/fcidump.py` & `pyscf-2.3.0/pyscf/tools/fcidump.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/mo_mapping.py` & `pyscf-2.3.0/pyscf/tools/mo_mapping.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/molden.py` & `pyscf-2.3.0/pyscf/tools/molden.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/ring.py` & `pyscf-2.3.0/pyscf/tools/ring.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/tools/wfn_format.py` & `pyscf-2.3.0/pyscf/tools/wfn_format.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/__init__.py` & `pyscf-2.3.0/pyscf/x2c/__init__.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/_response_functions.py` & `pyscf-2.3.0/pyscf/x2c/_response_functions.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/dft.py` & `pyscf-2.3.0/pyscf/x2c/dft.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/newton_ah.py` & `pyscf-2.3.0/pyscf/x2c/newton_ah.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/sfx2c1e.py` & `pyscf-2.3.0/pyscf/x2c/sfx2c1e.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/sfx2c1e_grad.py` & `pyscf-2.3.0/pyscf/x2c/sfx2c1e_grad.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/sfx2c1e_hess.py` & `pyscf-2.3.0/pyscf/x2c/sfx2c1e_hess.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/stability.py` & `pyscf-2.3.0/pyscf/x2c/stability.py`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/pyscf/x2c/tdscf.py` & `pyscf-2.3.0/pyscf/x2c/tdscf.py`

 * *Files 1% similar despite different names*

```diff
@@ -70,16 +70,16 @@
         b = b - numpy.einsum('jaib->iajb', eri_mo[:nocc,nocc:,:nocc,nocc:]) * hyb
         return a, b
 
     if isinstance(mf, dft.KohnShamDFT):
         from pyscf.dft import xc_deriv
         ni = mf._numint
         ni.libxc.test_deriv_order(mf.xc, 2, raise_error=True)
-        if getattr(mf, 'nlc', '') != '':
-            raise NotImplementedError
+        if mf.nlc or ni.libxc.is_nlc(mf.xc):
+            raise NotImplementedError('X2C-TDDFT for NLC functionals')
 
         if not mf.collinear:
             raise NotImplementedError
 
         omega, alpha, hyb = ni.rsh_and_hybrid_coeff(mf.xc, mol.spin)
 
         a, b = add_hf_(a, b, hyb)
```

### Comparing `pyscf-2.2.1/pyscf/x2c/x2c.py` & `pyscf-2.3.0/pyscf/x2c/x2c.py`

 * *Files 1% similar despite different names*

```diff
@@ -412,16 +412,15 @@
     vj, vk = _vhf.rdirect_mapdm('int2e_spinor', 's8',
                                 ('ji->s2kl', 'jk->s1il'), dm, 1,
                                 mol._atm, mol._bas, mol._env, mf_opt)
     vj = vj.reshape(dm.shape)
     vk = vk.reshape(dm.shape)
     return dhf._jk_triu_(mol, vj, vk, hermi)
 
-def make_rdm1(mo_coeff, mo_occ, **kwargs):
-    return numpy.dot(mo_coeff*mo_occ, mo_coeff.T.conj())
+make_rdm1 = hf.make_rdm1
 
 def init_guess_by_minao(mol):
     '''Initial guess in terms of the overlap to minimal basis.'''
     dm = hf.init_guess_by_minao(mol)
     return _proj_dmll(mol, dm, mol)
 
 def init_guess_by_1e(mol):
@@ -514,18 +513,15 @@
                             nocc, mo_energy[nocc-1], mo_energy[nocc])
         else:
             logger.info(self, 'nocc = %d  HOMO = %.12g  no LUMO',
                         nocc, mo_energy[nocc-1])
         logger.debug(self, '  mo_energy = %s', mo_energy)
         return mo_occ
 
-    def make_rdm1(self, mo_coeff=None, mo_occ=None, **kwargs):
-        if mo_coeff is None: mo_coeff = self.mo_coeff
-        if mo_occ is None: mo_occ = self.mo_occ
-        return make_rdm1(mo_coeff, mo_occ, **kwargs)
+    make_rdm1 = lib.module_method(make_rdm1, absences=['mo_coeff', 'mo_occ'])
 
     def init_direct_scf(self, mol=None):
         if mol is None: mol = self.mol
         def set_vkscreen(opt, name):
             opt._this.contents.r_vkscreen = _vhf._fpointer(name)
         opt = _vhf.VHFOpt(mol, 'int2e_spinor', 'CVHFrkbllll_prescreen',
                           'CVHFrkbllll_direct_scf',
```

### Comparing `pyscf-2.2.1/pyscf.egg-info/PKG-INFO` & `pyscf-2.3.0/pyscf.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyscf
-Version: 2.2.1
+Version: 2.3.0
 Summary: PySCF: Python-based Simulations of Chemistry Framework
 Home-page: http://www.pyscf.org
 Author: Qiming Sun
 Author-email: osirpt.sun@gmail.com
 License: Apache License 2.0
 Download-URL: http://github.com/pyscf/pyscf
 Platform: Linux
```

### Comparing `pyscf-2.2.1/pyscf.egg-info/SOURCES.txt` & `pyscf-2.3.0/pyscf.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -570,14 +570,15 @@
 pyscf/lib/gto/ft_ao.c
 pyscf/lib/gto/ft_ao.h
 pyscf/lib/gto/ft_ao_deriv.c
 pyscf/lib/gto/grid_ao_drv.c
 pyscf/lib/gto/grid_ao_drv.h
 pyscf/lib/gto/gto.h
 pyscf/lib/gto/nr_ecp.c
+pyscf/lib/gto/nr_ecp.h
 pyscf/lib/gto/nr_ecp_deriv.c
 pyscf/lib/gto/autocode/auto_eval1.c
 pyscf/lib/mcscf/CMakeLists.txt
 pyscf/lib/mcscf/fci.h
 pyscf/lib/mcscf/fci_4pdm.c
 pyscf/lib/mcscf/fci_contract.c
 pyscf/lib/mcscf/fci_contract_nosym.c
@@ -598,18 +599,20 @@
 pyscf/lib/pbc/cint3c2e.c
 pyscf/lib/pbc/fill_ints.c
 pyscf/lib/pbc/fill_ints_sr.c
 pyscf/lib/pbc/ft_ao.c
 pyscf/lib/pbc/grid_ao.c
 pyscf/lib/pbc/inner_dot.c
 pyscf/lib/pbc/nr_direct.c
+pyscf/lib/pbc/nr_ecp.c
 pyscf/lib/pbc/optimizer.c
 pyscf/lib/pbc/optimizer.h
 pyscf/lib/pbc/pbc.h
 pyscf/lib/pbc/symmetry.c
+pyscf/lib/pbc/transform_mo.c
 pyscf/lib/ri/CMakeLists.txt
 pyscf/lib/ri/r_df_incore.c
 pyscf/lib/vhf/CMakeLists.txt
 pyscf/lib/vhf/cvhf.h
 pyscf/lib/vhf/fblas.h
 pyscf/lib/vhf/fill_nr_s8.c
 pyscf/lib/vhf/hessian_screen.c
@@ -637,14 +640,15 @@
 pyscf/lo/nao.py
 pyscf/lo/orth.py
 pyscf/lo/pipek.py
 pyscf/lo/vvo.py
 pyscf/mcscf/PiOS.py
 pyscf/mcscf/__init__.py
 pyscf/mcscf/addons.py
+pyscf/mcscf/apc.py
 pyscf/mcscf/avas.py
 pyscf/mcscf/casci.py
 pyscf/mcscf/casci_symm.py
 pyscf/mcscf/chkfile.py
 pyscf/mcscf/df.py
 pyscf/mcscf/dmet_cas.py
 pyscf/mcscf/mc1step.py
```

### Comparing `pyscf-2.2.1/pyscf.egg-info/requires.txt` & `pyscf-2.3.0/pyscf.egg-info/requires.txt`

 * *Files identical despite different names*

### Comparing `pyscf-2.2.1/setup.py` & `pyscf-2.3.0/setup.py`

 * *Files identical despite different names*

